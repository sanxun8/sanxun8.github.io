{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"source/img/archive.jpg","path":"img/archive.jpg","modified":0,"renderable":0},{"_id":"source/img/default_bg.png","path":"img/default_bg.png","modified":0,"renderable":0},{"_id":"source/img/index.png","path":"img/index.png","modified":0,"renderable":0},{"_id":"source/img/marwel.webp","path":"img/marwel.webp","modified":0,"renderable":0},{"_id":"source/img/reward_alipay.jpg","path":"img/reward_alipay.jpg","modified":0,"renderable":0},{"_id":"source/img/reward_wechat.jpg","path":"img/reward_wechat.jpg","modified":0,"renderable":0},{"_id":"source/img/tag.jpg","path":"img/tag.jpg","modified":0,"renderable":0},{"_id":"source/img/tags.jpg","path":"img/tags.jpg","modified":0,"renderable":0},{"_id":"source/img/up.jpg","path":"img/up.jpg","modified":0,"renderable":0},{"_id":"source/img/video.jpg","path":"img/video.jpg","modified":0,"renderable":0},{"_id":"source/img/wallpaper.png","path":"img/wallpaper.png","modified":0,"renderable":0},{"_id":"source/img/reference/archive.jpg","path":"img/reference/archive.jpg","modified":0,"renderable":0},{"_id":"source/img/reference/index.jpg","path":"img/reference/index.jpg","modified":0,"renderable":0},{"_id":"source/photo/marwel/img/1.png","path":"photo/marwel/img/1.png","modified":0,"renderable":0},{"_id":"source/photo/marwel/img/1.webp","path":"photo/marwel/img/1.webp","modified":0,"renderable":0},{"_id":"source/photo/marwel/img/2.webp","path":"photo/marwel/img/2.webp","modified":0,"renderable":0},{"_id":"source/photo/marwel/img/3.webp","path":"photo/marwel/img/3.webp","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/1.png","path":"photo/wallpaper/img/1.png","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/10.png","path":"photo/wallpaper/img/10.png","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/11.png","path":"photo/wallpaper/img/11.png","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/13.png","path":"photo/wallpaper/img/13.png","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/14.png","path":"photo/wallpaper/img/14.png","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/15.png","path":"photo/wallpaper/img/15.png","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/16.jpg","path":"photo/wallpaper/img/16.jpg","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/17.jpg","path":"photo/wallpaper/img/17.jpg","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/18.png","path":"photo/wallpaper/img/18.png","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/2.png","path":"photo/wallpaper/img/2.png","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/3.png","path":"photo/wallpaper/img/3.png","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/4.jpg","path":"photo/wallpaper/img/4.jpg","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/5.jpg","path":"photo/wallpaper/img/5.jpg","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/5.png","path":"photo/wallpaper/img/5.png","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/6.jpg","path":"photo/wallpaper/img/6.jpg","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/67855.jpg","path":"photo/wallpaper/img/67855.jpg","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/7.jpg","path":"photo/wallpaper/img/7.jpg","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/8.png","path":"photo/wallpaper/img/8.png","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/9.jpeg","path":"photo/wallpaper/img/9.jpeg","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/anime-anime-girls-brunette-short-hair-squirrel-pants-1975319-wallhere.com.jpg","path":"photo/wallpaper/img/anime-anime-girls-brunette-short-hair-squirrel-pants-1975319-wallhere.com.jpg","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/cloud-sky-atmosphere-building-world-architecture-2063495-wallhere.com (1).jpg","path":"photo/wallpaper/img/cloud-sky-atmosphere-building-world-architecture-2063495-wallhere.com (1).jpg","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/cloud-sky-atmosphere-building-world-architecture-2063495-wallhere.com.jpg","path":"photo/wallpaper/img/cloud-sky-atmosphere-building-world-architecture-2063495-wallhere.com.jpg","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/cropped-1920-1080-113217.jpg","path":"photo/wallpaper/img/cropped-1920-1080-113217.jpg","modified":0,"renderable":0},{"_id":"source/photo/wallpaper/img/cropped-1920-1080-411009.jpg","path":"photo/wallpaper/img/cropped-1920-1080-411009.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/_drafts/设计模式/MVC.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710828766887},{"_id":"source/_drafts/设计模式/MVVM.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710828766887},{"_id":"source/_drafts/设计模式/享元模式.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710829008022},{"_id":"source/_drafts/设计模式/代理模式.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710829054057},{"_id":"source/_drafts/设计模式/单例模式.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710828766887},{"_id":"source/_drafts/设计模式/原型模式.md","hash":"bb8bd396c7a36c1f9846e79f0afc1c330cb0ba4a","modified":1711803805861},{"_id":"source/_drafts/设计模式/命令模式.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710828766887},{"_id":"source/_drafts/设计模式/备忘录模式.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710828766887},{"_id":"source/_drafts/设计模式/工厂模式.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710828766887},{"_id":"source/_drafts/设计模式/建造者模式.md","hash":"8ea7a6efe53104d4132a49b26a19f8979537408a","modified":1711360891331},{"_id":"source/_drafts/设计模式/桥接模式.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710829027486},{"_id":"source/_drafts/设计模式/模板方法模式.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710828766887},{"_id":"source/_drafts/设计模式/状态模式.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710828766887},{"_id":"source/_drafts/设计模式/策略模式.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710828766887},{"_id":"source/_drafts/设计模式/组合模式.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710829034367},{"_id":"source/_drafts/设计模式/装饰者模式.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710828766887},{"_id":"source/_drafts/设计模式/观察者模式.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710828766887},{"_id":"source/_drafts/设计模式/解释器模式.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710828766887},{"_id":"source/_drafts/设计模式/访问者模式.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710828766887},{"_id":"source/_drafts/设计模式/责任链模式.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710829019127},{"_id":"source/_drafts/设计模式/迭代器模式.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710829045542},{"_id":"source/_drafts/设计模式/适配器模式.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710828766887},{"_id":"source/_drafts/看八字.md","hash":"523fff2ed048521be46a2ef0ef4092b1e973c78f","modified":1711640340785},{"_id":"source/_drafts/在开始一个 Node.js 项目之前，你需要进行一些准备工作，以确保项目能够顺利进行。.md","hash":"82d76f581a1a91592b8e2fa8fa193acc6e10706f","modified":1710895823543},{"_id":"source/_drafts/test.js","hash":"7f8770ce5fa1812bd35f148df42009489dd613f5","modified":1711971448340},{"_id":"source/about-me/index.md","hash":"84a8f17843f7098c50e1a84c34dfbc2311f51202","modified":1691826800004},{"_id":"source/_data/link.yml","hash":"a6916d38cd25f9e4887fc5bfea1f6ed2ea72e97e","modified":1691868895590},{"_id":"source/_drafts/简历.md","hash":"fe2e5d65bcaa66ee4fd31cfb7dd99c0efe008d84","modified":1711701681480},{"_id":"source/_posts/3-渲染器-数据访问是如何被代理的.md","hash":"c5b81ab6a9694888624e8f0f5f819e80322a07a3","modified":1710895815318},{"_id":"source/archives/index.md","hash":"1835da47cb5545f77af281b816ba715ee34b30b2","modified":1691866533125},{"_id":"source/categories/index.md","hash":"022bfa827b8fd51949fd0aaeb8b0e58350282055","modified":1691867808550},{"_id":"source/img/default_bg.png","hash":"a064c25a67587991082f73f1e7e3f2aeba2fb3d0","modified":1691983554341},{"_id":"source/img/reward_wechat.jpg","hash":"93f683972593c9bdaea142f55befc8eedd99205d","modified":1691988099523},{"_id":"source/img/marwel.webp","hash":"c3d99a6427da67c597a69af3f540ce1441da54cb","modified":1691944040264},{"_id":"source/img/reward_alipay.jpg","hash":"03a77e07af48fb1ad8bc713502e68b44e9f5ba42","modified":1691988107915},{"_id":"source/link/index.md","hash":"e48ca8ce41063c44e37fd1185fc49ec2a2cf18b7","modified":1691913542232},{"_id":"source/list/index.md","hash":"f1edf850d1adcbb2cad868337d22e2c2f3f73a60","modified":1691866312186},{"_id":"source/messageboard/index.md","hash":"3ba8c29c0705cb3d9decf22a88878c0879c8d953","modified":1692024464281},{"_id":"source/music/index.md","hash":"a2c6553d02328af4a1e3b82befe58cfbf460479d","modified":1691904673426},{"_id":"source/movies/index.md","hash":"3b86ef799a64118f0aecb46f9a1615aea42ee880","modified":1691904699757},{"_id":"source/photo/index.md","hash":"53adfd6ba498070cb9647eab80c9e52643a94390","modified":1691990301142},{"_id":"source/tags/index.md","hash":"d7e7a73fe6022a638c4967e5cfad30a2ae07f159","modified":1691867670951},{"_id":"source/_drafts/technical-disclosure-of-vue3/13-ast-to-jsast.md","hash":"f034e25c7d4b132de915d27ac94cbd97e7ea3f6c","modified":1691826799989},{"_id":"source/pwa/manifest.json","hash":"c44bf1f2b40cd4fee4ea30058b35fcd4f603ee21","modified":1691948053767},{"_id":"source/_drafts/technical-disclosure-of-vue3/12-template-to-ast.md","hash":"17183556f96525d87d10b8991cc9202e14ea7e61","modified":1691826799989},{"_id":"source/_drafts/technical-disclosure-of-vue3/15-compile-optimize.md","hash":"68b8aa8fbcfda4c250d7dfd4901f46175b5319c1","modified":1691826799989},{"_id":"source/_drafts/technical-disclosure-of-vue3/14-jsast-to-render.md","hash":"9a9327a3545b065cbe0360439b8e730f4b048085","modified":1691826799989},{"_id":"source/_drafts/technical-disclosure-of-vue3/17--keep-alive.md","hash":"6c472fa8fd53eaec88e6e1c22deaff914852ae66","modified":1691826799989},{"_id":"source/_drafts/technical-disclosure-of-vue3/16-transition.md","hash":"e8a4fdf0069ee704ff1976478441a0481b3152ac","modified":1691826799989},{"_id":"source/_drafts/technical-disclosure-of-vue3/1-render-dom.md","hash":"7ae5064c74cf2cfa628affeaf6f1b223a73875d1","modified":1691826799989},{"_id":"source/_drafts/technical-disclosure-of-vue3/19-suspense.md","hash":"1a5dc3e8d917c2f42d4a7dd14e5f5bccbe63df04","modified":1691826799989},{"_id":"source/_drafts/technical-disclosure-of-vue3/18-teleport.md","hash":"2fe32c51fa83419de58307215133c1b94c579b49","modified":1691826799989},{"_id":"source/_drafts/technical-disclosure-of-vue3/20-v-model.md","hash":"e5c1e8ab095841598d016fee29b1410f886b2c1c","modified":1691826799989},{"_id":"source/_drafts/technical-disclosure-of-vue3/component-update.md","hash":"3c7c15e5b1c1b91b33cb83f00288f16cc077cf4a","modified":1691826799989},{"_id":"source/_drafts/technical-disclosure-of-vue3/21-slot.md","hash":"2ee4ae8ba5107569fea7206d5ce9736d7d484299","modified":1691826799989},{"_id":"source/_drafts/technical-disclosure-of-vue3/effect.md","hash":"0d6dae2226c13cd2eff3bffe081491e7e7dfcdfb","modified":1691826799989},{"_id":"source/_drafts/technical-disclosure-of-vue3/next-tick.md","hash":"3421c5911788b48bbf2278865f76d05ea1bd1cdf","modified":1691826799989},{"_id":"source/_drafts/technical-disclosure-of-vue3/computed.md","hash":"9eb80f5eb50b72f143f9740821fae195f4856c38","modified":1691826799989},{"_id":"source/_drafts/technical-disclosure-of-vue3/provide-and-inject.md","hash":"cc6da21954492dfeae0e7f1088296fd8afdb520b","modified":1691826799989},{"_id":"source/_drafts/technical-disclosure-of-vue3/patch-keyed-children.md","hash":"acf892b0d03ddab95385497e4b316b938dc7efa0","modified":1691826799989},{"_id":"source/_drafts/technical-disclosure-of-vue3/proxy-response.md","hash":"29e93d31b621f4b44a0dfe9be4a50f9c21d3bd8b","modified":1691826799989},{"_id":"source/_drafts/technical-disclosure-of-vue3/2-data-broker.md","hash":"5a74f4683c332c8a9b67594fbae69448a14dd8d6","modified":1691826799989},{"_id":"source/_drafts/technical-disclosure-of-vue3/watch.md","hash":"ea821aab962060235994d4ec6853a7021cdfe54b","modified":1691826799989},{"_id":"source/_drafts/设计模式/中介者模式.md","hash":"853b51d547ca2dc2568603510b93a52d093f3fac","modified":1710895717026},{"_id":"source/_drafts/源码/vu2响应式实现.md","hash":"e2a301a9fff9ce06792f68ad73493c241ca56b79","modified":1710894040805},{"_id":"source/photo/marwel/index.md","hash":"963f08f2bb89fe1578d11466b7dbb1ad73d896d7","modified":1691946981822},{"_id":"source/photo/wallpaper/index.md","hash":"c82a7689ecf1f0936a0288163e912b66aadd99ac","modified":1691946949918},{"_id":"source/photo/marwel/img/3.webp","hash":"fa9ca004e1290cffc39832113a2752df098e705c","modified":1691946893400},{"_id":"source/photo/marwel/img/2.webp","hash":"7f75339b5ad89fff31c307fc7bd62d3f23d6a4fc","modified":1691946888713},{"_id":"source/photo/marwel/img/1.webp","hash":"4e90c6d90e7b4403d0ae15217729c3f6e556e2bd","modified":1691946882982},{"_id":"source/photo/wallpaper/img/15.png","hash":"a064c25a67587991082f73f1e7e3f2aeba2fb3d0","modified":1691983554341},{"_id":"source/photo/wallpaper/img/17.jpg","hash":"80f5df9abcdaf196d4d3e51ff40f156dc113480c","modified":1691979679772},{"_id":"themes/butterfly/README.md","hash":"4edab59e45ef63ce52b343a1e6e33d3b78729c33","modified":1691863766744},{"_id":"themes/butterfly/_config.yml","hash":"10e22084ec4924395d07850a152d618dc97ce634","modified":1694964337116},{"_id":"themes/butterfly/package.json","hash":"c763336b7896c9b3862664ac1bac5f629f9dd270","modified":1691863766772},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1691863766743},{"_id":"themes/butterfly/README_CN.md","hash":"3655a8e204132b7e98933785f4728370495c1657","modified":1691863766744},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"2dcc70a011b37890215ae0fd6d8f8c78aa8af6b0","modified":1691863766746},{"_id":"themes/butterfly/plugins.yml","hash":"6e26929cd8ff987d02af1f4504b0358674b54947","modified":1691863766772},{"_id":"themes/butterfly/languages/en.yml","hash":"68127be0e6b44cfc5f31353d8b275c02939b3ff9","modified":1691863766746},{"_id":"themes/butterfly/languages/default.yml","hash":"90e9e2f36dc51aa77eb7804ae048b4876035b12d","modified":1691863766745},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1691863766771},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"1392e7b8c678cdfb54f55523693e66abc7d80538","modified":1691863766746},{"_id":"themes/butterfly/layout/archive.pug","hash":"bc77220dfc269b8faad0930e1a4142ebf68165e5","modified":1691863766746},{"_id":"themes/butterfly/layout/category.pug","hash":"bf979aec88d78b644fc5d31518f8679ad7625792","modified":1691863766747},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1691863766772},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"92683cb785a29e5a73701b33dba73d3afac268c3","modified":1691863766742},{"_id":"themes/butterfly/layout/page.pug","hash":"bf2d6c6d2d156777b55292e51be02b0b3acf0af8","modified":1691863766771},{"_id":"themes/butterfly/layout/post.pug","hash":"fdbb508b5e6dec30fb8753c5a7fdd494410c4fc0","modified":1691863766771},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"6e0f9470b18bd37d4891282ac73d61676b040e8c","modified":1691863766743},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"d9ff4bad9c9664e12729c7a531169a05698a3fd1","modified":1691863766742},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1691863766743},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1691863766743},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"aace9ddff469de4226e47a52ede1c81e66d66d5c","modified":1691863766747},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1691863766747},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"50eea5aa78cdeb6c72dd22f0aeabc407cc0f712e","modified":1691863766747},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"de1d0036792e2513540919ca3cb6e5f7e1a10037","modified":1691863766747},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"f448bf73103b88de4443e52d600e871cf3de3e32","modified":1691863766754},{"_id":"themes/butterfly/scripts/events/404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1691863766773},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"96df62e34661d8ca4a45267286127479e5178a79","modified":1691863766751},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1691863766773},{"_id":"themes/butterfly/scripts/events/init.js","hash":"ce68e84a9ccfcf91100befbaa9afc392a0cd93bb","modified":1691863766773},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"95479790234c291b064d031577d71214cdd1d820","modified":1691863766773},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"219cf538cabac9971428e6eab5b18f9aad93fda5","modified":1691863766773},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1691863766773},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"5ed2d7ef240c927fe1b7a7fb5bf9e55e2bfd55a5","modified":1691863766774},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"0df22d7dbfa766a65cb6032a1f003348f4307cfe","modified":1691863766774},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1691863766774},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"b12895e0765d596494e5526d121de0dd5a7c23d3","modified":1691863766775},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"cdd992c8577d583c237b6aac9f5077d8200879b2","modified":1691863766774},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"b55f71347d2ead097c7f98c0ec792b091433345c","modified":1691863766775},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"c74d6a9b8f71e69447f7847a5f5e81555d68b140","modified":1691863766775},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"76343ac8422c9c8539082e77eda6ffee4b877eb2","modified":1691863766776},{"_id":"themes/butterfly/scripts/helpers/series.js","hash":"17c0095bc8d612a268cdcab000b1742dc4c6f811","modified":1691863766776},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"164d5f1c2d1b4cb5a813a6fc574016743a53c019","modified":1691863766777},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"7ec77b3093f5de67e7032f40a5b12f1389f6f6ff","modified":1691863766777},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"3ba7677969ff01fab06fc6713455ddc6861f0024","modified":1691863766777},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"5d08c3552f7d3c80a724ca628bff66321abe2e5a","modified":1691863766777},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"b013dc0a3d57d2caa18b89263f23871da9ec456d","modified":1691863766778},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"c863d2732ce4bdc084f2d0db92f50f80328c1007","modified":1691863766777},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"289f85847c58f0b2b7d98a68e370a2896edb8949","modified":1691863766778},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"e68d8d21f3a86e3646907a3685550ee20e8d4a9f","modified":1691863766778},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"35d54adc92e717cc32e13515122b025fd1a98ea2","modified":1691863766778},{"_id":"themes/butterfly/scripts/tag/series.js","hash":"dc56e5182dd3813dc977c9bf8556dcc7615e467b","modified":1691863766778},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"7c448886f230adb4f4a0208c88fff809abcb5637","modified":1691863766779},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"e611074a5a7f489a8b04afac0a3f7f882ce26532","modified":1691863766779},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9277fead4c29dbe93976f078adaa26e8f9253da3","modified":1691863766754},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"c5c58714fb3cb839653e5c32e6094784c8662935","modified":1691863766753},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1691863766791},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1691863766790},{"_id":"themes/butterfly/source/css/index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1691863766790},{"_id":"themes/butterfly/source/css/var.styl","hash":"1ef97ae877a248e120b257983122b6912591f52f","modified":1691863766790},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"c8dbdfe6145a0bc6f7691c9551be8169a2698f0a","modified":1691863766748},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1691863766791},{"_id":"themes/butterfly/source/js/main.js","hash":"4a6d372dfd69d94cb08a726e338fffc49f424a15","modified":1691863766791},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"d776c670e4076ad6049dbb64cdee7a734b51d37f","modified":1691863766792},{"_id":"themes/butterfly/source/js/utils.js","hash":"7b871fe0c4456660cff4c7b9cc4ed089adac2caf","modified":1691863766793},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"bd5dd5452e28a4fe94c3241a758ec6f4fdb7a149","modified":1691863766748},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"069edb4278ace09498f6eec16d2f393df1424783","modified":1691863766748},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"c7666a10448edd93f5ace37296051b7670495f1b","modified":1691863766748},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1691863766749},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1691863766749},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"fd55f0e09827ef40c53c48d184a553464aac3e03","modified":1691863766749},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1691863766750},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"f1cd3581eb537a88c55baa9e8a1614489356ecf5","modified":1691863766749},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"1bef867c799ba158c5417272fb137539951aa120","modified":1691863766750},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"962ee70a35e60a13c31eea47d16b9f98069fe417","modified":1691863766750},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"ca8bcd90ad9467819330bfe7c02b76322754bccf","modified":1691863766750},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"e7b25a322ae861dca06d458d3f914220e92758cf","modified":1691863766751},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"00ae419f527d8225a2dc03d4f977cec737248423","modified":1691863766752},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"7a641b5dd45b970e1dafd1433eb32ea149e55cf2","modified":1691863766751},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"a6fde4835d6460ce7baf792fd5e1977fad73db25","modified":1691863766752},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"766baca6ddce49d1724a02312387b292ff2d0bdc","modified":1691863766751},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1691863766752},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"9155f01d4c644a2e19b2b13b2d3c6d5e34dd0abf","modified":1691863766752},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1691863766753},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"194a5f310dccecee3ae0b648e4e5318f6fbbddcd","modified":1691863766752},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"912df10a053db3135968e92b6fd1a707ee94c968","modified":1691863766754},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"12be059c536490af216a397e8f2a7abbf6d4610e","modified":1691863766753},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"e939344fd389aeb11864ee697d5fd9b036d8325f","modified":1691863766755},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"e37681bc9c169d4220f26ecda2b3d5c02b6b9a0f","modified":1691863766753},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"08979afbfecb4476a5ae8e360947b92624d285b8","modified":1691863766766},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"0abad416b1974a17e5be7817931d5fe799180170","modified":1691863766753},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"f0898509da70388b5c532f19e762756d74080200","modified":1691863766766},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"4e37535c63149708ecbedb262336014524ad8723","modified":1691863766762},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"9b734d99963f3e7f562597dcf60485ccbf6e961c","modified":1691863766766},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1691863766768},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1691863766768},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1691863766768},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"dfb5e16a7e7106bb20b2ac2d0df1251d0fc79609","modified":1691863766768},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"ab037bf5794638bd30da4cf7cf106e5d03b5f696","modified":1691863766768},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1691863766769},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1691863766769},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"8e22f53886a57a68286970d8af8b4c950fd4a1d7","modified":1691863766769},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"59d979702fa21d960443824198614d63aaf69662","modified":1691863766770},{"_id":"themes/butterfly/layout/includes/widget/card_post_series.pug","hash":"2084b8065e63dd045bdca3dc5992014133601e28","modified":1691863766770},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1691863766770},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1691863766770},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"842b772a387b576550fa127030e1c2e9bf65716d","modified":1691863766770},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"12185713f9ca08984fc74e3b69d8cd6828d23da8","modified":1691863766771},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"8df529f71e25f1c0a00e533de7944ed3d1ba7bd8","modified":1691863766771},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"ef05038ba108eea625232e36c39a60cff2878f23","modified":1691863766780},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"318ba0cc32078a7b4ea94d6f2bc70c451192c31b","modified":1691863766779},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"9893656128c347d1c09c90784627c84c979b326f","modified":1691863766779},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"3c178608406c31d768af355ef1d7326da37cc75f","modified":1691863766781},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"792a04d36de32f230ca3256ad87a90fe8392f333","modified":1691863766782},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"352c362479023e2b751909d9acaaaa841b425b99","modified":1691863766782},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"abda05eca95372cc421a53d7b8e670ee34cc7d6b","modified":1691863766782},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1691863766783},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"5e27f7842af82ff7498d4b59787ce9ca90fa9e6f","modified":1691863766782},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"bd099f7d3adef4b7edd24c0a25a07415b156e587","modified":1691863766783},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"66a7a0e3c58ac23c81afe9fe18834b9db9c42698","modified":1691863766783},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"e54e1597009265e609badafde4f5722c7573c7b5","modified":1691863766783},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"6dcf19c0933c8828a439f801b0f4b256447dec07","modified":1691863766783},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"c0b11a1a5f52e3a6af4e312a8134c93eda18a7dd","modified":1691863766784},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"ac51f68342e208b166ffc4f9ff0da304b9ef091e","modified":1691863766784},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"0322237e762db401d7b4aa33168d0b9334a9ec26","modified":1691863766784},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"15ea7564b2e3bf46bc91fb6e49c94d057b37caaf","modified":1691863766784},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"a22fd15048d21452f0015d0765d295d730203308","modified":1691863766785},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"dbc855795a881f8c805bf5c9c5c4d5d542a648ec","modified":1691863766784},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"a7223a8fcc4fa7b81e552c9a2554be7df9de312e","modified":1691863766785},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"68bc8cbea25dbb3cdc170f09f9b43ce130547717","modified":1691863766785},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"5dd1ba997741d02894ff846eda939ad8051c0bb2","modified":1691863766785},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"ecc2b2e28c179eb9406fc2c6f00e141078249cdd","modified":1691863766786},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"df7a51fcabbadab5aa31770e3202a47c9599bbb7","modified":1691863766786},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9e35f91847773b915c74a78b8aa66c7bdb950ad0","modified":1691863766786},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"0b23010154e19f37f0c4af0110f9f834d6d41a13","modified":1691863766787},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"a977cd8161ef4d6ddd5293e81403519076657430","modified":1691863766786},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"37db99299af380e9111dce2a78a5049b301b13e0","modified":1691863766787},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"62da1de0d5b8453fcecbfacddb16985265638ba5","modified":1691863766788},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"cf90ea339fbb7f345212319627fcd68964024e40","modified":1691863766787},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"3e9355b76f87e2ee90f652855282b37ab5ae0b3e","modified":1691863766788},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1691863766788},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1691863766788},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"b7cf7753479fcf2fe07287ffdb0e568adbba4c18","modified":1691863766788},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"2f83bd145b870d80d4b18b0ac603235229a5694e","modified":1691863766789},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"11d6a163c0ea27021c1f8aeb2b1b140e4a4b2c62","modified":1691863766789},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"07ea7134db7a66c87658116f089fb1a2a6906563","modified":1691863766789},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"331c89ecfb79fab68466944a43e9e3d0ff49c646","modified":1691863766789},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1691863766790},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"8f95aca305b56ccd7c8c7367b03d26db816ebd5f","modified":1691863766754},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"a7c2fe73cc05ad3525909b86ad0ede1a9f2d3b48","modified":1691863766792},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"58f37823f6cd9a194fb50f7ca7c2233e49939034","modified":1691863766755},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"cb5d892fdd26f884d7f47c7ceca7fcae3f191d6a","modified":1691863766792},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1691863766756},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"4b98145d6584d586cabf033493282afc72ae816a","modified":1691863766755},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"19b5cfa1f77781246e02967cefe149f19170e45f","modified":1691863766755},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d6fff5a7f84c8b09f282f9ddc0020a68a8aac9ea","modified":1691863766755},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1691863766756},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"fd2320ee25507bb8ef49f932c2d170586b44ea4d","modified":1691863766757},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"7e233f872aea6fd6beccdc9efd86b1bf9ec9f12d","modified":1691863766756},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"cd4fc9c5a61608a5dedf645c1295430a1623040f","modified":1691863766756},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"09d2ab2570b67e6f09244a898ccab5567cb82ace","modified":1691863766757},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"1157118db9f5d7c0c5a0fc7c346f6e934ca00d52","modified":1691863766757},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"08a85e52fc800d3562df869e5e2613313e76fce6","modified":1691863766757},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"6d40b521eec4136f6742c548a4445ed593470b1b","modified":1691863766758},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"0d960849d5b05d27ec87627b983ca35f2411b9e8","modified":1691863766757},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"eb8f2919ea9d52f6c829ffa8052ba2585d0b6b98","modified":1691863766758},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"364d1fd655baca9132038ef1e312abde2c0bc7de","modified":1691863766759},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"799da8f3015e6fe440681b21644bcb3810a5518c","modified":1691863766758},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"f78c9c20c86d58c7cf099f6f8d6097103d7d43e5","modified":1691863766759},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"11f5dca1432e59f22955aaf4ac3e9de6b286d887","modified":1691863766759},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"1eab7ca1cb16c6786f9c3ca0efef8cc15e444ab4","modified":1691863766759},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"db6713d2b90eb8183f86ac92c26761a8501c0ddb","modified":1691863766760},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1691863766761},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"1c86c8fc1a28514a02a1f6a25ca9ec05eb3955b7","modified":1691863766760},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"09c2ef4bc6d005f96dfa48b1d9af1ec095c5266d","modified":1691863766761},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"b65a42167df5fb07e2a63f312a58c321d3112a90","modified":1691863766762},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"0b44f6de0f5632b55298d506833f45dae46a6346","modified":1691863766762},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"4ed7c74087e81c6fcaf4fca7dced58b4e19f4cb1","modified":1691863766762},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"7f450664e6323a076ae59c393b0f22167cfa82e5","modified":1691863766761},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"f0d3eddd2bed68e5517274b3530bfe0fa5057d8e","modified":1691863766763},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1691863766763},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"7e56b48ab49bd03606d781aaa06f1f1132639ff2","modified":1691863766762},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"bb944185f4bb9f9a9b9d70ee215f66ccd6d4c6cf","modified":1691863766763},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"c682e4d61017fb0dd2e837bfcc242371f1a13364","modified":1691863766763},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"cfcfaed3a52fa47fff4cc65a053a2f025fb3b7b6","modified":1691863766764},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"a6be932d1f64c6190f5d03b5b77fba09fa0fd6b8","modified":1691863766764},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"4f8bd22c5c32d5430cbe08ab4e861b6f8b86f820","modified":1691863766764},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"edd4ebf76a79fb74cfae03a286fab90f74324dbd","modified":1691863766765},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f8b65460c399973090c1fb7ab81e3708c252e7cc","modified":1691863766764},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"ce4ab79c85df9f77395269eb01e9a023d7f96376","modified":1691863766765},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"90338ac4cd114d324fe1caaaeea8be9ca05d6a46","modified":1691863766766},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"4fb998a05e51ef2302775945883307ee3039a544","modified":1691863766765},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"862c7775b5639e082fab8833d996f383561877cd","modified":1691863766765},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"52a06a2e039f44383085333cac69f3f4e7d0ad3a","modified":1691863766766},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"3adcf28a8d205ea3ee19828eda0e668702fac07a","modified":1691863766767},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"4b9c35375e0eb9cf99ad246d5ca838eca64a635d","modified":1691863766767},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"1f02a26730e5f36cc2dfec7ff4d5c93a099ed5ba","modified":1691863766767},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"8106bd031586f075a994956ee4438eb13be25d7b","modified":1691863766767},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"c16ee69b5ca8db016db0508d014ae0867c4ce929","modified":1691863766767},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"fc702a4614d0562a381907b083f71ba63d301d86","modified":1691863766780},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"6e77f1ca0cfb0db6b028f5c0238780e66d344f3d","modified":1691863766780},{"_id":"source/img/up.jpg","hash":"09f12b62a399ecd5f17e42940a2abfbeee91e67f","modified":1691856650818},{"_id":"source/photo/marwel/img/1.png","hash":"ce6674d60b88d27893db1af12e309f70df23708d","modified":1691943954533},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"01ff9e77eb1bd454bec65a6ff5972c8e219bc708","modified":1691863766781},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1691863766781},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"0b8aea62d1550113e1fcc237fae1b03743190208","modified":1691863766781},{"_id":"source/img/reference/index.jpg","hash":"84a86ba35bccf1f22518ffeacac9bd530ac59372","modified":1691977093018},{"_id":"source/photo/wallpaper/img/cloud-sky-atmosphere-building-world-architecture-2063495-wallhere.com.jpg","hash":"036d6fcdd2ca471de62bb0833d655209e2e02775","modified":1691978691655},{"_id":"source/photo/wallpaper/img/cloud-sky-atmosphere-building-world-architecture-2063495-wallhere.com (1).jpg","hash":"036d6fcdd2ca471de62bb0833d655209e2e02775","modified":1691979045945},{"_id":"source/img/wallpaper.png","hash":"2af1b745656a2989678d5ce8799985b6438817b6","modified":1691943662101},{"_id":"source/img/reference/archive.jpg","hash":"1ec60a82235fd3414679c1f4784f2f66be5de9bd","modified":1691978525747},{"_id":"source/photo/wallpaper/img/16.jpg","hash":"a9f7909ca86049dd002e524ee95f4decd741f5fe","modified":1691978471718},{"_id":"source/photo/wallpaper/img/5.png","hash":"373158ad76e47e09cd6e7b55fca387d33cd79381","modified":1691979751316},{"_id":"source/img/archive.jpg","hash":"5fb1a24239abc0e70259efb5cd5cccde774df41f","modified":1691979269531},{"_id":"source/img/tags.jpg","hash":"61d2546e71a639562e346cc6474ce9508ca6af06","modified":1691979633186},{"_id":"source/photo/wallpaper/img/anime-anime-girls-brunette-short-hair-squirrel-pants-1975319-wallhere.com.jpg","hash":"44122650f4167dd90aed2623dfeb26a9dd7df2e7","modified":1691979194592},{"_id":"source/img/tag.jpg","hash":"f7ae3390aae32f4b0eac0c7b1034b1950f0ef2bd","modified":1691979857250},{"_id":"source/photo/wallpaper/img/cropped-1920-1080-411009.jpg","hash":"e3bf6237735793db31a38c4b2cf0aa42b7f2c843","modified":1691979509431},{"_id":"source/photo/wallpaper/img/67855.jpg","hash":"367f1e3b7e818a192f72cbdc1c502ca5888effc6","modified":1691978121639},{"_id":"source/img/video.jpg","hash":"bc5450d350854083137c659f346702d25d65a417","modified":1691942468140},{"_id":"source/photo/wallpaper/img/5.jpg","hash":"a2cd9b4b591bff86ec5e8764374bd58e1916f397","modified":1691977354988},{"_id":"source/photo/wallpaper/img/4.jpg","hash":"a22e64d8047d53984efe5c46fcc95fffaa532f91","modified":1691977243804},{"_id":"source/photo/wallpaper/img/9.jpeg","hash":"775418fe68c48690f1fa1098b912b57d20b3bf0c","modified":1691977377632},{"_id":"source/photo/wallpaper/img/3.png","hash":"697ebcb29ea5b20f78dd162b8a8d4615aa7049e5","modified":1691942708169},{"_id":"source/photo/wallpaper/img/8.png","hash":"695caa731367d6bd40a199310a57bdf93cb4925d","modified":1691977520639},{"_id":"source/photo/wallpaper/img/cropped-1920-1080-113217.jpg","hash":"4b0d24d58966adcde9d42064030206b62b1d3dbb","modified":1691979586267},{"_id":"source/photo/wallpaper/img/2.png","hash":"1d6660f850ba1c384be33b4b4e41492004902d48","modified":1691946409395},{"_id":"source/photo/wallpaper/img/7.jpg","hash":"017f5fb9a1c5258b204b86e8cede072bf6f6ead6","modified":1691977543810},{"_id":"source/img/index.png","hash":"f90ec9b70463e3ae0ab41b8edbd4df039d2f8e48","modified":1691977324986},{"_id":"source/photo/wallpaper/img/11.png","hash":"f90ec9b70463e3ae0ab41b8edbd4df039d2f8e48","modified":1691977324986},{"_id":"source/photo/wallpaper/img/6.jpg","hash":"ea3ead8ec8573c21051424ebc822d21971162004","modified":1691977506664},{"_id":"source/photo/wallpaper/img/1.png","hash":"476e158a75204717f6935a0c4287368f9adeed29","modified":1691942534229},{"_id":"source/photo/wallpaper/img/13.png","hash":"7beff1fce6648ba7a902daeb121393afc42ce9e2","modified":1691977289678},{"_id":"source/photo/wallpaper/img/10.png","hash":"321a60bfead0ac5917463f78ce5949008ae8bdc8","modified":1691977486242},{"_id":"source/photo/wallpaper/img/18.png","hash":"8d161afdaa33b0c39813cbe059f67a6b003bbb47","modified":1691978203306},{"_id":"source/photo/wallpaper/img/14.png","hash":"8efaabc48b43ddeb81f38bb1e839db4caa7ae5df","modified":1691978180934},{"_id":"public/pwa/manifest.json","hash":"e5653018c633c03092c691caf2b17921c60fe633","modified":1710938114432},{"_id":"public/atom.xml","hash":"7fe025a5f3fd91e40f635acca75060cafd79500b","modified":1712218457300},{"_id":"public/content.json","hash":"c660efd15852d938874d33f3a9921c549804123d","modified":1712218457300},{"_id":"public/search.xml","hash":"a6770502cacb0c6e5f6728b60fe4e506dd0eab86","modified":1712218457300},{"_id":"public/404.html","hash":"506c4adf49841b3249cbde4c6cde1771434d7522","modified":1712218457300},{"_id":"public/about-me/index.html","hash":"b2977fe7d053bf24a51f3e6489f7747c0df6678f","modified":1712218457300},{"_id":"public/archives/index.html","hash":"8c044e7c8e5fe2b0b3cdc04bb413d0aa9f68ece2","modified":1712218457300},{"_id":"public/categories/index.html","hash":"815eb6688b16316a723e732f8e02183154e9d25d","modified":1712218457300},{"_id":"public/link/index.html","hash":"a4a51fbb11a4a53056d1c07f9a1560833fd76ab6","modified":1712218457300},{"_id":"public/list/index.html","hash":"3ea15c1fc04cd2dd099316504b63bea8b6ea4d5c","modified":1712218457300},{"_id":"public/messageboard/index.html","hash":"d6609731600e02db82745c6d1ed404e2afc54881","modified":1712218457300},{"_id":"public/movies/index.html","hash":"5802bb8092dacb44df536306650c5ffc5679d97c","modified":1712218457300},{"_id":"public/music/index.html","hash":"104b99fc7472306259ccbcbb1503876ae657132d","modified":1712218457300},{"_id":"public/photo/index.html","hash":"31c9b72f2b76277769f28f259e4744548d2d43fb","modified":1712218457300},{"_id":"public/tags/index.html","hash":"4676ba7eae3d17dd2d43b0c56ff24c81df409d08","modified":1712218457300},{"_id":"public/photo/marwel/index.html","hash":"3d26979a177fa09f7167320720165cadde0ce7fc","modified":1712218457300},{"_id":"public/photo/wallpaper/index.html","hash":"2025f210c20718484739935633cd76d292dbd95b","modified":1712218457300},{"_id":"public/2024/03/13/3-渲染器-数据访问是如何被代理的/index.html","hash":"929bc4468e5a0826ad53b1f6ea7db6a5dead2341","modified":1710938114432},{"_id":"public/archives/2024/index.html","hash":"8419fd0c7b888c547a0e3120667f34993d7b8968","modified":1712218457300},{"_id":"public/archives/2024/03/index.html","hash":"61a5467c8c827467af4e4e95763d55293e860c37","modified":1712218457300},{"_id":"public/index.html","hash":"e8f54240c4dbab3282b915fe25484e7f1a408761","modified":1712218457300},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1710938114432},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1710938114432},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1710938114432},{"_id":"public/img/default_bg.png","hash":"a064c25a67587991082f73f1e7e3f2aeba2fb3d0","modified":1710938114432},{"_id":"public/img/marwel.webp","hash":"c3d99a6427da67c597a69af3f540ce1441da54cb","modified":1710938114432},{"_id":"public/img/reward_alipay.jpg","hash":"03a77e07af48fb1ad8bc713502e68b44e9f5ba42","modified":1710938114432},{"_id":"public/img/reward_wechat.jpg","hash":"93f683972593c9bdaea142f55befc8eedd99205d","modified":1710938114432},{"_id":"public/photo/marwel/img/1.webp","hash":"4e90c6d90e7b4403d0ae15217729c3f6e556e2bd","modified":1710938114432},{"_id":"public/photo/marwel/img/3.webp","hash":"fa9ca004e1290cffc39832113a2752df098e705c","modified":1710938114432},{"_id":"public/photo/marwel/img/2.webp","hash":"7f75339b5ad89fff31c307fc7bd62d3f23d6a4fc","modified":1710938114432},{"_id":"public/photo/wallpaper/img/15.png","hash":"a064c25a67587991082f73f1e7e3f2aeba2fb3d0","modified":1710938114432},{"_id":"public/photo/wallpaper/img/17.jpg","hash":"80f5df9abcdaf196d4d3e51ff40f156dc113480c","modified":1710938114432},{"_id":"public/img/up.jpg","hash":"09f12b62a399ecd5f17e42940a2abfbeee91e67f","modified":1710938114432},{"_id":"public/photo/marwel/img/1.png","hash":"ce6674d60b88d27893db1af12e309f70df23708d","modified":1710938114432},{"_id":"public/js/utils.js","hash":"8e6b48d294e7aeaba8ff6348c43b2271cf865547","modified":1710938114432},{"_id":"public/js/search/algolia.js","hash":"108988d046da9a4716148df43b3975217c8ceaae","modified":1710938114432},{"_id":"public/js/search/local-search.js","hash":"9c573c4f1af03e2e17322c75d00fcd11d44580dd","modified":1710938114432},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710938114432},{"_id":"public/js/main.js","hash":"22f5488598bb8810ce223f8f89d843effd6513e6","modified":1710938114432},{"_id":"public/js/tw_cn.js","hash":"f8d2e3f31468991a7f5171cbfdb157dfb86d3372","modified":1710938114432},{"_id":"public/css/index.css","hash":"5056602560bbbc39f4c6afb207267ca45603c61d","modified":1710938114432},{"_id":"public/img/reference/index.jpg","hash":"84a86ba35bccf1f22518ffeacac9bd530ac59372","modified":1710938114432},{"_id":"public/photo/wallpaper/img/cloud-sky-atmosphere-building-world-architecture-2063495-wallhere.com (1).jpg","hash":"036d6fcdd2ca471de62bb0833d655209e2e02775","modified":1710938114432},{"_id":"public/photo/wallpaper/img/cloud-sky-atmosphere-building-world-architecture-2063495-wallhere.com.jpg","hash":"036d6fcdd2ca471de62bb0833d655209e2e02775","modified":1710938114432},{"_id":"public/img/reference/archive.jpg","hash":"1ec60a82235fd3414679c1f4784f2f66be5de9bd","modified":1710938114432},{"_id":"public/img/wallpaper.png","hash":"2af1b745656a2989678d5ce8799985b6438817b6","modified":1710938114432},{"_id":"public/photo/wallpaper/img/16.jpg","hash":"a9f7909ca86049dd002e524ee95f4decd741f5fe","modified":1710938114432},{"_id":"public/photo/wallpaper/img/5.png","hash":"373158ad76e47e09cd6e7b55fca387d33cd79381","modified":1710938114432},{"_id":"public/img/archive.jpg","hash":"5fb1a24239abc0e70259efb5cd5cccde774df41f","modified":1710938114432},{"_id":"public/img/tags.jpg","hash":"61d2546e71a639562e346cc6474ce9508ca6af06","modified":1710938114432},{"_id":"public/photo/wallpaper/img/anime-anime-girls-brunette-short-hair-squirrel-pants-1975319-wallhere.com.jpg","hash":"44122650f4167dd90aed2623dfeb26a9dd7df2e7","modified":1710938114432},{"_id":"public/img/tag.jpg","hash":"f7ae3390aae32f4b0eac0c7b1034b1950f0ef2bd","modified":1710938114432},{"_id":"public/photo/wallpaper/img/cropped-1920-1080-411009.jpg","hash":"e3bf6237735793db31a38c4b2cf0aa42b7f2c843","modified":1710938114432},{"_id":"public/photo/wallpaper/img/67855.jpg","hash":"367f1e3b7e818a192f72cbdc1c502ca5888effc6","modified":1710938114432},{"_id":"public/img/video.jpg","hash":"bc5450d350854083137c659f346702d25d65a417","modified":1710938114432},{"_id":"public/photo/wallpaper/img/5.jpg","hash":"a2cd9b4b591bff86ec5e8764374bd58e1916f397","modified":1710938114432},{"_id":"public/photo/wallpaper/img/4.jpg","hash":"a22e64d8047d53984efe5c46fcc95fffaa532f91","modified":1710938114432},{"_id":"public/photo/wallpaper/img/9.jpeg","hash":"775418fe68c48690f1fa1098b912b57d20b3bf0c","modified":1710938114432},{"_id":"public/photo/wallpaper/img/3.png","hash":"697ebcb29ea5b20f78dd162b8a8d4615aa7049e5","modified":1710938114432},{"_id":"public/photo/wallpaper/img/8.png","hash":"695caa731367d6bd40a199310a57bdf93cb4925d","modified":1710938114432},{"_id":"public/photo/wallpaper/img/cropped-1920-1080-113217.jpg","hash":"4b0d24d58966adcde9d42064030206b62b1d3dbb","modified":1710938114432},{"_id":"public/photo/wallpaper/img/2.png","hash":"1d6660f850ba1c384be33b4b4e41492004902d48","modified":1710938114432},{"_id":"public/photo/wallpaper/img/7.jpg","hash":"017f5fb9a1c5258b204b86e8cede072bf6f6ead6","modified":1710938114432},{"_id":"public/img/index.png","hash":"f90ec9b70463e3ae0ab41b8edbd4df039d2f8e48","modified":1710938114432},{"_id":"public/photo/wallpaper/img/11.png","hash":"f90ec9b70463e3ae0ab41b8edbd4df039d2f8e48","modified":1710938114432},{"_id":"public/photo/wallpaper/img/6.jpg","hash":"ea3ead8ec8573c21051424ebc822d21971162004","modified":1710938114432},{"_id":"public/photo/wallpaper/img/1.png","hash":"476e158a75204717f6935a0c4287368f9adeed29","modified":1710938114432},{"_id":"public/photo/wallpaper/img/10.png","hash":"321a60bfead0ac5917463f78ce5949008ae8bdc8","modified":1710938114432},{"_id":"public/photo/wallpaper/img/13.png","hash":"7beff1fce6648ba7a902daeb121393afc42ce9e2","modified":1710938114432},{"_id":"public/photo/wallpaper/img/18.png","hash":"8d161afdaa33b0c39813cbe059f67a6b003bbb47","modified":1710938114432},{"_id":"public/photo/wallpaper/img/14.png","hash":"8efaabc48b43ddeb81f38bb1e839db4caa7ae5df","modified":1710938114432},{"_id":"source/_posts/设计模式/中介者模式.md","hash":"0efbc8fcc462811cac2c9080306bde0bb8ca286d","modified":1711360519471},{"_id":"source/_posts/源码/3-渲染器-数据访问是如何被代理的.md","hash":"c5b81ab6a9694888624e8f0f5f819e80322a07a3","modified":1710895815318},{"_id":"public/2024/03/19/设计模式/中介者模式/index.html","hash":"a05b17007f2462168efae7cbd97caddaa0b5b0ce","modified":1712218457300},{"_id":"public/2024/03/13/源码/3-渲染器-数据访问是如何被代理的/index.html","hash":"0149bb5ad4121fcd81b2863e2da452ad8b7d9429","modified":1711361307912},{"_id":"source/_posts/源码/vue3_dom_diff.md","hash":"a5a19eeccab80062c60e2a7e5c2c91ca61510ca2","modified":1711097034205},{"_id":"source/_drafts/源码/public/service-worker.js","hash":"6b99d3504712c4207a667850d642edc7bde5c5ab","modified":1711097152680},{"_id":"source/_drafts/源码/public/service-worker.js.map","hash":"5af6e331c48fcc24b14e1487606820a8b038a645","modified":1711097152680},{"_id":"source/_drafts/源码/public/workbox-47405685.js","hash":"4f1730de2a21c136eae0ad2dcbf25abc60462076","modified":1711097152680},{"_id":"source/_drafts/源码/public/workbox-47405685.js.map","hash":"bc8ae245b553b7d1937c56c742832729d3e12ccf","modified":1711097152680},{"_id":"source/_drafts/源码/vue2nextTick实现.md","hash":"681e4672042a1cfc19ec420ccafeea274ad12874","modified":1710989148782},{"_id":"source/_drafts/源码/vue2_nextTeck.md","hash":"0e2ad4df1c0a8bfe592ac5092c414e1ad29d01b7","modified":1711027468381},{"_id":"public/2024/03/22/源码/vue3_dom_diff/index.html","hash":"5008800471c900750f6094f39cbc227e750ceea7","modified":1711361307912},{"_id":"source/_drafts/源码/reactive.md","hash":"0e0f4984b9e96ac877e2b7c085afcaa8bf2cd9f7","modified":1711115514424},{"_id":"source/_drafts/源码/ref.md","hash":"b8fb65048c731da0dec928036de90e5fe6410b9d","modified":1711115514424},{"_id":"source/_drafts/源码/最长递增子序列.md","hash":"82618aea255b33536144cd7bc54b31cb9f0e85f2","modified":1711115514424},{"_id":"source/_posts/设计模式/单例模式.md","hash":"8efc3025fb4e750a4bb7cfb570f459abdfb273b4","modified":1711186229280},{"_id":"public/2024/03/19/设计模式/单例模式/index.html","hash":"4150b952ea494b5dfb22fd9d1c12c8fe64d81d98","modified":1712218457300},{"_id":"source/_drafts/设计模式/x.js","hash":"3867811dfa80d02364b2ce0886ad6da4539ec059","modified":1711376460359},{"_id":"source/_posts/设计模式/工厂模式.md","hash":"6cdefcd0b4bd265076f7b3233d95ab78386d3bd7","modified":1711277430808},{"_id":"public/2024/03/19/设计模式/工厂模式/index.html","hash":"320d79414269991a25ef89ff5c749ba4264846e6","modified":1712218457300},{"_id":"source/_posts/设计模式/建造者模式.md","hash":"8ea7a6efe53104d4132a49b26a19f8979537408a","modified":1711360891331},{"_id":"public/2024/03/19/设计模式/建造者模式/index.html","hash":"41596e7258610f6c7c7197ff64bc35fafdf5dfd4","modified":1712218457300},{"_id":"source/_drafts/test.html","hash":"e48f21e216d39e90cb5a35041a2faabcd618d85f","modified":1711706098088},{"_id":"source/_drafts/设计模式/简历记录.md","hash":"cf0b7abe3c75876bb8d40207208886f3966b485a","modified":1711618042396},{"_id":"source/_drafts/设计模式/x.md","hash":"c69889f2243a6fc20413297e0007ba20402f1ab8","modified":1711587274767},{"_id":"source/_posts/源码/vue3/3-渲染器-数据访问是如何被代理的.md","hash":"c5b81ab6a9694888624e8f0f5f819e80322a07a3","modified":1710895815318},{"_id":"source/_drafts/设计模式/x.json","hash":"f40e0fba28a7d5516a82a71689fc97a2f2efd1cd","modified":1711624330173},{"_id":"source/_posts/源码/vue2/vue2_nextTeck.md","hash":"e341e83c07dd078c67a93af8499c019eb69b2ff3","modified":1711725215007},{"_id":"source/_posts/源码/vue3/ref.md","hash":"647da722c17078bcd78312360c8d6f7b424f5a93","modified":1712137503405},{"_id":"source/_posts/源码/vue3/vue3_dom_diff.md","hash":"831b8da020b9fe312f14024f1e5a724937cc2d0e","modified":1711972333246},{"_id":"source/_posts/源码/vue3/最长递增子序列.md","hash":"382b262032dc8fbb0f966d9ccbcccc93159ff568","modified":1711725408013},{"_id":"source/_drafts/设计模式/x.html","hash":"c3ef2ec87a5ff4e205aa0ad7e12ae9de3bad0714","modified":1711624307084},{"_id":"public/2024/03/22/源码/vue3/ref/index.html","hash":"f81cd295567e6ed41d47347dfb7ed0fad1638354","modified":1712218457300},{"_id":"public/2024/03/22/源码/vue3/最长递增子序列/index.html","hash":"69e366a107bef8b90e2cae95fb6295a4c41ca75d","modified":1712218457300},{"_id":"public/2024/03/22/源码/vue3/vue3_dom_diff/index.html","hash":"d0816da8498fb798f9906f4018d45d3f29469333","modified":1712218457300},{"_id":"public/2024/03/21/源码/vue2/vue2_nextTeck/index.html","hash":"0bccf1595d1a612b95ddd4a06744ac9ae6db4d65","modified":1712218457300},{"_id":"public/2024/03/13/源码/vue3/3-渲染器-数据访问是如何被代理的/index.html","hash":"2295e38da23b97e4dd1ab80335e99633512ed50f","modified":1712218457300},{"_id":"source/_drafts/学习源码.md","hash":"2decff7ec74a036552250d5d0f75921f9beb2938","modified":1711759512843},{"_id":"source/_posts/源码/vue3/reactive.md","hash":"72e19dd8a02137399a836f9267f0f317e1640cae","modified":1712137759390},{"_id":"public/2024/03/22/源码/vue3/reactive/index.html","hash":"b48b83262fee59ac30f05603e2858f8a60fa659c","modified":1712114800740},{"_id":"source/_posts/源码/vue3/computed.md","hash":"ef10658d863a53a65612b0e8b1a6fde43a71b770","modified":1712141804572},{"_id":"source/_drafts/源码/vue3/reactive.js","hash":"3997c3175f53d74391efd24d755c02469039b7f3","modified":1711899506690},{"_id":"source/_drafts/源码/vue3/baseHandlers.js","hash":"6a4ef2fada19e696432ecf865b109b189d449789","modified":1711899992515},{"_id":"source/_drafts/源码/vue3/ref.js","hash":"63011a6c81aef7e93b97cbc8086f26773d652e1f","modified":1712113851440},{"_id":"public/2024/03/30/源码/vue3/computed/index.html","hash":"6e87bd86048eb3b70210b8f787a1be72f06fe732","modified":1712218457300},{"_id":"public/archives/page/2/index.html","hash":"9d5ba1624295ab1c96c8fde9f18b81b3b09e3db1","modified":1712218457300},{"_id":"public/archives/2024/page/2/index.html","hash":"bda13b77aff6749ae9d01a52737bea27462baf0f","modified":1712218457300},{"_id":"public/archives/2024/03/page/2/index.html","hash":"522dd9cdb510acf0fb67001fbc1433cd2ccde5da","modified":1712114800740},{"_id":"public/page/2/index.html","hash":"5432a5e61f0f7a6c4946adfbb1b7640f6c6805a2","modified":1712218457300},{"_id":"source/_drafts/源码/vue3/computed.js","hash":"44a178ffeefd18f28022c1aaaec19bcc98dfcb38","modified":1712101977644},{"_id":"source/_posts/源码/vue3/effect.md","hash":"b2731992e2e10f843686a43cd73383b01461073f","modified":1712153194197},{"_id":"source/_posts/源码/vue3/dep.md","hash":"7c457d943f92a435d1e0b347d730767d28495886","modified":1712114762401},{"_id":"source/_drafts/源码/vue3/dep.js","hash":"f0eee8d46906913297252d41ba3183e265559b2b","modified":1712108528640},{"_id":"source/_drafts/源码/vue3/effect.js","hash":"af6a8581c78c98f1b9db54a4625d5c2a0d234396","modified":1712133818857},{"_id":"source/_drafts/源码/vue3/reactiveEffects.js","hash":"ed99278998d663c477b0b4685cec852d666f5f32","modified":1712110178837},{"_id":"public/2024/04/03/源码/vue3/effect/index.html","hash":"3cc8ee8fa633064cb63c5f3428f8f9707e8534c6","modified":1712218457300},{"_id":"public/2024/04/03/源码/vue3/dep/index.html","hash":"80f30b4675fb329d1d3d872614f3e120c343cf10","modified":1712218457300},{"_id":"public/archives/2024/04/index.html","hash":"e4db859258675b332babd01d602c79abc361320f","modified":1712218457300},{"_id":"source/_posts/源码/vue3/watch.md","hash":"fcea2872a85c2af62f33349c213b06cab81f8ff2","modified":1712218436778},{"_id":"source/_drafts/源码/vue3/runtime-core/apiWatch.js","hash":"eba7f07bf4493e0fb101761d01a40e071bd929d9","modified":1712216236390},{"_id":"source/_drafts/源码/vue3/runtime-core/scheduler.js","hash":"9f8b5caec17bec2edd16ed9ff3b063e108b9693b","modified":1712217889433},{"_id":"public/2024/04/03/源码/vue3/watch/index.html","hash":"e5e37acd5ba409bb1975224b163fe4a8607dad37","modified":1712218457300},{"_id":"public/2024/04/03/源码/vue3/reactive/index.html","hash":"efe36b2b24a9c2d189664a0978c796d200f810c6","modified":1712218457300}],"Category":[{"name":"Vue3 技术揭秘","_id":"cltzsloke000csovcfy7h5805"}],"Data":[{"_id":"link","data":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}],"Page":[{"title":"About-Me","date":"2022-01-14T06:37:51.000Z","type":"about-me","layout":"about-me","_content":"","source":"about-me/index.md","raw":"---\ntitle: about-me\ndate: 2022-01-14 14:37:51\ntype: \"about-me\"\nlayout: \"about-me\"\n---\n","updated":"2023-08-12T07:53:20.004Z","path":"about-me/index.html","comments":1,"_id":"cltzslok20000sovcgrjld7z3","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":""},{"title":"Archives","date":"2022-01-14T06:32:41.000Z","type":"archives","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2022-01-14 14:32:41\ntype: \"archives\"\n---\n","updated":"2023-08-12T18:55:33.125Z","path":"archives/index.html","comments":1,"layout":"page","_id":"cltzslok70002sovce3om0qzc","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":""},{"title":"分类","date":"2022-01-14T06:19:06.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2022-01-14 14:19:06\ntype: \"categories\"\n---\n","updated":"2023-08-12T19:16:48.550Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cltzslok90004sovc94ez81tx","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#4ebde9","excerpt":"","more":""},{"date":"2023-08-12T18:52:22.000Z","type":"link","_content":"","source":"link/index.md","raw":"---\ndate: 2023-08-13 02:52:22\ntype: \"link\"\n---\n","updated":"2023-08-13T07:59:02.232Z","path":"link/index.html","title":"","comments":1,"layout":"page","_id":"cltzsloka0006sovc2ok6c0f3","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":""},{"title":"List","date":"2023-08-12T18:51:35.000Z","_content":"","source":"list/index.md","raw":"---\ntitle: list\ndate: 2023-08-13 02:51:35\n---\n","updated":"2023-08-12T18:51:52.186Z","path":"list/index.html","comments":1,"layout":"page","_id":"cltzslokb0008sovc04jtf8ei","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#e7817c","excerpt":"","more":""},{"title":"Messageboard","date":"2023-08-14T14:28:47.000Z","comments":1,"_content":"","source":"messageboard/index.md","raw":"---\ntitle: messageboard\ndate: 2023-08-14 22:28:47\ncomments: true\n---\n","updated":"2023-08-14T14:47:44.281Z","path":"messageboard/index.html","layout":"page","_id":"cltzslokc000asovc4u3ie1wd","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":""},{"title":"视频","date":"2023-08-13T05:31:06.000Z","_content":"","source":"movies/index.md","raw":"---\ntitle: 视频\ndate: 2023-08-13 13:31:06\n---\n","updated":"2023-08-13T05:31:39.757Z","path":"movies/index.html","comments":1,"layout":"page","_id":"cltzslokf000dsovca1p68vkz","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":""},{"title":"音乐","date":"2023-08-13T05:26:07.000Z","_content":"","source":"music/index.md","raw":"---\ntitle: 音乐\ndate: 2023-08-13 13:26:07\n---\n","updated":"2023-08-13T05:31:13.426Z","path":"music/index.html","comments":1,"layout":"page","_id":"cltzslokg000fsovc3c065a12","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":""},{"title":"图库","date":"2023-08-13T07:22:42.000Z","top_img":"/img/video.jpg","_content":"\n<div class=\"gallery-group-main\">\n{% galleryGroup '壁紙' '收藏的一些壁紙' '/photo/wallpaper' /img/wallpaper.png %}\n{% galleryGroup '漫威' '關於漫威的圖片' '/photo/marwel' /img/marwel.webp %}\n</div>\n","source":"photo/index.md","raw":"---\ntitle: 图库\ndate: 2023-08-13 15:22:42\ntop_img: /img/video.jpg\n---\n\n<div class=\"gallery-group-main\">\n{% galleryGroup '壁紙' '收藏的一些壁紙' '/photo/wallpaper' /img/wallpaper.png %}\n{% galleryGroup '漫威' '關於漫威的圖片' '/photo/marwel' /img/marwel.webp %}\n</div>\n","updated":"2023-08-14T05:18:21.142Z","path":"photo/index.html","comments":1,"layout":"page","_id":"cltzslokh000hsovc5z3ocynn","content":"<div class=\"gallery-group-main\">\n<figure class=\"gallery-group\">\n  <img class=\"gallery-group-img no-lightbox\" src='/img/wallpaper.png' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">壁紙</div>\n  <p>收藏的一些壁紙</p>\n  <a href='/photo/wallpaper'></a>\n  </figcaption>\n  </figure>\n  \n<figure class=\"gallery-group\">\n  <img class=\"gallery-group-img no-lightbox\" src='/img/marwel.webp' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">漫威</div>\n  <p>關於漫威的圖片</p>\n  <a href='/photo/marwel'></a>\n  </figcaption>\n  </figure>\n  \n</div>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#e7817c","excerpt":"","more":"<div class=\"gallery-group-main\">\n<figure class=\"gallery-group\">\n  <img class=\"gallery-group-img no-lightbox\" src='/img/wallpaper.png' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">壁紙</div>\n  <p>收藏的一些壁紙</p>\n  <a href='/photo/wallpaper'></a>\n  </figcaption>\n  </figure>\n  \n<figure class=\"gallery-group\">\n  <img class=\"gallery-group-img no-lightbox\" src='/img/marwel.webp' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">漫威</div>\n  <p>關於漫威的圖片</p>\n  <a href='/photo/marwel'></a>\n  </figcaption>\n  </figure>\n  \n</div>\n"},{"_content":"{\n    \"name\": \"string\",\n    \"short_name\": \"Junzhou\",\n    \"theme_color\": \"#49b1f5\",\n    \"background_color\": \"#49b1f5\",\n    \"display\": \"standalone\",\n    \"scope\": \"/\",\n    \"start_url\": \"/\",\n    \"icons\": [\n        {\n            \"src\": \"images/pwaicons/36.png\",\n            \"sizes\": \"36x36\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"images/pwaicons/48.png\",\n            \"sizes\": \"48x48\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"images/pwaicons/72.png\",\n            \"sizes\": \"72x72\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"images/pwaicons/96.png\",\n            \"sizes\": \"96x96\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"images/pwaicons/144.png\",\n            \"sizes\": \"144x144\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"images/pwaicons/192.png\",\n            \"sizes\": \"192x192\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"images/pwaicons/512.png\",\n            \"sizes\": \"512x512\",\n            \"type\": \"image/png\"\n        }\n    ],\n    \"splash_pages\": null\n}","source":"pwa/manifest.json","raw":"{\n    \"name\": \"string\",\n    \"short_name\": \"Junzhou\",\n    \"theme_color\": \"#49b1f5\",\n    \"background_color\": \"#49b1f5\",\n    \"display\": \"standalone\",\n    \"scope\": \"/\",\n    \"start_url\": \"/\",\n    \"icons\": [\n        {\n            \"src\": \"images/pwaicons/36.png\",\n            \"sizes\": \"36x36\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"images/pwaicons/48.png\",\n            \"sizes\": \"48x48\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"images/pwaicons/72.png\",\n            \"sizes\": \"72x72\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"images/pwaicons/96.png\",\n            \"sizes\": \"96x96\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"images/pwaicons/144.png\",\n            \"sizes\": \"144x144\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"images/pwaicons/192.png\",\n            \"sizes\": \"192x192\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"images/pwaicons/512.png\",\n            \"sizes\": \"512x512\",\n            \"type\": \"image/png\"\n        }\n    ],\n    \"splash_pages\": null\n}","date":"2023-08-13T17:36:04.285Z","updated":"2023-08-13T17:34:13.767Z","path":"pwa/manifest.json","layout":"false","title":"","comments":1,"_id":"cltzsloki000jsovceum97e8u","content":"{\"name\":\"string\",\"short_name\":\"Junzhou\",\"theme_color\":\"#49b1f5\",\"background_color\":\"#49b1f5\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"images/pwaicons/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#e7817c","excerpt":"","more":"{\"name\":\"string\",\"short_name\":\"Junzhou\",\"theme_color\":\"#49b1f5\",\"background_color\":\"#49b1f5\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"images/pwaicons/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"标签","date":"2022-01-14T06:36:42.000Z","type":"tags","orderby":1,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2022-01-14 14:36:42\ntype: tags\n# orderby: random\norderby: 1\n---\n","updated":"2023-08-12T19:14:30.951Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cltzslokj000lsovc232r8a61","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":""},{"title":"漫威","date":"2023-08-13T05:26:07.000Z","_content":"\n{% gallery %}\n![](/photo/marwel/img/1.png)\n![](/photo/marwel/img/1.webp)\n![](/photo/marwel/img/2.webp)\n![](/photo/marwel/img/3.webp)\n{% endgallery %}\n\n{% asset_img u/photo/marwel/1.png This is an example image %}\n","source":"photo/marwel/index.md","raw":"---\ntitle: 漫威\ndate: 2023-08-13 13:26:07\n---\n\n{% gallery %}\n![](/photo/marwel/img/1.png)\n![](/photo/marwel/img/1.webp)\n![](/photo/marwel/img/2.webp)\n![](/photo/marwel/img/3.webp)\n{% endgallery %}\n\n{% asset_img u/photo/marwel/1.png This is an example image %}\n","updated":"2023-08-13T17:16:21.822Z","path":"photo/marwel/index.html","comments":1,"layout":"page","_id":"cltzslokk000osovc3uzydqa8","content":"<div class=\"gallery-container\" data-type=\"data\" data-button=\"\">\n      <div class=\"gallery-data\">[{\"url\":\"/photo/marwel/img/1.png\",\"alt\":\"\"},{\"url\":\"/photo/marwel/img/1.webp\",\"alt\":\"\"},{\"url\":\"/photo/marwel/img/2.webp\",\"alt\":\"\"},{\"url\":\"/photo/marwel/img/3.webp\",\"alt\":\"\"}]</div>\n      <div class=\"gallery-items\">\n      </div>\n    </div>\n\n\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#4ebde9","excerpt":"","more":"<div class=\"gallery-container\" data-type=\"data\" data-button=\"\">\n      <div class=\"gallery-data\">[{\"url\":\"/photo/marwel/img/1.png\",\"alt\":\"\"},{\"url\":\"/photo/marwel/img/1.webp\",\"alt\":\"\"},{\"url\":\"/photo/marwel/img/2.webp\",\"alt\":\"\"},{\"url\":\"/photo/marwel/img/3.webp\",\"alt\":\"\"}]</div>\n      <div class=\"gallery-items\">\n      </div>\n    </div>\n\n\n"},{"title":"壁纸","date":"2023-08-13T07:28:24.000Z","_content":"\n![](/photo/wallpaper/img/1.png)\n![](/photo/wallpaper/img/2.png)\n![](/photo/wallpaper/img/3.png)","source":"photo/wallpaper/index.md","raw":"---\ntitle: 壁纸\ndate: 2023-08-13 15:28:24\n---\n\n![](/photo/wallpaper/img/1.png)\n![](/photo/wallpaper/img/2.png)\n![](/photo/wallpaper/img/3.png)","updated":"2023-08-13T17:15:49.918Z","path":"photo/wallpaper/index.html","comments":1,"layout":"page","_id":"cltzslokl000qsovc2mdz3bmd","content":"<p><img src=\"/photo/wallpaper/img/1.png\"><br><img src=\"/photo/wallpaper/img/2.png\"><br><img src=\"/photo/wallpaper/img/3.png\"></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":"<p><img src=\"/photo/wallpaper/img/1.png\"><br><img src=\"/photo/wallpaper/img/2.png\"><br><img src=\"/photo/wallpaper/img/3.png\"></p>\n"}],"Post":[{"title":"在开始一个 Node.js 项目之前，你需要进行一些准备工作，以确保项目能够顺利进行。","_content":"\n# 在开始一个 Node.js 项目之前，你需要进行一些准备工作，以确保项目能够顺利进行。\n\n以下是一些常见的准备工作：\n\n---\n\n## 以下是一些常见的准备工作：\n\n1. **安装Node.js：** Node.js 是运行 JavaScript 代码的运行时环境，你需要在你的计算机上安装 Node.js。你可以从 Node.js 的官方网站下载安装程序，并按照说明进行安装。\n2. **选择项目目录：** 确定你的项目所在的目录，并在该目录下进行后续操作\n3. **初始化项目：** 在项目目录下，你可以使用 `npm init` 命令或者 `yarn init` 命令初始化一个新的项目。这个命令会创建一个 `package.json` 文件，其中包含了你的项目的基本信息和依赖管理。\n4. **安装项目依赖：** 如果你的项目需要使用第三方库或框架，你可以使用 `npm install` 命令或者 `yarn add` 命令安装项目依赖。\n5. **创建项目文件结构：** 根据你的项目需求和组织结构，创建项目所需的文件和目录。典型的 Node.js 项目通常包括 `index.js`（或者其他入口文件）、`routes`（用于存放路由文件）、`controllers`（用于存放控制器逻辑）、`models`（用于存放数据模型）、`views`（如果是基于MVC框架）、`public`（用于存放静态资源文件）等。\n6. **编写代码：** 一切就绪后，你可以开始编写你的 Node.js 代码了。你可以编辑 `index.js` 文件作为入口文件，并根据需要创建其他文件来组织你的代码。\n7. **测试代码：** 在编写完代码后，建议进行代码测试以确保代码的质量和稳定性。你可以使用各种测试工具，如 Mocha、Jest、Jasmine 等来进行单元测试、集成测试和端到端测试。\n8. **启动应用：** 编写完代码后，你可以使用 `node index.js` 命令来启动你的应用。如果你使用了框架，可能需要按照框架的方式来启动应用。\n","source":"_drafts/在开始一个 Node.js 项目之前，你需要进行一些准备工作，以确保项目能够顺利进行。.md","raw":"---\ntitle: 在开始一个 Node.js 项目之前，你需要进行一些准备工作，以确保项目能够顺利进行。\n---\n\n# 在开始一个 Node.js 项目之前，你需要进行一些准备工作，以确保项目能够顺利进行。\n\n以下是一些常见的准备工作：\n\n---\n\n## 以下是一些常见的准备工作：\n\n1. **安装Node.js：** Node.js 是运行 JavaScript 代码的运行时环境，你需要在你的计算机上安装 Node.js。你可以从 Node.js 的官方网站下载安装程序，并按照说明进行安装。\n2. **选择项目目录：** 确定你的项目所在的目录，并在该目录下进行后续操作\n3. **初始化项目：** 在项目目录下，你可以使用 `npm init` 命令或者 `yarn init` 命令初始化一个新的项目。这个命令会创建一个 `package.json` 文件，其中包含了你的项目的基本信息和依赖管理。\n4. **安装项目依赖：** 如果你的项目需要使用第三方库或框架，你可以使用 `npm install` 命令或者 `yarn add` 命令安装项目依赖。\n5. **创建项目文件结构：** 根据你的项目需求和组织结构，创建项目所需的文件和目录。典型的 Node.js 项目通常包括 `index.js`（或者其他入口文件）、`routes`（用于存放路由文件）、`controllers`（用于存放控制器逻辑）、`models`（用于存放数据模型）、`views`（如果是基于MVC框架）、`public`（用于存放静态资源文件）等。\n6. **编写代码：** 一切就绪后，你可以开始编写你的 Node.js 代码了。你可以编辑 `index.js` 文件作为入口文件，并根据需要创建其他文件来组织你的代码。\n7. **测试代码：** 在编写完代码后，建议进行代码测试以确保代码的质量和稳定性。你可以使用各种测试工具，如 Mocha、Jest、Jasmine 等来进行单元测试、集成测试和端到端测试。\n8. **启动应用：** 编写完代码后，你可以使用 `node index.js` 命令来启动你的应用。如果你使用了框架，可能需要按照框架的方式来启动应用。\n","slug":"在开始一个 Node.js 项目之前，你需要进行一些准备工作，以确保项目能够顺利进行。","published":0,"date":"2023-08-14T14:37:14.481Z","updated":"2024-03-20T00:50:23.543Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslok40001sovcc44xbrht","content":"<h1 id=\"在开始一个-Node-js-项目之前，你需要进行一些准备工作，以确保项目能够顺利进行。\"><a href=\"#在开始一个-Node-js-项目之前，你需要进行一些准备工作，以确保项目能够顺利进行。\" class=\"headerlink\" title=\"在开始一个 Node.js 项目之前，你需要进行一些准备工作，以确保项目能够顺利进行。\"></a>在开始一个 Node.js 项目之前，你需要进行一些准备工作，以确保项目能够顺利进行。</h1><p>以下是一些常见的准备工作：</p>\n<hr>\n<h2 id=\"以下是一些常见的准备工作：\"><a href=\"#以下是一些常见的准备工作：\" class=\"headerlink\" title=\"以下是一些常见的准备工作：\"></a>以下是一些常见的准备工作：</h2><ol>\n<li><strong>安装Node.js：</strong> Node.js 是运行 JavaScript 代码的运行时环境，你需要在你的计算机上安装 Node.js。你可以从 Node.js 的官方网站下载安装程序，并按照说明进行安装。</li>\n<li><strong>选择项目目录：</strong> 确定你的项目所在的目录，并在该目录下进行后续操作</li>\n<li><strong>初始化项目：</strong> 在项目目录下，你可以使用 <code>npm init</code> 命令或者 <code>yarn init</code> 命令初始化一个新的项目。这个命令会创建一个 <code>package.json</code> 文件，其中包含了你的项目的基本信息和依赖管理。</li>\n<li><strong>安装项目依赖：</strong> 如果你的项目需要使用第三方库或框架，你可以使用 <code>npm install</code> 命令或者 <code>yarn add</code> 命令安装项目依赖。</li>\n<li><strong>创建项目文件结构：</strong> 根据你的项目需求和组织结构，创建项目所需的文件和目录。典型的 Node.js 项目通常包括 <code>index.js</code>（或者其他入口文件）、<code>routes</code>（用于存放路由文件）、<code>controllers</code>（用于存放控制器逻辑）、<code>models</code>（用于存放数据模型）、<code>views</code>（如果是基于MVC框架）、<code>public</code>（用于存放静态资源文件）等。</li>\n<li><strong>编写代码：</strong> 一切就绪后，你可以开始编写你的 Node.js 代码了。你可以编辑 <code>index.js</code> 文件作为入口文件，并根据需要创建其他文件来组织你的代码。</li>\n<li><strong>测试代码：</strong> 在编写完代码后，建议进行代码测试以确保代码的质量和稳定性。你可以使用各种测试工具，如 Mocha、Jest、Jasmine 等来进行单元测试、集成测试和端到端测试。</li>\n<li><strong>启动应用：</strong> 编写完代码后，你可以使用 <code>node index.js</code> 命令来启动你的应用。如果你使用了框架，可能需要按照框架的方式来启动应用。</li>\n</ol>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#4ebde9","excerpt":"","more":"<h1 id=\"在开始一个-Node-js-项目之前，你需要进行一些准备工作，以确保项目能够顺利进行。\"><a href=\"#在开始一个-Node-js-项目之前，你需要进行一些准备工作，以确保项目能够顺利进行。\" class=\"headerlink\" title=\"在开始一个 Node.js 项目之前，你需要进行一些准备工作，以确保项目能够顺利进行。\"></a>在开始一个 Node.js 项目之前，你需要进行一些准备工作，以确保项目能够顺利进行。</h1><p>以下是一些常见的准备工作：</p>\n<hr>\n<h2 id=\"以下是一些常见的准备工作：\"><a href=\"#以下是一些常见的准备工作：\" class=\"headerlink\" title=\"以下是一些常见的准备工作：\"></a>以下是一些常见的准备工作：</h2><ol>\n<li><strong>安装Node.js：</strong> Node.js 是运行 JavaScript 代码的运行时环境，你需要在你的计算机上安装 Node.js。你可以从 Node.js 的官方网站下载安装程序，并按照说明进行安装。</li>\n<li><strong>选择项目目录：</strong> 确定你的项目所在的目录，并在该目录下进行后续操作</li>\n<li><strong>初始化项目：</strong> 在项目目录下，你可以使用 <code>npm init</code> 命令或者 <code>yarn init</code> 命令初始化一个新的项目。这个命令会创建一个 <code>package.json</code> 文件，其中包含了你的项目的基本信息和依赖管理。</li>\n<li><strong>安装项目依赖：</strong> 如果你的项目需要使用第三方库或框架，你可以使用 <code>npm install</code> 命令或者 <code>yarn add</code> 命令安装项目依赖。</li>\n<li><strong>创建项目文件结构：</strong> 根据你的项目需求和组织结构，创建项目所需的文件和目录。典型的 Node.js 项目通常包括 <code>index.js</code>（或者其他入口文件）、<code>routes</code>（用于存放路由文件）、<code>controllers</code>（用于存放控制器逻辑）、<code>models</code>（用于存放数据模型）、<code>views</code>（如果是基于MVC框架）、<code>public</code>（用于存放静态资源文件）等。</li>\n<li><strong>编写代码：</strong> 一切就绪后，你可以开始编写你的 Node.js 代码了。你可以编辑 <code>index.js</code> 文件作为入口文件，并根据需要创建其他文件来组织你的代码。</li>\n<li><strong>测试代码：</strong> 在编写完代码后，建议进行代码测试以确保代码的质量和稳定性。你可以使用各种测试工具，如 Mocha、Jest、Jasmine 等来进行单元测试、集成测试和端到端测试。</li>\n<li><strong>启动应用：</strong> 编写完代码后，你可以使用 <code>node index.js</code> 命令来启动你的应用。如果你使用了框架，可能需要按照框架的方式来启动应用。</li>\n</ol>\n"},{"title":"学会看八字","_content":"\n# 学会看八字\n\n道教文化道教认为，**我命有我不由天**， 通过研究生命的规律可以去**趋吉避凶**，好事发生的时候那就把它加强一下，然后好事更好，但是坏事要发生了，那么怎么办呢~我们去规避一下大事给化解掉**大事化小小事化了。**\n\n---\n\n## 五行\n\n有个东西大家是没有办法省略的，就是**五行**，这个五行是道家文化所独有的一个传统文化，道教他认为**天地万物都分阴阳和五行**，那么通过这个学习**五行相生相克**，这是所有周易学派的一个基础，不管你以后学八字奇门遁甲，大六任，小六任，梅花艺术，紫微斗数，黄极其势等等，周易分很多门派很多学科但是他的核心就是**五行**。\n\n五行相生\n- 水: 地球出现的第一个元素\n- 水生木: 植物需要水来灌溉\n- 木生火: 钻木取火\n- 火生土: 火燃烧后变成灰, 灰就是土\n- 土生金: 沙里淘金\n- 金生水: 用金属工具挖井\n\n五行向克\n- 金克木: 用金属制作的斧头可以砍树\n- 木克土: 植物吸收了土里的营养\n- 土克水: 水来土掩\n- 水克火: 水能灭火\n- 火克金: 火能把金属融化\n\n![五行相生](https://picsum.photos/1200/500)\n![五行相生](https://picsum.photos/1200/500)\n\n## 四季土\n1-12月分别用地支表示: 寅卯**辰** / 巳午**未** / 申酉**戌** / 亥子**丑**\n- 其中每个季度的最后一个月份都是属土, 分别是 **辰 / 未 / 戌 / 丑**\n- 寅月和卯月属木, 巳月和午月属火, 申月和酉月属金, 亥月和子月属水\n\n## 天干\n\n甲\n方向: 东方\n阴阳: 阳木\n颜色: 绿色\n身体部位: 肝\n意象: 大树\n\n已\n方向: 东方\n阴阳: 阴木\n颜色: 绿色\n身体部位: 胆\n意象: 花草\n\n丙\n方向: 南方\n阴阳: 阳火\n颜色: 红色\n身体部位: 小肠\n意象: 太阳, 圆形物品\n\n丁\n方向: 南方\n阴阳: 阴火\n颜色: 红色\n身体部位: 心脏, 血液\n意象: 蜡烛, 电灯泡, 烟头\n\n戊\n方向: 中央\n阴阳: 阳土\n颜色: 黄色\n身体部位: 胃\n意象: 城墙土\n\n己\n方向: 中央\n阴阳: 阴土\n颜色: 黄色\n身体部位: 脾\n意象: 田地\n\n庚\n方向: 西方\n阴阳: 阳金\n颜色: 白色, 金色\n身体部位: 大肠\n意象: 宝剑, 大刀, 汽车\n\n辛\n方向: 西方\n阴阳: 阴金\n颜色: 白色, 金色\n身体部位: 肺\n意象: 首饰, 小型金属物品\n\n壬\n方向: 北方\n阴阳: 阳水\n颜色: 黑色, 蓝色\n身体部位: 膀胱\n意象: 大江, 大河, 大湖, 大海\n\n癸\n方向: 北方\n阴阳: 阴水\n颜色: 黑色, 蓝色\n身体部位: 肺\n意象: 小溪, 水井, 小河, 露水, 下水道\n\n\n## 地支\n\n子\n方向: 正北方\n颜色: 黑色, 蓝色\n阴阳: 阳水\n月份: 阴历11月\n时间: 23点到凌晨1点\n藏天干: 本气癸\n动物代表: 鼠\n\n丑\n方向: 东北方\n颜色: 黄色\n阴阳: 阴土\n月份: 阴历12月\n时间: 凌晨1点到3点\n藏天干: 本气己, 中气辛, 余气庚\n动物代表: 牛\n\n寅\n方向: 东北方\n颜色: 绿色\n阴阳: 阳木\n月份: 阴历一月\n时间: 凌晨3点到5点\n藏天干: 本气甲, 中气丙, 余气戊\n动物代表: 老虎\n\n卯\n方向: 正东方\n颜色: 绿色\n阴阳: 阴木\n月份: 阴历二月\n时间: 凌晨5点到7点\n藏天干: 本气乙\n动物代表: 兔子\n\n辰\n方向: 东南方\n颜色: 黄色\n阴阳: 阳土\n月份: 阴历3月\n时间: 上午7点到9点\n藏天干: 本气戊, 中气已, 余气庚\n动物代表: 龙\n\n巳\n方向: 东南方\n颜色:  红色\n阴阳: 阴火\n月份: 阴历4月\n时间: 上午9点到11点\n藏天干: 本气丙, 中气戊, 余气庚\n动物代表: 蛇\n\n午\n方向: 正南方\n颜色: 红色\n阴阳: 阳火\n月份: 阴历5月\n时间: 中午11点到下午13点\n藏天干: 本气丁, 中气乙\n动物代表: 马\n\n未\n方向: 西南方\n颜色: 黄色\n阴阳: 阴土\n月份: 阴历6月\n时间: 下午13点到15点\n藏天干: 本气已, 中气丁, 余气已\n动物代表: 羊\n\n申\n方向: 西南方\n颜色: 白色, 金色\n阴阳: 阳金\n月份: 阴历7月\n时间: 下午15点到17点\n藏天干: 本气庚, 中气壬, 余气戊\n动物代表: 猴\n\n酉\n方向: 正西方\n颜色: 白色, 金色\n阴阳: 阴金\n月份: 寅月8月\n时间: 下午17点到19点\n藏天干: 本气辛\n动物代表: 鸡\n\n戌\n方向: 西北方\n颜色: 黄色\n阴阳: 阳土\n月份: 阴历9月\n时间: 下午19点到21点\n藏天干: 本气戊, 中气辛, 余气丁\n动物代表: 狗\n\n亥\n方向: 西北方\n颜色: 蓝色, 黑色\n阴阳: 阴水\n月份: 阴历10月\n时间: 晚上21点23点\n藏天干: 本气壬, 中气甲\n动物代表: 猪\n\n\n\n\n## 藏干\n子: 癸\n丑: 己 / 辛 / 癸\n寅: 甲 / 丙 / 戊\n卯: 乙\n辰: 戊 / 乙 / 癸\n巳: 丙 / 戊 / 庚\n午: 丁 / 己\n未: 己 / 丁 / 乙\n申: 庚 / 壬 / 戊\n酉: 辛\n戌: 戊 / 辛 / 丁\n亥: 壬 / 甲\n\n\n## 宫位六亲\n注: 每个宫位代表9年\n年干: 父亲, 父亲家族    月干: 父亲, 姐姐哥哥, 社会上的哥哥姐姐  日元: 自己          时干: 长子\n年干: 母亲, 母亲家族    月令: 母亲, 弟弟妹妹, 社会上的弟弟妹妹  日支: 夫妻, 家族    时支: 次子\n祖先宫                 父母兄弟姐妹, 社会关系宫               夫妻宫              子女宫\n\n\n\n## 分清日元强弱\n年干\n\n看八字的第一步就是分清日元强弱\n\n![八字得分](https://picsum.photos/500/450)\n\n十二长生\n长生, 沐浴, 冠带, 临官, 帝旺, 衰, 病, 死, 墓, 绝, 胎, 养\n\n## 八卦九宫(河图洛书)\n        甲  乙  丙  丁  戊  己  庚  辛  壬  癸\n长生     亥  午  寅  酉  寅  酉  巳  子  申  卯                                                 \n沐浴     子  巳  卯  申  卯  申  午  亥  酉  寅\n\n冠带     丑  辰  辰  未  辰  未  未  戌  戌  丑                        \n临官     寅  卯  巳  午  巳  午  申  酉  亥  子                         \n帝旺     卯  寅  午  巳  午  巳  酉  申  子  亥                          \n\n衰       辰  丑  未  辰  未  辰  戌  未  丑  戌                   \n病       巳  子  申  卯  申  卯  亥  午  寅  酉                  \n死       午  亥  酉  寅  酉  寅  子  巳  卯  申                   \n墓       未  戌  戌  丑  戌  丑  丑  辰  辰  未                   \n绝       申  酉  亥  子  亥  子  寅  卯  巳  午                   \n胎       酉  申  子  亥  子  亥  卯  寅  午  巳                   \n养       戌  未  丑  戌  丑  戌  辰  丑  未  辰\n\n\n    巳  午  未\n辰  4   9   2   申\n\n卯  3   5   7   酉\n\n寅  8   1   6   戌\n    丑  子  亥\n\n\n## 十神(一位为真, 二位为争, 三位为病, 四五六都不好, 七个反而变好)\n天干地支分五行, 五行又分阴阳,总共是十个种类\n因日元和其他七个干支会产生十种关系, 所以得出十神\n分别是四个吉神: 正印    食神    正官    正财\n      四个恶神: 七杀    偏印    伤官    劫财\n      两个平神: 比肩    偏财\n规律：\n  - 克我者为官杀\n  - 我克者为财才\n  - 生我者为印枭\n  - 我生者为食伤\n  - 同我者为比劫\n    \n### 正印（智慧之神）\n正印详解：以日元为我，生我者为印枭，阴生阳我，阳生阴我，为正印，简记为“印”\n\n正印代表什么\n性格：聪明智慧，记性好，喜欢学习，心地善良，责任心强，少病少灾\n意像：房子，文书，教育，权利，脑中的天使\n职业选择：宜当教师、艺术家、出版商、秘书、护士、宗教家或星象家、棋手等\n正印的亲人：代表长辈，贵人，师长；男命代表母亲，女命代表祖父、女婿\n \n正印的含义\n1. 日元身弱, 最喜正印来生;\n    日元身强, 正印来生反而为害;\n2. 正印是你脑中的天使, 不停的啰嗦;\n    时刻提醒你不要做坏事, 不要做错事;\n3. 正印代表古代中的印玺, 代表权利. 命中无官, 有印一样能掌权.\n4. 正印代表思想文化, 正印多的人, \n    一生的追求是自己的思想观念能得到别人的认可.\n5. 日元身弱正印代表房子, 日元身强不代表房子.\n6. 男人命中正印代表母亲, 财可以克印;\n    男人一旦发财, 母亲的身体就会不好.\n    另外正财代表男人的老婆, 正财多的男人, 婆媳关系都不太好.\n    同理: 女人正印代表祖父, 女婿, 女人发财会克到祖父, 女婿.\n7. 命中没有正印的人, 不爱学习, 没有责任心, 记性不好, 学非所用\n    与母亲缘分浅, 经常生病\n\n### 食神（福神）\n食神详解：以日元为我，我生者为食伤。阳我生我，阴我生阴，为食神，简记为“食”\n\n食神代表什么：食神一位胜财官。\n性格：口才好，喜欢玩，好歌舞酒色，吃货，多福多寿，心宽体胖，为人宽宏大量，对艺术天赋异禀。\n意像：胖，大，有福气，衣食无忧。\n职业选择：演艺、娱乐、美术、美容、服装设计或餐饮酒店等。\n食神代表的亲人：代表晚辈，学生，下属。男人的孙子，女人的女儿\n\n食神的含义：\n1. 食神的主要作用是生财，吃喝玩乐还能把钱赚到。\n2. 日元身强，食神为喜用时能够泄化日主和比劫，食神一切好的一面就出现了。\n3. 日元身弱，再去生食神，食神为忌凶，代表自己腹有诗书，难遇伯乐，易郁郁寡欢，怀才不遇，自己的思想易与世俗红尘格格不入。\n4. 食神可以克制官杀，食神克制克我之七杀，保自己的命。食神一到，官运要丢。\n5. 时柱有食神最好，代表晚年有福，衣食无忧。时柱又代表子女宫\n6. 也代表能享子女之福。\n7. 食神不易过多，过多会身体肥胖，贪图享乐，好逸恶劳，不务正业，不知节俭。\n8. 没有食神也不好，不会玩，口才不好，不善言辞。\n\n### 正官（贵神）\n正官详解：以日元为我，克我者为官杀，阳克阴我，或阴克阳我，为正官；简记为“官”\n\n正官代表什么：\n性格：守信用、正直、光明磊落、好面子、在乎名声地位、廉洁、公正、稳重\n意像：大哥、领导、领袖、地位、受人敬仰\n职业选择：政治、法律、侦探、法官、记者、公职方面职业\n正官代表的亲人：长官、领导、上司；男人的女儿，女人的老公；\n\n正官的其他含义：\n《论语·子路篇》中有一段话：其身正，不令而行，其身不正，虽令不从。\n\n1. 命带正官之人，容易当官。年柱，班干部；月柱，当领导；日支：有组织领导能力；时支，子女光明正直。\n2. 命带正官之人，好操心，劳累，容易长白头发。\n3. 朋友大多是正经人，有恶习的人，赌博，涉黄，犯法，涉黑不正派的人不愿结交，但也不得罪\n4. 朋友不多，很难有死党知己。\n5. 女人正官代表老公，不宜太多。女人无官婚难成，女人一官最好命；女人二官心不定，女人三官会作娼\n6. 正官太多变成强迫症，古板死心眼，固执。\n7. 本名正官多，大运流年又遇到正官，会有执法单位，公检法来找事。\n8. 正官多的人，一生追求的是名誉地位，什么都可以不要，一定要当领导。\n9. 没有正官，对自己无法严格要求，不喜欢别人拘束，目无法律；我行我素，很难做领导。女同志没有正官会晚婚，严重的终身不嫁；\n\n\n### 正财（富神）\n正财详解：以日元为我，我克者为财才；阳我克阴，或阴我克阳，为正财，简记为“财”\n\n正财代表什么：\n性格：守本分，诚实守信，脚踏实地，勤俭节约，重视家庭，诚信，爱妻子，是个值得信赖的人。\n意像：稳定的收入，合法的收入\n职业选择：如银行、财政、外交、中介、杂货、百货、批发零售、药商等\n正财代表的亲人富翁，商人；男人的妻子，女人的父亲；\n\n正财的其他含义\n1. 日元身弱正财为忌凶，为人吝啬，并且不容易发财。\n2. 财喜藏不喜漏。天干之财为虚财，地支藏干里的财为真财。\n3. 女怕官旺，男怕财多，男人正财多，多妻之像，或者不重视结发之妻。\n4. 正财在年柱，工薪家庭，家庭条件还可以有房子住，正财在年柱跟发财关系不大。\n月柱日柱时柱有正财最好\n月柱正财30岁以后有稳定收入，才算是富命。\n日支逢正财，代表孩子发财，晚年有稳定收入。\n时支管55岁以后，时支正财是老年再结婚。\n5. 正财偏财过多，为愚蠢之人。除了对钱感兴趣，对别的全不感兴趣。\n6. 命中没有正财，一生财来财去，一场空；烂桃花多。女人与父亲缘薄，父多早丧，或病残，父亲无能。\n\n### 七杀（病神）\n七杀详解：以日元为我，遇克制日主的同性天干；阴阴相克，阳阳相克，就称为偏官；因同性相克力量比较凶狠，古人以七杀命名，简记为“杀”；\n\n七杀代表什么：\n负面性格：霸道，急躁如火，脾气古怪，任性倔强，好胜好斗，报复心强，偏激叛逆，鲁莽冲动，听不进谏言、易树敌\n正面性格：执行力强，有正义感和侠义精神，做事有魄力，勇于向困难挑战，勇于突破困境，坚强之意志力与干劲\n意像：小人，仇人，得病\n职业选择：武职，比如参军，警察，法院等需要具有杀气的行业，适合做二把手\n代表人物：军人，警察，公检法执法地位；男人的儿子，女人的情人\n\n五行身体部位\n甲肝乙胆丙胆，丁心戊胃己脾乡；庚金大肠辛金肺，壬是膀胱癸肾藏；\n年干（头）      月干（胸部）    日元（小腹）    时干（大腿）\n年支（脖子）    月令（腹部）    日支（屁股）    时支（小腿脚部）\n\n七杀的其他含义\n1. 七杀在哪个五行，哪个五行就容易得病。\n2. 七杀在哪个位置，哪个位置就容易得病。\n3. 七杀索我性命，伤官破我官爵；枭印夺我俸禄；劫财争我财产；都是不好的恶神；\n4. 七杀为日元的天敌，四凶神中的索命之鬼，因此八字批命首先看七杀，\n只有安顿了七杀，方可论富贵，否则连有命无命都不知道，何言富贵？\n七杀无制，在天干的多为突发之灾致残疾或凶死，在地支的则为慢性恶疾。\n5. 但是七杀得制，也可以出现好的情况。\n    1. 身强不怕七杀，七杀来克反为好，这叫身杀俩停。\n    2. 身弱有正印化解七杀。七杀生印，正印生日元。七杀反为我用，这叫杀印相生。\n    3. 身弱有食神制杀，没有偏印损害食神，七杀得制，这叫食神制杀。\n6. 本命七杀太多。大运流年遇到七杀，会有公检法执法单位找事。\n7. 本命没有七杀，正官太多，大运流年再遇到正官，正官会变成七杀。\n8. 只有七杀，没有正官，只能做二把手，做不了一把手。\n9. 聪明不过伤官，伶俐不过七杀\n10. 女命的七杀代表情人，相好的，女命不宜七杀过多。\n11. 没有七杀，代表男人不容易生儿子，女人没有情人。性格方面不会心太狠。\n\n### 偏印（郁神）\n偏印详解：以日元为我，生我者为印枭；阳生阳我，阴生阴我，为偏印，偏印带有凶性；古人称为枭神，简记为“枭”；\n\n偏印代表什么：\n负面性格：敏感，内心孤独，不开心，优柔寡断，犹豫不决。不善与人交往，宁可一个人独处，也不愿到人多的地方。\n正面性格：敏锐的观察力，分析力，感受力，理解力，困难的东西能迅速学，会多才多艺，心思细腻。\n意像：学习玄学有特殊天赋，一定会不开心。\n职业选择：研究，民意代表，发明，设计，创造，科技，武术，演艺，行销，直销，广告，模特，艳星等特殊专门性行业。\n代表人物：军事，参谋；男命之祖父，女命之母亲；\n\n偏印的其他含义\n1. 其他的干支偏印，命主会学习技术技能。月令偏印，必定有一技之长。\n2. 命局中见到偏印，马上可以断命主，不开心。和谁不开心？主要是食神。\n偏印和食神所在的官位，会产生对立。两个人性格不合。\n3. 偏印过多之人有通灵的能力，能够看到普通人看不到的鬼魂。\n4. 本命只有食神，没有偏印，大运流年遇到偏印，就会不开心。\n5. 本命只有偏印，没有食神，大运流年遇到食神，也会不开心。\n6. 每个人都有神经病，只是发作的周期和发作的程度不同。分几个等级：\n    一、轻度妄想：多疑，不安，虚惊，焦虑等。\n    二、中度忧郁：对现实生活茫然，对生命怀疑，没有目标，轻度矛盾分裂意识；\n    三、重度严重忧郁：失眠，严重幻想，有恐惧感，心理有强烈矛盾感；精神分裂严重，有自杀的倾向。\n    四、超重度：有以上情形，并且有躁郁的暴力冲动行为；会做出危害他人的伤害行为来。命局中有以上的情形；再加上同命局或是大运有 七杀 的杀气助力；\n    就会成为超重度的大枭神。一个人控制不住的情绪；做出一反常态，伤害别人的举动，就是因为这个产生的。俗称鬼上身。\n7. 命局没有偏印，做事不重视细节，没法感知别人内心的感受。\n\n### 伤官（狂神）\n伤官详解：以日元为我，我生者为食伤；遇到日元所生的异性天干，阳我生阴，阴我生阳；为伤官，简记为“伤”；\n\n伤官代表什么：\n负面性格：言语尖锐刻薄，狂傲不羁，肚量狭小，记仇，得理不饶人；任性蛮横，逞强好胜，一身傲骨，鄙视他人，死不认错；\n正面性格：聪明灵巧，个性突出，容易强风头，能演善辩，不愿服输，胆大，有魄力，有才华。过于自信到自负的程度。\n意像：男人主口舌，官司，纷争，女命另外主克夫；\n职业选择：宜从事文学，书画，艺术等职业，如文学家，影星，歌星，舞蹈家，音乐家以及画家等等。\n代表人物：晚辈，学生，下属；男人的祖母，孙女，女人的儿子；\n\n伤官的其他含义：\n1. 女带伤官必骂夫，女坐伤官必克夫；\n2. 这等女性，若非为人多才艺，就是长相清逸秀丽，或二者兼而有之。\n多半属于女强人形，很有气质，才华横溢，成就往往超越男性，因此伤官旺的女性具有开拓性，宜从事事业，而不宜做家庭主妇。\n3. 月柱伤官代表官司。日柱伤官代表夫妻吵架和官司。\n时柱伤官代表子女不孝，亦表示晚运凄凉悲苦。\n4. 伤官可以旺财，因为伤官上进心强。\n5. 伤官配印，非富即贵；\n如果一个人命中伤官特别强，又有强印来制，含义为：一个胆大，有魄力，才华横溢的人，同时又具备忍耐，慈爱，勤恳的德行，那么升官肯定特别快；\n到哪里都会脱颖而出，干出一番事业，更何况印也主权，所以伤官配印的命格位重权高。\n6. 伤官旺的人喜欢装B炫耀才华，伤官旺的人服软不服硬。\n7. 本命有伤官，大运流年遇到伤官，易有官司口舌纷争。\n8. 本命食神多，大运流年遇到食神，食神会变成伤官，也会有官司口舌纷争。\n\n### 劫财（骗神）\n劫财详解：以日元为我，同我者为比劫；凡是遇到日元的异性天干，阳同阴，阴同阳；为劫财，简记为“劫”；\n\n劫财代表什么：（劫财在地支又名羊刃）\n负面性格：固执己见，自我矛盾，好酒好赌，贪小便宜，好吹牛；喜抬杠，不讲信用，借钱不还，不诚实，满嘴瞎话\n正面性格：性格开朗，心思敏捷，个性明显，自尊心强，口才好，善于活跃气氛，鬼点子多，初次交往中能得到别人的好感。\n意像：赌博，破财，克父，克妻，滑头，骗子\n职业选择：自由业，服务业，直销，投资，贸易，流动行业\n代表的人物：异性的朋友，同辈，同学；男命姐妹，女命兄弟；\n\n劫财的其他含义：\n1. 年柱劫财，祖业耗散，无财产留给后人，家庭不好，早年贫困。\n月柱劫财为自己破财，还代表社会上的朋友借你的钱。\n日柱劫财离婚的几率很大。或者分居。\n时柱劫财晚年孤苦没有收入。\n2. 劫财之人为了达到个人的目的，下跪去发毒誓，甜言蜜语；\n会利用一切可以打动别人的东西去打动别人。\n你可要防备了，他对你是有目的和歹心的，利用完你就会一脚蹬开。\n3. 劫财之人喜欢赌博。本命没有劫财，不喜欢赌博，大运流年劫财一到，开始赌博。\n4. 劫财之人见面熟，交际手腕高，见人说人话，见鬼说鬼话。\n认识你以后就开始借钱，还不还钱要看其他十神的组合。\n借了一圈朋友的钱以后，开始进去新的朋友圈，混熟以后再借钱。\n喜欢做传销项目，因为朋友多，骗完一圈，再换圈子骗。\n5. 劫财过多，很难发财。\n6. 男命带劫财，大运流年又有劫财，会跟妻子分开，并且投资容易破财。\n7. 选择合伙人时，命里劫财过多的人，赚钱不择手段，坑蒙拐骗偷。你一定会吃亏。\n8. 女生选择男朋友的时候，要注意男人劫财多，会采取卑鄙霸道手段将女方骗上床，然后开始借钱，最后骗财骗色\n\n### 比肩（友神）\n比肩详解：以日元为我，同我者为比劫；凡是遇到日元同样的天干；为比肩，简记为“比”\n\n比肩代表什么：\n负面性格：固执己见，独断专行，自我中心，朋友很多，但知己不多，严厉刻薄，不通人情，喜自我封闭，闭门造车，刚愎自用\n正面性格：意志坚强，重情重义，独立自主，不轻易变动，敦厚忠实，做事有耐心，力争上游\n意像：忌凶克财，喜用合作得财，人缘好\n职业选择：直销，开阔者，运动员，流动行业，机械运动，中介，健身\n代表的人物：同性的朋友，同辈，同学，合伙人，股东；男命的兄弟，女命的姐妹；\n\n比肩的其他含义\n1. 比肩和劫财都是克制财星的，但稍有不同。\n    日元身弱，比肩为喜用，大运流年见比肩，可以跟人合作求财。\n    日元身强，比肩为忌神，大运流年见比肩，与人合作必破财。\n2. 身旺不喜比肩帮，运走比肩反遭殃\n身弱逢比运最通，合作营谋处处丰\n3. 比肩为忌神，得不到朋友或兄弟的帮助，反而被争夺财物。\n4. 比肩为用神，多得到朋友或兄弟帮助。\n5. 比肩人内心的想法是一生平安。\n6. 比肩多的人特别关心宠爱部下和朋友，但是和领导不会打交道。\n7. 身强大运流年逢比肩，主伤妻损财。\n8. 比肩流年大运要把钱分出去，钱不能独占。\n9. 没有比肩的人，不善与人交往，不会主动联系朋友，所以朋友很少。性格较孤僻。做事没有耐心，容易半途而费。\n\n### 偏财（侠神）\n偏财详解：以日元为我，我克者为财才；阳我克阳，阴我克阴，为偏财，简记为“才”；\n\n偏财代表什么：\n负面性格：不重视金钱，不善理财，一心多用，轻浮放荡，嗜酒好色，赌性太大。\n正面性格：慷慨大方，重义轻财，聪明机巧，开朗乐观，乐善好施，人脉广阔，风流多情，豪爽出手大方容易得女人欢心\n意像：侠客，做生意，意外之财\n职业选择：商业，企业，投资和投机生意，金融，信息咨询\n代表得人物：富翁，商人；男人的父亲和情人， 女人的婆婆\n\n偏财的其他含义\n1. 偏财在年柱，代表发财必须离开家乡发展；\n偏财在月干最好，代表父亲优秀能干，对自己的帮助大；\n如果偏财在月支，则代表自己能存下来巨额的财富。\n偏财在日支，代表配偶会给自己带来财富，同时代表感情方面会有烂桃花。\n偏财在时柱，代表子女发财，晚年发财\n2. 偏财比正财会赚钱，正财多为工作收入，偏财是敏锐的商业眼光做生意得来的。\n3. 偏财不好的一点就是时有时无，来的时候金山银海，但是会很长时间不来钱。\n4. 日元身弱，偏财为忌神，总想着不劳而获，但是偏财不是经常有，就会贪图享受，懒惰\n5. 偏财喜欢交朋友，三教九流都有，所以有广大的人脉关系，能得到相当多的情报资讯。\n6. 偏财为人大方慷慨，会去帮助朋友，所以对方愿意提供消息，让自己获得回报。\n7. 偏财爱往外面跑，到处结交朋友，与他人谈天说地，交际应酬特别多，加上出手大方，\n会愿意去分享，因此人缘特别好。对于陌生的人士，很快便可以熟识，并且能打成一片，建立友谊。\n8. 偏财本身多，遇大运流年流月流日流时，买彩票，一定中奖。\n9. 正财偏财混杂，家里有老婆。还花心在外边找情人。\n\n        \n\n## 神煞\n## 六十甲子和六甲空亡\n按照阳干配阳支, 阴干配阴支总共有60种组合, 每组多出的两个叫做空亡\n第一组: 甲乙丙丁戊己庚辛壬癸\n        子丑寅卯辰巳午未申酉     空亡: 戌亥\n第二组: 甲乙丙丁戊己庚辛壬癸\n        戌亥子丑寅卯辰巳午未     空亡: 申酉\n第三组: 甲乙丙丁戊己庚辛壬癸\n        申酉戌亥子丑寅卯辰巳     空亡: 午未\n第四组: 甲乙丙丁戊己庚辛壬癸\n        午未申酉戌亥子丑寅卯     空亡: 辰巳\n第五组: 甲乙丙丁戊己庚辛壬癸\n        辰巳午未申酉戌亥子丑     空亡: 寅卯\n第六组: 甲乙丙丁戊己庚辛壬癸\n        寅卯辰巳午未申酉戌亥     空亡: 子丑\n","source":"_drafts/看八字.md","raw":"---\ntitle: 学会看八字\n---\n\n# 学会看八字\n\n道教文化道教认为，**我命有我不由天**， 通过研究生命的规律可以去**趋吉避凶**，好事发生的时候那就把它加强一下，然后好事更好，但是坏事要发生了，那么怎么办呢~我们去规避一下大事给化解掉**大事化小小事化了。**\n\n---\n\n## 五行\n\n有个东西大家是没有办法省略的，就是**五行**，这个五行是道家文化所独有的一个传统文化，道教他认为**天地万物都分阴阳和五行**，那么通过这个学习**五行相生相克**，这是所有周易学派的一个基础，不管你以后学八字奇门遁甲，大六任，小六任，梅花艺术，紫微斗数，黄极其势等等，周易分很多门派很多学科但是他的核心就是**五行**。\n\n五行相生\n- 水: 地球出现的第一个元素\n- 水生木: 植物需要水来灌溉\n- 木生火: 钻木取火\n- 火生土: 火燃烧后变成灰, 灰就是土\n- 土生金: 沙里淘金\n- 金生水: 用金属工具挖井\n\n五行向克\n- 金克木: 用金属制作的斧头可以砍树\n- 木克土: 植物吸收了土里的营养\n- 土克水: 水来土掩\n- 水克火: 水能灭火\n- 火克金: 火能把金属融化\n\n![五行相生](https://picsum.photos/1200/500)\n![五行相生](https://picsum.photos/1200/500)\n\n## 四季土\n1-12月分别用地支表示: 寅卯**辰** / 巳午**未** / 申酉**戌** / 亥子**丑**\n- 其中每个季度的最后一个月份都是属土, 分别是 **辰 / 未 / 戌 / 丑**\n- 寅月和卯月属木, 巳月和午月属火, 申月和酉月属金, 亥月和子月属水\n\n## 天干\n\n甲\n方向: 东方\n阴阳: 阳木\n颜色: 绿色\n身体部位: 肝\n意象: 大树\n\n已\n方向: 东方\n阴阳: 阴木\n颜色: 绿色\n身体部位: 胆\n意象: 花草\n\n丙\n方向: 南方\n阴阳: 阳火\n颜色: 红色\n身体部位: 小肠\n意象: 太阳, 圆形物品\n\n丁\n方向: 南方\n阴阳: 阴火\n颜色: 红色\n身体部位: 心脏, 血液\n意象: 蜡烛, 电灯泡, 烟头\n\n戊\n方向: 中央\n阴阳: 阳土\n颜色: 黄色\n身体部位: 胃\n意象: 城墙土\n\n己\n方向: 中央\n阴阳: 阴土\n颜色: 黄色\n身体部位: 脾\n意象: 田地\n\n庚\n方向: 西方\n阴阳: 阳金\n颜色: 白色, 金色\n身体部位: 大肠\n意象: 宝剑, 大刀, 汽车\n\n辛\n方向: 西方\n阴阳: 阴金\n颜色: 白色, 金色\n身体部位: 肺\n意象: 首饰, 小型金属物品\n\n壬\n方向: 北方\n阴阳: 阳水\n颜色: 黑色, 蓝色\n身体部位: 膀胱\n意象: 大江, 大河, 大湖, 大海\n\n癸\n方向: 北方\n阴阳: 阴水\n颜色: 黑色, 蓝色\n身体部位: 肺\n意象: 小溪, 水井, 小河, 露水, 下水道\n\n\n## 地支\n\n子\n方向: 正北方\n颜色: 黑色, 蓝色\n阴阳: 阳水\n月份: 阴历11月\n时间: 23点到凌晨1点\n藏天干: 本气癸\n动物代表: 鼠\n\n丑\n方向: 东北方\n颜色: 黄色\n阴阳: 阴土\n月份: 阴历12月\n时间: 凌晨1点到3点\n藏天干: 本气己, 中气辛, 余气庚\n动物代表: 牛\n\n寅\n方向: 东北方\n颜色: 绿色\n阴阳: 阳木\n月份: 阴历一月\n时间: 凌晨3点到5点\n藏天干: 本气甲, 中气丙, 余气戊\n动物代表: 老虎\n\n卯\n方向: 正东方\n颜色: 绿色\n阴阳: 阴木\n月份: 阴历二月\n时间: 凌晨5点到7点\n藏天干: 本气乙\n动物代表: 兔子\n\n辰\n方向: 东南方\n颜色: 黄色\n阴阳: 阳土\n月份: 阴历3月\n时间: 上午7点到9点\n藏天干: 本气戊, 中气已, 余气庚\n动物代表: 龙\n\n巳\n方向: 东南方\n颜色:  红色\n阴阳: 阴火\n月份: 阴历4月\n时间: 上午9点到11点\n藏天干: 本气丙, 中气戊, 余气庚\n动物代表: 蛇\n\n午\n方向: 正南方\n颜色: 红色\n阴阳: 阳火\n月份: 阴历5月\n时间: 中午11点到下午13点\n藏天干: 本气丁, 中气乙\n动物代表: 马\n\n未\n方向: 西南方\n颜色: 黄色\n阴阳: 阴土\n月份: 阴历6月\n时间: 下午13点到15点\n藏天干: 本气已, 中气丁, 余气已\n动物代表: 羊\n\n申\n方向: 西南方\n颜色: 白色, 金色\n阴阳: 阳金\n月份: 阴历7月\n时间: 下午15点到17点\n藏天干: 本气庚, 中气壬, 余气戊\n动物代表: 猴\n\n酉\n方向: 正西方\n颜色: 白色, 金色\n阴阳: 阴金\n月份: 寅月8月\n时间: 下午17点到19点\n藏天干: 本气辛\n动物代表: 鸡\n\n戌\n方向: 西北方\n颜色: 黄色\n阴阳: 阳土\n月份: 阴历9月\n时间: 下午19点到21点\n藏天干: 本气戊, 中气辛, 余气丁\n动物代表: 狗\n\n亥\n方向: 西北方\n颜色: 蓝色, 黑色\n阴阳: 阴水\n月份: 阴历10月\n时间: 晚上21点23点\n藏天干: 本气壬, 中气甲\n动物代表: 猪\n\n\n\n\n## 藏干\n子: 癸\n丑: 己 / 辛 / 癸\n寅: 甲 / 丙 / 戊\n卯: 乙\n辰: 戊 / 乙 / 癸\n巳: 丙 / 戊 / 庚\n午: 丁 / 己\n未: 己 / 丁 / 乙\n申: 庚 / 壬 / 戊\n酉: 辛\n戌: 戊 / 辛 / 丁\n亥: 壬 / 甲\n\n\n## 宫位六亲\n注: 每个宫位代表9年\n年干: 父亲, 父亲家族    月干: 父亲, 姐姐哥哥, 社会上的哥哥姐姐  日元: 自己          时干: 长子\n年干: 母亲, 母亲家族    月令: 母亲, 弟弟妹妹, 社会上的弟弟妹妹  日支: 夫妻, 家族    时支: 次子\n祖先宫                 父母兄弟姐妹, 社会关系宫               夫妻宫              子女宫\n\n\n\n## 分清日元强弱\n年干\n\n看八字的第一步就是分清日元强弱\n\n![八字得分](https://picsum.photos/500/450)\n\n十二长生\n长生, 沐浴, 冠带, 临官, 帝旺, 衰, 病, 死, 墓, 绝, 胎, 养\n\n## 八卦九宫(河图洛书)\n        甲  乙  丙  丁  戊  己  庚  辛  壬  癸\n长生     亥  午  寅  酉  寅  酉  巳  子  申  卯                                                 \n沐浴     子  巳  卯  申  卯  申  午  亥  酉  寅\n\n冠带     丑  辰  辰  未  辰  未  未  戌  戌  丑                        \n临官     寅  卯  巳  午  巳  午  申  酉  亥  子                         \n帝旺     卯  寅  午  巳  午  巳  酉  申  子  亥                          \n\n衰       辰  丑  未  辰  未  辰  戌  未  丑  戌                   \n病       巳  子  申  卯  申  卯  亥  午  寅  酉                  \n死       午  亥  酉  寅  酉  寅  子  巳  卯  申                   \n墓       未  戌  戌  丑  戌  丑  丑  辰  辰  未                   \n绝       申  酉  亥  子  亥  子  寅  卯  巳  午                   \n胎       酉  申  子  亥  子  亥  卯  寅  午  巳                   \n养       戌  未  丑  戌  丑  戌  辰  丑  未  辰\n\n\n    巳  午  未\n辰  4   9   2   申\n\n卯  3   5   7   酉\n\n寅  8   1   6   戌\n    丑  子  亥\n\n\n## 十神(一位为真, 二位为争, 三位为病, 四五六都不好, 七个反而变好)\n天干地支分五行, 五行又分阴阳,总共是十个种类\n因日元和其他七个干支会产生十种关系, 所以得出十神\n分别是四个吉神: 正印    食神    正官    正财\n      四个恶神: 七杀    偏印    伤官    劫财\n      两个平神: 比肩    偏财\n规律：\n  - 克我者为官杀\n  - 我克者为财才\n  - 生我者为印枭\n  - 我生者为食伤\n  - 同我者为比劫\n    \n### 正印（智慧之神）\n正印详解：以日元为我，生我者为印枭，阴生阳我，阳生阴我，为正印，简记为“印”\n\n正印代表什么\n性格：聪明智慧，记性好，喜欢学习，心地善良，责任心强，少病少灾\n意像：房子，文书，教育，权利，脑中的天使\n职业选择：宜当教师、艺术家、出版商、秘书、护士、宗教家或星象家、棋手等\n正印的亲人：代表长辈，贵人，师长；男命代表母亲，女命代表祖父、女婿\n \n正印的含义\n1. 日元身弱, 最喜正印来生;\n    日元身强, 正印来生反而为害;\n2. 正印是你脑中的天使, 不停的啰嗦;\n    时刻提醒你不要做坏事, 不要做错事;\n3. 正印代表古代中的印玺, 代表权利. 命中无官, 有印一样能掌权.\n4. 正印代表思想文化, 正印多的人, \n    一生的追求是自己的思想观念能得到别人的认可.\n5. 日元身弱正印代表房子, 日元身强不代表房子.\n6. 男人命中正印代表母亲, 财可以克印;\n    男人一旦发财, 母亲的身体就会不好.\n    另外正财代表男人的老婆, 正财多的男人, 婆媳关系都不太好.\n    同理: 女人正印代表祖父, 女婿, 女人发财会克到祖父, 女婿.\n7. 命中没有正印的人, 不爱学习, 没有责任心, 记性不好, 学非所用\n    与母亲缘分浅, 经常生病\n\n### 食神（福神）\n食神详解：以日元为我，我生者为食伤。阳我生我，阴我生阴，为食神，简记为“食”\n\n食神代表什么：食神一位胜财官。\n性格：口才好，喜欢玩，好歌舞酒色，吃货，多福多寿，心宽体胖，为人宽宏大量，对艺术天赋异禀。\n意像：胖，大，有福气，衣食无忧。\n职业选择：演艺、娱乐、美术、美容、服装设计或餐饮酒店等。\n食神代表的亲人：代表晚辈，学生，下属。男人的孙子，女人的女儿\n\n食神的含义：\n1. 食神的主要作用是生财，吃喝玩乐还能把钱赚到。\n2. 日元身强，食神为喜用时能够泄化日主和比劫，食神一切好的一面就出现了。\n3. 日元身弱，再去生食神，食神为忌凶，代表自己腹有诗书，难遇伯乐，易郁郁寡欢，怀才不遇，自己的思想易与世俗红尘格格不入。\n4. 食神可以克制官杀，食神克制克我之七杀，保自己的命。食神一到，官运要丢。\n5. 时柱有食神最好，代表晚年有福，衣食无忧。时柱又代表子女宫\n6. 也代表能享子女之福。\n7. 食神不易过多，过多会身体肥胖，贪图享乐，好逸恶劳，不务正业，不知节俭。\n8. 没有食神也不好，不会玩，口才不好，不善言辞。\n\n### 正官（贵神）\n正官详解：以日元为我，克我者为官杀，阳克阴我，或阴克阳我，为正官；简记为“官”\n\n正官代表什么：\n性格：守信用、正直、光明磊落、好面子、在乎名声地位、廉洁、公正、稳重\n意像：大哥、领导、领袖、地位、受人敬仰\n职业选择：政治、法律、侦探、法官、记者、公职方面职业\n正官代表的亲人：长官、领导、上司；男人的女儿，女人的老公；\n\n正官的其他含义：\n《论语·子路篇》中有一段话：其身正，不令而行，其身不正，虽令不从。\n\n1. 命带正官之人，容易当官。年柱，班干部；月柱，当领导；日支：有组织领导能力；时支，子女光明正直。\n2. 命带正官之人，好操心，劳累，容易长白头发。\n3. 朋友大多是正经人，有恶习的人，赌博，涉黄，犯法，涉黑不正派的人不愿结交，但也不得罪\n4. 朋友不多，很难有死党知己。\n5. 女人正官代表老公，不宜太多。女人无官婚难成，女人一官最好命；女人二官心不定，女人三官会作娼\n6. 正官太多变成强迫症，古板死心眼，固执。\n7. 本名正官多，大运流年又遇到正官，会有执法单位，公检法来找事。\n8. 正官多的人，一生追求的是名誉地位，什么都可以不要，一定要当领导。\n9. 没有正官，对自己无法严格要求，不喜欢别人拘束，目无法律；我行我素，很难做领导。女同志没有正官会晚婚，严重的终身不嫁；\n\n\n### 正财（富神）\n正财详解：以日元为我，我克者为财才；阳我克阴，或阴我克阳，为正财，简记为“财”\n\n正财代表什么：\n性格：守本分，诚实守信，脚踏实地，勤俭节约，重视家庭，诚信，爱妻子，是个值得信赖的人。\n意像：稳定的收入，合法的收入\n职业选择：如银行、财政、外交、中介、杂货、百货、批发零售、药商等\n正财代表的亲人富翁，商人；男人的妻子，女人的父亲；\n\n正财的其他含义\n1. 日元身弱正财为忌凶，为人吝啬，并且不容易发财。\n2. 财喜藏不喜漏。天干之财为虚财，地支藏干里的财为真财。\n3. 女怕官旺，男怕财多，男人正财多，多妻之像，或者不重视结发之妻。\n4. 正财在年柱，工薪家庭，家庭条件还可以有房子住，正财在年柱跟发财关系不大。\n月柱日柱时柱有正财最好\n月柱正财30岁以后有稳定收入，才算是富命。\n日支逢正财，代表孩子发财，晚年有稳定收入。\n时支管55岁以后，时支正财是老年再结婚。\n5. 正财偏财过多，为愚蠢之人。除了对钱感兴趣，对别的全不感兴趣。\n6. 命中没有正财，一生财来财去，一场空；烂桃花多。女人与父亲缘薄，父多早丧，或病残，父亲无能。\n\n### 七杀（病神）\n七杀详解：以日元为我，遇克制日主的同性天干；阴阴相克，阳阳相克，就称为偏官；因同性相克力量比较凶狠，古人以七杀命名，简记为“杀”；\n\n七杀代表什么：\n负面性格：霸道，急躁如火，脾气古怪，任性倔强，好胜好斗，报复心强，偏激叛逆，鲁莽冲动，听不进谏言、易树敌\n正面性格：执行力强，有正义感和侠义精神，做事有魄力，勇于向困难挑战，勇于突破困境，坚强之意志力与干劲\n意像：小人，仇人，得病\n职业选择：武职，比如参军，警察，法院等需要具有杀气的行业，适合做二把手\n代表人物：军人，警察，公检法执法地位；男人的儿子，女人的情人\n\n五行身体部位\n甲肝乙胆丙胆，丁心戊胃己脾乡；庚金大肠辛金肺，壬是膀胱癸肾藏；\n年干（头）      月干（胸部）    日元（小腹）    时干（大腿）\n年支（脖子）    月令（腹部）    日支（屁股）    时支（小腿脚部）\n\n七杀的其他含义\n1. 七杀在哪个五行，哪个五行就容易得病。\n2. 七杀在哪个位置，哪个位置就容易得病。\n3. 七杀索我性命，伤官破我官爵；枭印夺我俸禄；劫财争我财产；都是不好的恶神；\n4. 七杀为日元的天敌，四凶神中的索命之鬼，因此八字批命首先看七杀，\n只有安顿了七杀，方可论富贵，否则连有命无命都不知道，何言富贵？\n七杀无制，在天干的多为突发之灾致残疾或凶死，在地支的则为慢性恶疾。\n5. 但是七杀得制，也可以出现好的情况。\n    1. 身强不怕七杀，七杀来克反为好，这叫身杀俩停。\n    2. 身弱有正印化解七杀。七杀生印，正印生日元。七杀反为我用，这叫杀印相生。\n    3. 身弱有食神制杀，没有偏印损害食神，七杀得制，这叫食神制杀。\n6. 本命七杀太多。大运流年遇到七杀，会有公检法执法单位找事。\n7. 本命没有七杀，正官太多，大运流年再遇到正官，正官会变成七杀。\n8. 只有七杀，没有正官，只能做二把手，做不了一把手。\n9. 聪明不过伤官，伶俐不过七杀\n10. 女命的七杀代表情人，相好的，女命不宜七杀过多。\n11. 没有七杀，代表男人不容易生儿子，女人没有情人。性格方面不会心太狠。\n\n### 偏印（郁神）\n偏印详解：以日元为我，生我者为印枭；阳生阳我，阴生阴我，为偏印，偏印带有凶性；古人称为枭神，简记为“枭”；\n\n偏印代表什么：\n负面性格：敏感，内心孤独，不开心，优柔寡断，犹豫不决。不善与人交往，宁可一个人独处，也不愿到人多的地方。\n正面性格：敏锐的观察力，分析力，感受力，理解力，困难的东西能迅速学，会多才多艺，心思细腻。\n意像：学习玄学有特殊天赋，一定会不开心。\n职业选择：研究，民意代表，发明，设计，创造，科技，武术，演艺，行销，直销，广告，模特，艳星等特殊专门性行业。\n代表人物：军事，参谋；男命之祖父，女命之母亲；\n\n偏印的其他含义\n1. 其他的干支偏印，命主会学习技术技能。月令偏印，必定有一技之长。\n2. 命局中见到偏印，马上可以断命主，不开心。和谁不开心？主要是食神。\n偏印和食神所在的官位，会产生对立。两个人性格不合。\n3. 偏印过多之人有通灵的能力，能够看到普通人看不到的鬼魂。\n4. 本命只有食神，没有偏印，大运流年遇到偏印，就会不开心。\n5. 本命只有偏印，没有食神，大运流年遇到食神，也会不开心。\n6. 每个人都有神经病，只是发作的周期和发作的程度不同。分几个等级：\n    一、轻度妄想：多疑，不安，虚惊，焦虑等。\n    二、中度忧郁：对现实生活茫然，对生命怀疑，没有目标，轻度矛盾分裂意识；\n    三、重度严重忧郁：失眠，严重幻想，有恐惧感，心理有强烈矛盾感；精神分裂严重，有自杀的倾向。\n    四、超重度：有以上情形，并且有躁郁的暴力冲动行为；会做出危害他人的伤害行为来。命局中有以上的情形；再加上同命局或是大运有 七杀 的杀气助力；\n    就会成为超重度的大枭神。一个人控制不住的情绪；做出一反常态，伤害别人的举动，就是因为这个产生的。俗称鬼上身。\n7. 命局没有偏印，做事不重视细节，没法感知别人内心的感受。\n\n### 伤官（狂神）\n伤官详解：以日元为我，我生者为食伤；遇到日元所生的异性天干，阳我生阴，阴我生阳；为伤官，简记为“伤”；\n\n伤官代表什么：\n负面性格：言语尖锐刻薄，狂傲不羁，肚量狭小，记仇，得理不饶人；任性蛮横，逞强好胜，一身傲骨，鄙视他人，死不认错；\n正面性格：聪明灵巧，个性突出，容易强风头，能演善辩，不愿服输，胆大，有魄力，有才华。过于自信到自负的程度。\n意像：男人主口舌，官司，纷争，女命另外主克夫；\n职业选择：宜从事文学，书画，艺术等职业，如文学家，影星，歌星，舞蹈家，音乐家以及画家等等。\n代表人物：晚辈，学生，下属；男人的祖母，孙女，女人的儿子；\n\n伤官的其他含义：\n1. 女带伤官必骂夫，女坐伤官必克夫；\n2. 这等女性，若非为人多才艺，就是长相清逸秀丽，或二者兼而有之。\n多半属于女强人形，很有气质，才华横溢，成就往往超越男性，因此伤官旺的女性具有开拓性，宜从事事业，而不宜做家庭主妇。\n3. 月柱伤官代表官司。日柱伤官代表夫妻吵架和官司。\n时柱伤官代表子女不孝，亦表示晚运凄凉悲苦。\n4. 伤官可以旺财，因为伤官上进心强。\n5. 伤官配印，非富即贵；\n如果一个人命中伤官特别强，又有强印来制，含义为：一个胆大，有魄力，才华横溢的人，同时又具备忍耐，慈爱，勤恳的德行，那么升官肯定特别快；\n到哪里都会脱颖而出，干出一番事业，更何况印也主权，所以伤官配印的命格位重权高。\n6. 伤官旺的人喜欢装B炫耀才华，伤官旺的人服软不服硬。\n7. 本命有伤官，大运流年遇到伤官，易有官司口舌纷争。\n8. 本命食神多，大运流年遇到食神，食神会变成伤官，也会有官司口舌纷争。\n\n### 劫财（骗神）\n劫财详解：以日元为我，同我者为比劫；凡是遇到日元的异性天干，阳同阴，阴同阳；为劫财，简记为“劫”；\n\n劫财代表什么：（劫财在地支又名羊刃）\n负面性格：固执己见，自我矛盾，好酒好赌，贪小便宜，好吹牛；喜抬杠，不讲信用，借钱不还，不诚实，满嘴瞎话\n正面性格：性格开朗，心思敏捷，个性明显，自尊心强，口才好，善于活跃气氛，鬼点子多，初次交往中能得到别人的好感。\n意像：赌博，破财，克父，克妻，滑头，骗子\n职业选择：自由业，服务业，直销，投资，贸易，流动行业\n代表的人物：异性的朋友，同辈，同学；男命姐妹，女命兄弟；\n\n劫财的其他含义：\n1. 年柱劫财，祖业耗散，无财产留给后人，家庭不好，早年贫困。\n月柱劫财为自己破财，还代表社会上的朋友借你的钱。\n日柱劫财离婚的几率很大。或者分居。\n时柱劫财晚年孤苦没有收入。\n2. 劫财之人为了达到个人的目的，下跪去发毒誓，甜言蜜语；\n会利用一切可以打动别人的东西去打动别人。\n你可要防备了，他对你是有目的和歹心的，利用完你就会一脚蹬开。\n3. 劫财之人喜欢赌博。本命没有劫财，不喜欢赌博，大运流年劫财一到，开始赌博。\n4. 劫财之人见面熟，交际手腕高，见人说人话，见鬼说鬼话。\n认识你以后就开始借钱，还不还钱要看其他十神的组合。\n借了一圈朋友的钱以后，开始进去新的朋友圈，混熟以后再借钱。\n喜欢做传销项目，因为朋友多，骗完一圈，再换圈子骗。\n5. 劫财过多，很难发财。\n6. 男命带劫财，大运流年又有劫财，会跟妻子分开，并且投资容易破财。\n7. 选择合伙人时，命里劫财过多的人，赚钱不择手段，坑蒙拐骗偷。你一定会吃亏。\n8. 女生选择男朋友的时候，要注意男人劫财多，会采取卑鄙霸道手段将女方骗上床，然后开始借钱，最后骗财骗色\n\n### 比肩（友神）\n比肩详解：以日元为我，同我者为比劫；凡是遇到日元同样的天干；为比肩，简记为“比”\n\n比肩代表什么：\n负面性格：固执己见，独断专行，自我中心，朋友很多，但知己不多，严厉刻薄，不通人情，喜自我封闭，闭门造车，刚愎自用\n正面性格：意志坚强，重情重义，独立自主，不轻易变动，敦厚忠实，做事有耐心，力争上游\n意像：忌凶克财，喜用合作得财，人缘好\n职业选择：直销，开阔者，运动员，流动行业，机械运动，中介，健身\n代表的人物：同性的朋友，同辈，同学，合伙人，股东；男命的兄弟，女命的姐妹；\n\n比肩的其他含义\n1. 比肩和劫财都是克制财星的，但稍有不同。\n    日元身弱，比肩为喜用，大运流年见比肩，可以跟人合作求财。\n    日元身强，比肩为忌神，大运流年见比肩，与人合作必破财。\n2. 身旺不喜比肩帮，运走比肩反遭殃\n身弱逢比运最通，合作营谋处处丰\n3. 比肩为忌神，得不到朋友或兄弟的帮助，反而被争夺财物。\n4. 比肩为用神，多得到朋友或兄弟帮助。\n5. 比肩人内心的想法是一生平安。\n6. 比肩多的人特别关心宠爱部下和朋友，但是和领导不会打交道。\n7. 身强大运流年逢比肩，主伤妻损财。\n8. 比肩流年大运要把钱分出去，钱不能独占。\n9. 没有比肩的人，不善与人交往，不会主动联系朋友，所以朋友很少。性格较孤僻。做事没有耐心，容易半途而费。\n\n### 偏财（侠神）\n偏财详解：以日元为我，我克者为财才；阳我克阳，阴我克阴，为偏财，简记为“才”；\n\n偏财代表什么：\n负面性格：不重视金钱，不善理财，一心多用，轻浮放荡，嗜酒好色，赌性太大。\n正面性格：慷慨大方，重义轻财，聪明机巧，开朗乐观，乐善好施，人脉广阔，风流多情，豪爽出手大方容易得女人欢心\n意像：侠客，做生意，意外之财\n职业选择：商业，企业，投资和投机生意，金融，信息咨询\n代表得人物：富翁，商人；男人的父亲和情人， 女人的婆婆\n\n偏财的其他含义\n1. 偏财在年柱，代表发财必须离开家乡发展；\n偏财在月干最好，代表父亲优秀能干，对自己的帮助大；\n如果偏财在月支，则代表自己能存下来巨额的财富。\n偏财在日支，代表配偶会给自己带来财富，同时代表感情方面会有烂桃花。\n偏财在时柱，代表子女发财，晚年发财\n2. 偏财比正财会赚钱，正财多为工作收入，偏财是敏锐的商业眼光做生意得来的。\n3. 偏财不好的一点就是时有时无，来的时候金山银海，但是会很长时间不来钱。\n4. 日元身弱，偏财为忌神，总想着不劳而获，但是偏财不是经常有，就会贪图享受，懒惰\n5. 偏财喜欢交朋友，三教九流都有，所以有广大的人脉关系，能得到相当多的情报资讯。\n6. 偏财为人大方慷慨，会去帮助朋友，所以对方愿意提供消息，让自己获得回报。\n7. 偏财爱往外面跑，到处结交朋友，与他人谈天说地，交际应酬特别多，加上出手大方，\n会愿意去分享，因此人缘特别好。对于陌生的人士，很快便可以熟识，并且能打成一片，建立友谊。\n8. 偏财本身多，遇大运流年流月流日流时，买彩票，一定中奖。\n9. 正财偏财混杂，家里有老婆。还花心在外边找情人。\n\n        \n\n## 神煞\n## 六十甲子和六甲空亡\n按照阳干配阳支, 阴干配阴支总共有60种组合, 每组多出的两个叫做空亡\n第一组: 甲乙丙丁戊己庚辛壬癸\n        子丑寅卯辰巳午未申酉     空亡: 戌亥\n第二组: 甲乙丙丁戊己庚辛壬癸\n        戌亥子丑寅卯辰巳午未     空亡: 申酉\n第三组: 甲乙丙丁戊己庚辛壬癸\n        申酉戌亥子丑寅卯辰巳     空亡: 午未\n第四组: 甲乙丙丁戊己庚辛壬癸\n        午未申酉戌亥子丑寅卯     空亡: 辰巳\n第五组: 甲乙丙丁戊己庚辛壬癸\n        辰巳午未申酉戌亥子丑     空亡: 寅卯\n第六组: 甲乙丙丁戊己庚辛壬癸\n        寅卯辰巳午未申酉戌亥     空亡: 子丑\n","slug":"看八字","published":0,"date":"2024-03-16T13:20:10.758Z","updated":"2024-03-28T15:39:00.785Z","_id":"cltzslok80003sovcfa42hjx5","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"学会看八字\"><a href=\"#学会看八字\" class=\"headerlink\" title=\"学会看八字\"></a>学会看八字</h1><p>道教文化道教认为，<strong>我命有我不由天</strong>， 通过研究生命的规律可以去<strong>趋吉避凶</strong>，好事发生的时候那就把它加强一下，然后好事更好，但是坏事要发生了，那么怎么办呢~我们去规避一下大事给化解掉<strong>大事化小小事化了。</strong></p>\n<hr>\n<h2 id=\"五行\"><a href=\"#五行\" class=\"headerlink\" title=\"五行\"></a>五行</h2><p>有个东西大家是没有办法省略的，就是<strong>五行</strong>，这个五行是道家文化所独有的一个传统文化，道教他认为<strong>天地万物都分阴阳和五行</strong>，那么通过这个学习<strong>五行相生相克</strong>，这是所有周易学派的一个基础，不管你以后学八字奇门遁甲，大六任，小六任，梅花艺术，紫微斗数，黄极其势等等，周易分很多门派很多学科但是他的核心就是<strong>五行</strong>。</p>\n<p>五行相生</p>\n<ul>\n<li>水: 地球出现的第一个元素</li>\n<li>水生木: 植物需要水来灌溉</li>\n<li>木生火: 钻木取火</li>\n<li>火生土: 火燃烧后变成灰, 灰就是土</li>\n<li>土生金: 沙里淘金</li>\n<li>金生水: 用金属工具挖井</li>\n</ul>\n<p>五行向克</p>\n<ul>\n<li>金克木: 用金属制作的斧头可以砍树</li>\n<li>木克土: 植物吸收了土里的营养</li>\n<li>土克水: 水来土掩</li>\n<li>水克火: 水能灭火</li>\n<li>火克金: 火能把金属融化</li>\n</ul>\n<p><img src=\"https://picsum.photos/1200/500\" alt=\"五行相生\"><br><img src=\"https://picsum.photos/1200/500\" alt=\"五行相生\"></p>\n<h2 id=\"四季土\"><a href=\"#四季土\" class=\"headerlink\" title=\"四季土\"></a>四季土</h2><p>1-12月分别用地支表示: 寅卯<strong>辰</strong> &#x2F; 巳午<strong>未</strong> &#x2F; 申酉<strong>戌</strong> &#x2F; 亥子<strong>丑</strong></p>\n<ul>\n<li>其中每个季度的最后一个月份都是属土, 分别是 <strong>辰 &#x2F; 未 &#x2F; 戌 &#x2F; 丑</strong></li>\n<li>寅月和卯月属木, 巳月和午月属火, 申月和酉月属金, 亥月和子月属水</li>\n</ul>\n<h2 id=\"天干\"><a href=\"#天干\" class=\"headerlink\" title=\"天干\"></a>天干</h2><p>甲<br>方向: 东方<br>阴阳: 阳木<br>颜色: 绿色<br>身体部位: 肝<br>意象: 大树</p>\n<p>已<br>方向: 东方<br>阴阳: 阴木<br>颜色: 绿色<br>身体部位: 胆<br>意象: 花草</p>\n<p>丙<br>方向: 南方<br>阴阳: 阳火<br>颜色: 红色<br>身体部位: 小肠<br>意象: 太阳, 圆形物品</p>\n<p>丁<br>方向: 南方<br>阴阳: 阴火<br>颜色: 红色<br>身体部位: 心脏, 血液<br>意象: 蜡烛, 电灯泡, 烟头</p>\n<p>戊<br>方向: 中央<br>阴阳: 阳土<br>颜色: 黄色<br>身体部位: 胃<br>意象: 城墙土</p>\n<p>己<br>方向: 中央<br>阴阳: 阴土<br>颜色: 黄色<br>身体部位: 脾<br>意象: 田地</p>\n<p>庚<br>方向: 西方<br>阴阳: 阳金<br>颜色: 白色, 金色<br>身体部位: 大肠<br>意象: 宝剑, 大刀, 汽车</p>\n<p>辛<br>方向: 西方<br>阴阳: 阴金<br>颜色: 白色, 金色<br>身体部位: 肺<br>意象: 首饰, 小型金属物品</p>\n<p>壬<br>方向: 北方<br>阴阳: 阳水<br>颜色: 黑色, 蓝色<br>身体部位: 膀胱<br>意象: 大江, 大河, 大湖, 大海</p>\n<p>癸<br>方向: 北方<br>阴阳: 阴水<br>颜色: 黑色, 蓝色<br>身体部位: 肺<br>意象: 小溪, 水井, 小河, 露水, 下水道</p>\n<h2 id=\"地支\"><a href=\"#地支\" class=\"headerlink\" title=\"地支\"></a>地支</h2><p>子<br>方向: 正北方<br>颜色: 黑色, 蓝色<br>阴阳: 阳水<br>月份: 阴历11月<br>时间: 23点到凌晨1点<br>藏天干: 本气癸<br>动物代表: 鼠</p>\n<p>丑<br>方向: 东北方<br>颜色: 黄色<br>阴阳: 阴土<br>月份: 阴历12月<br>时间: 凌晨1点到3点<br>藏天干: 本气己, 中气辛, 余气庚<br>动物代表: 牛</p>\n<p>寅<br>方向: 东北方<br>颜色: 绿色<br>阴阳: 阳木<br>月份: 阴历一月<br>时间: 凌晨3点到5点<br>藏天干: 本气甲, 中气丙, 余气戊<br>动物代表: 老虎</p>\n<p>卯<br>方向: 正东方<br>颜色: 绿色<br>阴阳: 阴木<br>月份: 阴历二月<br>时间: 凌晨5点到7点<br>藏天干: 本气乙<br>动物代表: 兔子</p>\n<p>辰<br>方向: 东南方<br>颜色: 黄色<br>阴阳: 阳土<br>月份: 阴历3月<br>时间: 上午7点到9点<br>藏天干: 本气戊, 中气已, 余气庚<br>动物代表: 龙</p>\n<p>巳<br>方向: 东南方<br>颜色:  红色<br>阴阳: 阴火<br>月份: 阴历4月<br>时间: 上午9点到11点<br>藏天干: 本气丙, 中气戊, 余气庚<br>动物代表: 蛇</p>\n<p>午<br>方向: 正南方<br>颜色: 红色<br>阴阳: 阳火<br>月份: 阴历5月<br>时间: 中午11点到下午13点<br>藏天干: 本气丁, 中气乙<br>动物代表: 马</p>\n<p>未<br>方向: 西南方<br>颜色: 黄色<br>阴阳: 阴土<br>月份: 阴历6月<br>时间: 下午13点到15点<br>藏天干: 本气已, 中气丁, 余气已<br>动物代表: 羊</p>\n<p>申<br>方向: 西南方<br>颜色: 白色, 金色<br>阴阳: 阳金<br>月份: 阴历7月<br>时间: 下午15点到17点<br>藏天干: 本气庚, 中气壬, 余气戊<br>动物代表: 猴</p>\n<p>酉<br>方向: 正西方<br>颜色: 白色, 金色<br>阴阳: 阴金<br>月份: 寅月8月<br>时间: 下午17点到19点<br>藏天干: 本气辛<br>动物代表: 鸡</p>\n<p>戌<br>方向: 西北方<br>颜色: 黄色<br>阴阳: 阳土<br>月份: 阴历9月<br>时间: 下午19点到21点<br>藏天干: 本气戊, 中气辛, 余气丁<br>动物代表: 狗</p>\n<p>亥<br>方向: 西北方<br>颜色: 蓝色, 黑色<br>阴阳: 阴水<br>月份: 阴历10月<br>时间: 晚上21点23点<br>藏天干: 本气壬, 中气甲<br>动物代表: 猪</p>\n<h2 id=\"藏干\"><a href=\"#藏干\" class=\"headerlink\" title=\"藏干\"></a>藏干</h2><p>子: 癸<br>丑: 己 &#x2F; 辛 &#x2F; 癸<br>寅: 甲 &#x2F; 丙 &#x2F; 戊<br>卯: 乙<br>辰: 戊 &#x2F; 乙 &#x2F; 癸<br>巳: 丙 &#x2F; 戊 &#x2F; 庚<br>午: 丁 &#x2F; 己<br>未: 己 &#x2F; 丁 &#x2F; 乙<br>申: 庚 &#x2F; 壬 &#x2F; 戊<br>酉: 辛<br>戌: 戊 &#x2F; 辛 &#x2F; 丁<br>亥: 壬 &#x2F; 甲</p>\n<h2 id=\"宫位六亲\"><a href=\"#宫位六亲\" class=\"headerlink\" title=\"宫位六亲\"></a>宫位六亲</h2><p>注: 每个宫位代表9年<br>年干: 父亲, 父亲家族    月干: 父亲, 姐姐哥哥, 社会上的哥哥姐姐  日元: 自己          时干: 长子<br>年干: 母亲, 母亲家族    月令: 母亲, 弟弟妹妹, 社会上的弟弟妹妹  日支: 夫妻, 家族    时支: 次子<br>祖先宫                 父母兄弟姐妹, 社会关系宫               夫妻宫              子女宫</p>\n<h2 id=\"分清日元强弱\"><a href=\"#分清日元强弱\" class=\"headerlink\" title=\"分清日元强弱\"></a>分清日元强弱</h2><p>年干</p>\n<p>看八字的第一步就是分清日元强弱</p>\n<p><img src=\"https://picsum.photos/500/450\" alt=\"八字得分\"></p>\n<p>十二长生<br>长生, 沐浴, 冠带, 临官, 帝旺, 衰, 病, 死, 墓, 绝, 胎, 养</p>\n<h2 id=\"八卦九宫-河图洛书\"><a href=\"#八卦九宫-河图洛书\" class=\"headerlink\" title=\"八卦九宫(河图洛书)\"></a>八卦九宫(河图洛书)</h2><pre><code>    甲  乙  丙  丁  戊  己  庚  辛  壬  癸\n</code></pre>\n<p>长生     亥  午  寅  酉  寅  酉  巳  子  申  卯<br>沐浴     子  巳  卯  申  卯  申  午  亥  酉  寅</p>\n<p>冠带     丑  辰  辰  未  辰  未  未  戌  戌  丑<br>临官     寅  卯  巳  午  巳  午  申  酉  亥  子<br>帝旺     卯  寅  午  巳  午  巳  酉  申  子  亥                          </p>\n<p>衰       辰  丑  未  辰  未  辰  戌  未  丑  戌<br>病       巳  子  申  卯  申  卯  亥  午  寅  酉<br>死       午  亥  酉  寅  酉  寅  子  巳  卯  申<br>墓       未  戌  戌  丑  戌  丑  丑  辰  辰  未<br>绝       申  酉  亥  子  亥  子  寅  卯  巳  午<br>胎       酉  申  子  亥  子  亥  卯  寅  午  巳<br>养       戌  未  丑  戌  丑  戌  辰  丑  未  辰</p>\n<pre><code>巳  午  未\n</code></pre>\n<p>辰  4   9   2   申</p>\n<p>卯  3   5   7   酉</p>\n<p>寅  8   1   6   戌<br>    丑  子  亥</p>\n<h2 id=\"十神-一位为真-二位为争-三位为病-四五六都不好-七个反而变好\"><a href=\"#十神-一位为真-二位为争-三位为病-四五六都不好-七个反而变好\" class=\"headerlink\" title=\"十神(一位为真, 二位为争, 三位为病, 四五六都不好, 七个反而变好)\"></a>十神(一位为真, 二位为争, 三位为病, 四五六都不好, 七个反而变好)</h2><p>天干地支分五行, 五行又分阴阳,总共是十个种类<br>因日元和其他七个干支会产生十种关系, 所以得出十神<br>分别是四个吉神: 正印    食神    正官    正财<br>      四个恶神: 七杀    偏印    伤官    劫财<br>      两个平神: 比肩    偏财<br>规律：</p>\n<ul>\n<li>克我者为官杀</li>\n<li>我克者为财才</li>\n<li>生我者为印枭</li>\n<li>我生者为食伤</li>\n<li>同我者为比劫</li>\n</ul>\n<h3 id=\"正印（智慧之神）\"><a href=\"#正印（智慧之神）\" class=\"headerlink\" title=\"正印（智慧之神）\"></a>正印（智慧之神）</h3><p>正印详解：以日元为我，生我者为印枭，阴生阳我，阳生阴我，为正印，简记为“印”</p>\n<p>正印代表什么<br>性格：聪明智慧，记性好，喜欢学习，心地善良，责任心强，少病少灾<br>意像：房子，文书，教育，权利，脑中的天使<br>职业选择：宜当教师、艺术家、出版商、秘书、护士、宗教家或星象家、棋手等<br>正印的亲人：代表长辈，贵人，师长；男命代表母亲，女命代表祖父、女婿</p>\n<p>正印的含义</p>\n<ol>\n<li>日元身弱, 最喜正印来生;<br> 日元身强, 正印来生反而为害;</li>\n<li>正印是你脑中的天使, 不停的啰嗦;<br> 时刻提醒你不要做坏事, 不要做错事;</li>\n<li>正印代表古代中的印玺, 代表权利. 命中无官, 有印一样能掌权.</li>\n<li>正印代表思想文化, 正印多的人,<br> 一生的追求是自己的思想观念能得到别人的认可.</li>\n<li>日元身弱正印代表房子, 日元身强不代表房子.</li>\n<li>男人命中正印代表母亲, 财可以克印;<br> 男人一旦发财, 母亲的身体就会不好.<br> 另外正财代表男人的老婆, 正财多的男人, 婆媳关系都不太好.<br> 同理: 女人正印代表祖父, 女婿, 女人发财会克到祖父, 女婿.</li>\n<li>命中没有正印的人, 不爱学习, 没有责任心, 记性不好, 学非所用<br> 与母亲缘分浅, 经常生病</li>\n</ol>\n<h3 id=\"食神（福神）\"><a href=\"#食神（福神）\" class=\"headerlink\" title=\"食神（福神）\"></a>食神（福神）</h3><p>食神详解：以日元为我，我生者为食伤。阳我生我，阴我生阴，为食神，简记为“食”</p>\n<p>食神代表什么：食神一位胜财官。<br>性格：口才好，喜欢玩，好歌舞酒色，吃货，多福多寿，心宽体胖，为人宽宏大量，对艺术天赋异禀。<br>意像：胖，大，有福气，衣食无忧。<br>职业选择：演艺、娱乐、美术、美容、服装设计或餐饮酒店等。<br>食神代表的亲人：代表晚辈，学生，下属。男人的孙子，女人的女儿</p>\n<p>食神的含义：</p>\n<ol>\n<li>食神的主要作用是生财，吃喝玩乐还能把钱赚到。</li>\n<li>日元身强，食神为喜用时能够泄化日主和比劫，食神一切好的一面就出现了。</li>\n<li>日元身弱，再去生食神，食神为忌凶，代表自己腹有诗书，难遇伯乐，易郁郁寡欢，怀才不遇，自己的思想易与世俗红尘格格不入。</li>\n<li>食神可以克制官杀，食神克制克我之七杀，保自己的命。食神一到，官运要丢。</li>\n<li>时柱有食神最好，代表晚年有福，衣食无忧。时柱又代表子女宫</li>\n<li>也代表能享子女之福。</li>\n<li>食神不易过多，过多会身体肥胖，贪图享乐，好逸恶劳，不务正业，不知节俭。</li>\n<li>没有食神也不好，不会玩，口才不好，不善言辞。</li>\n</ol>\n<h3 id=\"正官（贵神）\"><a href=\"#正官（贵神）\" class=\"headerlink\" title=\"正官（贵神）\"></a>正官（贵神）</h3><p>正官详解：以日元为我，克我者为官杀，阳克阴我，或阴克阳我，为正官；简记为“官”</p>\n<p>正官代表什么：<br>性格：守信用、正直、光明磊落、好面子、在乎名声地位、廉洁、公正、稳重<br>意像：大哥、领导、领袖、地位、受人敬仰<br>职业选择：政治、法律、侦探、法官、记者、公职方面职业<br>正官代表的亲人：长官、领导、上司；男人的女儿，女人的老公；</p>\n<p>正官的其他含义：<br>《论语·子路篇》中有一段话：其身正，不令而行，其身不正，虽令不从。</p>\n<ol>\n<li>命带正官之人，容易当官。年柱，班干部；月柱，当领导；日支：有组织领导能力；时支，子女光明正直。</li>\n<li>命带正官之人，好操心，劳累，容易长白头发。</li>\n<li>朋友大多是正经人，有恶习的人，赌博，涉黄，犯法，涉黑不正派的人不愿结交，但也不得罪</li>\n<li>朋友不多，很难有死党知己。</li>\n<li>女人正官代表老公，不宜太多。女人无官婚难成，女人一官最好命；女人二官心不定，女人三官会作娼</li>\n<li>正官太多变成强迫症，古板死心眼，固执。</li>\n<li>本名正官多，大运流年又遇到正官，会有执法单位，公检法来找事。</li>\n<li>正官多的人，一生追求的是名誉地位，什么都可以不要，一定要当领导。</li>\n<li>没有正官，对自己无法严格要求，不喜欢别人拘束，目无法律；我行我素，很难做领导。女同志没有正官会晚婚，严重的终身不嫁；</li>\n</ol>\n<h3 id=\"正财（富神）\"><a href=\"#正财（富神）\" class=\"headerlink\" title=\"正财（富神）\"></a>正财（富神）</h3><p>正财详解：以日元为我，我克者为财才；阳我克阴，或阴我克阳，为正财，简记为“财”</p>\n<p>正财代表什么：<br>性格：守本分，诚实守信，脚踏实地，勤俭节约，重视家庭，诚信，爱妻子，是个值得信赖的人。<br>意像：稳定的收入，合法的收入<br>职业选择：如银行、财政、外交、中介、杂货、百货、批发零售、药商等<br>正财代表的亲人富翁，商人；男人的妻子，女人的父亲；</p>\n<p>正财的其他含义</p>\n<ol>\n<li>日元身弱正财为忌凶，为人吝啬，并且不容易发财。</li>\n<li>财喜藏不喜漏。天干之财为虚财，地支藏干里的财为真财。</li>\n<li>女怕官旺，男怕财多，男人正财多，多妻之像，或者不重视结发之妻。</li>\n<li>正财在年柱，工薪家庭，家庭条件还可以有房子住，正财在年柱跟发财关系不大。<br>月柱日柱时柱有正财最好<br>月柱正财30岁以后有稳定收入，才算是富命。<br>日支逢正财，代表孩子发财，晚年有稳定收入。<br>时支管55岁以后，时支正财是老年再结婚。</li>\n<li>正财偏财过多，为愚蠢之人。除了对钱感兴趣，对别的全不感兴趣。</li>\n<li>命中没有正财，一生财来财去，一场空；烂桃花多。女人与父亲缘薄，父多早丧，或病残，父亲无能。</li>\n</ol>\n<h3 id=\"七杀（病神）\"><a href=\"#七杀（病神）\" class=\"headerlink\" title=\"七杀（病神）\"></a>七杀（病神）</h3><p>七杀详解：以日元为我，遇克制日主的同性天干；阴阴相克，阳阳相克，就称为偏官；因同性相克力量比较凶狠，古人以七杀命名，简记为“杀”；</p>\n<p>七杀代表什么：<br>负面性格：霸道，急躁如火，脾气古怪，任性倔强，好胜好斗，报复心强，偏激叛逆，鲁莽冲动，听不进谏言、易树敌<br>正面性格：执行力强，有正义感和侠义精神，做事有魄力，勇于向困难挑战，勇于突破困境，坚强之意志力与干劲<br>意像：小人，仇人，得病<br>职业选择：武职，比如参军，警察，法院等需要具有杀气的行业，适合做二把手<br>代表人物：军人，警察，公检法执法地位；男人的儿子，女人的情人</p>\n<p>五行身体部位<br>甲肝乙胆丙胆，丁心戊胃己脾乡；庚金大肠辛金肺，壬是膀胱癸肾藏；<br>年干（头）      月干（胸部）    日元（小腹）    时干（大腿）<br>年支（脖子）    月令（腹部）    日支（屁股）    时支（小腿脚部）</p>\n<p>七杀的其他含义</p>\n<ol>\n<li>七杀在哪个五行，哪个五行就容易得病。</li>\n<li>七杀在哪个位置，哪个位置就容易得病。</li>\n<li>七杀索我性命，伤官破我官爵；枭印夺我俸禄；劫财争我财产；都是不好的恶神；</li>\n<li>七杀为日元的天敌，四凶神中的索命之鬼，因此八字批命首先看七杀，<br>只有安顿了七杀，方可论富贵，否则连有命无命都不知道，何言富贵？<br>七杀无制，在天干的多为突发之灾致残疾或凶死，在地支的则为慢性恶疾。</li>\n<li>但是七杀得制，也可以出现好的情况。<ol>\n<li>身强不怕七杀，七杀来克反为好，这叫身杀俩停。</li>\n<li>身弱有正印化解七杀。七杀生印，正印生日元。七杀反为我用，这叫杀印相生。</li>\n<li>身弱有食神制杀，没有偏印损害食神，七杀得制，这叫食神制杀。</li>\n</ol>\n</li>\n<li>本命七杀太多。大运流年遇到七杀，会有公检法执法单位找事。</li>\n<li>本命没有七杀，正官太多，大运流年再遇到正官，正官会变成七杀。</li>\n<li>只有七杀，没有正官，只能做二把手，做不了一把手。</li>\n<li>聪明不过伤官，伶俐不过七杀</li>\n<li>女命的七杀代表情人，相好的，女命不宜七杀过多。</li>\n<li>没有七杀，代表男人不容易生儿子，女人没有情人。性格方面不会心太狠。</li>\n</ol>\n<h3 id=\"偏印（郁神）\"><a href=\"#偏印（郁神）\" class=\"headerlink\" title=\"偏印（郁神）\"></a>偏印（郁神）</h3><p>偏印详解：以日元为我，生我者为印枭；阳生阳我，阴生阴我，为偏印，偏印带有凶性；古人称为枭神，简记为“枭”；</p>\n<p>偏印代表什么：<br>负面性格：敏感，内心孤独，不开心，优柔寡断，犹豫不决。不善与人交往，宁可一个人独处，也不愿到人多的地方。<br>正面性格：敏锐的观察力，分析力，感受力，理解力，困难的东西能迅速学，会多才多艺，心思细腻。<br>意像：学习玄学有特殊天赋，一定会不开心。<br>职业选择：研究，民意代表，发明，设计，创造，科技，武术，演艺，行销，直销，广告，模特，艳星等特殊专门性行业。<br>代表人物：军事，参谋；男命之祖父，女命之母亲；</p>\n<p>偏印的其他含义</p>\n<ol>\n<li>其他的干支偏印，命主会学习技术技能。月令偏印，必定有一技之长。</li>\n<li>命局中见到偏印，马上可以断命主，不开心。和谁不开心？主要是食神。<br>偏印和食神所在的官位，会产生对立。两个人性格不合。</li>\n<li>偏印过多之人有通灵的能力，能够看到普通人看不到的鬼魂。</li>\n<li>本命只有食神，没有偏印，大运流年遇到偏印，就会不开心。</li>\n<li>本命只有偏印，没有食神，大运流年遇到食神，也会不开心。</li>\n<li>每个人都有神经病，只是发作的周期和发作的程度不同。分几个等级：<br> 一、轻度妄想：多疑，不安，虚惊，焦虑等。<br> 二、中度忧郁：对现实生活茫然，对生命怀疑，没有目标，轻度矛盾分裂意识；<br> 三、重度严重忧郁：失眠，严重幻想，有恐惧感，心理有强烈矛盾感；精神分裂严重，有自杀的倾向。<br> 四、超重度：有以上情形，并且有躁郁的暴力冲动行为；会做出危害他人的伤害行为来。命局中有以上的情形；再加上同命局或是大运有 七杀 的杀气助力；<br> 就会成为超重度的大枭神。一个人控制不住的情绪；做出一反常态，伤害别人的举动，就是因为这个产生的。俗称鬼上身。</li>\n<li>命局没有偏印，做事不重视细节，没法感知别人内心的感受。</li>\n</ol>\n<h3 id=\"伤官（狂神）\"><a href=\"#伤官（狂神）\" class=\"headerlink\" title=\"伤官（狂神）\"></a>伤官（狂神）</h3><p>伤官详解：以日元为我，我生者为食伤；遇到日元所生的异性天干，阳我生阴，阴我生阳；为伤官，简记为“伤”；</p>\n<p>伤官代表什么：<br>负面性格：言语尖锐刻薄，狂傲不羁，肚量狭小，记仇，得理不饶人；任性蛮横，逞强好胜，一身傲骨，鄙视他人，死不认错；<br>正面性格：聪明灵巧，个性突出，容易强风头，能演善辩，不愿服输，胆大，有魄力，有才华。过于自信到自负的程度。<br>意像：男人主口舌，官司，纷争，女命另外主克夫；<br>职业选择：宜从事文学，书画，艺术等职业，如文学家，影星，歌星，舞蹈家，音乐家以及画家等等。<br>代表人物：晚辈，学生，下属；男人的祖母，孙女，女人的儿子；</p>\n<p>伤官的其他含义：</p>\n<ol>\n<li>女带伤官必骂夫，女坐伤官必克夫；</li>\n<li>这等女性，若非为人多才艺，就是长相清逸秀丽，或二者兼而有之。<br>多半属于女强人形，很有气质，才华横溢，成就往往超越男性，因此伤官旺的女性具有开拓性，宜从事事业，而不宜做家庭主妇。</li>\n<li>月柱伤官代表官司。日柱伤官代表夫妻吵架和官司。<br>时柱伤官代表子女不孝，亦表示晚运凄凉悲苦。</li>\n<li>伤官可以旺财，因为伤官上进心强。</li>\n<li>伤官配印，非富即贵；<br>如果一个人命中伤官特别强，又有强印来制，含义为：一个胆大，有魄力，才华横溢的人，同时又具备忍耐，慈爱，勤恳的德行，那么升官肯定特别快；<br>到哪里都会脱颖而出，干出一番事业，更何况印也主权，所以伤官配印的命格位重权高。</li>\n<li>伤官旺的人喜欢装B炫耀才华，伤官旺的人服软不服硬。</li>\n<li>本命有伤官，大运流年遇到伤官，易有官司口舌纷争。</li>\n<li>本命食神多，大运流年遇到食神，食神会变成伤官，也会有官司口舌纷争。</li>\n</ol>\n<h3 id=\"劫财（骗神）\"><a href=\"#劫财（骗神）\" class=\"headerlink\" title=\"劫财（骗神）\"></a>劫财（骗神）</h3><p>劫财详解：以日元为我，同我者为比劫；凡是遇到日元的异性天干，阳同阴，阴同阳；为劫财，简记为“劫”；</p>\n<p>劫财代表什么：（劫财在地支又名羊刃）<br>负面性格：固执己见，自我矛盾，好酒好赌，贪小便宜，好吹牛；喜抬杠，不讲信用，借钱不还，不诚实，满嘴瞎话<br>正面性格：性格开朗，心思敏捷，个性明显，自尊心强，口才好，善于活跃气氛，鬼点子多，初次交往中能得到别人的好感。<br>意像：赌博，破财，克父，克妻，滑头，骗子<br>职业选择：自由业，服务业，直销，投资，贸易，流动行业<br>代表的人物：异性的朋友，同辈，同学；男命姐妹，女命兄弟；</p>\n<p>劫财的其他含义：</p>\n<ol>\n<li>年柱劫财，祖业耗散，无财产留给后人，家庭不好，早年贫困。<br>月柱劫财为自己破财，还代表社会上的朋友借你的钱。<br>日柱劫财离婚的几率很大。或者分居。<br>时柱劫财晚年孤苦没有收入。</li>\n<li>劫财之人为了达到个人的目的，下跪去发毒誓，甜言蜜语；<br>会利用一切可以打动别人的东西去打动别人。<br>你可要防备了，他对你是有目的和歹心的，利用完你就会一脚蹬开。</li>\n<li>劫财之人喜欢赌博。本命没有劫财，不喜欢赌博，大运流年劫财一到，开始赌博。</li>\n<li>劫财之人见面熟，交际手腕高，见人说人话，见鬼说鬼话。<br>认识你以后就开始借钱，还不还钱要看其他十神的组合。<br>借了一圈朋友的钱以后，开始进去新的朋友圈，混熟以后再借钱。<br>喜欢做传销项目，因为朋友多，骗完一圈，再换圈子骗。</li>\n<li>劫财过多，很难发财。</li>\n<li>男命带劫财，大运流年又有劫财，会跟妻子分开，并且投资容易破财。</li>\n<li>选择合伙人时，命里劫财过多的人，赚钱不择手段，坑蒙拐骗偷。你一定会吃亏。</li>\n<li>女生选择男朋友的时候，要注意男人劫财多，会采取卑鄙霸道手段将女方骗上床，然后开始借钱，最后骗财骗色</li>\n</ol>\n<h3 id=\"比肩（友神）\"><a href=\"#比肩（友神）\" class=\"headerlink\" title=\"比肩（友神）\"></a>比肩（友神）</h3><p>比肩详解：以日元为我，同我者为比劫；凡是遇到日元同样的天干；为比肩，简记为“比”</p>\n<p>比肩代表什么：<br>负面性格：固执己见，独断专行，自我中心，朋友很多，但知己不多，严厉刻薄，不通人情，喜自我封闭，闭门造车，刚愎自用<br>正面性格：意志坚强，重情重义，独立自主，不轻易变动，敦厚忠实，做事有耐心，力争上游<br>意像：忌凶克财，喜用合作得财，人缘好<br>职业选择：直销，开阔者，运动员，流动行业，机械运动，中介，健身<br>代表的人物：同性的朋友，同辈，同学，合伙人，股东；男命的兄弟，女命的姐妹；</p>\n<p>比肩的其他含义</p>\n<ol>\n<li>比肩和劫财都是克制财星的，但稍有不同。<br> 日元身弱，比肩为喜用，大运流年见比肩，可以跟人合作求财。<br> 日元身强，比肩为忌神，大运流年见比肩，与人合作必破财。</li>\n<li>身旺不喜比肩帮，运走比肩反遭殃<br>身弱逢比运最通，合作营谋处处丰</li>\n<li>比肩为忌神，得不到朋友或兄弟的帮助，反而被争夺财物。</li>\n<li>比肩为用神，多得到朋友或兄弟帮助。</li>\n<li>比肩人内心的想法是一生平安。</li>\n<li>比肩多的人特别关心宠爱部下和朋友，但是和领导不会打交道。</li>\n<li>身强大运流年逢比肩，主伤妻损财。</li>\n<li>比肩流年大运要把钱分出去，钱不能独占。</li>\n<li>没有比肩的人，不善与人交往，不会主动联系朋友，所以朋友很少。性格较孤僻。做事没有耐心，容易半途而费。</li>\n</ol>\n<h3 id=\"偏财（侠神）\"><a href=\"#偏财（侠神）\" class=\"headerlink\" title=\"偏财（侠神）\"></a>偏财（侠神）</h3><p>偏财详解：以日元为我，我克者为财才；阳我克阳，阴我克阴，为偏财，简记为“才”；</p>\n<p>偏财代表什么：<br>负面性格：不重视金钱，不善理财，一心多用，轻浮放荡，嗜酒好色，赌性太大。<br>正面性格：慷慨大方，重义轻财，聪明机巧，开朗乐观，乐善好施，人脉广阔，风流多情，豪爽出手大方容易得女人欢心<br>意像：侠客，做生意，意外之财<br>职业选择：商业，企业，投资和投机生意，金融，信息咨询<br>代表得人物：富翁，商人；男人的父亲和情人， 女人的婆婆</p>\n<p>偏财的其他含义</p>\n<ol>\n<li>偏财在年柱，代表发财必须离开家乡发展；<br>偏财在月干最好，代表父亲优秀能干，对自己的帮助大；<br>如果偏财在月支，则代表自己能存下来巨额的财富。<br>偏财在日支，代表配偶会给自己带来财富，同时代表感情方面会有烂桃花。<br>偏财在时柱，代表子女发财，晚年发财</li>\n<li>偏财比正财会赚钱，正财多为工作收入，偏财是敏锐的商业眼光做生意得来的。</li>\n<li>偏财不好的一点就是时有时无，来的时候金山银海，但是会很长时间不来钱。</li>\n<li>日元身弱，偏财为忌神，总想着不劳而获，但是偏财不是经常有，就会贪图享受，懒惰</li>\n<li>偏财喜欢交朋友，三教九流都有，所以有广大的人脉关系，能得到相当多的情报资讯。</li>\n<li>偏财为人大方慷慨，会去帮助朋友，所以对方愿意提供消息，让自己获得回报。</li>\n<li>偏财爱往外面跑，到处结交朋友，与他人谈天说地，交际应酬特别多，加上出手大方，<br>会愿意去分享，因此人缘特别好。对于陌生的人士，很快便可以熟识，并且能打成一片，建立友谊。</li>\n<li>偏财本身多，遇大运流年流月流日流时，买彩票，一定中奖。</li>\n<li>正财偏财混杂，家里有老婆。还花心在外边找情人。</li>\n</ol>\n<h2 id=\"神煞\"><a href=\"#神煞\" class=\"headerlink\" title=\"神煞\"></a>神煞</h2><h2 id=\"六十甲子和六甲空亡\"><a href=\"#六十甲子和六甲空亡\" class=\"headerlink\" title=\"六十甲子和六甲空亡\"></a>六十甲子和六甲空亡</h2><p>按照阳干配阳支, 阴干配阴支总共有60种组合, 每组多出的两个叫做空亡<br>第一组: 甲乙丙丁戊己庚辛壬癸<br>        子丑寅卯辰巳午未申酉     空亡: 戌亥<br>第二组: 甲乙丙丁戊己庚辛壬癸<br>        戌亥子丑寅卯辰巳午未     空亡: 申酉<br>第三组: 甲乙丙丁戊己庚辛壬癸<br>        申酉戌亥子丑寅卯辰巳     空亡: 午未<br>第四组: 甲乙丙丁戊己庚辛壬癸<br>        午未申酉戌亥子丑寅卯     空亡: 辰巳<br>第五组: 甲乙丙丁戊己庚辛壬癸<br>        辰巳午未申酉戌亥子丑     空亡: 寅卯<br>第六组: 甲乙丙丁戊己庚辛壬癸<br>        寅卯辰巳午未申酉戌亥     空亡: 子丑</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":"<h1 id=\"学会看八字\"><a href=\"#学会看八字\" class=\"headerlink\" title=\"学会看八字\"></a>学会看八字</h1><p>道教文化道教认为，<strong>我命有我不由天</strong>， 通过研究生命的规律可以去<strong>趋吉避凶</strong>，好事发生的时候那就把它加强一下，然后好事更好，但是坏事要发生了，那么怎么办呢~我们去规避一下大事给化解掉<strong>大事化小小事化了。</strong></p>\n<hr>\n<h2 id=\"五行\"><a href=\"#五行\" class=\"headerlink\" title=\"五行\"></a>五行</h2><p>有个东西大家是没有办法省略的，就是<strong>五行</strong>，这个五行是道家文化所独有的一个传统文化，道教他认为<strong>天地万物都分阴阳和五行</strong>，那么通过这个学习<strong>五行相生相克</strong>，这是所有周易学派的一个基础，不管你以后学八字奇门遁甲，大六任，小六任，梅花艺术，紫微斗数，黄极其势等等，周易分很多门派很多学科但是他的核心就是<strong>五行</strong>。</p>\n<p>五行相生</p>\n<ul>\n<li>水: 地球出现的第一个元素</li>\n<li>水生木: 植物需要水来灌溉</li>\n<li>木生火: 钻木取火</li>\n<li>火生土: 火燃烧后变成灰, 灰就是土</li>\n<li>土生金: 沙里淘金</li>\n<li>金生水: 用金属工具挖井</li>\n</ul>\n<p>五行向克</p>\n<ul>\n<li>金克木: 用金属制作的斧头可以砍树</li>\n<li>木克土: 植物吸收了土里的营养</li>\n<li>土克水: 水来土掩</li>\n<li>水克火: 水能灭火</li>\n<li>火克金: 火能把金属融化</li>\n</ul>\n<p><img src=\"https://picsum.photos/1200/500\" alt=\"五行相生\"><br><img src=\"https://picsum.photos/1200/500\" alt=\"五行相生\"></p>\n<h2 id=\"四季土\"><a href=\"#四季土\" class=\"headerlink\" title=\"四季土\"></a>四季土</h2><p>1-12月分别用地支表示: 寅卯<strong>辰</strong> &#x2F; 巳午<strong>未</strong> &#x2F; 申酉<strong>戌</strong> &#x2F; 亥子<strong>丑</strong></p>\n<ul>\n<li>其中每个季度的最后一个月份都是属土, 分别是 <strong>辰 &#x2F; 未 &#x2F; 戌 &#x2F; 丑</strong></li>\n<li>寅月和卯月属木, 巳月和午月属火, 申月和酉月属金, 亥月和子月属水</li>\n</ul>\n<h2 id=\"天干\"><a href=\"#天干\" class=\"headerlink\" title=\"天干\"></a>天干</h2><p>甲<br>方向: 东方<br>阴阳: 阳木<br>颜色: 绿色<br>身体部位: 肝<br>意象: 大树</p>\n<p>已<br>方向: 东方<br>阴阳: 阴木<br>颜色: 绿色<br>身体部位: 胆<br>意象: 花草</p>\n<p>丙<br>方向: 南方<br>阴阳: 阳火<br>颜色: 红色<br>身体部位: 小肠<br>意象: 太阳, 圆形物品</p>\n<p>丁<br>方向: 南方<br>阴阳: 阴火<br>颜色: 红色<br>身体部位: 心脏, 血液<br>意象: 蜡烛, 电灯泡, 烟头</p>\n<p>戊<br>方向: 中央<br>阴阳: 阳土<br>颜色: 黄色<br>身体部位: 胃<br>意象: 城墙土</p>\n<p>己<br>方向: 中央<br>阴阳: 阴土<br>颜色: 黄色<br>身体部位: 脾<br>意象: 田地</p>\n<p>庚<br>方向: 西方<br>阴阳: 阳金<br>颜色: 白色, 金色<br>身体部位: 大肠<br>意象: 宝剑, 大刀, 汽车</p>\n<p>辛<br>方向: 西方<br>阴阳: 阴金<br>颜色: 白色, 金色<br>身体部位: 肺<br>意象: 首饰, 小型金属物品</p>\n<p>壬<br>方向: 北方<br>阴阳: 阳水<br>颜色: 黑色, 蓝色<br>身体部位: 膀胱<br>意象: 大江, 大河, 大湖, 大海</p>\n<p>癸<br>方向: 北方<br>阴阳: 阴水<br>颜色: 黑色, 蓝色<br>身体部位: 肺<br>意象: 小溪, 水井, 小河, 露水, 下水道</p>\n<h2 id=\"地支\"><a href=\"#地支\" class=\"headerlink\" title=\"地支\"></a>地支</h2><p>子<br>方向: 正北方<br>颜色: 黑色, 蓝色<br>阴阳: 阳水<br>月份: 阴历11月<br>时间: 23点到凌晨1点<br>藏天干: 本气癸<br>动物代表: 鼠</p>\n<p>丑<br>方向: 东北方<br>颜色: 黄色<br>阴阳: 阴土<br>月份: 阴历12月<br>时间: 凌晨1点到3点<br>藏天干: 本气己, 中气辛, 余气庚<br>动物代表: 牛</p>\n<p>寅<br>方向: 东北方<br>颜色: 绿色<br>阴阳: 阳木<br>月份: 阴历一月<br>时间: 凌晨3点到5点<br>藏天干: 本气甲, 中气丙, 余气戊<br>动物代表: 老虎</p>\n<p>卯<br>方向: 正东方<br>颜色: 绿色<br>阴阳: 阴木<br>月份: 阴历二月<br>时间: 凌晨5点到7点<br>藏天干: 本气乙<br>动物代表: 兔子</p>\n<p>辰<br>方向: 东南方<br>颜色: 黄色<br>阴阳: 阳土<br>月份: 阴历3月<br>时间: 上午7点到9点<br>藏天干: 本气戊, 中气已, 余气庚<br>动物代表: 龙</p>\n<p>巳<br>方向: 东南方<br>颜色:  红色<br>阴阳: 阴火<br>月份: 阴历4月<br>时间: 上午9点到11点<br>藏天干: 本气丙, 中气戊, 余气庚<br>动物代表: 蛇</p>\n<p>午<br>方向: 正南方<br>颜色: 红色<br>阴阳: 阳火<br>月份: 阴历5月<br>时间: 中午11点到下午13点<br>藏天干: 本气丁, 中气乙<br>动物代表: 马</p>\n<p>未<br>方向: 西南方<br>颜色: 黄色<br>阴阳: 阴土<br>月份: 阴历6月<br>时间: 下午13点到15点<br>藏天干: 本气已, 中气丁, 余气已<br>动物代表: 羊</p>\n<p>申<br>方向: 西南方<br>颜色: 白色, 金色<br>阴阳: 阳金<br>月份: 阴历7月<br>时间: 下午15点到17点<br>藏天干: 本气庚, 中气壬, 余气戊<br>动物代表: 猴</p>\n<p>酉<br>方向: 正西方<br>颜色: 白色, 金色<br>阴阳: 阴金<br>月份: 寅月8月<br>时间: 下午17点到19点<br>藏天干: 本气辛<br>动物代表: 鸡</p>\n<p>戌<br>方向: 西北方<br>颜色: 黄色<br>阴阳: 阳土<br>月份: 阴历9月<br>时间: 下午19点到21点<br>藏天干: 本气戊, 中气辛, 余气丁<br>动物代表: 狗</p>\n<p>亥<br>方向: 西北方<br>颜色: 蓝色, 黑色<br>阴阳: 阴水<br>月份: 阴历10月<br>时间: 晚上21点23点<br>藏天干: 本气壬, 中气甲<br>动物代表: 猪</p>\n<h2 id=\"藏干\"><a href=\"#藏干\" class=\"headerlink\" title=\"藏干\"></a>藏干</h2><p>子: 癸<br>丑: 己 &#x2F; 辛 &#x2F; 癸<br>寅: 甲 &#x2F; 丙 &#x2F; 戊<br>卯: 乙<br>辰: 戊 &#x2F; 乙 &#x2F; 癸<br>巳: 丙 &#x2F; 戊 &#x2F; 庚<br>午: 丁 &#x2F; 己<br>未: 己 &#x2F; 丁 &#x2F; 乙<br>申: 庚 &#x2F; 壬 &#x2F; 戊<br>酉: 辛<br>戌: 戊 &#x2F; 辛 &#x2F; 丁<br>亥: 壬 &#x2F; 甲</p>\n<h2 id=\"宫位六亲\"><a href=\"#宫位六亲\" class=\"headerlink\" title=\"宫位六亲\"></a>宫位六亲</h2><p>注: 每个宫位代表9年<br>年干: 父亲, 父亲家族    月干: 父亲, 姐姐哥哥, 社会上的哥哥姐姐  日元: 自己          时干: 长子<br>年干: 母亲, 母亲家族    月令: 母亲, 弟弟妹妹, 社会上的弟弟妹妹  日支: 夫妻, 家族    时支: 次子<br>祖先宫                 父母兄弟姐妹, 社会关系宫               夫妻宫              子女宫</p>\n<h2 id=\"分清日元强弱\"><a href=\"#分清日元强弱\" class=\"headerlink\" title=\"分清日元强弱\"></a>分清日元强弱</h2><p>年干</p>\n<p>看八字的第一步就是分清日元强弱</p>\n<p><img src=\"https://picsum.photos/500/450\" alt=\"八字得分\"></p>\n<p>十二长生<br>长生, 沐浴, 冠带, 临官, 帝旺, 衰, 病, 死, 墓, 绝, 胎, 养</p>\n<h2 id=\"八卦九宫-河图洛书\"><a href=\"#八卦九宫-河图洛书\" class=\"headerlink\" title=\"八卦九宫(河图洛书)\"></a>八卦九宫(河图洛书)</h2><pre><code>    甲  乙  丙  丁  戊  己  庚  辛  壬  癸\n</code></pre>\n<p>长生     亥  午  寅  酉  寅  酉  巳  子  申  卯<br>沐浴     子  巳  卯  申  卯  申  午  亥  酉  寅</p>\n<p>冠带     丑  辰  辰  未  辰  未  未  戌  戌  丑<br>临官     寅  卯  巳  午  巳  午  申  酉  亥  子<br>帝旺     卯  寅  午  巳  午  巳  酉  申  子  亥                          </p>\n<p>衰       辰  丑  未  辰  未  辰  戌  未  丑  戌<br>病       巳  子  申  卯  申  卯  亥  午  寅  酉<br>死       午  亥  酉  寅  酉  寅  子  巳  卯  申<br>墓       未  戌  戌  丑  戌  丑  丑  辰  辰  未<br>绝       申  酉  亥  子  亥  子  寅  卯  巳  午<br>胎       酉  申  子  亥  子  亥  卯  寅  午  巳<br>养       戌  未  丑  戌  丑  戌  辰  丑  未  辰</p>\n<pre><code>巳  午  未\n</code></pre>\n<p>辰  4   9   2   申</p>\n<p>卯  3   5   7   酉</p>\n<p>寅  8   1   6   戌<br>    丑  子  亥</p>\n<h2 id=\"十神-一位为真-二位为争-三位为病-四五六都不好-七个反而变好\"><a href=\"#十神-一位为真-二位为争-三位为病-四五六都不好-七个反而变好\" class=\"headerlink\" title=\"十神(一位为真, 二位为争, 三位为病, 四五六都不好, 七个反而变好)\"></a>十神(一位为真, 二位为争, 三位为病, 四五六都不好, 七个反而变好)</h2><p>天干地支分五行, 五行又分阴阳,总共是十个种类<br>因日元和其他七个干支会产生十种关系, 所以得出十神<br>分别是四个吉神: 正印    食神    正官    正财<br>      四个恶神: 七杀    偏印    伤官    劫财<br>      两个平神: 比肩    偏财<br>规律：</p>\n<ul>\n<li>克我者为官杀</li>\n<li>我克者为财才</li>\n<li>生我者为印枭</li>\n<li>我生者为食伤</li>\n<li>同我者为比劫</li>\n</ul>\n<h3 id=\"正印（智慧之神）\"><a href=\"#正印（智慧之神）\" class=\"headerlink\" title=\"正印（智慧之神）\"></a>正印（智慧之神）</h3><p>正印详解：以日元为我，生我者为印枭，阴生阳我，阳生阴我，为正印，简记为“印”</p>\n<p>正印代表什么<br>性格：聪明智慧，记性好，喜欢学习，心地善良，责任心强，少病少灾<br>意像：房子，文书，教育，权利，脑中的天使<br>职业选择：宜当教师、艺术家、出版商、秘书、护士、宗教家或星象家、棋手等<br>正印的亲人：代表长辈，贵人，师长；男命代表母亲，女命代表祖父、女婿</p>\n<p>正印的含义</p>\n<ol>\n<li>日元身弱, 最喜正印来生;<br> 日元身强, 正印来生反而为害;</li>\n<li>正印是你脑中的天使, 不停的啰嗦;<br> 时刻提醒你不要做坏事, 不要做错事;</li>\n<li>正印代表古代中的印玺, 代表权利. 命中无官, 有印一样能掌权.</li>\n<li>正印代表思想文化, 正印多的人,<br> 一生的追求是自己的思想观念能得到别人的认可.</li>\n<li>日元身弱正印代表房子, 日元身强不代表房子.</li>\n<li>男人命中正印代表母亲, 财可以克印;<br> 男人一旦发财, 母亲的身体就会不好.<br> 另外正财代表男人的老婆, 正财多的男人, 婆媳关系都不太好.<br> 同理: 女人正印代表祖父, 女婿, 女人发财会克到祖父, 女婿.</li>\n<li>命中没有正印的人, 不爱学习, 没有责任心, 记性不好, 学非所用<br> 与母亲缘分浅, 经常生病</li>\n</ol>\n<h3 id=\"食神（福神）\"><a href=\"#食神（福神）\" class=\"headerlink\" title=\"食神（福神）\"></a>食神（福神）</h3><p>食神详解：以日元为我，我生者为食伤。阳我生我，阴我生阴，为食神，简记为“食”</p>\n<p>食神代表什么：食神一位胜财官。<br>性格：口才好，喜欢玩，好歌舞酒色，吃货，多福多寿，心宽体胖，为人宽宏大量，对艺术天赋异禀。<br>意像：胖，大，有福气，衣食无忧。<br>职业选择：演艺、娱乐、美术、美容、服装设计或餐饮酒店等。<br>食神代表的亲人：代表晚辈，学生，下属。男人的孙子，女人的女儿</p>\n<p>食神的含义：</p>\n<ol>\n<li>食神的主要作用是生财，吃喝玩乐还能把钱赚到。</li>\n<li>日元身强，食神为喜用时能够泄化日主和比劫，食神一切好的一面就出现了。</li>\n<li>日元身弱，再去生食神，食神为忌凶，代表自己腹有诗书，难遇伯乐，易郁郁寡欢，怀才不遇，自己的思想易与世俗红尘格格不入。</li>\n<li>食神可以克制官杀，食神克制克我之七杀，保自己的命。食神一到，官运要丢。</li>\n<li>时柱有食神最好，代表晚年有福，衣食无忧。时柱又代表子女宫</li>\n<li>也代表能享子女之福。</li>\n<li>食神不易过多，过多会身体肥胖，贪图享乐，好逸恶劳，不务正业，不知节俭。</li>\n<li>没有食神也不好，不会玩，口才不好，不善言辞。</li>\n</ol>\n<h3 id=\"正官（贵神）\"><a href=\"#正官（贵神）\" class=\"headerlink\" title=\"正官（贵神）\"></a>正官（贵神）</h3><p>正官详解：以日元为我，克我者为官杀，阳克阴我，或阴克阳我，为正官；简记为“官”</p>\n<p>正官代表什么：<br>性格：守信用、正直、光明磊落、好面子、在乎名声地位、廉洁、公正、稳重<br>意像：大哥、领导、领袖、地位、受人敬仰<br>职业选择：政治、法律、侦探、法官、记者、公职方面职业<br>正官代表的亲人：长官、领导、上司；男人的女儿，女人的老公；</p>\n<p>正官的其他含义：<br>《论语·子路篇》中有一段话：其身正，不令而行，其身不正，虽令不从。</p>\n<ol>\n<li>命带正官之人，容易当官。年柱，班干部；月柱，当领导；日支：有组织领导能力；时支，子女光明正直。</li>\n<li>命带正官之人，好操心，劳累，容易长白头发。</li>\n<li>朋友大多是正经人，有恶习的人，赌博，涉黄，犯法，涉黑不正派的人不愿结交，但也不得罪</li>\n<li>朋友不多，很难有死党知己。</li>\n<li>女人正官代表老公，不宜太多。女人无官婚难成，女人一官最好命；女人二官心不定，女人三官会作娼</li>\n<li>正官太多变成强迫症，古板死心眼，固执。</li>\n<li>本名正官多，大运流年又遇到正官，会有执法单位，公检法来找事。</li>\n<li>正官多的人，一生追求的是名誉地位，什么都可以不要，一定要当领导。</li>\n<li>没有正官，对自己无法严格要求，不喜欢别人拘束，目无法律；我行我素，很难做领导。女同志没有正官会晚婚，严重的终身不嫁；</li>\n</ol>\n<h3 id=\"正财（富神）\"><a href=\"#正财（富神）\" class=\"headerlink\" title=\"正财（富神）\"></a>正财（富神）</h3><p>正财详解：以日元为我，我克者为财才；阳我克阴，或阴我克阳，为正财，简记为“财”</p>\n<p>正财代表什么：<br>性格：守本分，诚实守信，脚踏实地，勤俭节约，重视家庭，诚信，爱妻子，是个值得信赖的人。<br>意像：稳定的收入，合法的收入<br>职业选择：如银行、财政、外交、中介、杂货、百货、批发零售、药商等<br>正财代表的亲人富翁，商人；男人的妻子，女人的父亲；</p>\n<p>正财的其他含义</p>\n<ol>\n<li>日元身弱正财为忌凶，为人吝啬，并且不容易发财。</li>\n<li>财喜藏不喜漏。天干之财为虚财，地支藏干里的财为真财。</li>\n<li>女怕官旺，男怕财多，男人正财多，多妻之像，或者不重视结发之妻。</li>\n<li>正财在年柱，工薪家庭，家庭条件还可以有房子住，正财在年柱跟发财关系不大。<br>月柱日柱时柱有正财最好<br>月柱正财30岁以后有稳定收入，才算是富命。<br>日支逢正财，代表孩子发财，晚年有稳定收入。<br>时支管55岁以后，时支正财是老年再结婚。</li>\n<li>正财偏财过多，为愚蠢之人。除了对钱感兴趣，对别的全不感兴趣。</li>\n<li>命中没有正财，一生财来财去，一场空；烂桃花多。女人与父亲缘薄，父多早丧，或病残，父亲无能。</li>\n</ol>\n<h3 id=\"七杀（病神）\"><a href=\"#七杀（病神）\" class=\"headerlink\" title=\"七杀（病神）\"></a>七杀（病神）</h3><p>七杀详解：以日元为我，遇克制日主的同性天干；阴阴相克，阳阳相克，就称为偏官；因同性相克力量比较凶狠，古人以七杀命名，简记为“杀”；</p>\n<p>七杀代表什么：<br>负面性格：霸道，急躁如火，脾气古怪，任性倔强，好胜好斗，报复心强，偏激叛逆，鲁莽冲动，听不进谏言、易树敌<br>正面性格：执行力强，有正义感和侠义精神，做事有魄力，勇于向困难挑战，勇于突破困境，坚强之意志力与干劲<br>意像：小人，仇人，得病<br>职业选择：武职，比如参军，警察，法院等需要具有杀气的行业，适合做二把手<br>代表人物：军人，警察，公检法执法地位；男人的儿子，女人的情人</p>\n<p>五行身体部位<br>甲肝乙胆丙胆，丁心戊胃己脾乡；庚金大肠辛金肺，壬是膀胱癸肾藏；<br>年干（头）      月干（胸部）    日元（小腹）    时干（大腿）<br>年支（脖子）    月令（腹部）    日支（屁股）    时支（小腿脚部）</p>\n<p>七杀的其他含义</p>\n<ol>\n<li>七杀在哪个五行，哪个五行就容易得病。</li>\n<li>七杀在哪个位置，哪个位置就容易得病。</li>\n<li>七杀索我性命，伤官破我官爵；枭印夺我俸禄；劫财争我财产；都是不好的恶神；</li>\n<li>七杀为日元的天敌，四凶神中的索命之鬼，因此八字批命首先看七杀，<br>只有安顿了七杀，方可论富贵，否则连有命无命都不知道，何言富贵？<br>七杀无制，在天干的多为突发之灾致残疾或凶死，在地支的则为慢性恶疾。</li>\n<li>但是七杀得制，也可以出现好的情况。<ol>\n<li>身强不怕七杀，七杀来克反为好，这叫身杀俩停。</li>\n<li>身弱有正印化解七杀。七杀生印，正印生日元。七杀反为我用，这叫杀印相生。</li>\n<li>身弱有食神制杀，没有偏印损害食神，七杀得制，这叫食神制杀。</li>\n</ol>\n</li>\n<li>本命七杀太多。大运流年遇到七杀，会有公检法执法单位找事。</li>\n<li>本命没有七杀，正官太多，大运流年再遇到正官，正官会变成七杀。</li>\n<li>只有七杀，没有正官，只能做二把手，做不了一把手。</li>\n<li>聪明不过伤官，伶俐不过七杀</li>\n<li>女命的七杀代表情人，相好的，女命不宜七杀过多。</li>\n<li>没有七杀，代表男人不容易生儿子，女人没有情人。性格方面不会心太狠。</li>\n</ol>\n<h3 id=\"偏印（郁神）\"><a href=\"#偏印（郁神）\" class=\"headerlink\" title=\"偏印（郁神）\"></a>偏印（郁神）</h3><p>偏印详解：以日元为我，生我者为印枭；阳生阳我，阴生阴我，为偏印，偏印带有凶性；古人称为枭神，简记为“枭”；</p>\n<p>偏印代表什么：<br>负面性格：敏感，内心孤独，不开心，优柔寡断，犹豫不决。不善与人交往，宁可一个人独处，也不愿到人多的地方。<br>正面性格：敏锐的观察力，分析力，感受力，理解力，困难的东西能迅速学，会多才多艺，心思细腻。<br>意像：学习玄学有特殊天赋，一定会不开心。<br>职业选择：研究，民意代表，发明，设计，创造，科技，武术，演艺，行销，直销，广告，模特，艳星等特殊专门性行业。<br>代表人物：军事，参谋；男命之祖父，女命之母亲；</p>\n<p>偏印的其他含义</p>\n<ol>\n<li>其他的干支偏印，命主会学习技术技能。月令偏印，必定有一技之长。</li>\n<li>命局中见到偏印，马上可以断命主，不开心。和谁不开心？主要是食神。<br>偏印和食神所在的官位，会产生对立。两个人性格不合。</li>\n<li>偏印过多之人有通灵的能力，能够看到普通人看不到的鬼魂。</li>\n<li>本命只有食神，没有偏印，大运流年遇到偏印，就会不开心。</li>\n<li>本命只有偏印，没有食神，大运流年遇到食神，也会不开心。</li>\n<li>每个人都有神经病，只是发作的周期和发作的程度不同。分几个等级：<br> 一、轻度妄想：多疑，不安，虚惊，焦虑等。<br> 二、中度忧郁：对现实生活茫然，对生命怀疑，没有目标，轻度矛盾分裂意识；<br> 三、重度严重忧郁：失眠，严重幻想，有恐惧感，心理有强烈矛盾感；精神分裂严重，有自杀的倾向。<br> 四、超重度：有以上情形，并且有躁郁的暴力冲动行为；会做出危害他人的伤害行为来。命局中有以上的情形；再加上同命局或是大运有 七杀 的杀气助力；<br> 就会成为超重度的大枭神。一个人控制不住的情绪；做出一反常态，伤害别人的举动，就是因为这个产生的。俗称鬼上身。</li>\n<li>命局没有偏印，做事不重视细节，没法感知别人内心的感受。</li>\n</ol>\n<h3 id=\"伤官（狂神）\"><a href=\"#伤官（狂神）\" class=\"headerlink\" title=\"伤官（狂神）\"></a>伤官（狂神）</h3><p>伤官详解：以日元为我，我生者为食伤；遇到日元所生的异性天干，阳我生阴，阴我生阳；为伤官，简记为“伤”；</p>\n<p>伤官代表什么：<br>负面性格：言语尖锐刻薄，狂傲不羁，肚量狭小，记仇，得理不饶人；任性蛮横，逞强好胜，一身傲骨，鄙视他人，死不认错；<br>正面性格：聪明灵巧，个性突出，容易强风头，能演善辩，不愿服输，胆大，有魄力，有才华。过于自信到自负的程度。<br>意像：男人主口舌，官司，纷争，女命另外主克夫；<br>职业选择：宜从事文学，书画，艺术等职业，如文学家，影星，歌星，舞蹈家，音乐家以及画家等等。<br>代表人物：晚辈，学生，下属；男人的祖母，孙女，女人的儿子；</p>\n<p>伤官的其他含义：</p>\n<ol>\n<li>女带伤官必骂夫，女坐伤官必克夫；</li>\n<li>这等女性，若非为人多才艺，就是长相清逸秀丽，或二者兼而有之。<br>多半属于女强人形，很有气质，才华横溢，成就往往超越男性，因此伤官旺的女性具有开拓性，宜从事事业，而不宜做家庭主妇。</li>\n<li>月柱伤官代表官司。日柱伤官代表夫妻吵架和官司。<br>时柱伤官代表子女不孝，亦表示晚运凄凉悲苦。</li>\n<li>伤官可以旺财，因为伤官上进心强。</li>\n<li>伤官配印，非富即贵；<br>如果一个人命中伤官特别强，又有强印来制，含义为：一个胆大，有魄力，才华横溢的人，同时又具备忍耐，慈爱，勤恳的德行，那么升官肯定特别快；<br>到哪里都会脱颖而出，干出一番事业，更何况印也主权，所以伤官配印的命格位重权高。</li>\n<li>伤官旺的人喜欢装B炫耀才华，伤官旺的人服软不服硬。</li>\n<li>本命有伤官，大运流年遇到伤官，易有官司口舌纷争。</li>\n<li>本命食神多，大运流年遇到食神，食神会变成伤官，也会有官司口舌纷争。</li>\n</ol>\n<h3 id=\"劫财（骗神）\"><a href=\"#劫财（骗神）\" class=\"headerlink\" title=\"劫财（骗神）\"></a>劫财（骗神）</h3><p>劫财详解：以日元为我，同我者为比劫；凡是遇到日元的异性天干，阳同阴，阴同阳；为劫财，简记为“劫”；</p>\n<p>劫财代表什么：（劫财在地支又名羊刃）<br>负面性格：固执己见，自我矛盾，好酒好赌，贪小便宜，好吹牛；喜抬杠，不讲信用，借钱不还，不诚实，满嘴瞎话<br>正面性格：性格开朗，心思敏捷，个性明显，自尊心强，口才好，善于活跃气氛，鬼点子多，初次交往中能得到别人的好感。<br>意像：赌博，破财，克父，克妻，滑头，骗子<br>职业选择：自由业，服务业，直销，投资，贸易，流动行业<br>代表的人物：异性的朋友，同辈，同学；男命姐妹，女命兄弟；</p>\n<p>劫财的其他含义：</p>\n<ol>\n<li>年柱劫财，祖业耗散，无财产留给后人，家庭不好，早年贫困。<br>月柱劫财为自己破财，还代表社会上的朋友借你的钱。<br>日柱劫财离婚的几率很大。或者分居。<br>时柱劫财晚年孤苦没有收入。</li>\n<li>劫财之人为了达到个人的目的，下跪去发毒誓，甜言蜜语；<br>会利用一切可以打动别人的东西去打动别人。<br>你可要防备了，他对你是有目的和歹心的，利用完你就会一脚蹬开。</li>\n<li>劫财之人喜欢赌博。本命没有劫财，不喜欢赌博，大运流年劫财一到，开始赌博。</li>\n<li>劫财之人见面熟，交际手腕高，见人说人话，见鬼说鬼话。<br>认识你以后就开始借钱，还不还钱要看其他十神的组合。<br>借了一圈朋友的钱以后，开始进去新的朋友圈，混熟以后再借钱。<br>喜欢做传销项目，因为朋友多，骗完一圈，再换圈子骗。</li>\n<li>劫财过多，很难发财。</li>\n<li>男命带劫财，大运流年又有劫财，会跟妻子分开，并且投资容易破财。</li>\n<li>选择合伙人时，命里劫财过多的人，赚钱不择手段，坑蒙拐骗偷。你一定会吃亏。</li>\n<li>女生选择男朋友的时候，要注意男人劫财多，会采取卑鄙霸道手段将女方骗上床，然后开始借钱，最后骗财骗色</li>\n</ol>\n<h3 id=\"比肩（友神）\"><a href=\"#比肩（友神）\" class=\"headerlink\" title=\"比肩（友神）\"></a>比肩（友神）</h3><p>比肩详解：以日元为我，同我者为比劫；凡是遇到日元同样的天干；为比肩，简记为“比”</p>\n<p>比肩代表什么：<br>负面性格：固执己见，独断专行，自我中心，朋友很多，但知己不多，严厉刻薄，不通人情，喜自我封闭，闭门造车，刚愎自用<br>正面性格：意志坚强，重情重义，独立自主，不轻易变动，敦厚忠实，做事有耐心，力争上游<br>意像：忌凶克财，喜用合作得财，人缘好<br>职业选择：直销，开阔者，运动员，流动行业，机械运动，中介，健身<br>代表的人物：同性的朋友，同辈，同学，合伙人，股东；男命的兄弟，女命的姐妹；</p>\n<p>比肩的其他含义</p>\n<ol>\n<li>比肩和劫财都是克制财星的，但稍有不同。<br> 日元身弱，比肩为喜用，大运流年见比肩，可以跟人合作求财。<br> 日元身强，比肩为忌神，大运流年见比肩，与人合作必破财。</li>\n<li>身旺不喜比肩帮，运走比肩反遭殃<br>身弱逢比运最通，合作营谋处处丰</li>\n<li>比肩为忌神，得不到朋友或兄弟的帮助，反而被争夺财物。</li>\n<li>比肩为用神，多得到朋友或兄弟帮助。</li>\n<li>比肩人内心的想法是一生平安。</li>\n<li>比肩多的人特别关心宠爱部下和朋友，但是和领导不会打交道。</li>\n<li>身强大运流年逢比肩，主伤妻损财。</li>\n<li>比肩流年大运要把钱分出去，钱不能独占。</li>\n<li>没有比肩的人，不善与人交往，不会主动联系朋友，所以朋友很少。性格较孤僻。做事没有耐心，容易半途而费。</li>\n</ol>\n<h3 id=\"偏财（侠神）\"><a href=\"#偏财（侠神）\" class=\"headerlink\" title=\"偏财（侠神）\"></a>偏财（侠神）</h3><p>偏财详解：以日元为我，我克者为财才；阳我克阳，阴我克阴，为偏财，简记为“才”；</p>\n<p>偏财代表什么：<br>负面性格：不重视金钱，不善理财，一心多用，轻浮放荡，嗜酒好色，赌性太大。<br>正面性格：慷慨大方，重义轻财，聪明机巧，开朗乐观，乐善好施，人脉广阔，风流多情，豪爽出手大方容易得女人欢心<br>意像：侠客，做生意，意外之财<br>职业选择：商业，企业，投资和投机生意，金融，信息咨询<br>代表得人物：富翁，商人；男人的父亲和情人， 女人的婆婆</p>\n<p>偏财的其他含义</p>\n<ol>\n<li>偏财在年柱，代表发财必须离开家乡发展；<br>偏财在月干最好，代表父亲优秀能干，对自己的帮助大；<br>如果偏财在月支，则代表自己能存下来巨额的财富。<br>偏财在日支，代表配偶会给自己带来财富，同时代表感情方面会有烂桃花。<br>偏财在时柱，代表子女发财，晚年发财</li>\n<li>偏财比正财会赚钱，正财多为工作收入，偏财是敏锐的商业眼光做生意得来的。</li>\n<li>偏财不好的一点就是时有时无，来的时候金山银海，但是会很长时间不来钱。</li>\n<li>日元身弱，偏财为忌神，总想着不劳而获，但是偏财不是经常有，就会贪图享受，懒惰</li>\n<li>偏财喜欢交朋友，三教九流都有，所以有广大的人脉关系，能得到相当多的情报资讯。</li>\n<li>偏财为人大方慷慨，会去帮助朋友，所以对方愿意提供消息，让自己获得回报。</li>\n<li>偏财爱往外面跑，到处结交朋友，与他人谈天说地，交际应酬特别多，加上出手大方，<br>会愿意去分享，因此人缘特别好。对于陌生的人士，很快便可以熟识，并且能打成一片，建立友谊。</li>\n<li>偏财本身多，遇大运流年流月流日流时，买彩票，一定中奖。</li>\n<li>正财偏财混杂，家里有老婆。还花心在外边找情人。</li>\n</ol>\n<h2 id=\"神煞\"><a href=\"#神煞\" class=\"headerlink\" title=\"神煞\"></a>神煞</h2><h2 id=\"六十甲子和六甲空亡\"><a href=\"#六十甲子和六甲空亡\" class=\"headerlink\" title=\"六十甲子和六甲空亡\"></a>六十甲子和六甲空亡</h2><p>按照阳干配阳支, 阴干配阴支总共有60种组合, 每组多出的两个叫做空亡<br>第一组: 甲乙丙丁戊己庚辛壬癸<br>        子丑寅卯辰巳午未申酉     空亡: 戌亥<br>第二组: 甲乙丙丁戊己庚辛壬癸<br>        戌亥子丑寅卯辰巳午未     空亡: 申酉<br>第三组: 甲乙丙丁戊己庚辛壬癸<br>        申酉戌亥子丑寅卯辰巳     空亡: 午未<br>第四组: 甲乙丙丁戊己庚辛壬癸<br>        午未申酉戌亥子丑寅卯     空亡: 辰巳<br>第五组: 甲乙丙丁戊己庚辛壬癸<br>        辰巳午未申酉戌亥子丑     空亡: 寅卯<br>第六组: 甲乙丙丁戊己庚辛壬癸<br>        寅卯辰巳午未申酉戌亥     空亡: 子丑</p>\n"},{"title":"First","_content":"\n\n## 课程目录\n1. 简历 - 铺好你的门面\n2. 找职位 - 铺开各渠道\n3. 首次沟通 - 信息收集\n4. 面试前 - 针对性准备\n5. 一面 - 突出技术根基\n6. 二面 - 述说领域经验\n7. 三面 - 体现综合能力\n8. HR面 - 展现健康人格\n9. 谈薪 - 自信不谦虚\n10. 试用期 - 实现预期自我\n\n### 简历 - 铺好你的门面\n什么是简历 - 先罗衣后敬人\n什么是简历 - **1**个核心目标: 用**最短时间**让面试官在人群中**发现**你, 并想**认识**你!\n\n简历筛选流程 - 面试官 细简历\n简历 => HR筛选入库(卡底线: 学历/学校/工作年限) => 入库 => 面试官捞简历(找上线: 学历/学校/工作年限) => 粗看简历(卡匹配度: 求职城市/薪资意向/技术领域)\n\n简历筛选流程 - 制作原则\n**弱化**底线 **无**干扰项 **放大**亮点\n- 底线: 公司的最低要求, 一般由 HR 去把控, 如: 学校, 学历, 等等 **(弱化)**\n- 干扰项: 可能会让面试官离开的信息, 如: 期望薪酬, 意向工作地, 等等 **删除**\n- 亮点: 能留住面试官的信息, 如: 大厂经历, 大型应用经验, 拿过的奖, 等等 **放大**\n\n### 如何写简历 - 个人信息\n姓名: XXX 学校:    学校: XX大学(2015 ~ 2019)\n手机:135xxxxxx98  邮箱: xxxxxxxx@qq.com\n\n如何写简历 - 工作经历\n起始年月日  公司名 - 部门   职位名称(职级)\n\n如何写简历 - 项目经验\n公司 - 项目名 (开始时间 ~ 结束时间)\n描述: (简要提炼重点,让面试官快速了解**系统性质**与**规模**)\n技术栈: (主要描述**你涉及**到的技术栈, 让面试官快速知道**你会什么**)\n\n负责部分: (描述前端**团队规模**, 与你所**负责**的部分, 让面试官知道**你做了什么**, **占比**多重)\n\n如何写简历 - 其他信息\n1. 获奖情况\n2. 个人项目\n3. 参与过的开源项目\n4. 发表过的文章\n5. 参与过的业界分享\n\n简历全貌\n个人信息: 姓名, 手机, 邮箱, 学历(年份)\n工作经历: 起始年份, 年份, 职位(职级)\n项目经验: 公司, 项目名, 周期, 描述, 技术栈, 负责部分\n其他信息: 奖项, 个人项目, 文章, 分享等等\n\n### 找职位 - 铺开各渠道\n情景分析 - 投递简历 石沉大海\n1. 学校原因: 双非一本不被待见\n2. 培训机构原因: 被歧视\n3. 外包经历原因: 被歧视\n4. 技术栈原因: vue落后了 要学 react\n5. 工作年限原因: 都要3年以上\n\n消极归因：教育背景（95%），其他（亮点没突出、投递不对、经验不匹配、基础不扎实、沟通不恰当占比5%）\n理性归因：教育背景（45%），其他（亮点没突出、投递不对、经验不匹配、基础不扎实、沟通不恰当占比55%）\n\n**抹掉**刻板认知 **塑造**独立思维\n情景分析 - 时代大背景\n\n```mermaid\ngraph TD;\n  互联网经济下行-->公司员工;\n  互联网经济下行-->岗位;\n  岗位-->停招聘\n  停招聘-->岗位1/3\n  公司员工-->裁员-->毕业生\n  裁员-->被裁员工\n  裁员-->培训机构\n  毕业生-->求职程序员2/3\n  被裁员工-->求职程序员2/3\n  培训机构-->求职程序员2/3\n  岗位1/3-->岗位供不应求,物件上涨,门槛提升\n  求职程序员2/3-->岗位供不应求,物件上涨,门槛提升\n```\n\n情景分析 - 时代大背景\n| 报名资格      | 职级           |\n| -----------   | -----------   |\n| 硕士/博士     |  王者          |\n| 985/211本科   |  钻石          |\n| 本科及以上    |  黄金          |\n| 大专及以上    |  青铜          |\n\n10年职业规划\n认清自己**水平**，处于什么**阶段**，有什么职业**诉求**，对自己有清晰**定位**。\n例：\n| 诉求               | 目标职位                                           | 耗时    |\n| -----------       | -----------                                        | -----   |\n| 工作经验 + 项目经验 | 有学习机会，能接触到更多项目，2年后拿到18k以上的offer | 2       |\n| 18k 以上的offer    | 能独当一面，独立负责系统，三年后进入大厂              | 3       |\n| 进入一线大厂        | 大厂，且进入较好业务，持续工作下去，晋升              | 5       |\n\n简历投递流程\n1. 选岗位\n2. 了解岗位信息\n3. 调整简历\n4. 复盘\n\n简历投递流程 - 选岗位\n1. 内推渠道\n2. 猎头渠道\n3. 企业官网\n4. 招聘APP\n\n简历投递流程 - 选岗位\n内推渠道\n特点：职场人脉（同学，校友，同事，朋友，前端社群，脉脉...）\n关键：内推到自己所在的团队，最好直接是团队Leader，否则和自己投递没区别。（很重要）\n优势：\n1. 面试前能深入了解团队技术栈，业务细节。\n2. 能更直接跟进面试情况。\n3. 有团队成员背书，遇到横向对比时，增加成功率。\n\n简历投递流程 - 选岗位\n猎头渠道\n特点：中高端岗位。\n关键：猎头必须投递公司s级合作方，或长期与该公司合作（很重要）\n又是：\n1. 了解这家公司的招聘背景，岗位紧急程度，以往通过率等等，给到你指引。\n2. 会有更多这家公司的面试题库，能做更针对性的面试前准备。\n3. 面试成功，能协助你谈到一个较好的offer。\n4. 面试失败，能协调你到其他岗位，再走流程。\n\n简历投递流程 - 选岗位\n内推 vs 猎头\n内推：工作年限 **<5年**, P7以**下**, 找**你需要**的岗位\n猎头: 工作年限 **>5年**, P7以**上**, 找**需要你**的岗位\n\n简历投递流程- 选岗位\n企业招聘官网\n缺乏主动沟通环节,除非你特别优秀,否则**不太建议**直接投递\n\n简历投递流程 - 了解岗位学习\n**穷尽**办法**收集**岗位信息,包括但不限于: 业务, 技术栈, 紧急程度, 面试题, 面试官等等\n\n简历投递流程- 调整简历\n面向对象建简历\n```mermaid\ngraph TD;\n  简历(基类)-->简历A(子类)-->岗位A\n  简历(基类)-->简历B(子类)-->岗位B\n  简历(基类)-->简历C(子类)-->岗位C\n```\n\n简历投递流程 - 复盘\n追问 -> 分析 -> 改进\n\n简历 \n-> HR筛选入库(我们要求本科以上, 你不太合适;\n我们需要5年工作经验以上的, 你不太适合;\n我们要求需要有React开发经验的, 你不太适合;\n我们需要有985/211的,你不太适合) -> 入库 -> 面试官捞简历(用人部门还没有回应; 再等等还没反馈) \n-> 粗看简历(你工作地必须是XX吗?\n你对薪酬的要求必须是XX吗?\n你对岗位的要求必须是XX吗?)\n-> 细看简历(看了你的项目经历,和我们的岗位不太匹配;\n我们这边还是找有做编辑器经验的人,你不太匹配;\n我们希望曾经有做tob经验的同学,你不太匹配) -> 发起面试\n\n课程总结\n1. 塑造独立思维\n2. 明确职业规划\n3. 简历投递心得分享\n\n电话邀约面试\nHR(确认面试时间) -> 候选人 -> 信息收集 -> 准备面试看八股文,刷程序题 \n\n历史视觉 - 孙子兵法\n上兵伐谋(谋略) 其次伐交(外交) 其次伐兵(动武) 其下攻城(攻城)\n\n现代军事视觉\n航母战斗群(覆盖2000公里)\n歼20(覆盖范围?)\n\n投资视觉\n第一层(2年前 获取100%信息)\n第二层(1年前 获取80%信息)\n第三层(半年前 获取50%信息)\n...\n第38层(现在获取20%信息)\n\n自己经验\n我(收纳1、2、3、4、5班考试资料) -> 考试\n\n求职场景\n信息**收集**得更多, 具备领先别人的**条件**\n信息**分析**得更**准**, 具备领先别人的**能力**\n\n招聘本质\n找更强的 ×\n找更匹配的 √\n\n匹配案例\n岗位薪酬:15k ~ 20k\n培训班毕业同学 ×\n能力到达40k ~ 50k的同学 ×\n2 ~ 3年中厂工作经验同学\n\n**收集**岗位信息 **判断**岗位核心诉求 **调整**自己为岗位匹配者\n1. 沟通能力\n2. 分析判断能力\n\n环节分析 - 采集岗位信息\nHR\n  - 关系转变: 对立 -> 同盟\n  - 电话收集: 部门、小组、业务\n  - 微信收集: 发展史、团队规模、竞品、企业文化、遇到困难、面试官风格等等\n猎头\n  - 收集: 面试成功案例, 过往面试题, 面试官风格等等.\n朋友\n  - 收集: 团队氛围, Leader风格, 加班情况, 面试官风格等等\n\n环节分析 - 分析岗位核心诉求\n技术栈\n  - 判断: Vue / React ? Element-ui? node? 前后端如何协作\n什么端\n  - 判断: PC / 移动端 / 原生?各有什么注意事项?\n用户群体\n  - 判断: 人群特点, 人群与业务是否契合, 会有什么问题?\n团队组成\n  - 判断: 自己的核心程度,承担多大工作量?\n\n课程总结\n1. **信息差**的重要性\n2. 招聘的本质: 找到**更匹配的**人\n3. 面试前准备: **采集**信息 - **分析**诉求 - **调整**自己\n4. 培养能力: **沟通**能力、**分析判断**能力\n\n岗位核心诉求\n技术诉求\n- 需要你懂什么: Vue / React / Uniapp ? PC / 移动端 / 小程序 / 原生 ? nodejs / Java?\n能力诉求\n- 需要你做什么: 带团队? 项目负责人? 核心研发? 普通研发?\n业务(经验)诉求\n- 需要做过什么: toB? toC? 自媒体? 游戏? 图片处理? 性能优化? 中台建设?\n成本诉求\n- 需要多少成本: 8k? 10k? 15k? 20k? 30k? 40k? 55k? 70k?\n\n诉求: 需要用**A成本**, 请一个懂**B技术**, 有**C经验**, 具备**D能力**的人\n回答: 我就是懂**B技术**, 有**C经验**, 具备**D能力**, 能接受**A成本**的人\n\n面试前的准备\n1. 自我介绍\n2. 复习基础\n3. 针对性技术准备\n4. 针对性项目准备\n5. 业务建议\n\n自我介绍 - 社招\n正常换工作\n你好, 我XX年毕业于XX学校, 有XX年工作经验, 主要在XX公司工作, 技术栈主要是 **${B技术}**, 开发的项目主要是 **${C经验}**, 在过去团队中, 主要承担的任务是 **${D能力}**\n\n毕业后空窗期找工作\n你好, 我XX年毕业于XX学校, XX专业, 技术栈主要是 **${B技术}**, 过去一段时间, 主要个人开发为主, 开发过的项目主要是 **${C经验}**, 个人从0到1搭建XX项目, 具备 **${D能力}**\n\n培训机构毕业找工作\n你好, 我XX年毕业于XX学习, XX专业, 学习的主要是 **${B技术}**, 过程中参与开发过的项目主要是 **${C经验}**, 在培训团队中, 主要承担的任务是 **${D能力}**\n\n应届毕业生 / 实习生\n你好, 我XX年毕业于XX学校, XX专业, XX月份毕业, 我个人对前端有比较大的兴趣, 所以,处理好本专业课程以外, 还自学了前端, 参与了学校XX团队XX年, 用到的技术栈主要是 **${B技术}**, 开发的项目主要是**${C经验}**, 在过去团队中, 主要承担的任务是 **${D能力}**\n\n\n复习基础\n学习能力\n解决问题能力\n\n复习基础\n第一层: 数据结构 + 计算机网络 + 设计模式\n第二层: JavaScript + HTML + CSS\n第三层: 框架原理 + 工程化 + 前端运维\n第四层: nodejs + Mysql\n\n针对性技术准备\n突出**技术**匹配度\n\n针对性技术准备\n过往面试题目(信息来源: 猎头)\n覆盖: 扫一遍题目, 透彻理解, 且准备最佳答案\n延展: 以题目为圆心, 覆盖周边延展题目\n\n面试官风格(信息来源: 猎头, 朋友)\n喜欢问概念: 多复习八股文, 刷题, 背面试题\n喜欢问实践: 多回顾复盘曾经做过的项目\n\n技术栈(信息来源: JD, 朋友)\n框架/工具: 了解对应原理, 回顾实践中的问题, 优化过的经验(知乎, 掘金)\n\n针对性项目准备\n选出与岗位诉求匹配的项目\n项目描述: 通过无差别录制用户行为, 以便有问题时能快速还原问题现场, 解决Tob私有化部署客户问题难定位问题\n个人负责: 系统负责人, 一人独立完成\n项目难点: 前端无差别录制会导致前端卡顿\n业界方案: 减少记录数据、用indexDB存储、数据合并、web-worker\n如何解决: 卡顿本质是计算线程阻塞了渲染线程, 通过webworker + indexDB的方案, web-worker完成计算, 让渲染线程保持通畅\n解决效果: 从卡顿到近乎无感知\n\n业务建议\n对业务的了解\n对行业竞品的了解\n对该行业的经验\n业务可能遇到的问题\n对该业务的建议\n\n课程总结\n懂**B技术**, 有**C经验**, 具备**D能力**, 能接受**A成本**的人\n自我介绍\n前端4层学习体系\n针对性的技术/项目/业务准备\n\n一面 - 突出技术根基\n\n面试要素\n本质认知\n  - 和面试官PK ×\n  - 获得HR认可 ×\n  - 表现得比其他面试者更优秀 √\n\n心态\n  - 去考试 ×\n  - 去交流 √\n\n姿态\n  - 被盘问 ×\n  - 技术交流 √\n  - 知识分享 √√\n\n面试官\n  细节 ----> 宏观\n\n面试技巧\n话术: **八股文**(依赖知识图谱) + **自己看法** + **自己经验**(依赖信息收集)\n引导: 引向自己**熟悉**的领域(依赖简历制作)\n\n场景与话术\n懂原理 + 有经验: 八股文 + 自己见解 + 自己经验\n懂原理 + 没经验: 八股文 + 行业方案\n不懂原理 + 有经验: 直接分享经验\n不懂原理 + 没经验: 找相似 / 直接告知不会, 记下, 整理到知识图谱\n\n编码题目\n懂: 编码 + 思路分享\n不懂: 咨询边界值 + 思路分享 / 直接告知不懂\n\n面试官目的\n**挖掘**候选的技术能力, 判断与岗位**匹配度**\n\n一面回顾\n一面面试官: 一线研发\n二面面试官: 团队leader\n\n二面 - 诉说领域经验\n核心考察\n靠擦点1: 过往的业务**经验**和我们是否**匹配**?\n电商管理系统: 订单管理, 仓储管理, 营销管理, 秒杀抢购, 物流跟踪等等\n移动端页面: 多机型适配, 加载性能, 体验新能, 虚拟列表, 滚动防抖, 预加载, 懒加载等等\nTOB中后台系统: 较强的抽象能力, 应对不同客户定制化需求, 问题跟进, 工单跟进等等\n\n考察点2: 业务能力(做事能力)\n根据已有的**知识体系**, 结合**业务**, 是否有形成自己成熟的做事**方法论**\n而该方法论是否全面, 包含考虑到项目的稳定性, 安全性,可拓展性, 可维护性, 持续集成成本等等\n\n我们要做什么\n1. 告诉面试官, 我做了什么**事情**, 这个事情属于什么**业务类型**\n\n做事思维方式\n**遇到**什么需求 / 问题 + **业界**解决方案 + **我的**解决方案 + **落地** 效果\n\n例:挑战点 -- **灵活高效**支撑多触达场景\n问题: 客户间有**不同**的触达场景, 且**定制化**程度高, 难以**灵活**应对, 一对一开发影响交付**效率**\n挑战点: 如何**灵活、高效**支撑多触达场景,降低成本, 提高效率\n分析思考: 客户需求虽各异, 但万变不离\"**人-货-场**\" (把特定货品, 在特定场景, 推送给特定人群)\n业界方案: \n方案A: **大而全**的触达系统, **标准化**流程(行业参考: 神策, 易观)\n方案A问题: 1. 不适合**多客户**交付场景; \n2. 交付时**冗余**过多无用能力; \n3. **定制化**拓展能力弱, 往往牺牲客户需求; \n4. 跟随迭代, **熵增**明显\n\n方案B: **多个**子系统配合, **灵活**配置各个运营场景\n方案B问题:\n1. 不适合**外部客户私有化**交付场景\n2. 通过建站能力不适用于**领域性较强**的场景\n3. 过分灵活, 搭建复杂, 并无**实质性提效**\n4. 未能**体系化**解决触达领域问题\n\n折中解决方案\n粒度: 算子服务 + AOP: 领域建模 + 面向对象建站\n\n挑战点 -- **灵活高效**支撑多触达场景: 算子服务\n算子服务: 描述\"人货场\"的基本单元, 组成系统的最小粒度, 一种**可复用**的**系统能力**\n\n触达领域\"人货场\"基本单元\n算子服务结构\n前端组件: page, 样式, 交互, 网络请求\n服务逻辑: 写库, 读库, 加工, 第三方依赖\n离线逻辑: 召回, 过滤, 排序, 离线计算\nDB存储: 数据结构, 存储场景\n钩子: 页面钩子, 组件钩子, 后端钩子\n\n前端组件: 决定算子前端样式与交互, 网络请求\n服务逻辑: 决定算子的存储逻辑, 依赖方\n计算逻辑: 决定算子离线行为, 计算逻辑\nDB存储: 决定算子存储结构, 存储场景\n钩子: 算子能重载, 想通过**定制化**能力保证\n\n挑战点 -- **灵活高效**支撑多触达场景: 面向切片领域建模(AOP)\n领域模型: 由算子拼装而成, 一种**可复用**的**通用业务能力**, 可重复**生成**多个营运系统\n\n挑战点 -- **灵活高效**支撑多触达场景: 面向对象建站, 平衡通用与定制化\n营运系统(**交付**客户)\n派生自领域模型, 针对客户需求定制化的营运系统, 交付客户的最终产品\n\n通用能力**复用**\n通过领域模型, 保证领域通用能力可复用, 节省重复开发人力成本\n\n模型**定制化拓展**\n依据面向对象\"继承\" \"重载\"等设计思想, 通过算子的拓展, 实现领域模型拓展, 灵活高效支持多客户场景\n\n关键要素\n封装: 一个类是多个算子的集合\n继承: 子类拥有父类所包含算子, 且能动态添加新算子\n多态: 算子可重载(钩子能力)\n\n案例:消息推送模型->实例化(领域模型支持**插拔式**组装算子, 算子支持各种**钩子**, 有效应对客户各种**定制化**需求)\n\n消息推送 - 领域模型(领域模型沉淀通用业务能力, 保证高**复用性**, 大幅降低重复开发成本)\n包含: 消息内容, 触发点, 业务条件, 人群定向\n\n挑战点 -- **灵活高效**支撑多触达场景: 最终解决方案\n\n算子->算子服务->算子服务库->算子库->领域模型->面向对象建站\n\n挑战点 -- **灵活高效**支撑多触达场景: 落地效果\n提效情况(**高效**)\n1. 开发系统=>开发算子 + 领域**建模**\n2. 一个算子的平均开发时间为5天/人\n3. 算子库可多人持续集成, 人力成本**边际效应**明显\n\n交付情况(**灵活**)\n1. 1年, 孵化领域模型**8**个, 营运系统**30+**\n2. 插入客户**24**个, 其中内部客户**13**个, 外部客户**11**个\n\n移动端列表页\n挑战点: 当用户往下滚动加载数据, 数据会越来越多, 页面会卡顿\n业界方案: 通过预加载, 懒加载的方式优化列表, 但是没很好解决卡顿问题\n我的方案: 当数据量超过阈值的时候, 切换为虚拟列表. 譬如加载超过1000条数据的时候, 无感知切换到虚拟列表, 始终只加载前后100条数据\n落地效果: 前端列表无限加载都无感知\n\n后台管理系统\n挑战点: 都是用UI框架搭建模块, 研发都在做CRUD体力活, 很浪费研发资源\n业界方案: 通过低代码平台处理, 但是你们人力有限, 项目也不大, 要构建一个低代码平台成本比较高\n我的方案: 分析得出, 每个模块其实基本功能都很类似, 都是有搜索框, 列表, 修改增加弹框, 翻页. 我就通过沉淀出这类模板, 并且暴露各参数, 使得有重复功能模块上线的时候, 直接通过配置即可生成板块,\n大大地提升研发效率, 同时也不会浪费研发资源制作CRUD的体力活事情\n落地效果: 同类型模块只需配置即可, 开发一个模块的人力从3人/天, 降低到1人/天\n\n门户页面\n挑战点: 需要经常和后端对接口, 经常需要耗费时间等联调, 影响效率\n业界方案: 通过模拟数据, 或者开发中写死等等, 但是这样需要额外去整理mock数据, 而且当结构变动的时候很难保持同步, 没有可维护性\n我的方案: 通过构造一套data-mocker服务, 前后端之间的沟通就通过data-mocker完成, data-mocker相当于一个API工具, 双方在系统上协商好api, data-mocker就会充当一个媒介,\n前端开发完就可以请求data-mocker返回模拟数据, 后端先开发完, 就可以利用data-mocker发起请求\n落地效果: 前后端联调不再互相依赖, 都以data-mocker作为媒介, 有效的提升效率. 前后端研发不再会因为API调整而增加更多的额外沟通成本\n\n一个功能模块\n挑战点: 这个组件非常特殊, 产品总是对这个产品的需求进行高频调整\n业界方案: 为模块提供其多的开放性配置, 应多产品经理的诉求, 但这样会极大增加维护成本\n我的方案: 写好模块的模板, 同时模板中留出很多的slot插槽, 同时收拢一个组件库, 用 公用组件 + 插槽 + 模板 的方案, 解决高频变动模块\n落地效果: 就算频繁变动, 也不会额外增加我更多的工作量\n\n\n","source":"_drafts/简历.md","raw":"---\ntitle: first\n---\n\n\n## 课程目录\n1. 简历 - 铺好你的门面\n2. 找职位 - 铺开各渠道\n3. 首次沟通 - 信息收集\n4. 面试前 - 针对性准备\n5. 一面 - 突出技术根基\n6. 二面 - 述说领域经验\n7. 三面 - 体现综合能力\n8. HR面 - 展现健康人格\n9. 谈薪 - 自信不谦虚\n10. 试用期 - 实现预期自我\n\n### 简历 - 铺好你的门面\n什么是简历 - 先罗衣后敬人\n什么是简历 - **1**个核心目标: 用**最短时间**让面试官在人群中**发现**你, 并想**认识**你!\n\n简历筛选流程 - 面试官 细简历\n简历 => HR筛选入库(卡底线: 学历/学校/工作年限) => 入库 => 面试官捞简历(找上线: 学历/学校/工作年限) => 粗看简历(卡匹配度: 求职城市/薪资意向/技术领域)\n\n简历筛选流程 - 制作原则\n**弱化**底线 **无**干扰项 **放大**亮点\n- 底线: 公司的最低要求, 一般由 HR 去把控, 如: 学校, 学历, 等等 **(弱化)**\n- 干扰项: 可能会让面试官离开的信息, 如: 期望薪酬, 意向工作地, 等等 **删除**\n- 亮点: 能留住面试官的信息, 如: 大厂经历, 大型应用经验, 拿过的奖, 等等 **放大**\n\n### 如何写简历 - 个人信息\n姓名: XXX 学校:    学校: XX大学(2015 ~ 2019)\n手机:135xxxxxx98  邮箱: xxxxxxxx@qq.com\n\n如何写简历 - 工作经历\n起始年月日  公司名 - 部门   职位名称(职级)\n\n如何写简历 - 项目经验\n公司 - 项目名 (开始时间 ~ 结束时间)\n描述: (简要提炼重点,让面试官快速了解**系统性质**与**规模**)\n技术栈: (主要描述**你涉及**到的技术栈, 让面试官快速知道**你会什么**)\n\n负责部分: (描述前端**团队规模**, 与你所**负责**的部分, 让面试官知道**你做了什么**, **占比**多重)\n\n如何写简历 - 其他信息\n1. 获奖情况\n2. 个人项目\n3. 参与过的开源项目\n4. 发表过的文章\n5. 参与过的业界分享\n\n简历全貌\n个人信息: 姓名, 手机, 邮箱, 学历(年份)\n工作经历: 起始年份, 年份, 职位(职级)\n项目经验: 公司, 项目名, 周期, 描述, 技术栈, 负责部分\n其他信息: 奖项, 个人项目, 文章, 分享等等\n\n### 找职位 - 铺开各渠道\n情景分析 - 投递简历 石沉大海\n1. 学校原因: 双非一本不被待见\n2. 培训机构原因: 被歧视\n3. 外包经历原因: 被歧视\n4. 技术栈原因: vue落后了 要学 react\n5. 工作年限原因: 都要3年以上\n\n消极归因：教育背景（95%），其他（亮点没突出、投递不对、经验不匹配、基础不扎实、沟通不恰当占比5%）\n理性归因：教育背景（45%），其他（亮点没突出、投递不对、经验不匹配、基础不扎实、沟通不恰当占比55%）\n\n**抹掉**刻板认知 **塑造**独立思维\n情景分析 - 时代大背景\n\n```mermaid\ngraph TD;\n  互联网经济下行-->公司员工;\n  互联网经济下行-->岗位;\n  岗位-->停招聘\n  停招聘-->岗位1/3\n  公司员工-->裁员-->毕业生\n  裁员-->被裁员工\n  裁员-->培训机构\n  毕业生-->求职程序员2/3\n  被裁员工-->求职程序员2/3\n  培训机构-->求职程序员2/3\n  岗位1/3-->岗位供不应求,物件上涨,门槛提升\n  求职程序员2/3-->岗位供不应求,物件上涨,门槛提升\n```\n\n情景分析 - 时代大背景\n| 报名资格      | 职级           |\n| -----------   | -----------   |\n| 硕士/博士     |  王者          |\n| 985/211本科   |  钻石          |\n| 本科及以上    |  黄金          |\n| 大专及以上    |  青铜          |\n\n10年职业规划\n认清自己**水平**，处于什么**阶段**，有什么职业**诉求**，对自己有清晰**定位**。\n例：\n| 诉求               | 目标职位                                           | 耗时    |\n| -----------       | -----------                                        | -----   |\n| 工作经验 + 项目经验 | 有学习机会，能接触到更多项目，2年后拿到18k以上的offer | 2       |\n| 18k 以上的offer    | 能独当一面，独立负责系统，三年后进入大厂              | 3       |\n| 进入一线大厂        | 大厂，且进入较好业务，持续工作下去，晋升              | 5       |\n\n简历投递流程\n1. 选岗位\n2. 了解岗位信息\n3. 调整简历\n4. 复盘\n\n简历投递流程 - 选岗位\n1. 内推渠道\n2. 猎头渠道\n3. 企业官网\n4. 招聘APP\n\n简历投递流程 - 选岗位\n内推渠道\n特点：职场人脉（同学，校友，同事，朋友，前端社群，脉脉...）\n关键：内推到自己所在的团队，最好直接是团队Leader，否则和自己投递没区别。（很重要）\n优势：\n1. 面试前能深入了解团队技术栈，业务细节。\n2. 能更直接跟进面试情况。\n3. 有团队成员背书，遇到横向对比时，增加成功率。\n\n简历投递流程 - 选岗位\n猎头渠道\n特点：中高端岗位。\n关键：猎头必须投递公司s级合作方，或长期与该公司合作（很重要）\n又是：\n1. 了解这家公司的招聘背景，岗位紧急程度，以往通过率等等，给到你指引。\n2. 会有更多这家公司的面试题库，能做更针对性的面试前准备。\n3. 面试成功，能协助你谈到一个较好的offer。\n4. 面试失败，能协调你到其他岗位，再走流程。\n\n简历投递流程 - 选岗位\n内推 vs 猎头\n内推：工作年限 **<5年**, P7以**下**, 找**你需要**的岗位\n猎头: 工作年限 **>5年**, P7以**上**, 找**需要你**的岗位\n\n简历投递流程- 选岗位\n企业招聘官网\n缺乏主动沟通环节,除非你特别优秀,否则**不太建议**直接投递\n\n简历投递流程 - 了解岗位学习\n**穷尽**办法**收集**岗位信息,包括但不限于: 业务, 技术栈, 紧急程度, 面试题, 面试官等等\n\n简历投递流程- 调整简历\n面向对象建简历\n```mermaid\ngraph TD;\n  简历(基类)-->简历A(子类)-->岗位A\n  简历(基类)-->简历B(子类)-->岗位B\n  简历(基类)-->简历C(子类)-->岗位C\n```\n\n简历投递流程 - 复盘\n追问 -> 分析 -> 改进\n\n简历 \n-> HR筛选入库(我们要求本科以上, 你不太合适;\n我们需要5年工作经验以上的, 你不太适合;\n我们要求需要有React开发经验的, 你不太适合;\n我们需要有985/211的,你不太适合) -> 入库 -> 面试官捞简历(用人部门还没有回应; 再等等还没反馈) \n-> 粗看简历(你工作地必须是XX吗?\n你对薪酬的要求必须是XX吗?\n你对岗位的要求必须是XX吗?)\n-> 细看简历(看了你的项目经历,和我们的岗位不太匹配;\n我们这边还是找有做编辑器经验的人,你不太匹配;\n我们希望曾经有做tob经验的同学,你不太匹配) -> 发起面试\n\n课程总结\n1. 塑造独立思维\n2. 明确职业规划\n3. 简历投递心得分享\n\n电话邀约面试\nHR(确认面试时间) -> 候选人 -> 信息收集 -> 准备面试看八股文,刷程序题 \n\n历史视觉 - 孙子兵法\n上兵伐谋(谋略) 其次伐交(外交) 其次伐兵(动武) 其下攻城(攻城)\n\n现代军事视觉\n航母战斗群(覆盖2000公里)\n歼20(覆盖范围?)\n\n投资视觉\n第一层(2年前 获取100%信息)\n第二层(1年前 获取80%信息)\n第三层(半年前 获取50%信息)\n...\n第38层(现在获取20%信息)\n\n自己经验\n我(收纳1、2、3、4、5班考试资料) -> 考试\n\n求职场景\n信息**收集**得更多, 具备领先别人的**条件**\n信息**分析**得更**准**, 具备领先别人的**能力**\n\n招聘本质\n找更强的 ×\n找更匹配的 √\n\n匹配案例\n岗位薪酬:15k ~ 20k\n培训班毕业同学 ×\n能力到达40k ~ 50k的同学 ×\n2 ~ 3年中厂工作经验同学\n\n**收集**岗位信息 **判断**岗位核心诉求 **调整**自己为岗位匹配者\n1. 沟通能力\n2. 分析判断能力\n\n环节分析 - 采集岗位信息\nHR\n  - 关系转变: 对立 -> 同盟\n  - 电话收集: 部门、小组、业务\n  - 微信收集: 发展史、团队规模、竞品、企业文化、遇到困难、面试官风格等等\n猎头\n  - 收集: 面试成功案例, 过往面试题, 面试官风格等等.\n朋友\n  - 收集: 团队氛围, Leader风格, 加班情况, 面试官风格等等\n\n环节分析 - 分析岗位核心诉求\n技术栈\n  - 判断: Vue / React ? Element-ui? node? 前后端如何协作\n什么端\n  - 判断: PC / 移动端 / 原生?各有什么注意事项?\n用户群体\n  - 判断: 人群特点, 人群与业务是否契合, 会有什么问题?\n团队组成\n  - 判断: 自己的核心程度,承担多大工作量?\n\n课程总结\n1. **信息差**的重要性\n2. 招聘的本质: 找到**更匹配的**人\n3. 面试前准备: **采集**信息 - **分析**诉求 - **调整**自己\n4. 培养能力: **沟通**能力、**分析判断**能力\n\n岗位核心诉求\n技术诉求\n- 需要你懂什么: Vue / React / Uniapp ? PC / 移动端 / 小程序 / 原生 ? nodejs / Java?\n能力诉求\n- 需要你做什么: 带团队? 项目负责人? 核心研发? 普通研发?\n业务(经验)诉求\n- 需要做过什么: toB? toC? 自媒体? 游戏? 图片处理? 性能优化? 中台建设?\n成本诉求\n- 需要多少成本: 8k? 10k? 15k? 20k? 30k? 40k? 55k? 70k?\n\n诉求: 需要用**A成本**, 请一个懂**B技术**, 有**C经验**, 具备**D能力**的人\n回答: 我就是懂**B技术**, 有**C经验**, 具备**D能力**, 能接受**A成本**的人\n\n面试前的准备\n1. 自我介绍\n2. 复习基础\n3. 针对性技术准备\n4. 针对性项目准备\n5. 业务建议\n\n自我介绍 - 社招\n正常换工作\n你好, 我XX年毕业于XX学校, 有XX年工作经验, 主要在XX公司工作, 技术栈主要是 **${B技术}**, 开发的项目主要是 **${C经验}**, 在过去团队中, 主要承担的任务是 **${D能力}**\n\n毕业后空窗期找工作\n你好, 我XX年毕业于XX学校, XX专业, 技术栈主要是 **${B技术}**, 过去一段时间, 主要个人开发为主, 开发过的项目主要是 **${C经验}**, 个人从0到1搭建XX项目, 具备 **${D能力}**\n\n培训机构毕业找工作\n你好, 我XX年毕业于XX学习, XX专业, 学习的主要是 **${B技术}**, 过程中参与开发过的项目主要是 **${C经验}**, 在培训团队中, 主要承担的任务是 **${D能力}**\n\n应届毕业生 / 实习生\n你好, 我XX年毕业于XX学校, XX专业, XX月份毕业, 我个人对前端有比较大的兴趣, 所以,处理好本专业课程以外, 还自学了前端, 参与了学校XX团队XX年, 用到的技术栈主要是 **${B技术}**, 开发的项目主要是**${C经验}**, 在过去团队中, 主要承担的任务是 **${D能力}**\n\n\n复习基础\n学习能力\n解决问题能力\n\n复习基础\n第一层: 数据结构 + 计算机网络 + 设计模式\n第二层: JavaScript + HTML + CSS\n第三层: 框架原理 + 工程化 + 前端运维\n第四层: nodejs + Mysql\n\n针对性技术准备\n突出**技术**匹配度\n\n针对性技术准备\n过往面试题目(信息来源: 猎头)\n覆盖: 扫一遍题目, 透彻理解, 且准备最佳答案\n延展: 以题目为圆心, 覆盖周边延展题目\n\n面试官风格(信息来源: 猎头, 朋友)\n喜欢问概念: 多复习八股文, 刷题, 背面试题\n喜欢问实践: 多回顾复盘曾经做过的项目\n\n技术栈(信息来源: JD, 朋友)\n框架/工具: 了解对应原理, 回顾实践中的问题, 优化过的经验(知乎, 掘金)\n\n针对性项目准备\n选出与岗位诉求匹配的项目\n项目描述: 通过无差别录制用户行为, 以便有问题时能快速还原问题现场, 解决Tob私有化部署客户问题难定位问题\n个人负责: 系统负责人, 一人独立完成\n项目难点: 前端无差别录制会导致前端卡顿\n业界方案: 减少记录数据、用indexDB存储、数据合并、web-worker\n如何解决: 卡顿本质是计算线程阻塞了渲染线程, 通过webworker + indexDB的方案, web-worker完成计算, 让渲染线程保持通畅\n解决效果: 从卡顿到近乎无感知\n\n业务建议\n对业务的了解\n对行业竞品的了解\n对该行业的经验\n业务可能遇到的问题\n对该业务的建议\n\n课程总结\n懂**B技术**, 有**C经验**, 具备**D能力**, 能接受**A成本**的人\n自我介绍\n前端4层学习体系\n针对性的技术/项目/业务准备\n\n一面 - 突出技术根基\n\n面试要素\n本质认知\n  - 和面试官PK ×\n  - 获得HR认可 ×\n  - 表现得比其他面试者更优秀 √\n\n心态\n  - 去考试 ×\n  - 去交流 √\n\n姿态\n  - 被盘问 ×\n  - 技术交流 √\n  - 知识分享 √√\n\n面试官\n  细节 ----> 宏观\n\n面试技巧\n话术: **八股文**(依赖知识图谱) + **自己看法** + **自己经验**(依赖信息收集)\n引导: 引向自己**熟悉**的领域(依赖简历制作)\n\n场景与话术\n懂原理 + 有经验: 八股文 + 自己见解 + 自己经验\n懂原理 + 没经验: 八股文 + 行业方案\n不懂原理 + 有经验: 直接分享经验\n不懂原理 + 没经验: 找相似 / 直接告知不会, 记下, 整理到知识图谱\n\n编码题目\n懂: 编码 + 思路分享\n不懂: 咨询边界值 + 思路分享 / 直接告知不懂\n\n面试官目的\n**挖掘**候选的技术能力, 判断与岗位**匹配度**\n\n一面回顾\n一面面试官: 一线研发\n二面面试官: 团队leader\n\n二面 - 诉说领域经验\n核心考察\n靠擦点1: 过往的业务**经验**和我们是否**匹配**?\n电商管理系统: 订单管理, 仓储管理, 营销管理, 秒杀抢购, 物流跟踪等等\n移动端页面: 多机型适配, 加载性能, 体验新能, 虚拟列表, 滚动防抖, 预加载, 懒加载等等\nTOB中后台系统: 较强的抽象能力, 应对不同客户定制化需求, 问题跟进, 工单跟进等等\n\n考察点2: 业务能力(做事能力)\n根据已有的**知识体系**, 结合**业务**, 是否有形成自己成熟的做事**方法论**\n而该方法论是否全面, 包含考虑到项目的稳定性, 安全性,可拓展性, 可维护性, 持续集成成本等等\n\n我们要做什么\n1. 告诉面试官, 我做了什么**事情**, 这个事情属于什么**业务类型**\n\n做事思维方式\n**遇到**什么需求 / 问题 + **业界**解决方案 + **我的**解决方案 + **落地** 效果\n\n例:挑战点 -- **灵活高效**支撑多触达场景\n问题: 客户间有**不同**的触达场景, 且**定制化**程度高, 难以**灵活**应对, 一对一开发影响交付**效率**\n挑战点: 如何**灵活、高效**支撑多触达场景,降低成本, 提高效率\n分析思考: 客户需求虽各异, 但万变不离\"**人-货-场**\" (把特定货品, 在特定场景, 推送给特定人群)\n业界方案: \n方案A: **大而全**的触达系统, **标准化**流程(行业参考: 神策, 易观)\n方案A问题: 1. 不适合**多客户**交付场景; \n2. 交付时**冗余**过多无用能力; \n3. **定制化**拓展能力弱, 往往牺牲客户需求; \n4. 跟随迭代, **熵增**明显\n\n方案B: **多个**子系统配合, **灵活**配置各个运营场景\n方案B问题:\n1. 不适合**外部客户私有化**交付场景\n2. 通过建站能力不适用于**领域性较强**的场景\n3. 过分灵活, 搭建复杂, 并无**实质性提效**\n4. 未能**体系化**解决触达领域问题\n\n折中解决方案\n粒度: 算子服务 + AOP: 领域建模 + 面向对象建站\n\n挑战点 -- **灵活高效**支撑多触达场景: 算子服务\n算子服务: 描述\"人货场\"的基本单元, 组成系统的最小粒度, 一种**可复用**的**系统能力**\n\n触达领域\"人货场\"基本单元\n算子服务结构\n前端组件: page, 样式, 交互, 网络请求\n服务逻辑: 写库, 读库, 加工, 第三方依赖\n离线逻辑: 召回, 过滤, 排序, 离线计算\nDB存储: 数据结构, 存储场景\n钩子: 页面钩子, 组件钩子, 后端钩子\n\n前端组件: 决定算子前端样式与交互, 网络请求\n服务逻辑: 决定算子的存储逻辑, 依赖方\n计算逻辑: 决定算子离线行为, 计算逻辑\nDB存储: 决定算子存储结构, 存储场景\n钩子: 算子能重载, 想通过**定制化**能力保证\n\n挑战点 -- **灵活高效**支撑多触达场景: 面向切片领域建模(AOP)\n领域模型: 由算子拼装而成, 一种**可复用**的**通用业务能力**, 可重复**生成**多个营运系统\n\n挑战点 -- **灵活高效**支撑多触达场景: 面向对象建站, 平衡通用与定制化\n营运系统(**交付**客户)\n派生自领域模型, 针对客户需求定制化的营运系统, 交付客户的最终产品\n\n通用能力**复用**\n通过领域模型, 保证领域通用能力可复用, 节省重复开发人力成本\n\n模型**定制化拓展**\n依据面向对象\"继承\" \"重载\"等设计思想, 通过算子的拓展, 实现领域模型拓展, 灵活高效支持多客户场景\n\n关键要素\n封装: 一个类是多个算子的集合\n继承: 子类拥有父类所包含算子, 且能动态添加新算子\n多态: 算子可重载(钩子能力)\n\n案例:消息推送模型->实例化(领域模型支持**插拔式**组装算子, 算子支持各种**钩子**, 有效应对客户各种**定制化**需求)\n\n消息推送 - 领域模型(领域模型沉淀通用业务能力, 保证高**复用性**, 大幅降低重复开发成本)\n包含: 消息内容, 触发点, 业务条件, 人群定向\n\n挑战点 -- **灵活高效**支撑多触达场景: 最终解决方案\n\n算子->算子服务->算子服务库->算子库->领域模型->面向对象建站\n\n挑战点 -- **灵活高效**支撑多触达场景: 落地效果\n提效情况(**高效**)\n1. 开发系统=>开发算子 + 领域**建模**\n2. 一个算子的平均开发时间为5天/人\n3. 算子库可多人持续集成, 人力成本**边际效应**明显\n\n交付情况(**灵活**)\n1. 1年, 孵化领域模型**8**个, 营运系统**30+**\n2. 插入客户**24**个, 其中内部客户**13**个, 外部客户**11**个\n\n移动端列表页\n挑战点: 当用户往下滚动加载数据, 数据会越来越多, 页面会卡顿\n业界方案: 通过预加载, 懒加载的方式优化列表, 但是没很好解决卡顿问题\n我的方案: 当数据量超过阈值的时候, 切换为虚拟列表. 譬如加载超过1000条数据的时候, 无感知切换到虚拟列表, 始终只加载前后100条数据\n落地效果: 前端列表无限加载都无感知\n\n后台管理系统\n挑战点: 都是用UI框架搭建模块, 研发都在做CRUD体力活, 很浪费研发资源\n业界方案: 通过低代码平台处理, 但是你们人力有限, 项目也不大, 要构建一个低代码平台成本比较高\n我的方案: 分析得出, 每个模块其实基本功能都很类似, 都是有搜索框, 列表, 修改增加弹框, 翻页. 我就通过沉淀出这类模板, 并且暴露各参数, 使得有重复功能模块上线的时候, 直接通过配置即可生成板块,\n大大地提升研发效率, 同时也不会浪费研发资源制作CRUD的体力活事情\n落地效果: 同类型模块只需配置即可, 开发一个模块的人力从3人/天, 降低到1人/天\n\n门户页面\n挑战点: 需要经常和后端对接口, 经常需要耗费时间等联调, 影响效率\n业界方案: 通过模拟数据, 或者开发中写死等等, 但是这样需要额外去整理mock数据, 而且当结构变动的时候很难保持同步, 没有可维护性\n我的方案: 通过构造一套data-mocker服务, 前后端之间的沟通就通过data-mocker完成, data-mocker相当于一个API工具, 双方在系统上协商好api, data-mocker就会充当一个媒介,\n前端开发完就可以请求data-mocker返回模拟数据, 后端先开发完, 就可以利用data-mocker发起请求\n落地效果: 前后端联调不再互相依赖, 都以data-mocker作为媒介, 有效的提升效率. 前后端研发不再会因为API调整而增加更多的额外沟通成本\n\n一个功能模块\n挑战点: 这个组件非常特殊, 产品总是对这个产品的需求进行高频调整\n业界方案: 为模块提供其多的开放性配置, 应多产品经理的诉求, 但这样会极大增加维护成本\n我的方案: 写好模块的模板, 同时模板中留出很多的slot插槽, 同时收拢一个组件库, 用 公用组件 + 插槽 + 模板 的方案, 解决高频变动模块\n落地效果: 就算频繁变动, 也不会额外增加我更多的工作量\n\n\n","slug":"简历","published":0,"date":"2024-03-16T13:49:09.874Z","updated":"2024-03-29T08:41:21.480Z","_id":"cltzslok90005sovcb4pmca18","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"课程目录\"><a href=\"#课程目录\" class=\"headerlink\" title=\"课程目录\"></a>课程目录</h2><ol>\n<li>简历 - 铺好你的门面</li>\n<li>找职位 - 铺开各渠道</li>\n<li>首次沟通 - 信息收集</li>\n<li>面试前 - 针对性准备</li>\n<li>一面 - 突出技术根基</li>\n<li>二面 - 述说领域经验</li>\n<li>三面 - 体现综合能力</li>\n<li>HR面 - 展现健康人格</li>\n<li>谈薪 - 自信不谦虚</li>\n<li>试用期 - 实现预期自我</li>\n</ol>\n<h3 id=\"简历-铺好你的门面\"><a href=\"#简历-铺好你的门面\" class=\"headerlink\" title=\"简历 - 铺好你的门面\"></a>简历 - 铺好你的门面</h3><p>什么是简历 - 先罗衣后敬人<br>什么是简历 - <strong>1</strong>个核心目标: 用<strong>最短时间</strong>让面试官在人群中<strong>发现</strong>你, 并想<strong>认识</strong>你!</p>\n<p>简历筛选流程 - 面试官 细简历<br>简历 &#x3D;&gt; HR筛选入库(卡底线: 学历&#x2F;学校&#x2F;工作年限) &#x3D;&gt; 入库 &#x3D;&gt; 面试官捞简历(找上线: 学历&#x2F;学校&#x2F;工作年限) &#x3D;&gt; 粗看简历(卡匹配度: 求职城市&#x2F;薪资意向&#x2F;技术领域)</p>\n<p>简历筛选流程 - 制作原则<br><strong>弱化</strong>底线 <strong>无</strong>干扰项 <strong>放大</strong>亮点</p>\n<ul>\n<li>底线: 公司的最低要求, 一般由 HR 去把控, 如: 学校, 学历, 等等 <strong>(弱化)</strong></li>\n<li>干扰项: 可能会让面试官离开的信息, 如: 期望薪酬, 意向工作地, 等等 <strong>删除</strong></li>\n<li>亮点: 能留住面试官的信息, 如: 大厂经历, 大型应用经验, 拿过的奖, 等等 <strong>放大</strong></li>\n</ul>\n<h3 id=\"如何写简历-个人信息\"><a href=\"#如何写简历-个人信息\" class=\"headerlink\" title=\"如何写简历 - 个人信息\"></a>如何写简历 - 个人信息</h3><p>姓名: XXX 学校:    学校: XX大学(2015 ~ 2019)<br>手机:135xxxxxx98  邮箱: <a href=\"mailto:&#120;&#x78;&#x78;&#x78;&#x78;&#x78;&#120;&#x78;&#x40;&#113;&#x71;&#x2e;&#x63;&#111;&#x6d;\">&#120;&#x78;&#x78;&#x78;&#x78;&#x78;&#120;&#x78;&#x40;&#113;&#x71;&#x2e;&#x63;&#111;&#x6d;</a></p>\n<p>如何写简历 - 工作经历<br>起始年月日  公司名 - 部门   职位名称(职级)</p>\n<p>如何写简历 - 项目经验<br>公司 - 项目名 (开始时间 ~ 结束时间)<br>描述: (简要提炼重点,让面试官快速了解<strong>系统性质</strong>与<strong>规模</strong>)<br>技术栈: (主要描述<strong>你涉及</strong>到的技术栈, 让面试官快速知道<strong>你会什么</strong>)</p>\n<p>负责部分: (描述前端<strong>团队规模</strong>, 与你所<strong>负责</strong>的部分, 让面试官知道<strong>你做了什么</strong>, <strong>占比</strong>多重)</p>\n<p>如何写简历 - 其他信息</p>\n<ol>\n<li>获奖情况</li>\n<li>个人项目</li>\n<li>参与过的开源项目</li>\n<li>发表过的文章</li>\n<li>参与过的业界分享</li>\n</ol>\n<p>简历全貌<br>个人信息: 姓名, 手机, 邮箱, 学历(年份)<br>工作经历: 起始年份, 年份, 职位(职级)<br>项目经验: 公司, 项目名, 周期, 描述, 技术栈, 负责部分<br>其他信息: 奖项, 个人项目, 文章, 分享等等</p>\n<h3 id=\"找职位-铺开各渠道\"><a href=\"#找职位-铺开各渠道\" class=\"headerlink\" title=\"找职位 - 铺开各渠道\"></a>找职位 - 铺开各渠道</h3><p>情景分析 - 投递简历 石沉大海</p>\n<ol>\n<li>学校原因: 双非一本不被待见</li>\n<li>培训机构原因: 被歧视</li>\n<li>外包经历原因: 被歧视</li>\n<li>技术栈原因: vue落后了 要学 react</li>\n<li>工作年限原因: 都要3年以上</li>\n</ol>\n<p>消极归因：教育背景（95%），其他（亮点没突出、投递不对、经验不匹配、基础不扎实、沟通不恰当占比5%）<br>理性归因：教育背景（45%），其他（亮点没突出、投递不对、经验不匹配、基础不扎实、沟通不恰当占比55%）</p>\n<p><strong>抹掉</strong>刻板认知 <strong>塑造</strong>独立思维<br>情景分析 - 时代大背景</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">  互联网经济下行--&gt;公司员工;</span><br><span class=\"line\">  互联网经济下行--&gt;岗位;</span><br><span class=\"line\">  岗位--&gt;停招聘</span><br><span class=\"line\">  停招聘--&gt;岗位1/3</span><br><span class=\"line\">  公司员工--&gt;裁员--&gt;毕业生</span><br><span class=\"line\">  裁员--&gt;被裁员工</span><br><span class=\"line\">  裁员--&gt;培训机构</span><br><span class=\"line\">  毕业生--&gt;求职程序员2/3</span><br><span class=\"line\">  被裁员工--&gt;求职程序员2/3</span><br><span class=\"line\">  培训机构--&gt;求职程序员2/3</span><br><span class=\"line\">  岗位1/3--&gt;岗位供不应求,物件上涨,门槛提升</span><br><span class=\"line\">  求职程序员2/3--&gt;岗位供不应求,物件上涨,门槛提升</span><br></pre></td></tr></table></figure>\n\n<p>情景分析 - 时代大背景</p>\n<table>\n<thead>\n<tr>\n<th>报名资格</th>\n<th>职级</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>硕士&#x2F;博士</td>\n<td>王者</td>\n</tr>\n<tr>\n<td>985&#x2F;211本科</td>\n<td>钻石</td>\n</tr>\n<tr>\n<td>本科及以上</td>\n<td>黄金</td>\n</tr>\n<tr>\n<td>大专及以上</td>\n<td>青铜</td>\n</tr>\n</tbody></table>\n<p>10年职业规划<br>认清自己<strong>水平</strong>，处于什么<strong>阶段</strong>，有什么职业<strong>诉求</strong>，对自己有清晰<strong>定位</strong>。<br>例：</p>\n<table>\n<thead>\n<tr>\n<th>诉求</th>\n<th>目标职位</th>\n<th>耗时</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>工作经验 + 项目经验</td>\n<td>有学习机会，能接触到更多项目，2年后拿到18k以上的offer</td>\n<td>2</td>\n</tr>\n<tr>\n<td>18k 以上的offer</td>\n<td>能独当一面，独立负责系统，三年后进入大厂</td>\n<td>3</td>\n</tr>\n<tr>\n<td>进入一线大厂</td>\n<td>大厂，且进入较好业务，持续工作下去，晋升</td>\n<td>5</td>\n</tr>\n</tbody></table>\n<p>简历投递流程</p>\n<ol>\n<li>选岗位</li>\n<li>了解岗位信息</li>\n<li>调整简历</li>\n<li>复盘</li>\n</ol>\n<p>简历投递流程 - 选岗位</p>\n<ol>\n<li>内推渠道</li>\n<li>猎头渠道</li>\n<li>企业官网</li>\n<li>招聘APP</li>\n</ol>\n<p>简历投递流程 - 选岗位<br>内推渠道<br>特点：职场人脉（同学，校友，同事，朋友，前端社群，脉脉…）<br>关键：内推到自己所在的团队，最好直接是团队Leader，否则和自己投递没区别。（很重要）<br>优势：</p>\n<ol>\n<li>面试前能深入了解团队技术栈，业务细节。</li>\n<li>能更直接跟进面试情况。</li>\n<li>有团队成员背书，遇到横向对比时，增加成功率。</li>\n</ol>\n<p>简历投递流程 - 选岗位<br>猎头渠道<br>特点：中高端岗位。<br>关键：猎头必须投递公司s级合作方，或长期与该公司合作（很重要）<br>又是：</p>\n<ol>\n<li>了解这家公司的招聘背景，岗位紧急程度，以往通过率等等，给到你指引。</li>\n<li>会有更多这家公司的面试题库，能做更针对性的面试前准备。</li>\n<li>面试成功，能协助你谈到一个较好的offer。</li>\n<li>面试失败，能协调你到其他岗位，再走流程。</li>\n</ol>\n<p>简历投递流程 - 选岗位<br>内推 vs 猎头<br>内推：工作年限 <strong>&lt;5年**, P7以**下**, 找**你需要**的岗位<br>猎头: 工作年限 **&gt;5年</strong>, P7以<strong>上</strong>, 找<strong>需要你</strong>的岗位</p>\n<p>简历投递流程- 选岗位<br>企业招聘官网<br>缺乏主动沟通环节,除非你特别优秀,否则<strong>不太建议</strong>直接投递</p>\n<p>简历投递流程 - 了解岗位学习<br><strong>穷尽</strong>办法<strong>收集</strong>岗位信息,包括但不限于: 业务, 技术栈, 紧急程度, 面试题, 面试官等等</p>\n<p>简历投递流程- 调整简历<br>面向对象建简历</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">  简历(基类)--&gt;简历A(子类)--&gt;岗位A</span><br><span class=\"line\">  简历(基类)--&gt;简历B(子类)--&gt;岗位B</span><br><span class=\"line\">  简历(基类)--&gt;简历C(子类)--&gt;岗位C</span><br></pre></td></tr></table></figure>\n\n<p>简历投递流程 - 复盘<br>追问 -&gt; 分析 -&gt; 改进</p>\n<p>简历<br>-&gt; HR筛选入库(我们要求本科以上, 你不太合适;<br>我们需要5年工作经验以上的, 你不太适合;<br>我们要求需要有React开发经验的, 你不太适合;<br>我们需要有985&#x2F;211的,你不太适合) -&gt; 入库 -&gt; 面试官捞简历(用人部门还没有回应; 再等等还没反馈)<br>-&gt; 粗看简历(你工作地必须是XX吗?<br>你对薪酬的要求必须是XX吗?<br>你对岗位的要求必须是XX吗?)<br>-&gt; 细看简历(看了你的项目经历,和我们的岗位不太匹配;<br>我们这边还是找有做编辑器经验的人,你不太匹配;<br>我们希望曾经有做tob经验的同学,你不太匹配) -&gt; 发起面试</p>\n<p>课程总结</p>\n<ol>\n<li>塑造独立思维</li>\n<li>明确职业规划</li>\n<li>简历投递心得分享</li>\n</ol>\n<p>电话邀约面试<br>HR(确认面试时间) -&gt; 候选人 -&gt; 信息收集 -&gt; 准备面试看八股文,刷程序题 </p>\n<p>历史视觉 - 孙子兵法<br>上兵伐谋(谋略) 其次伐交(外交) 其次伐兵(动武) 其下攻城(攻城)</p>\n<p>现代军事视觉<br>航母战斗群(覆盖2000公里)<br>歼20(覆盖范围?)</p>\n<p>投资视觉<br>第一层(2年前 获取100%信息)<br>第二层(1年前 获取80%信息)<br>第三层(半年前 获取50%信息)<br>…<br>第38层(现在获取20%信息)</p>\n<p>自己经验<br>我(收纳1、2、3、4、5班考试资料) -&gt; 考试</p>\n<p>求职场景<br>信息<strong>收集</strong>得更多, 具备领先别人的<strong>条件</strong><br>信息<strong>分析</strong>得更<strong>准</strong>, 具备领先别人的<strong>能力</strong></p>\n<p>招聘本质<br>找更强的 ×<br>找更匹配的 √</p>\n<p>匹配案例<br>岗位薪酬:15k ~ 20k<br>培训班毕业同学 ×<br>能力到达40k ~ 50k的同学 ×<br>2 ~ 3年中厂工作经验同学</p>\n<p><strong>收集</strong>岗位信息 <strong>判断</strong>岗位核心诉求 <strong>调整</strong>自己为岗位匹配者</p>\n<ol>\n<li>沟通能力</li>\n<li>分析判断能力</li>\n</ol>\n<p>环节分析 - 采集岗位信息<br>HR</p>\n<ul>\n<li>关系转变: 对立 -&gt; 同盟</li>\n<li>电话收集: 部门、小组、业务</li>\n<li>微信收集: 发展史、团队规模、竞品、企业文化、遇到困难、面试官风格等等<br>猎头</li>\n<li>收集: 面试成功案例, 过往面试题, 面试官风格等等.<br>朋友</li>\n<li>收集: 团队氛围, Leader风格, 加班情况, 面试官风格等等</li>\n</ul>\n<p>环节分析 - 分析岗位核心诉求<br>技术栈</p>\n<ul>\n<li>判断: Vue &#x2F; React ? Element-ui? node? 前后端如何协作<br>什么端</li>\n<li>判断: PC &#x2F; 移动端 &#x2F; 原生?各有什么注意事项?<br>用户群体</li>\n<li>判断: 人群特点, 人群与业务是否契合, 会有什么问题?<br>团队组成</li>\n<li>判断: 自己的核心程度,承担多大工作量?</li>\n</ul>\n<p>课程总结</p>\n<ol>\n<li><strong>信息差</strong>的重要性</li>\n<li>招聘的本质: 找到<strong>更匹配的</strong>人</li>\n<li>面试前准备: <strong>采集</strong>信息 - <strong>分析</strong>诉求 - <strong>调整</strong>自己</li>\n<li>培养能力: <strong>沟通</strong>能力、<strong>分析判断</strong>能力</li>\n</ol>\n<p>岗位核心诉求<br>技术诉求</p>\n<ul>\n<li>需要你懂什么: Vue &#x2F; React &#x2F; Uniapp ? PC &#x2F; 移动端 &#x2F; 小程序 &#x2F; 原生 ? nodejs &#x2F; Java?<br>能力诉求</li>\n<li>需要你做什么: 带团队? 项目负责人? 核心研发? 普通研发?<br>业务(经验)诉求</li>\n<li>需要做过什么: toB? toC? 自媒体? 游戏? 图片处理? 性能优化? 中台建设?<br>成本诉求</li>\n<li>需要多少成本: 8k? 10k? 15k? 20k? 30k? 40k? 55k? 70k?</li>\n</ul>\n<p>诉求: 需要用<strong>A成本</strong>, 请一个懂<strong>B技术</strong>, 有<strong>C经验</strong>, 具备<strong>D能力</strong>的人<br>回答: 我就是懂<strong>B技术</strong>, 有<strong>C经验</strong>, 具备<strong>D能力</strong>, 能接受<strong>A成本</strong>的人</p>\n<p>面试前的准备</p>\n<ol>\n<li>自我介绍</li>\n<li>复习基础</li>\n<li>针对性技术准备</li>\n<li>针对性项目准备</li>\n<li>业务建议</li>\n</ol>\n<p>自我介绍 - 社招<br>正常换工作<br>你好, 我XX年毕业于XX学校, 有XX年工作经验, 主要在XX公司工作, 技术栈主要是 <strong>${B技术}</strong>, 开发的项目主要是 <strong>${C经验}</strong>, 在过去团队中, 主要承担的任务是 <strong>${D能力}</strong></p>\n<p>毕业后空窗期找工作<br>你好, 我XX年毕业于XX学校, XX专业, 技术栈主要是 <strong>${B技术}</strong>, 过去一段时间, 主要个人开发为主, 开发过的项目主要是 <strong>${C经验}</strong>, 个人从0到1搭建XX项目, 具备 <strong>${D能力}</strong></p>\n<p>培训机构毕业找工作<br>你好, 我XX年毕业于XX学习, XX专业, 学习的主要是 <strong>${B技术}</strong>, 过程中参与开发过的项目主要是 <strong>${C经验}</strong>, 在培训团队中, 主要承担的任务是 <strong>${D能力}</strong></p>\n<p>应届毕业生 &#x2F; 实习生<br>你好, 我XX年毕业于XX学校, XX专业, XX月份毕业, 我个人对前端有比较大的兴趣, 所以,处理好本专业课程以外, 还自学了前端, 参与了学校XX团队XX年, 用到的技术栈主要是 <strong>${B技术}</strong>, 开发的项目主要是**${C经验}**, 在过去团队中, 主要承担的任务是 <strong>${D能力}</strong></p>\n<p>复习基础<br>学习能力<br>解决问题能力</p>\n<p>复习基础<br>第一层: 数据结构 + 计算机网络 + 设计模式<br>第二层: JavaScript + HTML + CSS<br>第三层: 框架原理 + 工程化 + 前端运维<br>第四层: nodejs + Mysql</p>\n<p>针对性技术准备<br>突出<strong>技术</strong>匹配度</p>\n<p>针对性技术准备<br>过往面试题目(信息来源: 猎头)<br>覆盖: 扫一遍题目, 透彻理解, 且准备最佳答案<br>延展: 以题目为圆心, 覆盖周边延展题目</p>\n<p>面试官风格(信息来源: 猎头, 朋友)<br>喜欢问概念: 多复习八股文, 刷题, 背面试题<br>喜欢问实践: 多回顾复盘曾经做过的项目</p>\n<p>技术栈(信息来源: JD, 朋友)<br>框架&#x2F;工具: 了解对应原理, 回顾实践中的问题, 优化过的经验(知乎, 掘金)</p>\n<p>针对性项目准备<br>选出与岗位诉求匹配的项目<br>项目描述: 通过无差别录制用户行为, 以便有问题时能快速还原问题现场, 解决Tob私有化部署客户问题难定位问题<br>个人负责: 系统负责人, 一人独立完成<br>项目难点: 前端无差别录制会导致前端卡顿<br>业界方案: 减少记录数据、用indexDB存储、数据合并、web-worker<br>如何解决: 卡顿本质是计算线程阻塞了渲染线程, 通过webworker + indexDB的方案, web-worker完成计算, 让渲染线程保持通畅<br>解决效果: 从卡顿到近乎无感知</p>\n<p>业务建议<br>对业务的了解<br>对行业竞品的了解<br>对该行业的经验<br>业务可能遇到的问题<br>对该业务的建议</p>\n<p>课程总结<br>懂<strong>B技术</strong>, 有<strong>C经验</strong>, 具备<strong>D能力</strong>, 能接受<strong>A成本</strong>的人<br>自我介绍<br>前端4层学习体系<br>针对性的技术&#x2F;项目&#x2F;业务准备</p>\n<p>一面 - 突出技术根基</p>\n<p>面试要素<br>本质认知</p>\n<ul>\n<li>和面试官PK ×</li>\n<li>获得HR认可 ×</li>\n<li>表现得比其他面试者更优秀 √</li>\n</ul>\n<p>心态</p>\n<ul>\n<li>去考试 ×</li>\n<li>去交流 √</li>\n</ul>\n<p>姿态</p>\n<ul>\n<li>被盘问 ×</li>\n<li>技术交流 √</li>\n<li>知识分享 √√</li>\n</ul>\n<p>面试官<br>  细节 —-&gt; 宏观</p>\n<p>面试技巧<br>话术: <strong>八股文</strong>(依赖知识图谱) + <strong>自己看法</strong> + <strong>自己经验</strong>(依赖信息收集)<br>引导: 引向自己<strong>熟悉</strong>的领域(依赖简历制作)</p>\n<p>场景与话术<br>懂原理 + 有经验: 八股文 + 自己见解 + 自己经验<br>懂原理 + 没经验: 八股文 + 行业方案<br>不懂原理 + 有经验: 直接分享经验<br>不懂原理 + 没经验: 找相似 &#x2F; 直接告知不会, 记下, 整理到知识图谱</p>\n<p>编码题目<br>懂: 编码 + 思路分享<br>不懂: 咨询边界值 + 思路分享 &#x2F; 直接告知不懂</p>\n<p>面试官目的<br><strong>挖掘</strong>候选的技术能力, 判断与岗位<strong>匹配度</strong></p>\n<p>一面回顾<br>一面面试官: 一线研发<br>二面面试官: 团队leader</p>\n<p>二面 - 诉说领域经验<br>核心考察<br>靠擦点1: 过往的业务<strong>经验</strong>和我们是否<strong>匹配</strong>?<br>电商管理系统: 订单管理, 仓储管理, 营销管理, 秒杀抢购, 物流跟踪等等<br>移动端页面: 多机型适配, 加载性能, 体验新能, 虚拟列表, 滚动防抖, 预加载, 懒加载等等<br>TOB中后台系统: 较强的抽象能力, 应对不同客户定制化需求, 问题跟进, 工单跟进等等</p>\n<p>考察点2: 业务能力(做事能力)<br>根据已有的<strong>知识体系</strong>, 结合<strong>业务</strong>, 是否有形成自己成熟的做事<strong>方法论</strong><br>而该方法论是否全面, 包含考虑到项目的稳定性, 安全性,可拓展性, 可维护性, 持续集成成本等等</p>\n<p>我们要做什么</p>\n<ol>\n<li>告诉面试官, 我做了什么<strong>事情</strong>, 这个事情属于什么<strong>业务类型</strong></li>\n</ol>\n<p>做事思维方式<br><strong>遇到</strong>什么需求 &#x2F; 问题 + <strong>业界</strong>解决方案 + <strong>我的</strong>解决方案 + <strong>落地</strong> 效果</p>\n<p>例:挑战点 – <strong>灵活高效</strong>支撑多触达场景<br>问题: 客户间有<strong>不同</strong>的触达场景, 且<strong>定制化</strong>程度高, 难以<strong>灵活</strong>应对, 一对一开发影响交付<strong>效率</strong><br>挑战点: 如何<strong>灵活、高效</strong>支撑多触达场景,降低成本, 提高效率<br>分析思考: 客户需求虽各异, 但万变不离”<strong>人-货-场</strong>“ (把特定货品, 在特定场景, 推送给特定人群)<br>业界方案:<br>方案A: <strong>大而全</strong>的触达系统, <strong>标准化</strong>流程(行业参考: 神策, 易观)<br>方案A问题: 1. 不适合<strong>多客户</strong>交付场景;<br>2. 交付时<strong>冗余</strong>过多无用能力;<br>3. <strong>定制化</strong>拓展能力弱, 往往牺牲客户需求;<br>4. 跟随迭代, <strong>熵增</strong>明显</p>\n<p>方案B: <strong>多个</strong>子系统配合, <strong>灵活</strong>配置各个运营场景<br>方案B问题:</p>\n<ol>\n<li>不适合<strong>外部客户私有化</strong>交付场景</li>\n<li>通过建站能力不适用于<strong>领域性较强</strong>的场景</li>\n<li>过分灵活, 搭建复杂, 并无<strong>实质性提效</strong></li>\n<li>未能<strong>体系化</strong>解决触达领域问题</li>\n</ol>\n<p>折中解决方案<br>粒度: 算子服务 + AOP: 领域建模 + 面向对象建站</p>\n<p>挑战点 – <strong>灵活高效</strong>支撑多触达场景: 算子服务<br>算子服务: 描述”人货场”的基本单元, 组成系统的最小粒度, 一种<strong>可复用</strong>的<strong>系统能力</strong></p>\n<p>触达领域”人货场”基本单元<br>算子服务结构<br>前端组件: page, 样式, 交互, 网络请求<br>服务逻辑: 写库, 读库, 加工, 第三方依赖<br>离线逻辑: 召回, 过滤, 排序, 离线计算<br>DB存储: 数据结构, 存储场景<br>钩子: 页面钩子, 组件钩子, 后端钩子</p>\n<p>前端组件: 决定算子前端样式与交互, 网络请求<br>服务逻辑: 决定算子的存储逻辑, 依赖方<br>计算逻辑: 决定算子离线行为, 计算逻辑<br>DB存储: 决定算子存储结构, 存储场景<br>钩子: 算子能重载, 想通过<strong>定制化</strong>能力保证</p>\n<p>挑战点 – <strong>灵活高效</strong>支撑多触达场景: 面向切片领域建模(AOP)<br>领域模型: 由算子拼装而成, 一种<strong>可复用</strong>的<strong>通用业务能力</strong>, 可重复<strong>生成</strong>多个营运系统</p>\n<p>挑战点 – <strong>灵活高效</strong>支撑多触达场景: 面向对象建站, 平衡通用与定制化<br>营运系统(<strong>交付</strong>客户)<br>派生自领域模型, 针对客户需求定制化的营运系统, 交付客户的最终产品</p>\n<p>通用能力<strong>复用</strong><br>通过领域模型, 保证领域通用能力可复用, 节省重复开发人力成本</p>\n<p>模型<strong>定制化拓展</strong><br>依据面向对象”继承” “重载”等设计思想, 通过算子的拓展, 实现领域模型拓展, 灵活高效支持多客户场景</p>\n<p>关键要素<br>封装: 一个类是多个算子的集合<br>继承: 子类拥有父类所包含算子, 且能动态添加新算子<br>多态: 算子可重载(钩子能力)</p>\n<p>案例:消息推送模型-&gt;实例化(领域模型支持<strong>插拔式</strong>组装算子, 算子支持各种<strong>钩子</strong>, 有效应对客户各种<strong>定制化</strong>需求)</p>\n<p>消息推送 - 领域模型(领域模型沉淀通用业务能力, 保证高<strong>复用性</strong>, 大幅降低重复开发成本)<br>包含: 消息内容, 触发点, 业务条件, 人群定向</p>\n<p>挑战点 – <strong>灵活高效</strong>支撑多触达场景: 最终解决方案</p>\n<p>算子-&gt;算子服务-&gt;算子服务库-&gt;算子库-&gt;领域模型-&gt;面向对象建站</p>\n<p>挑战点 – <strong>灵活高效</strong>支撑多触达场景: 落地效果<br>提效情况(<strong>高效</strong>)</p>\n<ol>\n<li>开发系统&#x3D;&gt;开发算子 + 领域<strong>建模</strong></li>\n<li>一个算子的平均开发时间为5天&#x2F;人</li>\n<li>算子库可多人持续集成, 人力成本<strong>边际效应</strong>明显</li>\n</ol>\n<p>交付情况(<strong>灵活</strong>)</p>\n<ol>\n<li>1年, 孵化领域模型<strong>8</strong>个, 营运系统<strong>30+</strong></li>\n<li>插入客户<strong>24</strong>个, 其中内部客户<strong>13</strong>个, 外部客户<strong>11</strong>个</li>\n</ol>\n<p>移动端列表页<br>挑战点: 当用户往下滚动加载数据, 数据会越来越多, 页面会卡顿<br>业界方案: 通过预加载, 懒加载的方式优化列表, 但是没很好解决卡顿问题<br>我的方案: 当数据量超过阈值的时候, 切换为虚拟列表. 譬如加载超过1000条数据的时候, 无感知切换到虚拟列表, 始终只加载前后100条数据<br>落地效果: 前端列表无限加载都无感知</p>\n<p>后台管理系统<br>挑战点: 都是用UI框架搭建模块, 研发都在做CRUD体力活, 很浪费研发资源<br>业界方案: 通过低代码平台处理, 但是你们人力有限, 项目也不大, 要构建一个低代码平台成本比较高<br>我的方案: 分析得出, 每个模块其实基本功能都很类似, 都是有搜索框, 列表, 修改增加弹框, 翻页. 我就通过沉淀出这类模板, 并且暴露各参数, 使得有重复功能模块上线的时候, 直接通过配置即可生成板块,<br>大大地提升研发效率, 同时也不会浪费研发资源制作CRUD的体力活事情<br>落地效果: 同类型模块只需配置即可, 开发一个模块的人力从3人&#x2F;天, 降低到1人&#x2F;天</p>\n<p>门户页面<br>挑战点: 需要经常和后端对接口, 经常需要耗费时间等联调, 影响效率<br>业界方案: 通过模拟数据, 或者开发中写死等等, 但是这样需要额外去整理mock数据, 而且当结构变动的时候很难保持同步, 没有可维护性<br>我的方案: 通过构造一套data-mocker服务, 前后端之间的沟通就通过data-mocker完成, data-mocker相当于一个API工具, 双方在系统上协商好api, data-mocker就会充当一个媒介,<br>前端开发完就可以请求data-mocker返回模拟数据, 后端先开发完, 就可以利用data-mocker发起请求<br>落地效果: 前后端联调不再互相依赖, 都以data-mocker作为媒介, 有效的提升效率. 前后端研发不再会因为API调整而增加更多的额外沟通成本</p>\n<p>一个功能模块<br>挑战点: 这个组件非常特殊, 产品总是对这个产品的需求进行高频调整<br>业界方案: 为模块提供其多的开放性配置, 应多产品经理的诉求, 但这样会极大增加维护成本<br>我的方案: 写好模块的模板, 同时模板中留出很多的slot插槽, 同时收拢一个组件库, 用 公用组件 + 插槽 + 模板 的方案, 解决高频变动模块<br>落地效果: 就算频繁变动, 也不会额外增加我更多的工作量</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#4ebde9","excerpt":"","more":"<h2 id=\"课程目录\"><a href=\"#课程目录\" class=\"headerlink\" title=\"课程目录\"></a>课程目录</h2><ol>\n<li>简历 - 铺好你的门面</li>\n<li>找职位 - 铺开各渠道</li>\n<li>首次沟通 - 信息收集</li>\n<li>面试前 - 针对性准备</li>\n<li>一面 - 突出技术根基</li>\n<li>二面 - 述说领域经验</li>\n<li>三面 - 体现综合能力</li>\n<li>HR面 - 展现健康人格</li>\n<li>谈薪 - 自信不谦虚</li>\n<li>试用期 - 实现预期自我</li>\n</ol>\n<h3 id=\"简历-铺好你的门面\"><a href=\"#简历-铺好你的门面\" class=\"headerlink\" title=\"简历 - 铺好你的门面\"></a>简历 - 铺好你的门面</h3><p>什么是简历 - 先罗衣后敬人<br>什么是简历 - <strong>1</strong>个核心目标: 用<strong>最短时间</strong>让面试官在人群中<strong>发现</strong>你, 并想<strong>认识</strong>你!</p>\n<p>简历筛选流程 - 面试官 细简历<br>简历 &#x3D;&gt; HR筛选入库(卡底线: 学历&#x2F;学校&#x2F;工作年限) &#x3D;&gt; 入库 &#x3D;&gt; 面试官捞简历(找上线: 学历&#x2F;学校&#x2F;工作年限) &#x3D;&gt; 粗看简历(卡匹配度: 求职城市&#x2F;薪资意向&#x2F;技术领域)</p>\n<p>简历筛选流程 - 制作原则<br><strong>弱化</strong>底线 <strong>无</strong>干扰项 <strong>放大</strong>亮点</p>\n<ul>\n<li>底线: 公司的最低要求, 一般由 HR 去把控, 如: 学校, 学历, 等等 <strong>(弱化)</strong></li>\n<li>干扰项: 可能会让面试官离开的信息, 如: 期望薪酬, 意向工作地, 等等 <strong>删除</strong></li>\n<li>亮点: 能留住面试官的信息, 如: 大厂经历, 大型应用经验, 拿过的奖, 等等 <strong>放大</strong></li>\n</ul>\n<h3 id=\"如何写简历-个人信息\"><a href=\"#如何写简历-个人信息\" class=\"headerlink\" title=\"如何写简历 - 个人信息\"></a>如何写简历 - 个人信息</h3><p>姓名: XXX 学校:    学校: XX大学(2015 ~ 2019)<br>手机:135xxxxxx98  邮箱: <a href=\"mailto:&#120;&#x78;&#x78;&#x78;&#x78;&#x78;&#120;&#x78;&#x40;&#113;&#x71;&#x2e;&#x63;&#111;&#x6d;\">&#120;&#x78;&#x78;&#x78;&#x78;&#x78;&#120;&#x78;&#x40;&#113;&#x71;&#x2e;&#x63;&#111;&#x6d;</a></p>\n<p>如何写简历 - 工作经历<br>起始年月日  公司名 - 部门   职位名称(职级)</p>\n<p>如何写简历 - 项目经验<br>公司 - 项目名 (开始时间 ~ 结束时间)<br>描述: (简要提炼重点,让面试官快速了解<strong>系统性质</strong>与<strong>规模</strong>)<br>技术栈: (主要描述<strong>你涉及</strong>到的技术栈, 让面试官快速知道<strong>你会什么</strong>)</p>\n<p>负责部分: (描述前端<strong>团队规模</strong>, 与你所<strong>负责</strong>的部分, 让面试官知道<strong>你做了什么</strong>, <strong>占比</strong>多重)</p>\n<p>如何写简历 - 其他信息</p>\n<ol>\n<li>获奖情况</li>\n<li>个人项目</li>\n<li>参与过的开源项目</li>\n<li>发表过的文章</li>\n<li>参与过的业界分享</li>\n</ol>\n<p>简历全貌<br>个人信息: 姓名, 手机, 邮箱, 学历(年份)<br>工作经历: 起始年份, 年份, 职位(职级)<br>项目经验: 公司, 项目名, 周期, 描述, 技术栈, 负责部分<br>其他信息: 奖项, 个人项目, 文章, 分享等等</p>\n<h3 id=\"找职位-铺开各渠道\"><a href=\"#找职位-铺开各渠道\" class=\"headerlink\" title=\"找职位 - 铺开各渠道\"></a>找职位 - 铺开各渠道</h3><p>情景分析 - 投递简历 石沉大海</p>\n<ol>\n<li>学校原因: 双非一本不被待见</li>\n<li>培训机构原因: 被歧视</li>\n<li>外包经历原因: 被歧视</li>\n<li>技术栈原因: vue落后了 要学 react</li>\n<li>工作年限原因: 都要3年以上</li>\n</ol>\n<p>消极归因：教育背景（95%），其他（亮点没突出、投递不对、经验不匹配、基础不扎实、沟通不恰当占比5%）<br>理性归因：教育背景（45%），其他（亮点没突出、投递不对、经验不匹配、基础不扎实、沟通不恰当占比55%）</p>\n<p><strong>抹掉</strong>刻板认知 <strong>塑造</strong>独立思维<br>情景分析 - 时代大背景</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">  互联网经济下行--&gt;公司员工;</span><br><span class=\"line\">  互联网经济下行--&gt;岗位;</span><br><span class=\"line\">  岗位--&gt;停招聘</span><br><span class=\"line\">  停招聘--&gt;岗位1/3</span><br><span class=\"line\">  公司员工--&gt;裁员--&gt;毕业生</span><br><span class=\"line\">  裁员--&gt;被裁员工</span><br><span class=\"line\">  裁员--&gt;培训机构</span><br><span class=\"line\">  毕业生--&gt;求职程序员2/3</span><br><span class=\"line\">  被裁员工--&gt;求职程序员2/3</span><br><span class=\"line\">  培训机构--&gt;求职程序员2/3</span><br><span class=\"line\">  岗位1/3--&gt;岗位供不应求,物件上涨,门槛提升</span><br><span class=\"line\">  求职程序员2/3--&gt;岗位供不应求,物件上涨,门槛提升</span><br></pre></td></tr></table></figure>\n\n<p>情景分析 - 时代大背景</p>\n<table>\n<thead>\n<tr>\n<th>报名资格</th>\n<th>职级</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>硕士&#x2F;博士</td>\n<td>王者</td>\n</tr>\n<tr>\n<td>985&#x2F;211本科</td>\n<td>钻石</td>\n</tr>\n<tr>\n<td>本科及以上</td>\n<td>黄金</td>\n</tr>\n<tr>\n<td>大专及以上</td>\n<td>青铜</td>\n</tr>\n</tbody></table>\n<p>10年职业规划<br>认清自己<strong>水平</strong>，处于什么<strong>阶段</strong>，有什么职业<strong>诉求</strong>，对自己有清晰<strong>定位</strong>。<br>例：</p>\n<table>\n<thead>\n<tr>\n<th>诉求</th>\n<th>目标职位</th>\n<th>耗时</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>工作经验 + 项目经验</td>\n<td>有学习机会，能接触到更多项目，2年后拿到18k以上的offer</td>\n<td>2</td>\n</tr>\n<tr>\n<td>18k 以上的offer</td>\n<td>能独当一面，独立负责系统，三年后进入大厂</td>\n<td>3</td>\n</tr>\n<tr>\n<td>进入一线大厂</td>\n<td>大厂，且进入较好业务，持续工作下去，晋升</td>\n<td>5</td>\n</tr>\n</tbody></table>\n<p>简历投递流程</p>\n<ol>\n<li>选岗位</li>\n<li>了解岗位信息</li>\n<li>调整简历</li>\n<li>复盘</li>\n</ol>\n<p>简历投递流程 - 选岗位</p>\n<ol>\n<li>内推渠道</li>\n<li>猎头渠道</li>\n<li>企业官网</li>\n<li>招聘APP</li>\n</ol>\n<p>简历投递流程 - 选岗位<br>内推渠道<br>特点：职场人脉（同学，校友，同事，朋友，前端社群，脉脉…）<br>关键：内推到自己所在的团队，最好直接是团队Leader，否则和自己投递没区别。（很重要）<br>优势：</p>\n<ol>\n<li>面试前能深入了解团队技术栈，业务细节。</li>\n<li>能更直接跟进面试情况。</li>\n<li>有团队成员背书，遇到横向对比时，增加成功率。</li>\n</ol>\n<p>简历投递流程 - 选岗位<br>猎头渠道<br>特点：中高端岗位。<br>关键：猎头必须投递公司s级合作方，或长期与该公司合作（很重要）<br>又是：</p>\n<ol>\n<li>了解这家公司的招聘背景，岗位紧急程度，以往通过率等等，给到你指引。</li>\n<li>会有更多这家公司的面试题库，能做更针对性的面试前准备。</li>\n<li>面试成功，能协助你谈到一个较好的offer。</li>\n<li>面试失败，能协调你到其他岗位，再走流程。</li>\n</ol>\n<p>简历投递流程 - 选岗位<br>内推 vs 猎头<br>内推：工作年限 <strong>&lt;5年**, P7以**下**, 找**你需要**的岗位<br>猎头: 工作年限 **&gt;5年</strong>, P7以<strong>上</strong>, 找<strong>需要你</strong>的岗位</p>\n<p>简历投递流程- 选岗位<br>企业招聘官网<br>缺乏主动沟通环节,除非你特别优秀,否则<strong>不太建议</strong>直接投递</p>\n<p>简历投递流程 - 了解岗位学习<br><strong>穷尽</strong>办法<strong>收集</strong>岗位信息,包括但不限于: 业务, 技术栈, 紧急程度, 面试题, 面试官等等</p>\n<p>简历投递流程- 调整简历<br>面向对象建简历</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">  简历(基类)--&gt;简历A(子类)--&gt;岗位A</span><br><span class=\"line\">  简历(基类)--&gt;简历B(子类)--&gt;岗位B</span><br><span class=\"line\">  简历(基类)--&gt;简历C(子类)--&gt;岗位C</span><br></pre></td></tr></table></figure>\n\n<p>简历投递流程 - 复盘<br>追问 -&gt; 分析 -&gt; 改进</p>\n<p>简历<br>-&gt; HR筛选入库(我们要求本科以上, 你不太合适;<br>我们需要5年工作经验以上的, 你不太适合;<br>我们要求需要有React开发经验的, 你不太适合;<br>我们需要有985&#x2F;211的,你不太适合) -&gt; 入库 -&gt; 面试官捞简历(用人部门还没有回应; 再等等还没反馈)<br>-&gt; 粗看简历(你工作地必须是XX吗?<br>你对薪酬的要求必须是XX吗?<br>你对岗位的要求必须是XX吗?)<br>-&gt; 细看简历(看了你的项目经历,和我们的岗位不太匹配;<br>我们这边还是找有做编辑器经验的人,你不太匹配;<br>我们希望曾经有做tob经验的同学,你不太匹配) -&gt; 发起面试</p>\n<p>课程总结</p>\n<ol>\n<li>塑造独立思维</li>\n<li>明确职业规划</li>\n<li>简历投递心得分享</li>\n</ol>\n<p>电话邀约面试<br>HR(确认面试时间) -&gt; 候选人 -&gt; 信息收集 -&gt; 准备面试看八股文,刷程序题 </p>\n<p>历史视觉 - 孙子兵法<br>上兵伐谋(谋略) 其次伐交(外交) 其次伐兵(动武) 其下攻城(攻城)</p>\n<p>现代军事视觉<br>航母战斗群(覆盖2000公里)<br>歼20(覆盖范围?)</p>\n<p>投资视觉<br>第一层(2年前 获取100%信息)<br>第二层(1年前 获取80%信息)<br>第三层(半年前 获取50%信息)<br>…<br>第38层(现在获取20%信息)</p>\n<p>自己经验<br>我(收纳1、2、3、4、5班考试资料) -&gt; 考试</p>\n<p>求职场景<br>信息<strong>收集</strong>得更多, 具备领先别人的<strong>条件</strong><br>信息<strong>分析</strong>得更<strong>准</strong>, 具备领先别人的<strong>能力</strong></p>\n<p>招聘本质<br>找更强的 ×<br>找更匹配的 √</p>\n<p>匹配案例<br>岗位薪酬:15k ~ 20k<br>培训班毕业同学 ×<br>能力到达40k ~ 50k的同学 ×<br>2 ~ 3年中厂工作经验同学</p>\n<p><strong>收集</strong>岗位信息 <strong>判断</strong>岗位核心诉求 <strong>调整</strong>自己为岗位匹配者</p>\n<ol>\n<li>沟通能力</li>\n<li>分析判断能力</li>\n</ol>\n<p>环节分析 - 采集岗位信息<br>HR</p>\n<ul>\n<li>关系转变: 对立 -&gt; 同盟</li>\n<li>电话收集: 部门、小组、业务</li>\n<li>微信收集: 发展史、团队规模、竞品、企业文化、遇到困难、面试官风格等等<br>猎头</li>\n<li>收集: 面试成功案例, 过往面试题, 面试官风格等等.<br>朋友</li>\n<li>收集: 团队氛围, Leader风格, 加班情况, 面试官风格等等</li>\n</ul>\n<p>环节分析 - 分析岗位核心诉求<br>技术栈</p>\n<ul>\n<li>判断: Vue &#x2F; React ? Element-ui? node? 前后端如何协作<br>什么端</li>\n<li>判断: PC &#x2F; 移动端 &#x2F; 原生?各有什么注意事项?<br>用户群体</li>\n<li>判断: 人群特点, 人群与业务是否契合, 会有什么问题?<br>团队组成</li>\n<li>判断: 自己的核心程度,承担多大工作量?</li>\n</ul>\n<p>课程总结</p>\n<ol>\n<li><strong>信息差</strong>的重要性</li>\n<li>招聘的本质: 找到<strong>更匹配的</strong>人</li>\n<li>面试前准备: <strong>采集</strong>信息 - <strong>分析</strong>诉求 - <strong>调整</strong>自己</li>\n<li>培养能力: <strong>沟通</strong>能力、<strong>分析判断</strong>能力</li>\n</ol>\n<p>岗位核心诉求<br>技术诉求</p>\n<ul>\n<li>需要你懂什么: Vue &#x2F; React &#x2F; Uniapp ? PC &#x2F; 移动端 &#x2F; 小程序 &#x2F; 原生 ? nodejs &#x2F; Java?<br>能力诉求</li>\n<li>需要你做什么: 带团队? 项目负责人? 核心研发? 普通研发?<br>业务(经验)诉求</li>\n<li>需要做过什么: toB? toC? 自媒体? 游戏? 图片处理? 性能优化? 中台建设?<br>成本诉求</li>\n<li>需要多少成本: 8k? 10k? 15k? 20k? 30k? 40k? 55k? 70k?</li>\n</ul>\n<p>诉求: 需要用<strong>A成本</strong>, 请一个懂<strong>B技术</strong>, 有<strong>C经验</strong>, 具备<strong>D能力</strong>的人<br>回答: 我就是懂<strong>B技术</strong>, 有<strong>C经验</strong>, 具备<strong>D能力</strong>, 能接受<strong>A成本</strong>的人</p>\n<p>面试前的准备</p>\n<ol>\n<li>自我介绍</li>\n<li>复习基础</li>\n<li>针对性技术准备</li>\n<li>针对性项目准备</li>\n<li>业务建议</li>\n</ol>\n<p>自我介绍 - 社招<br>正常换工作<br>你好, 我XX年毕业于XX学校, 有XX年工作经验, 主要在XX公司工作, 技术栈主要是 <strong>${B技术}</strong>, 开发的项目主要是 <strong>${C经验}</strong>, 在过去团队中, 主要承担的任务是 <strong>${D能力}</strong></p>\n<p>毕业后空窗期找工作<br>你好, 我XX年毕业于XX学校, XX专业, 技术栈主要是 <strong>${B技术}</strong>, 过去一段时间, 主要个人开发为主, 开发过的项目主要是 <strong>${C经验}</strong>, 个人从0到1搭建XX项目, 具备 <strong>${D能力}</strong></p>\n<p>培训机构毕业找工作<br>你好, 我XX年毕业于XX学习, XX专业, 学习的主要是 <strong>${B技术}</strong>, 过程中参与开发过的项目主要是 <strong>${C经验}</strong>, 在培训团队中, 主要承担的任务是 <strong>${D能力}</strong></p>\n<p>应届毕业生 &#x2F; 实习生<br>你好, 我XX年毕业于XX学校, XX专业, XX月份毕业, 我个人对前端有比较大的兴趣, 所以,处理好本专业课程以外, 还自学了前端, 参与了学校XX团队XX年, 用到的技术栈主要是 <strong>${B技术}</strong>, 开发的项目主要是**${C经验}**, 在过去团队中, 主要承担的任务是 <strong>${D能力}</strong></p>\n<p>复习基础<br>学习能力<br>解决问题能力</p>\n<p>复习基础<br>第一层: 数据结构 + 计算机网络 + 设计模式<br>第二层: JavaScript + HTML + CSS<br>第三层: 框架原理 + 工程化 + 前端运维<br>第四层: nodejs + Mysql</p>\n<p>针对性技术准备<br>突出<strong>技术</strong>匹配度</p>\n<p>针对性技术准备<br>过往面试题目(信息来源: 猎头)<br>覆盖: 扫一遍题目, 透彻理解, 且准备最佳答案<br>延展: 以题目为圆心, 覆盖周边延展题目</p>\n<p>面试官风格(信息来源: 猎头, 朋友)<br>喜欢问概念: 多复习八股文, 刷题, 背面试题<br>喜欢问实践: 多回顾复盘曾经做过的项目</p>\n<p>技术栈(信息来源: JD, 朋友)<br>框架&#x2F;工具: 了解对应原理, 回顾实践中的问题, 优化过的经验(知乎, 掘金)</p>\n<p>针对性项目准备<br>选出与岗位诉求匹配的项目<br>项目描述: 通过无差别录制用户行为, 以便有问题时能快速还原问题现场, 解决Tob私有化部署客户问题难定位问题<br>个人负责: 系统负责人, 一人独立完成<br>项目难点: 前端无差别录制会导致前端卡顿<br>业界方案: 减少记录数据、用indexDB存储、数据合并、web-worker<br>如何解决: 卡顿本质是计算线程阻塞了渲染线程, 通过webworker + indexDB的方案, web-worker完成计算, 让渲染线程保持通畅<br>解决效果: 从卡顿到近乎无感知</p>\n<p>业务建议<br>对业务的了解<br>对行业竞品的了解<br>对该行业的经验<br>业务可能遇到的问题<br>对该业务的建议</p>\n<p>课程总结<br>懂<strong>B技术</strong>, 有<strong>C经验</strong>, 具备<strong>D能力</strong>, 能接受<strong>A成本</strong>的人<br>自我介绍<br>前端4层学习体系<br>针对性的技术&#x2F;项目&#x2F;业务准备</p>\n<p>一面 - 突出技术根基</p>\n<p>面试要素<br>本质认知</p>\n<ul>\n<li>和面试官PK ×</li>\n<li>获得HR认可 ×</li>\n<li>表现得比其他面试者更优秀 √</li>\n</ul>\n<p>心态</p>\n<ul>\n<li>去考试 ×</li>\n<li>去交流 √</li>\n</ul>\n<p>姿态</p>\n<ul>\n<li>被盘问 ×</li>\n<li>技术交流 √</li>\n<li>知识分享 √√</li>\n</ul>\n<p>面试官<br>  细节 —-&gt; 宏观</p>\n<p>面试技巧<br>话术: <strong>八股文</strong>(依赖知识图谱) + <strong>自己看法</strong> + <strong>自己经验</strong>(依赖信息收集)<br>引导: 引向自己<strong>熟悉</strong>的领域(依赖简历制作)</p>\n<p>场景与话术<br>懂原理 + 有经验: 八股文 + 自己见解 + 自己经验<br>懂原理 + 没经验: 八股文 + 行业方案<br>不懂原理 + 有经验: 直接分享经验<br>不懂原理 + 没经验: 找相似 &#x2F; 直接告知不会, 记下, 整理到知识图谱</p>\n<p>编码题目<br>懂: 编码 + 思路分享<br>不懂: 咨询边界值 + 思路分享 &#x2F; 直接告知不懂</p>\n<p>面试官目的<br><strong>挖掘</strong>候选的技术能力, 判断与岗位<strong>匹配度</strong></p>\n<p>一面回顾<br>一面面试官: 一线研发<br>二面面试官: 团队leader</p>\n<p>二面 - 诉说领域经验<br>核心考察<br>靠擦点1: 过往的业务<strong>经验</strong>和我们是否<strong>匹配</strong>?<br>电商管理系统: 订单管理, 仓储管理, 营销管理, 秒杀抢购, 物流跟踪等等<br>移动端页面: 多机型适配, 加载性能, 体验新能, 虚拟列表, 滚动防抖, 预加载, 懒加载等等<br>TOB中后台系统: 较强的抽象能力, 应对不同客户定制化需求, 问题跟进, 工单跟进等等</p>\n<p>考察点2: 业务能力(做事能力)<br>根据已有的<strong>知识体系</strong>, 结合<strong>业务</strong>, 是否有形成自己成熟的做事<strong>方法论</strong><br>而该方法论是否全面, 包含考虑到项目的稳定性, 安全性,可拓展性, 可维护性, 持续集成成本等等</p>\n<p>我们要做什么</p>\n<ol>\n<li>告诉面试官, 我做了什么<strong>事情</strong>, 这个事情属于什么<strong>业务类型</strong></li>\n</ol>\n<p>做事思维方式<br><strong>遇到</strong>什么需求 &#x2F; 问题 + <strong>业界</strong>解决方案 + <strong>我的</strong>解决方案 + <strong>落地</strong> 效果</p>\n<p>例:挑战点 – <strong>灵活高效</strong>支撑多触达场景<br>问题: 客户间有<strong>不同</strong>的触达场景, 且<strong>定制化</strong>程度高, 难以<strong>灵活</strong>应对, 一对一开发影响交付<strong>效率</strong><br>挑战点: 如何<strong>灵活、高效</strong>支撑多触达场景,降低成本, 提高效率<br>分析思考: 客户需求虽各异, 但万变不离”<strong>人-货-场</strong>“ (把特定货品, 在特定场景, 推送给特定人群)<br>业界方案:<br>方案A: <strong>大而全</strong>的触达系统, <strong>标准化</strong>流程(行业参考: 神策, 易观)<br>方案A问题: 1. 不适合<strong>多客户</strong>交付场景;<br>2. 交付时<strong>冗余</strong>过多无用能力;<br>3. <strong>定制化</strong>拓展能力弱, 往往牺牲客户需求;<br>4. 跟随迭代, <strong>熵增</strong>明显</p>\n<p>方案B: <strong>多个</strong>子系统配合, <strong>灵活</strong>配置各个运营场景<br>方案B问题:</p>\n<ol>\n<li>不适合<strong>外部客户私有化</strong>交付场景</li>\n<li>通过建站能力不适用于<strong>领域性较强</strong>的场景</li>\n<li>过分灵活, 搭建复杂, 并无<strong>实质性提效</strong></li>\n<li>未能<strong>体系化</strong>解决触达领域问题</li>\n</ol>\n<p>折中解决方案<br>粒度: 算子服务 + AOP: 领域建模 + 面向对象建站</p>\n<p>挑战点 – <strong>灵活高效</strong>支撑多触达场景: 算子服务<br>算子服务: 描述”人货场”的基本单元, 组成系统的最小粒度, 一种<strong>可复用</strong>的<strong>系统能力</strong></p>\n<p>触达领域”人货场”基本单元<br>算子服务结构<br>前端组件: page, 样式, 交互, 网络请求<br>服务逻辑: 写库, 读库, 加工, 第三方依赖<br>离线逻辑: 召回, 过滤, 排序, 离线计算<br>DB存储: 数据结构, 存储场景<br>钩子: 页面钩子, 组件钩子, 后端钩子</p>\n<p>前端组件: 决定算子前端样式与交互, 网络请求<br>服务逻辑: 决定算子的存储逻辑, 依赖方<br>计算逻辑: 决定算子离线行为, 计算逻辑<br>DB存储: 决定算子存储结构, 存储场景<br>钩子: 算子能重载, 想通过<strong>定制化</strong>能力保证</p>\n<p>挑战点 – <strong>灵活高效</strong>支撑多触达场景: 面向切片领域建模(AOP)<br>领域模型: 由算子拼装而成, 一种<strong>可复用</strong>的<strong>通用业务能力</strong>, 可重复<strong>生成</strong>多个营运系统</p>\n<p>挑战点 – <strong>灵活高效</strong>支撑多触达场景: 面向对象建站, 平衡通用与定制化<br>营运系统(<strong>交付</strong>客户)<br>派生自领域模型, 针对客户需求定制化的营运系统, 交付客户的最终产品</p>\n<p>通用能力<strong>复用</strong><br>通过领域模型, 保证领域通用能力可复用, 节省重复开发人力成本</p>\n<p>模型<strong>定制化拓展</strong><br>依据面向对象”继承” “重载”等设计思想, 通过算子的拓展, 实现领域模型拓展, 灵活高效支持多客户场景</p>\n<p>关键要素<br>封装: 一个类是多个算子的集合<br>继承: 子类拥有父类所包含算子, 且能动态添加新算子<br>多态: 算子可重载(钩子能力)</p>\n<p>案例:消息推送模型-&gt;实例化(领域模型支持<strong>插拔式</strong>组装算子, 算子支持各种<strong>钩子</strong>, 有效应对客户各种<strong>定制化</strong>需求)</p>\n<p>消息推送 - 领域模型(领域模型沉淀通用业务能力, 保证高<strong>复用性</strong>, 大幅降低重复开发成本)<br>包含: 消息内容, 触发点, 业务条件, 人群定向</p>\n<p>挑战点 – <strong>灵活高效</strong>支撑多触达场景: 最终解决方案</p>\n<p>算子-&gt;算子服务-&gt;算子服务库-&gt;算子库-&gt;领域模型-&gt;面向对象建站</p>\n<p>挑战点 – <strong>灵活高效</strong>支撑多触达场景: 落地效果<br>提效情况(<strong>高效</strong>)</p>\n<ol>\n<li>开发系统&#x3D;&gt;开发算子 + 领域<strong>建模</strong></li>\n<li>一个算子的平均开发时间为5天&#x2F;人</li>\n<li>算子库可多人持续集成, 人力成本<strong>边际效应</strong>明显</li>\n</ol>\n<p>交付情况(<strong>灵活</strong>)</p>\n<ol>\n<li>1年, 孵化领域模型<strong>8</strong>个, 营运系统<strong>30+</strong></li>\n<li>插入客户<strong>24</strong>个, 其中内部客户<strong>13</strong>个, 外部客户<strong>11</strong>个</li>\n</ol>\n<p>移动端列表页<br>挑战点: 当用户往下滚动加载数据, 数据会越来越多, 页面会卡顿<br>业界方案: 通过预加载, 懒加载的方式优化列表, 但是没很好解决卡顿问题<br>我的方案: 当数据量超过阈值的时候, 切换为虚拟列表. 譬如加载超过1000条数据的时候, 无感知切换到虚拟列表, 始终只加载前后100条数据<br>落地效果: 前端列表无限加载都无感知</p>\n<p>后台管理系统<br>挑战点: 都是用UI框架搭建模块, 研发都在做CRUD体力活, 很浪费研发资源<br>业界方案: 通过低代码平台处理, 但是你们人力有限, 项目也不大, 要构建一个低代码平台成本比较高<br>我的方案: 分析得出, 每个模块其实基本功能都很类似, 都是有搜索框, 列表, 修改增加弹框, 翻页. 我就通过沉淀出这类模板, 并且暴露各参数, 使得有重复功能模块上线的时候, 直接通过配置即可生成板块,<br>大大地提升研发效率, 同时也不会浪费研发资源制作CRUD的体力活事情<br>落地效果: 同类型模块只需配置即可, 开发一个模块的人力从3人&#x2F;天, 降低到1人&#x2F;天</p>\n<p>门户页面<br>挑战点: 需要经常和后端对接口, 经常需要耗费时间等联调, 影响效率<br>业界方案: 通过模拟数据, 或者开发中写死等等, 但是这样需要额外去整理mock数据, 而且当结构变动的时候很难保持同步, 没有可维护性<br>我的方案: 通过构造一套data-mocker服务, 前后端之间的沟通就通过data-mocker完成, data-mocker相当于一个API工具, 双方在系统上协商好api, data-mocker就会充当一个媒介,<br>前端开发完就可以请求data-mocker返回模拟数据, 后端先开发完, 就可以利用data-mocker发起请求<br>落地效果: 前后端联调不再互相依赖, 都以data-mocker作为媒介, 有效的提升效率. 前后端研发不再会因为API调整而增加更多的额外沟通成本</p>\n<p>一个功能模块<br>挑战点: 这个组件非常特殊, 产品总是对这个产品的需求进行高频调整<br>业界方案: 为模块提供其多的开放性配置, 应多产品经理的诉求, 但这样会极大增加维护成本<br>我的方案: 写好模块的模板, 同时模板中留出很多的slot插槽, 同时收拢一个组件库, 用 公用组件 + 插槽 + 模板 的方案, 解决高频变动模块<br>落地效果: 就算频繁变动, 也不会额外增加我更多的工作量</p>\n"},{"title":"渲染器：组件是如何被渲染成DOM的？","_content":"\n<!-- \ncreateApp\n  ensureRender\n    createRenderer\n      baseCreateRenderer\n        createAppAPI\n\n\napp.mount\n  mount\n    createVNode: createVNodeWithArgsTransform\n      _createVNode\n        createBaseVNode\n    render\n      patch\n        processComponent\n          mountComponent\n            setupRenderEffect\n              instance.update\n                run\n                  componentUpdateFn\n                    renderComponentRoot\n                      render(编译)\n            createComponentInstance \n            setupComponent\n              initProps\n              initSlots\n              setupStatefulComponent\n        processFragment\n          mountChildren\n        processElement\n          mountElement\n            createElement\n            patchProp\n            setElementText\n            hostInsert\n            mountChildren\n          updateElement\n          updateComponent\n -->\n\n#### 前言\n相对于传统的 jQuery 一把梭子撸到底的开发模式，组件化可以帮助我们实现 视图 和 逻辑 的复用，并且可以对每个部分进行单独的思考。对于一个大型的 Vue.js 应用，通常是由一个个组件组合而成：\n\n但是我们实际访问的页面，是由 DOM 元素构成的，而组件的 <code>\\<template></code> 中的内容只是一个模板字符串而已。那模板字符串是如何被渲染成 DOM 的呢？接下来我们将从组件入手，揭秘 Vue 的组件是如何被渲染成真实的 DOM 的。\n\n#### 初始化一个 Vue 3 应用\n在开始本章节之前，我们先来简单初始化一个 Vue 3 的应用：\n\n```\n# 安装 vue cli \n$ yarn global add @vue/cli\n\n# 创建 vue3 的基础脚手架 一路回车\n$ vue create vue3-demo\n```\n\n接下来，打开项目，可以看到Vue.js 的入口文件 main.js 的内容如下：\n\n```typescript\nimport { createApp } from 'vue'\nimport App from './App.vue'\n\ncreateApp(App).mount('#app')\n```\n\n这里就有一个根组件 App.vue。为了更加简单地介绍 Vue 根组件的渲染过程，我把 App.vue 根组件进行了一个简单的修改：\n\n```typescript\n<template>\n  <div class=\"helloWorld\">\n    hello world\n  </div>\n</template>\n<script>\nexport default {\n  setup() {\n    // ...\n  }\n}\n</script>\n```\n\n#### 根组件模板编译\n我们知道 .vue 类型的文件无法在 Web 端直接加载，我们通常会在 webpack 的编译阶段，通过 vue-loader 编译生成组件相关的 JavaScript 和 CSS，并把 template 部分编译转换成 render 函数添加到组件对象的属性中。\n\n上述的 App.vue 文件内的模板其实是会被编译工具在编译时转成一个渲染函数，大致如下：\n\n```typescript\nimport { openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\"\n\nconst _hoisted_1 = { class: \"helloWorld\" }\n\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return (_openBlock(), _createElementBlock(\"div\", _hoisted_1, \" hello world \"))\n}\n```\n\n关于 \\<template> 中的模板字符串是如何被编译成 render 函数的，以及 _hoisted_1 是个什么玩意，我们将在后续章节中详细介绍。\n\n现在我们只需要知道 \\<script> 中的对象内容最终会和编译后的模板内容一起，生成一个 App 对象传入 createApp 函数中：\n\n```typescript\n{\n\n  render(_ctx, _cache, $props, $setup, $data, $options) { \n    // ... \n  },\n  setup() {\n    // ...\n  }\n}\n```\n\n#### 对象组件渲染成真实的 DOM\n接着回到 main.js 的入口文件，整个初始化的过程只剩下如下部分了：\n\n```typescript\ncreateApp(App).mount('#app')\n```\n\n打开源码，可以看一下 createApp 的过程：\n\n```typescript\n// packages/runtime-dom/src/index.ts\nexport const createApp = (...args) => {\n  const app = ensureRenderer().createApp(...args);\n  // ...\n  return app;\n};\n```\n\n猜测一下，ensureRenderer().createApp(...args) 这个链式函数执行完成后肯定返回了 mount 函数，ensureRenderer 就是构造了一个带有 createApp 函数的渲染器 renderer 对象 ：\n\n```typescript\n// packages/runtime-dom/src/index.ts\nfunction ensureRenderer() {\n  // 如果 renderer 有值的话，那么以后都不会初始化了\n  return (\n    renderer ||\n    (renderer = createRenderer(rendererOptions)\n  )\n}\n\n// renderOptions 包含以下函数：\n\nconst renderOptions = {\n  createElement,\n  createText,\n  setText,\n  setElementText,\n  patchProp,\n  insert,\n  remove,\n}\n```\n\n这里返回的 renderer 对象，可以认为是一个跨平台的渲染器对象，针对不同的平台，会创建出不同的 renderer 对象，上述是创建浏览器环境的 renderer 对象，对于服务端渲染的场景，则会创建 server render 的 renderer:\n\n```typescript\n// packages/runtime-dom/src/index.ts\nlet enabledHydration = false\nfunction ensureHydrationRenderer() {\n  renderer = enabledHydration\n    ? renderer\n    : createHydrationRenderer(rendererOptions)\n  enabledHydration = true\n  return renderer\n}\n```\n\n再来看一下 createRenderer 返回的对象：\n\n```typescript\n// packages/runtime-core/src/renderer.ts\nexport function createRenderer(options) {\n  // ...\n  // 这里不介绍 hydrate 模式\n  return {\n    render,\n    hydrate,\n    createApp: createAppAPI(render, hydrate),\n  }\n}\n```\n\n可以看到，renderer 对象上包含了 createApp 和 render 方法。再来看一下 createApp 方法：\n\n```typescript\n// packages/runtime-core/src/apiCreateApp.ts\nfunction createAppAPI(render, hydrate) {\n  // createApp createApp 方法接收的两个参数：根组件的对象和 prop\n  return function createApp(rootComponent, rootProps = null) {\n    const app = {\n      // ... 省略很多不需要在这里介绍的属性\n      _component: rootComponent,\n      _props: rootProps,\n      mount(rootContainer, isHydrate, isSVG) {\n        // ...\n      }\n    }\n    return app\n  }\n}\n```\n\n直到这里，我们才真正拨开了 Vue 3 初始化根组件的核心方法，也就是入口文件 createApp 真正执行的内容就是这里的 createAppAPI 函数中的 createApp 函数，该函数接收了 <App /> 组件作为根组件 rootComponent，返回了一个包含 mount 方法的 app 对象。\n\n接下来再深入地看一下 mount 的内部实现：\n\n```typescript\n// packages/runtime-core/src/apiCreateApp.ts\nmount(rootContainer, isHydrate, isSVG) {\n  if (!isMounted) {\n    // ... 省略部分不重要的代码\n    // 1. 创建根组件的 vnode\n    const vnode = createVNode(\n      rootComponent,\n      rootProps\n    )\n    \n    // 2. 渲染根组件\n    render(vnode, rootContainer, isSVG)\n    isMounted = true\n  }\n}\n```\n\n##### 1. 创建根组件的 vnode\n什么是 vnode 节点呢？其实它和 Virtual DOM 是一个意思，就是将真实的 DOM 以普通对象形式的数据结构来表达，简化了很多 DOM 中内容。\n\n熟悉 JS DOM 编程的小伙伴都知道 JS 直接操作 DOM 往往会带来许多性能负担，所以 vnode 提供了对真实 DOM 上的一层虚拟映射，我们只需要操作这个虚拟的数据结构，那些真正费性能的活交给这些框架来操作就好了，框架会帮我们做很多性能优化的事情。这也是 vnode 带来的最大的优势之一。\n\n其次，因为 vnode 只是一种与平台无关的数据结构而已，所以理论上我们也可以将它渲染到不同平台上从而达到跨平台渲染的目的。这个也是 weex、mpvue 等跨端渲染框架的核心基础。\n\n上述例子中的 template 中的内容用 vnode 可以表示为：\n\n```typescript\nconst vnode = {\n  type: 'div',\n  props: { \n    'class': 'helloWorld'\n  },\n  children: 'helloWorld'\n}\n```\n\n说了这么多，那么根节点是如何被创建成一个 vnode 的呢？核心也就在 createVNode 函数中：\n\n```typescript\n// packages/runtime-core/src/vnode.ts\nfunction createBaseVNode(...) {\n  const vnode = {\n    type,\n    props,\n    key: props && normalizeKey(props),\n    children,\n    component: null,\n    shapeFlag,\n    patchFlag,\n    dynamicProps,\n    dynamicChildren: null,\n    // ... 一些其他属性\n  }\n  // ...\n  return vnode\n}\nfunction createVNode(type, props = null, children = null) {\n  if (props) {\n    // 如果存在 props 则需要对 props 进行一些处理，这里先省略\n  }\n  // ...\n  // 处理 shapeFlag 类型\n  const shapeFlag = isString(type)\n    ? ShapeFlags.ELEMENT\n    : __FEATURE_SUSPENSE__ && isSuspense(type)\n    ? ShapeFlags.SUSPENSE\n    : isTeleport(type)\n    ? ShapeFlags.TELEPORT\n    : isObject(type)\n    ? ShapeFlags.STATEFUL_COMPONENT\n    : isFunction(type)\n    ? ShapeFlags.FUNCTIONAL_COMPONENT\n    : 0\n  \n  // ...\n  return createBaseVNode(\n    type,\n    props,\n    children,\n    patchFlag,\n    dynamicProps,\n    shapeFlag,\n    isBlockNode,\n    true\n  )\n}\n```\n\n当进行根组件渲染的时候，createVNode 的第一个入参 type 是我们的 App 对象，也就是一个 Object，所以得到的 shapeFlag 的值是 STATEFUL_COMPONENT，代表的是一个有状态组件对象。（这里顺便提一下，如果传入的是个函数，那么就是一个函数式组件 FUNCTIONAL_COMPONENT，函数式组件和有状态的对象组件都是 Vue 可处理的组件类型，这个会在下面渲染阶段提及。）\n\n到这里，Vue 完成了对根组件的 Vnode 对象的创建，接下来要做的就是将该组件渲染到页面中。\n\n##### 2. VNode 渲染成真实的组件\n回到 mount 函数中，接下来一步就是对 vnode 的渲染工作，核心代码：\n\n```typescript\nrender(vnode, rootContainer);\n```\n\n那么这里的 render 函数是什么呢？通过上面的代码我们发现，其实它是在调用 createAppAPI 时传入进来的，而 createAppAPI 则是在创建 renderer 渲染器的时候调用的。那么，接下来看看 render 函数的实现：\n\n```typescript\n// packages/runtime-core/src/renderer.ts\nconst render = (vnode, container) => {\n  if (vnode == null) {\n    // 如果 vnode 不存在，表示需要卸载组件\n    if (container._vnode) {\n      unmount(container._vnode, null, null, true)\n    }\n  } else {\n    // 否则进入更新流程（初始化创建也是特殊的一种更新）\n    patch(container._vnode || null, vnode, container)\n  }\n  // 缓存 vnode\n  container._vnode = vnode\n}\n```\n\n很明显，对于初始化根组件的过程中，传入了一个根组件的 vnode 对象，所以这里会执行 patch 相关的动作。patch 本意是补丁的意思，可以理解成为更新做一些补丁的活儿，其实初始的过程也可以看作是一个全量补丁，一种特殊的更新操作。\n\n```typescript\n// packages/runtime-core/src/renderer.ts\nfunction patch(n1,n2,container = null,anchor = null,parentComponent = null) {\n  // 对于类型不同的新老节点，直接进行卸载\n  if (n1 && !isSameVNodeType(n1, n2)) {\n    anchor = getNextHostNode(n1)\n    unmount(n1, parentComponent, parentSuspense, true)\n    n1 = null\n  }\n  // 基于 n2 的类型来判断\n  // 因为 n2 是新的 vnode\n  const { type, shapeFlag } = n2;\n  switch (type) {\n    case Text:\n       // 处理文本节点\n      break;\n    // 其中还有几个类型比如： static fragment comment\n    default:\n      // 这里就基于 shapeFlag 来处理\n      if (shapeFlag & ShapeFlags.ELEMENT) {\n        // 处理普通 DOM 元素\n        processElement(n1, n2, container, anchor, parentComponent);\n      } else if (shapeFlag & ShapeFlags.COMPONENT) {\n        // 处理 component\n        processComponent(n1, n2, container, parentComponent);\n      } else if {\n        // ... 处理其他元素\n      }\n  }\n}\n```\n\npatch 函数主要接收的参数说明如下：\n\nn1 表示老的 vnode 节点；\nn2 表示新的 vnode 节点；\ncontainer 表示需要挂载的 dom 容器；\nanchor 挂载的参考元素；\nparentComponent 父组件。\n这里我们主要关注前 3 个参数，因为是初始化的过程，所以 n1 本次值为空，核心看 n2 的值，n2 有一个 type 和 shapeFlag。当前 n2 的 type 是 App 组件对象，所以逻辑会进入 Switch 的 default 中。再比较 shapeFlag 属性，前面提到 shapeFlag 的值是 STATEFUL_COMPONENT。\n\n```\n这里需要注意的是 ShapeFlags 是一个二进制左移操作符生成的对象，其中 ShapeFlags.COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT， 所以 shapeFlag & ShapeFlags.COMPONENT 这里的值是 true，关于二进制左移操作符对象在 Vue 3 中会大量使用，后面也会详细介绍。\n```\n\n接着也就进入了 processComponent 的逻辑了：\n\n```typescript\n// packages/runtime-core/src/renderer.ts\nfunction processComponent(n1, n2, container, parentComponent) {\n  // 如果 n1 没有值的话，那么就是 mount\n  if (!n1) {\n    // 初始化 component\n    mountComponent(n2, container, parentComponent);\n  } else {\n    updateComponent(n1, n2, container);\n  }\n}\n```\n\n同理，这里我们只看初始化的逻辑，所以 n1 此时还是个空值，那么就会进入 mountComponent 函数对组件进行初始挂载过程。\n\n```typescript\n// packages/runtime-core/src/renderer.ts\nfunction mountComponent(initialVNode, container, parentComponent) {\n  // 1. 先创建一个 component instance\n  const instance = (initialVNode.component = createComponentInstance(\n    initialVNode,\n    parentComponent\n  ));\n  \n  // 2. 初始化 instance 上的 props, slots, 执行组件的 setup 函数...\n  setupComponent(instance);\n\n  // 3. 设置并运行带副作用的渲染函数\n  setupRenderEffect(instance, initialVNode, container);\n}\n```\n\n该函数实现过程还是非常清晰的，思考一下，一个组件的初始化要做哪些内容呢？\n\n其实很容易想到，我们需要一个实例化的组件对象，该对象可以在 Vue 执行的运行时上下文中随时获取到，另外还需要对实例化后的组件中的属性做一些优化、处理、赋值等操作，最后，就是把组件实例的 render 函数执行一遍。\n\n上面也是 mountComponent 核心做的事情，我们一个个来看。\n\n第一步是组件实例化，在 Vue 3 中通过 createComponentInstance 的方法创建组件实例，返回的是一个组件实例的对象，大致包含以下属性：\n\n```typescript\n// packages/runtime-core/src/component.ts\nconst instance = {\n  // 这里是组件对象\n  type: vnode.type, \n  // 组件 vnode\n  vnode,\n  // 新的组件 vnode\n  next: null, \n  // props 相关\n  props: {}, \n  // 指向父组件\n  parent,\n  // 依赖注入相关\n  provides: parent ? parent.provides : {},\n  // 渲染上下文代理\n  proxy: null,\n  // 标记是否被挂载\n  isMounted: false,\n  // attrs 相关\n  attrs: {}, \n  // slots 相关\n  slots: {}, \n  // context 相关\n  ctx: {},\n  // setup return 的状态数据\n  setupState: {}, \n  // ...\n};\n```\n\n上述实例属性，相对源码而言，已经省略了很多内容了，这些属性现在看着肯定不知所云，头皮发麻。但相应的属性是 vue 在特定的场景和功能下才会用到的，相信你跟着本小册一起阅读后，回过头来再去看一遍这些属性，就会“顿悟”。\n\n然后是对实例化后的组件中的属性做一些优化、处理、赋值等操作，这里主要是初始化了 props、slots，并执行组件的 setup 函数，核心的实现和功能我们将在下一节介绍。\n\n```typescript\n// packages/runtime-core/src/component.ts\nexport function setupComponent(instance) {\n  // 1. 处理 props\n  // 取出存在 vnode 里面的 props\n  const { props, children } = instance.vnode;\n  initProps(instance, props);\n  // 2. 处理 slots\n  initSlots(instance, children);\n\n  // 3. 调用 setup 并处理 setupResult\n  setupStatefulComponent(instance);\n}\n```\n\n最后是把组件实例的 render 函数执行一遍，这里是通过 setupRenderEffect 来执行的。我们再看一下这个函数的实现：\n\n```typescript\n// packages/runtime-core/src/renderer.ts\nconst setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\n  function componentUpdateFn() {\n    if (!instance.isMounted) {\n      // 渲染子树的 vnode\n      const subTree = (instance.subTree = renderComponentRoot(instance))\n      // 挂载子树 vnode 到 container 中\n      patch(null, subTree, container, anchor, instance, parentSuspense, isSVG)\n      // 把渲染生成的子树根 DOM 节点存储到 el 属性上\n      initialVNode.el = subTree.el\n      instance.isMounted = true\n    }\n    else {\n      // 更新相关，后面介绍\n    }\n  }\n  // 创建副作用渲染函数\n  instance.update = effect(componentUpdateFn, prodEffectOptions)\n}\n```\n\n这里我们再看一下 componentUpdateFn 这个函数，核心是调用了 renderComponentRoot 来生成 subTree，然后再把 subTree 挂载到 container 中。其实 renderComponentRoot 的核心工作就是执行 instance.render 方法，该方法前面我们已经说了，组件在编译时会生成组件对象，包含了 render 函数，该函数内部是一系列的渲染函数的执行：\n\n```typescript\nimport { openBlock, createElementBlock } from \"vue\"\n\nconst _hoisted_1 = { class: \"helloWorld\" }\n\nexport function render(...) {\n  return (openBlock(), createElementBlock(\"div\", _hoisted_1, \" hello world \"))\n}\n```\n\n那么只需要看一下 createElementBlock 函数的实现：\n\n```typescript\n// packages/runtime-core/src/vnode.ts\nexport const createElementBlock = (...) => {\n  return setupBlock(\n    createBaseVNode(\n      type,\n      props,\n      children,\n      patchFlag,\n      dynamicProps,\n      shapeFlag,\n      true /* isBlock */\n    )\n  )\n};\n```\n\n可以看到本质还是调用了 createBaseVNode 创新 vnode。所以，我们可以推导出 subtree 就是调用 render 函数而生产的 vnode 节点。这里需要注意的一点是，因为 subtree 调用的 createBaseVNode 创建时，传入的 type = div 在这里是个 string，所以返回的 shapeFlags 的值是 ELEMENT。\n\n渲染生成子树 vnode 后，接下来就是继续调用 patch 函数把子树 vnode 挂载到 container 中了，前面说过了 patch 的实现，再来简单看一下当传入的 vnode 的 shapeFlags 是个 ELEMENT 时，会调用 processElement 这个函数：\n\n```typescript\nif (shapeFlag & ShapeFlags.ELEMENT) {\n  processElement(n1, n2, container, anchor, parentComponent);\n}\n```\n\n我们来看一下 processElement 的实现：\n\n```typescript\n// packages/runtime-core/src/renderer.ts\nfunction processElement(n1, n2, container, anchor, parentComponent) {\n  if (!n1) {\n    // 挂载元素节点\n    mountElement(n2, container, anchor);\n  } else {\n    // 更新元素节点\n    updateElement(n1, n2, container, anchor, parentComponent);\n  }\n}\n```\n\n因为在初始化的过程中，n1 是 null，所以这里执行的是 mountElement 进行元素的初始化挂载。\n\n```typescript\n// packages/runtime-core/src/renderer.ts\nconst mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  let el\n  const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode\n  // ...\n  // 根据 vnode 创建 DOM 节点\n  el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is)\n  if (props) {\n    // 处理 props 属性\n    for (const key in props) {\n      if (!isReservedProp(key)) {\n        hostPatchProp(el, key, null, props[key], isSVG)\n      }\n    }\n  }\n  // 文本节点处理\n  if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n    hostSetElementText(el, vnode.children)\n  } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n    // 如果节点是个数据类型，则递归子节点\n    mountChildren(vnode.children, el)\n  }\n  // 把创建好的 el 元素挂载到容器中\n  hostInsert(el, container, anchor)\n}\n```\n\nmountElemet 首先是通过 hostCreateElement 创建了一个 DOM 节点，然后处理一下 props 属性，接着根据 shapeFlag 判断子节点的类型，如果节点是个文本节点，则直接创建文本节点，如果子节点是个数组，比如这种情况：\n\n```typescript\nreturn (openBlock(), createElementBlock(\"div\", _hoisted_1, [\n  hoisted_2,\n  createVNode(_component_Hello)\n]))\n```\n\n对于这种子节点是数组的情况时，它的 shapeFlag 将是一个数组类型 ARRAY_CHILDREN。此时会对该 vnode 节点的子节点调用 mountChildren 进行递归的 patch 渲染。\n\n最后，处理完所有子节点后，通过 hostInsert 方法把缓存在内存中的 DOM el 映射渲染到真实的 DOM Container 当中。\n\n```typescript\n// packages/runtime-dom/src/nodeOps.ts\ninsert: (child, parent, anchor) {\n  parent.insertBefore(child, anchor || null)\n}\n```\n\n#### 总结\n到这里，我们已经完成了从入口文件开始，分析根组件如何挂载渲染到真实 DOM 的流程，再简单通过一张流程图回顾一下上述内容，绿色部分是初始化的过程，也是本小节的内容，灰色部分我们后面章节再做介绍。\n\n然后我们再引用一下 Vue 官网上的一张渲染流程图：\n\n现在再来看这一张图，整体流程就会清晰了很多：在组件初始化挂载阶段，模板被编译成渲染函数的形式，交由渲染器执行，渲染器执行渲染函数得到 APP 组件对象的子树 vnode，子树 vnode 进行递归 patch 后生成不同类型的 DOM 节点，最后把这些 DOM 节点挂载到页面的 container 当中。\n\n关于具体的编译器和更新以及响应式的部分我们会在后续章节继续介绍。本节主要介绍了挂载过程，后面的小节我们接着介绍一下更新策略。","source":"_drafts/technical-disclosure-of-vue3/1-render-dom.md","raw":"---\ntitle: 渲染器：组件是如何被渲染成DOM的？\ncategories:\n  - Vue3 技术揭秘\n---\n\n<!-- \ncreateApp\n  ensureRender\n    createRenderer\n      baseCreateRenderer\n        createAppAPI\n\n\napp.mount\n  mount\n    createVNode: createVNodeWithArgsTransform\n      _createVNode\n        createBaseVNode\n    render\n      patch\n        processComponent\n          mountComponent\n            setupRenderEffect\n              instance.update\n                run\n                  componentUpdateFn\n                    renderComponentRoot\n                      render(编译)\n            createComponentInstance \n            setupComponent\n              initProps\n              initSlots\n              setupStatefulComponent\n        processFragment\n          mountChildren\n        processElement\n          mountElement\n            createElement\n            patchProp\n            setElementText\n            hostInsert\n            mountChildren\n          updateElement\n          updateComponent\n -->\n\n#### 前言\n相对于传统的 jQuery 一把梭子撸到底的开发模式，组件化可以帮助我们实现 视图 和 逻辑 的复用，并且可以对每个部分进行单独的思考。对于一个大型的 Vue.js 应用，通常是由一个个组件组合而成：\n\n但是我们实际访问的页面，是由 DOM 元素构成的，而组件的 <code>\\<template></code> 中的内容只是一个模板字符串而已。那模板字符串是如何被渲染成 DOM 的呢？接下来我们将从组件入手，揭秘 Vue 的组件是如何被渲染成真实的 DOM 的。\n\n#### 初始化一个 Vue 3 应用\n在开始本章节之前，我们先来简单初始化一个 Vue 3 的应用：\n\n```\n# 安装 vue cli \n$ yarn global add @vue/cli\n\n# 创建 vue3 的基础脚手架 一路回车\n$ vue create vue3-demo\n```\n\n接下来，打开项目，可以看到Vue.js 的入口文件 main.js 的内容如下：\n\n```typescript\nimport { createApp } from 'vue'\nimport App from './App.vue'\n\ncreateApp(App).mount('#app')\n```\n\n这里就有一个根组件 App.vue。为了更加简单地介绍 Vue 根组件的渲染过程，我把 App.vue 根组件进行了一个简单的修改：\n\n```typescript\n<template>\n  <div class=\"helloWorld\">\n    hello world\n  </div>\n</template>\n<script>\nexport default {\n  setup() {\n    // ...\n  }\n}\n</script>\n```\n\n#### 根组件模板编译\n我们知道 .vue 类型的文件无法在 Web 端直接加载，我们通常会在 webpack 的编译阶段，通过 vue-loader 编译生成组件相关的 JavaScript 和 CSS，并把 template 部分编译转换成 render 函数添加到组件对象的属性中。\n\n上述的 App.vue 文件内的模板其实是会被编译工具在编译时转成一个渲染函数，大致如下：\n\n```typescript\nimport { openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\"\n\nconst _hoisted_1 = { class: \"helloWorld\" }\n\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return (_openBlock(), _createElementBlock(\"div\", _hoisted_1, \" hello world \"))\n}\n```\n\n关于 \\<template> 中的模板字符串是如何被编译成 render 函数的，以及 _hoisted_1 是个什么玩意，我们将在后续章节中详细介绍。\n\n现在我们只需要知道 \\<script> 中的对象内容最终会和编译后的模板内容一起，生成一个 App 对象传入 createApp 函数中：\n\n```typescript\n{\n\n  render(_ctx, _cache, $props, $setup, $data, $options) { \n    // ... \n  },\n  setup() {\n    // ...\n  }\n}\n```\n\n#### 对象组件渲染成真实的 DOM\n接着回到 main.js 的入口文件，整个初始化的过程只剩下如下部分了：\n\n```typescript\ncreateApp(App).mount('#app')\n```\n\n打开源码，可以看一下 createApp 的过程：\n\n```typescript\n// packages/runtime-dom/src/index.ts\nexport const createApp = (...args) => {\n  const app = ensureRenderer().createApp(...args);\n  // ...\n  return app;\n};\n```\n\n猜测一下，ensureRenderer().createApp(...args) 这个链式函数执行完成后肯定返回了 mount 函数，ensureRenderer 就是构造了一个带有 createApp 函数的渲染器 renderer 对象 ：\n\n```typescript\n// packages/runtime-dom/src/index.ts\nfunction ensureRenderer() {\n  // 如果 renderer 有值的话，那么以后都不会初始化了\n  return (\n    renderer ||\n    (renderer = createRenderer(rendererOptions)\n  )\n}\n\n// renderOptions 包含以下函数：\n\nconst renderOptions = {\n  createElement,\n  createText,\n  setText,\n  setElementText,\n  patchProp,\n  insert,\n  remove,\n}\n```\n\n这里返回的 renderer 对象，可以认为是一个跨平台的渲染器对象，针对不同的平台，会创建出不同的 renderer 对象，上述是创建浏览器环境的 renderer 对象，对于服务端渲染的场景，则会创建 server render 的 renderer:\n\n```typescript\n// packages/runtime-dom/src/index.ts\nlet enabledHydration = false\nfunction ensureHydrationRenderer() {\n  renderer = enabledHydration\n    ? renderer\n    : createHydrationRenderer(rendererOptions)\n  enabledHydration = true\n  return renderer\n}\n```\n\n再来看一下 createRenderer 返回的对象：\n\n```typescript\n// packages/runtime-core/src/renderer.ts\nexport function createRenderer(options) {\n  // ...\n  // 这里不介绍 hydrate 模式\n  return {\n    render,\n    hydrate,\n    createApp: createAppAPI(render, hydrate),\n  }\n}\n```\n\n可以看到，renderer 对象上包含了 createApp 和 render 方法。再来看一下 createApp 方法：\n\n```typescript\n// packages/runtime-core/src/apiCreateApp.ts\nfunction createAppAPI(render, hydrate) {\n  // createApp createApp 方法接收的两个参数：根组件的对象和 prop\n  return function createApp(rootComponent, rootProps = null) {\n    const app = {\n      // ... 省略很多不需要在这里介绍的属性\n      _component: rootComponent,\n      _props: rootProps,\n      mount(rootContainer, isHydrate, isSVG) {\n        // ...\n      }\n    }\n    return app\n  }\n}\n```\n\n直到这里，我们才真正拨开了 Vue 3 初始化根组件的核心方法，也就是入口文件 createApp 真正执行的内容就是这里的 createAppAPI 函数中的 createApp 函数，该函数接收了 <App /> 组件作为根组件 rootComponent，返回了一个包含 mount 方法的 app 对象。\n\n接下来再深入地看一下 mount 的内部实现：\n\n```typescript\n// packages/runtime-core/src/apiCreateApp.ts\nmount(rootContainer, isHydrate, isSVG) {\n  if (!isMounted) {\n    // ... 省略部分不重要的代码\n    // 1. 创建根组件的 vnode\n    const vnode = createVNode(\n      rootComponent,\n      rootProps\n    )\n    \n    // 2. 渲染根组件\n    render(vnode, rootContainer, isSVG)\n    isMounted = true\n  }\n}\n```\n\n##### 1. 创建根组件的 vnode\n什么是 vnode 节点呢？其实它和 Virtual DOM 是一个意思，就是将真实的 DOM 以普通对象形式的数据结构来表达，简化了很多 DOM 中内容。\n\n熟悉 JS DOM 编程的小伙伴都知道 JS 直接操作 DOM 往往会带来许多性能负担，所以 vnode 提供了对真实 DOM 上的一层虚拟映射，我们只需要操作这个虚拟的数据结构，那些真正费性能的活交给这些框架来操作就好了，框架会帮我们做很多性能优化的事情。这也是 vnode 带来的最大的优势之一。\n\n其次，因为 vnode 只是一种与平台无关的数据结构而已，所以理论上我们也可以将它渲染到不同平台上从而达到跨平台渲染的目的。这个也是 weex、mpvue 等跨端渲染框架的核心基础。\n\n上述例子中的 template 中的内容用 vnode 可以表示为：\n\n```typescript\nconst vnode = {\n  type: 'div',\n  props: { \n    'class': 'helloWorld'\n  },\n  children: 'helloWorld'\n}\n```\n\n说了这么多，那么根节点是如何被创建成一个 vnode 的呢？核心也就在 createVNode 函数中：\n\n```typescript\n// packages/runtime-core/src/vnode.ts\nfunction createBaseVNode(...) {\n  const vnode = {\n    type,\n    props,\n    key: props && normalizeKey(props),\n    children,\n    component: null,\n    shapeFlag,\n    patchFlag,\n    dynamicProps,\n    dynamicChildren: null,\n    // ... 一些其他属性\n  }\n  // ...\n  return vnode\n}\nfunction createVNode(type, props = null, children = null) {\n  if (props) {\n    // 如果存在 props 则需要对 props 进行一些处理，这里先省略\n  }\n  // ...\n  // 处理 shapeFlag 类型\n  const shapeFlag = isString(type)\n    ? ShapeFlags.ELEMENT\n    : __FEATURE_SUSPENSE__ && isSuspense(type)\n    ? ShapeFlags.SUSPENSE\n    : isTeleport(type)\n    ? ShapeFlags.TELEPORT\n    : isObject(type)\n    ? ShapeFlags.STATEFUL_COMPONENT\n    : isFunction(type)\n    ? ShapeFlags.FUNCTIONAL_COMPONENT\n    : 0\n  \n  // ...\n  return createBaseVNode(\n    type,\n    props,\n    children,\n    patchFlag,\n    dynamicProps,\n    shapeFlag,\n    isBlockNode,\n    true\n  )\n}\n```\n\n当进行根组件渲染的时候，createVNode 的第一个入参 type 是我们的 App 对象，也就是一个 Object，所以得到的 shapeFlag 的值是 STATEFUL_COMPONENT，代表的是一个有状态组件对象。（这里顺便提一下，如果传入的是个函数，那么就是一个函数式组件 FUNCTIONAL_COMPONENT，函数式组件和有状态的对象组件都是 Vue 可处理的组件类型，这个会在下面渲染阶段提及。）\n\n到这里，Vue 完成了对根组件的 Vnode 对象的创建，接下来要做的就是将该组件渲染到页面中。\n\n##### 2. VNode 渲染成真实的组件\n回到 mount 函数中，接下来一步就是对 vnode 的渲染工作，核心代码：\n\n```typescript\nrender(vnode, rootContainer);\n```\n\n那么这里的 render 函数是什么呢？通过上面的代码我们发现，其实它是在调用 createAppAPI 时传入进来的，而 createAppAPI 则是在创建 renderer 渲染器的时候调用的。那么，接下来看看 render 函数的实现：\n\n```typescript\n// packages/runtime-core/src/renderer.ts\nconst render = (vnode, container) => {\n  if (vnode == null) {\n    // 如果 vnode 不存在，表示需要卸载组件\n    if (container._vnode) {\n      unmount(container._vnode, null, null, true)\n    }\n  } else {\n    // 否则进入更新流程（初始化创建也是特殊的一种更新）\n    patch(container._vnode || null, vnode, container)\n  }\n  // 缓存 vnode\n  container._vnode = vnode\n}\n```\n\n很明显，对于初始化根组件的过程中，传入了一个根组件的 vnode 对象，所以这里会执行 patch 相关的动作。patch 本意是补丁的意思，可以理解成为更新做一些补丁的活儿，其实初始的过程也可以看作是一个全量补丁，一种特殊的更新操作。\n\n```typescript\n// packages/runtime-core/src/renderer.ts\nfunction patch(n1,n2,container = null,anchor = null,parentComponent = null) {\n  // 对于类型不同的新老节点，直接进行卸载\n  if (n1 && !isSameVNodeType(n1, n2)) {\n    anchor = getNextHostNode(n1)\n    unmount(n1, parentComponent, parentSuspense, true)\n    n1 = null\n  }\n  // 基于 n2 的类型来判断\n  // 因为 n2 是新的 vnode\n  const { type, shapeFlag } = n2;\n  switch (type) {\n    case Text:\n       // 处理文本节点\n      break;\n    // 其中还有几个类型比如： static fragment comment\n    default:\n      // 这里就基于 shapeFlag 来处理\n      if (shapeFlag & ShapeFlags.ELEMENT) {\n        // 处理普通 DOM 元素\n        processElement(n1, n2, container, anchor, parentComponent);\n      } else if (shapeFlag & ShapeFlags.COMPONENT) {\n        // 处理 component\n        processComponent(n1, n2, container, parentComponent);\n      } else if {\n        // ... 处理其他元素\n      }\n  }\n}\n```\n\npatch 函数主要接收的参数说明如下：\n\nn1 表示老的 vnode 节点；\nn2 表示新的 vnode 节点；\ncontainer 表示需要挂载的 dom 容器；\nanchor 挂载的参考元素；\nparentComponent 父组件。\n这里我们主要关注前 3 个参数，因为是初始化的过程，所以 n1 本次值为空，核心看 n2 的值，n2 有一个 type 和 shapeFlag。当前 n2 的 type 是 App 组件对象，所以逻辑会进入 Switch 的 default 中。再比较 shapeFlag 属性，前面提到 shapeFlag 的值是 STATEFUL_COMPONENT。\n\n```\n这里需要注意的是 ShapeFlags 是一个二进制左移操作符生成的对象，其中 ShapeFlags.COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT， 所以 shapeFlag & ShapeFlags.COMPONENT 这里的值是 true，关于二进制左移操作符对象在 Vue 3 中会大量使用，后面也会详细介绍。\n```\n\n接着也就进入了 processComponent 的逻辑了：\n\n```typescript\n// packages/runtime-core/src/renderer.ts\nfunction processComponent(n1, n2, container, parentComponent) {\n  // 如果 n1 没有值的话，那么就是 mount\n  if (!n1) {\n    // 初始化 component\n    mountComponent(n2, container, parentComponent);\n  } else {\n    updateComponent(n1, n2, container);\n  }\n}\n```\n\n同理，这里我们只看初始化的逻辑，所以 n1 此时还是个空值，那么就会进入 mountComponent 函数对组件进行初始挂载过程。\n\n```typescript\n// packages/runtime-core/src/renderer.ts\nfunction mountComponent(initialVNode, container, parentComponent) {\n  // 1. 先创建一个 component instance\n  const instance = (initialVNode.component = createComponentInstance(\n    initialVNode,\n    parentComponent\n  ));\n  \n  // 2. 初始化 instance 上的 props, slots, 执行组件的 setup 函数...\n  setupComponent(instance);\n\n  // 3. 设置并运行带副作用的渲染函数\n  setupRenderEffect(instance, initialVNode, container);\n}\n```\n\n该函数实现过程还是非常清晰的，思考一下，一个组件的初始化要做哪些内容呢？\n\n其实很容易想到，我们需要一个实例化的组件对象，该对象可以在 Vue 执行的运行时上下文中随时获取到，另外还需要对实例化后的组件中的属性做一些优化、处理、赋值等操作，最后，就是把组件实例的 render 函数执行一遍。\n\n上面也是 mountComponent 核心做的事情，我们一个个来看。\n\n第一步是组件实例化，在 Vue 3 中通过 createComponentInstance 的方法创建组件实例，返回的是一个组件实例的对象，大致包含以下属性：\n\n```typescript\n// packages/runtime-core/src/component.ts\nconst instance = {\n  // 这里是组件对象\n  type: vnode.type, \n  // 组件 vnode\n  vnode,\n  // 新的组件 vnode\n  next: null, \n  // props 相关\n  props: {}, \n  // 指向父组件\n  parent,\n  // 依赖注入相关\n  provides: parent ? parent.provides : {},\n  // 渲染上下文代理\n  proxy: null,\n  // 标记是否被挂载\n  isMounted: false,\n  // attrs 相关\n  attrs: {}, \n  // slots 相关\n  slots: {}, \n  // context 相关\n  ctx: {},\n  // setup return 的状态数据\n  setupState: {}, \n  // ...\n};\n```\n\n上述实例属性，相对源码而言，已经省略了很多内容了，这些属性现在看着肯定不知所云，头皮发麻。但相应的属性是 vue 在特定的场景和功能下才会用到的，相信你跟着本小册一起阅读后，回过头来再去看一遍这些属性，就会“顿悟”。\n\n然后是对实例化后的组件中的属性做一些优化、处理、赋值等操作，这里主要是初始化了 props、slots，并执行组件的 setup 函数，核心的实现和功能我们将在下一节介绍。\n\n```typescript\n// packages/runtime-core/src/component.ts\nexport function setupComponent(instance) {\n  // 1. 处理 props\n  // 取出存在 vnode 里面的 props\n  const { props, children } = instance.vnode;\n  initProps(instance, props);\n  // 2. 处理 slots\n  initSlots(instance, children);\n\n  // 3. 调用 setup 并处理 setupResult\n  setupStatefulComponent(instance);\n}\n```\n\n最后是把组件实例的 render 函数执行一遍，这里是通过 setupRenderEffect 来执行的。我们再看一下这个函数的实现：\n\n```typescript\n// packages/runtime-core/src/renderer.ts\nconst setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\n  function componentUpdateFn() {\n    if (!instance.isMounted) {\n      // 渲染子树的 vnode\n      const subTree = (instance.subTree = renderComponentRoot(instance))\n      // 挂载子树 vnode 到 container 中\n      patch(null, subTree, container, anchor, instance, parentSuspense, isSVG)\n      // 把渲染生成的子树根 DOM 节点存储到 el 属性上\n      initialVNode.el = subTree.el\n      instance.isMounted = true\n    }\n    else {\n      // 更新相关，后面介绍\n    }\n  }\n  // 创建副作用渲染函数\n  instance.update = effect(componentUpdateFn, prodEffectOptions)\n}\n```\n\n这里我们再看一下 componentUpdateFn 这个函数，核心是调用了 renderComponentRoot 来生成 subTree，然后再把 subTree 挂载到 container 中。其实 renderComponentRoot 的核心工作就是执行 instance.render 方法，该方法前面我们已经说了，组件在编译时会生成组件对象，包含了 render 函数，该函数内部是一系列的渲染函数的执行：\n\n```typescript\nimport { openBlock, createElementBlock } from \"vue\"\n\nconst _hoisted_1 = { class: \"helloWorld\" }\n\nexport function render(...) {\n  return (openBlock(), createElementBlock(\"div\", _hoisted_1, \" hello world \"))\n}\n```\n\n那么只需要看一下 createElementBlock 函数的实现：\n\n```typescript\n// packages/runtime-core/src/vnode.ts\nexport const createElementBlock = (...) => {\n  return setupBlock(\n    createBaseVNode(\n      type,\n      props,\n      children,\n      patchFlag,\n      dynamicProps,\n      shapeFlag,\n      true /* isBlock */\n    )\n  )\n};\n```\n\n可以看到本质还是调用了 createBaseVNode 创新 vnode。所以，我们可以推导出 subtree 就是调用 render 函数而生产的 vnode 节点。这里需要注意的一点是，因为 subtree 调用的 createBaseVNode 创建时，传入的 type = div 在这里是个 string，所以返回的 shapeFlags 的值是 ELEMENT。\n\n渲染生成子树 vnode 后，接下来就是继续调用 patch 函数把子树 vnode 挂载到 container 中了，前面说过了 patch 的实现，再来简单看一下当传入的 vnode 的 shapeFlags 是个 ELEMENT 时，会调用 processElement 这个函数：\n\n```typescript\nif (shapeFlag & ShapeFlags.ELEMENT) {\n  processElement(n1, n2, container, anchor, parentComponent);\n}\n```\n\n我们来看一下 processElement 的实现：\n\n```typescript\n// packages/runtime-core/src/renderer.ts\nfunction processElement(n1, n2, container, anchor, parentComponent) {\n  if (!n1) {\n    // 挂载元素节点\n    mountElement(n2, container, anchor);\n  } else {\n    // 更新元素节点\n    updateElement(n1, n2, container, anchor, parentComponent);\n  }\n}\n```\n\n因为在初始化的过程中，n1 是 null，所以这里执行的是 mountElement 进行元素的初始化挂载。\n\n```typescript\n// packages/runtime-core/src/renderer.ts\nconst mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  let el\n  const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode\n  // ...\n  // 根据 vnode 创建 DOM 节点\n  el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is)\n  if (props) {\n    // 处理 props 属性\n    for (const key in props) {\n      if (!isReservedProp(key)) {\n        hostPatchProp(el, key, null, props[key], isSVG)\n      }\n    }\n  }\n  // 文本节点处理\n  if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n    hostSetElementText(el, vnode.children)\n  } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n    // 如果节点是个数据类型，则递归子节点\n    mountChildren(vnode.children, el)\n  }\n  // 把创建好的 el 元素挂载到容器中\n  hostInsert(el, container, anchor)\n}\n```\n\nmountElemet 首先是通过 hostCreateElement 创建了一个 DOM 节点，然后处理一下 props 属性，接着根据 shapeFlag 判断子节点的类型，如果节点是个文本节点，则直接创建文本节点，如果子节点是个数组，比如这种情况：\n\n```typescript\nreturn (openBlock(), createElementBlock(\"div\", _hoisted_1, [\n  hoisted_2,\n  createVNode(_component_Hello)\n]))\n```\n\n对于这种子节点是数组的情况时，它的 shapeFlag 将是一个数组类型 ARRAY_CHILDREN。此时会对该 vnode 节点的子节点调用 mountChildren 进行递归的 patch 渲染。\n\n最后，处理完所有子节点后，通过 hostInsert 方法把缓存在内存中的 DOM el 映射渲染到真实的 DOM Container 当中。\n\n```typescript\n// packages/runtime-dom/src/nodeOps.ts\ninsert: (child, parent, anchor) {\n  parent.insertBefore(child, anchor || null)\n}\n```\n\n#### 总结\n到这里，我们已经完成了从入口文件开始，分析根组件如何挂载渲染到真实 DOM 的流程，再简单通过一张流程图回顾一下上述内容，绿色部分是初始化的过程，也是本小节的内容，灰色部分我们后面章节再做介绍。\n\n然后我们再引用一下 Vue 官网上的一张渲染流程图：\n\n现在再来看这一张图，整体流程就会清晰了很多：在组件初始化挂载阶段，模板被编译成渲染函数的形式，交由渲染器执行，渲染器执行渲染函数得到 APP 组件对象的子树 vnode，子树 vnode 进行递归 patch 后生成不同类型的 DOM 节点，最后把这些 DOM 节点挂载到页面的 container 当中。\n\n关于具体的编译器和更新以及响应式的部分我们会在后续章节继续介绍。本节主要介绍了挂载过程，后面的小节我们接着介绍一下更新策略。","slug":"technical-disclosure-of-vue3/1-render-dom","published":0,"date":"2023-08-12T07:53:19.989Z","updated":"2023-08-12T07:53:19.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokc0009sovcajyz2jrd","content":"<!-- \ncreateApp\n  ensureRender\n    createRenderer\n      baseCreateRenderer\n        createAppAPI\n\n\napp.mount\n  mount\n    createVNode: createVNodeWithArgsTransform\n      _createVNode\n        createBaseVNode\n    render\n      patch\n        processComponent\n          mountComponent\n            setupRenderEffect\n              instance.update\n                run\n                  componentUpdateFn\n                    renderComponentRoot\n                      render(编译)\n            createComponentInstance \n            setupComponent\n              initProps\n              initSlots\n              setupStatefulComponent\n        processFragment\n          mountChildren\n        processElement\n          mountElement\n            createElement\n            patchProp\n            setElementText\n            hostInsert\n            mountChildren\n          updateElement\n          updateComponent\n -->\n\n<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>相对于传统的 jQuery 一把梭子撸到底的开发模式，组件化可以帮助我们实现 视图 和 逻辑 的复用，并且可以对每个部分进行单独的思考。对于一个大型的 Vue.js 应用，通常是由一个个组件组合而成：</p>\n<p>但是我们实际访问的页面，是由 DOM 元素构成的，而组件的 <code>&lt;template></code> 中的内容只是一个模板字符串而已。那模板字符串是如何被渲染成 DOM 的呢？接下来我们将从组件入手，揭秘 Vue 的组件是如何被渲染成真实的 DOM 的。</p>\n<h4 id=\"初始化一个-Vue-3-应用\"><a href=\"#初始化一个-Vue-3-应用\" class=\"headerlink\" title=\"初始化一个 Vue 3 应用\"></a>初始化一个 Vue 3 应用</h4><p>在开始本章节之前，我们先来简单初始化一个 Vue 3 的应用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 安装 vue cli </span><br><span class=\"line\">$ yarn global add @vue/cli</span><br><span class=\"line\"></span><br><span class=\"line\"># 创建 vue3 的基础脚手架 一路回车</span><br><span class=\"line\">$ vue create vue3-demo</span><br></pre></td></tr></table></figure>\n\n<p>接下来，打开项目，可以看到Vue.js 的入口文件 main.js 的内容如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createApp &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">App</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./App.vue&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">createApp</span>(<span class=\"title class_\">App</span>).<span class=\"title function_\">mount</span>(<span class=\"string\">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这里就有一个根组件 App.vue。为了更加简单地介绍 Vue 根组件的渲染过程，我把 App.vue 根组件进行了一个简单的修改：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;helloWorld&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    hello world</span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"title function_\">setup</span>(<span class=\"params\"></span>) &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"comment\">// ...</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">&#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"根组件模板编译\"><a href=\"#根组件模板编译\" class=\"headerlink\" title=\"根组件模板编译\"></a>根组件模板编译</h4><p>我们知道 .vue 类型的文件无法在 Web 端直接加载，我们通常会在 webpack 的编译阶段，通过 vue-loader 编译生成组件相关的 JavaScript 和 CSS，并把 template 部分编译转换成 render 函数添加到组件对象的属性中。</p>\n<p>上述的 App.vue 文件内的模板其实是会被编译工具在编译时转成一个渲染函数，大致如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; openBlock <span class=\"keyword\">as</span> _openBlock, createElementBlock <span class=\"keyword\">as</span> _createElementBlock &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;vue&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> _hoisted_1 = &#123; <span class=\"attr\">class</span>: <span class=\"string\">&quot;helloWorld&quot;</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"title function_\">_openBlock</span>(), <span class=\"title function_\">_createElementBlock</span>(<span class=\"string\">&quot;div&quot;</span>, _hoisted_1, <span class=\"string\">&quot; hello world &quot;</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于 &lt;template&gt; 中的模板字符串是如何被编译成 render 函数的，以及 _hoisted_1 是个什么玩意，我们将在后续章节中详细介绍。</p>\n<p>现在我们只需要知道 &lt;script&gt; 中的对象内容最终会和编译后的模板内容一起，生成一个 App 对象传入 createApp 函数中：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\">_ctx, _cache, $props, $setup, $data, $options</span>) &#123; </span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"title function_\">setup</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"对象组件渲染成真实的-DOM\"><a href=\"#对象组件渲染成真实的-DOM\" class=\"headerlink\" title=\"对象组件渲染成真实的 DOM\"></a>对象组件渲染成真实的 DOM</h4><p>接着回到 main.js 的入口文件，整个初始化的过程只剩下如下部分了：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">createApp</span>(<span class=\"title class_\">App</span>).<span class=\"title function_\">mount</span>(<span class=\"string\">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>打开源码，可以看一下 createApp 的过程：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-dom/src/index.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">createApp</span> = (<span class=\"params\">...args</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> app = <span class=\"title function_\">ensureRenderer</span>().<span class=\"title function_\">createApp</span>(...args);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> app;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>猜测一下，ensureRenderer().createApp(…args) 这个链式函数执行完成后肯定返回了 mount 函数，ensureRenderer 就是构造了一个带有 createApp 函数的渲染器 renderer 对象 ：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-dom/src/index.ts</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ensureRenderer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果 renderer 有值的话，那么以后都不会初始化了</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    renderer ||</span><br><span class=\"line\">    (renderer = <span class=\"title function_\">createRenderer</span>(rendererOptions)</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// renderOptions 包含以下函数：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> renderOptions = &#123;</span><br><span class=\"line\">  createElement,</span><br><span class=\"line\">  createText,</span><br><span class=\"line\">  setText,</span><br><span class=\"line\">  setElementText,</span><br><span class=\"line\">  patchProp,</span><br><span class=\"line\">  insert,</span><br><span class=\"line\">  remove,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里返回的 renderer 对象，可以认为是一个跨平台的渲染器对象，针对不同的平台，会创建出不同的 renderer 对象，上述是创建浏览器环境的 renderer 对象，对于服务端渲染的场景，则会创建 server render 的 renderer:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-dom/src/index.ts</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> enabledHydration = <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ensureHydrationRenderer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  renderer = enabledHydration</span><br><span class=\"line\">    ? renderer</span><br><span class=\"line\">    : <span class=\"title function_\">createHydrationRenderer</span>(rendererOptions)</span><br><span class=\"line\">  enabledHydration = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> renderer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再来看一下 createRenderer 返回的对象：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/renderer.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createRenderer</span>(<span class=\"params\">options</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 这里不介绍 hydrate 模式</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    render,</span><br><span class=\"line\">    hydrate,</span><br><span class=\"line\">    <span class=\"attr\">createApp</span>: <span class=\"title function_\">createAppAPI</span>(render, hydrate),</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，renderer 对象上包含了 createApp 和 render 方法。再来看一下 createApp 方法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/apiCreateApp.ts</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createAppAPI</span>(<span class=\"params\">render, hydrate</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// createApp createApp 方法接收的两个参数：根组件的对象和 prop</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createApp</span>(<span class=\"params\">rootComponent, rootProps = <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> app = &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... 省略很多不需要在这里介绍的属性</span></span><br><span class=\"line\">      <span class=\"attr\">_component</span>: rootComponent,</span><br><span class=\"line\">      <span class=\"attr\">_props</span>: rootProps,</span><br><span class=\"line\">      <span class=\"title function_\">mount</span>(<span class=\"params\">rootContainer, isHydrate, isSVG</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> app</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>直到这里，我们才真正拨开了 Vue 3 初始化根组件的核心方法，也就是入口文件 createApp 真正执行的内容就是这里的 createAppAPI 函数中的 createApp 函数，该函数接收了 <App /> 组件作为根组件 rootComponent，返回了一个包含 mount 方法的 app 对象。</p>\n<p>接下来再深入地看一下 mount 的内部实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/apiCreateApp.ts</span></span><br><span class=\"line\"><span class=\"title function_\">mount</span>(<span class=\"params\">rootContainer, isHydrate, isSVG</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isMounted) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... 省略部分不重要的代码</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. 创建根组件的 vnode</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> vnode = <span class=\"title function_\">createVNode</span>(</span><br><span class=\"line\">      rootComponent,</span><br><span class=\"line\">      rootProps</span><br><span class=\"line\">    )</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 2. 渲染根组件</span></span><br><span class=\"line\">    <span class=\"title function_\">render</span>(vnode, rootContainer, isSVG)</span><br><span class=\"line\">    isMounted = <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"1-创建根组件的-vnode\"><a href=\"#1-创建根组件的-vnode\" class=\"headerlink\" title=\"1. 创建根组件的 vnode\"></a>1. 创建根组件的 vnode</h5><p>什么是 vnode 节点呢？其实它和 Virtual DOM 是一个意思，就是将真实的 DOM 以普通对象形式的数据结构来表达，简化了很多 DOM 中内容。</p>\n<p>熟悉 JS DOM 编程的小伙伴都知道 JS 直接操作 DOM 往往会带来许多性能负担，所以 vnode 提供了对真实 DOM 上的一层虚拟映射，我们只需要操作这个虚拟的数据结构，那些真正费性能的活交给这些框架来操作就好了，框架会帮我们做很多性能优化的事情。这也是 vnode 带来的最大的优势之一。</p>\n<p>其次，因为 vnode 只是一种与平台无关的数据结构而已，所以理论上我们也可以将它渲染到不同平台上从而达到跨平台渲染的目的。这个也是 weex、mpvue 等跨端渲染框架的核心基础。</p>\n<p>上述例子中的 template 中的内容用 vnode 可以表示为：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> vnode = &#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&#x27;div&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123; </span><br><span class=\"line\">    <span class=\"string\">&#x27;class&#x27;</span>: <span class=\"string\">&#x27;helloWorld&#x27;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">children</span>: <span class=\"string\">&#x27;helloWorld&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>说了这么多，那么根节点是如何被创建成一个 vnode 的呢？核心也就在 createVNode 函数中：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/vnode.ts</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createBaseVNode</span>(<span class=\"params\">...</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> vnode = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">type</span>,</span><br><span class=\"line\">    props,</span><br><span class=\"line\">    <span class=\"attr\">key</span>: props &amp;&amp; <span class=\"title function_\">normalizeKey</span>(props),</span><br><span class=\"line\">    children,</span><br><span class=\"line\">    <span class=\"attr\">component</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    shapeFlag,</span><br><span class=\"line\">    patchFlag,</span><br><span class=\"line\">    dynamicProps,</span><br><span class=\"line\">    <span class=\"attr\">dynamicChildren</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"comment\">// ... 一些其他属性</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> vnode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createVNode</span>(<span class=\"params\"><span class=\"keyword\">type</span>, props = <span class=\"literal\">null</span>, children = <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (props) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果存在 props 则需要对 props 进行一些处理，这里先省略</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 处理 shapeFlag 类型</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> shapeFlag = <span class=\"title function_\">isString</span>(<span class=\"keyword\">type</span>)</span><br><span class=\"line\">    ? <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">ELEMENT</span></span><br><span class=\"line\">    : __FEATURE_SUSPENSE__ &amp;&amp; <span class=\"title function_\">isSuspense</span>(<span class=\"keyword\">type</span>)</span><br><span class=\"line\">    ? <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">SUSPENSE</span></span><br><span class=\"line\">    : <span class=\"title function_\">isTeleport</span>(<span class=\"keyword\">type</span>)</span><br><span class=\"line\">    ? <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">TELEPORT</span></span><br><span class=\"line\">    : <span class=\"title function_\">isObject</span>(<span class=\"keyword\">type</span>)</span><br><span class=\"line\">    ? <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">STATEFUL_COMPONENT</span></span><br><span class=\"line\">    : <span class=\"title function_\">isFunction</span>(<span class=\"keyword\">type</span>)</span><br><span class=\"line\">    ? <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">FUNCTIONAL_COMPONENT</span></span><br><span class=\"line\">    : <span class=\"number\">0</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">createBaseVNode</span>(</span><br><span class=\"line\">    <span class=\"keyword\">type</span>,</span><br><span class=\"line\">    props,</span><br><span class=\"line\">    children,</span><br><span class=\"line\">    patchFlag,</span><br><span class=\"line\">    dynamicProps,</span><br><span class=\"line\">    shapeFlag,</span><br><span class=\"line\">    isBlockNode,</span><br><span class=\"line\">    <span class=\"literal\">true</span></span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当进行根组件渲染的时候，createVNode 的第一个入参 type 是我们的 App 对象，也就是一个 Object，所以得到的 shapeFlag 的值是 STATEFUL_COMPONENT，代表的是一个有状态组件对象。（这里顺便提一下，如果传入的是个函数，那么就是一个函数式组件 FUNCTIONAL_COMPONENT，函数式组件和有状态的对象组件都是 Vue 可处理的组件类型，这个会在下面渲染阶段提及。）</p>\n<p>到这里，Vue 完成了对根组件的 Vnode 对象的创建，接下来要做的就是将该组件渲染到页面中。</p>\n<h5 id=\"2-VNode-渲染成真实的组件\"><a href=\"#2-VNode-渲染成真实的组件\" class=\"headerlink\" title=\"2. VNode 渲染成真实的组件\"></a>2. VNode 渲染成真实的组件</h5><p>回到 mount 函数中，接下来一步就是对 vnode 的渲染工作，核心代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">render</span>(vnode, rootContainer);</span><br></pre></td></tr></table></figure>\n\n<p>那么这里的 render 函数是什么呢？通过上面的代码我们发现，其实它是在调用 createAppAPI 时传入进来的，而 createAppAPI 则是在创建 renderer 渲染器的时候调用的。那么，接下来看看 render 函数的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/renderer.ts</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">render</span> = (<span class=\"params\">vnode, container</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (vnode == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 vnode 不存在，表示需要卸载组件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (container.<span class=\"property\">_vnode</span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">unmount</span>(container.<span class=\"property\">_vnode</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 否则进入更新流程（初始化创建也是特殊的一种更新）</span></span><br><span class=\"line\">    <span class=\"title function_\">patch</span>(container.<span class=\"property\">_vnode</span> || <span class=\"literal\">null</span>, vnode, container)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 缓存 vnode</span></span><br><span class=\"line\">  container.<span class=\"property\">_vnode</span> = vnode</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很明显，对于初始化根组件的过程中，传入了一个根组件的 vnode 对象，所以这里会执行 patch 相关的动作。patch 本意是补丁的意思，可以理解成为更新做一些补丁的活儿，其实初始的过程也可以看作是一个全量补丁，一种特殊的更新操作。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/renderer.ts</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">patch</span>(<span class=\"params\">n1,n2,container = <span class=\"literal\">null</span>,anchor = <span class=\"literal\">null</span>,parentComponent = <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 对于类型不同的新老节点，直接进行卸载</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n1 &amp;&amp; !<span class=\"title function_\">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class=\"line\">    anchor = <span class=\"title function_\">getNextHostNode</span>(n1)</span><br><span class=\"line\">    <span class=\"title function_\">unmount</span>(n1, parentComponent, parentSuspense, <span class=\"literal\">true</span>)</span><br><span class=\"line\">    n1 = <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 基于 n2 的类型来判断</span></span><br><span class=\"line\">  <span class=\"comment\">// 因为 n2 是新的 vnode</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">type</span>, shapeFlag &#125; = n2;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"title class_\">Text</span>:</span><br><span class=\"line\">       <span class=\"comment\">// 处理文本节点</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 其中还有几个类型比如： static fragment comment</span></span><br><span class=\"line\">    <span class=\"attr\">default</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 这里就基于 shapeFlag 来处理</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (shapeFlag &amp; <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">ELEMENT</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理普通 DOM 元素</span></span><br><span class=\"line\">        <span class=\"title function_\">processElement</span>(n1, n2, container, anchor, parentComponent);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (shapeFlag &amp; <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">COMPONENT</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理 component</span></span><br><span class=\"line\">        <span class=\"title function_\">processComponent</span>(n1, n2, container, parentComponent);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... 处理其他元素</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>patch 函数主要接收的参数说明如下：</p>\n<p>n1 表示老的 vnode 节点；<br>n2 表示新的 vnode 节点；<br>container 表示需要挂载的 dom 容器；<br>anchor 挂载的参考元素；<br>parentComponent 父组件。<br>这里我们主要关注前 3 个参数，因为是初始化的过程，所以 n1 本次值为空，核心看 n2 的值，n2 有一个 type 和 shapeFlag。当前 n2 的 type 是 App 组件对象，所以逻辑会进入 Switch 的 default 中。再比较 shapeFlag 属性，前面提到 shapeFlag 的值是 STATEFUL_COMPONENT。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">这里需要注意的是 ShapeFlags 是一个二进制左移操作符生成的对象，其中 ShapeFlags.COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT， 所以 shapeFlag &amp; ShapeFlags.COMPONENT 这里的值是 true，关于二进制左移操作符对象在 Vue 3 中会大量使用，后面也会详细介绍。</span><br></pre></td></tr></table></figure>\n\n<p>接着也就进入了 processComponent 的逻辑了：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/renderer.ts</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">processComponent</span>(<span class=\"params\">n1, n2, container, parentComponent</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果 n1 没有值的话，那么就是 mount</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!n1) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化 component</span></span><br><span class=\"line\">    <span class=\"title function_\">mountComponent</span>(n2, container, parentComponent);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">updateComponent</span>(n1, n2, container);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同理，这里我们只看初始化的逻辑，所以 n1 此时还是个空值，那么就会进入 mountComponent 函数对组件进行初始挂载过程。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/renderer.ts</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">mountComponent</span>(<span class=\"params\">initialVNode, container, parentComponent</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 先创建一个 component instance</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> instance = (initialVNode.<span class=\"property\">component</span> = <span class=\"title function_\">createComponentInstance</span>(</span><br><span class=\"line\">    initialVNode,</span><br><span class=\"line\">    parentComponent</span><br><span class=\"line\">  ));</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 2. 初始化 instance 上的 props, slots, 执行组件的 setup 函数...</span></span><br><span class=\"line\">  <span class=\"title function_\">setupComponent</span>(instance);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 设置并运行带副作用的渲染函数</span></span><br><span class=\"line\">  <span class=\"title function_\">setupRenderEffect</span>(instance, initialVNode, container);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该函数实现过程还是非常清晰的，思考一下，一个组件的初始化要做哪些内容呢？</p>\n<p>其实很容易想到，我们需要一个实例化的组件对象，该对象可以在 Vue 执行的运行时上下文中随时获取到，另外还需要对实例化后的组件中的属性做一些优化、处理、赋值等操作，最后，就是把组件实例的 render 函数执行一遍。</p>\n<p>上面也是 mountComponent 核心做的事情，我们一个个来看。</p>\n<p>第一步是组件实例化，在 Vue 3 中通过 createComponentInstance 的方法创建组件实例，返回的是一个组件实例的对象，大致包含以下属性：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/component.ts</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> instance = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里是组件对象</span></span><br><span class=\"line\">  <span class=\"attr\">type</span>: vnode.<span class=\"property\">type</span>, </span><br><span class=\"line\">  <span class=\"comment\">// 组件 vnode</span></span><br><span class=\"line\">  vnode,</span><br><span class=\"line\">  <span class=\"comment\">// 新的组件 vnode</span></span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"literal\">null</span>, </span><br><span class=\"line\">  <span class=\"comment\">// props 相关</span></span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123;&#125;, </span><br><span class=\"line\">  <span class=\"comment\">// 指向父组件</span></span><br><span class=\"line\">  parent,</span><br><span class=\"line\">  <span class=\"comment\">// 依赖注入相关</span></span><br><span class=\"line\">  <span class=\"attr\">provides</span>: parent ? parent.<span class=\"property\">provides</span> : &#123;&#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 渲染上下文代理</span></span><br><span class=\"line\">  <span class=\"attr\">proxy</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  <span class=\"comment\">// 标记是否被挂载</span></span><br><span class=\"line\">  <span class=\"attr\">isMounted</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"comment\">// attrs 相关</span></span><br><span class=\"line\">  <span class=\"attr\">attrs</span>: &#123;&#125;, </span><br><span class=\"line\">  <span class=\"comment\">// slots 相关</span></span><br><span class=\"line\">  <span class=\"attr\">slots</span>: &#123;&#125;, </span><br><span class=\"line\">  <span class=\"comment\">// context 相关</span></span><br><span class=\"line\">  <span class=\"attr\">ctx</span>: &#123;&#125;,</span><br><span class=\"line\">  <span class=\"comment\">// setup return 的状态数据</span></span><br><span class=\"line\">  <span class=\"attr\">setupState</span>: &#123;&#125;, </span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上述实例属性，相对源码而言，已经省略了很多内容了，这些属性现在看着肯定不知所云，头皮发麻。但相应的属性是 vue 在特定的场景和功能下才会用到的，相信你跟着本小册一起阅读后，回过头来再去看一遍这些属性，就会“顿悟”。</p>\n<p>然后是对实例化后的组件中的属性做一些优化、处理、赋值等操作，这里主要是初始化了 props、slots，并执行组件的 setup 函数，核心的实现和功能我们将在下一节介绍。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/component.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">setupComponent</span>(<span class=\"params\">instance</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 处理 props</span></span><br><span class=\"line\">  <span class=\"comment\">// 取出存在 vnode 里面的 props</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; props, children &#125; = instance.<span class=\"property\">vnode</span>;</span><br><span class=\"line\">  <span class=\"title function_\">initProps</span>(instance, props);</span><br><span class=\"line\">  <span class=\"comment\">// 2. 处理 slots</span></span><br><span class=\"line\">  <span class=\"title function_\">initSlots</span>(instance, children);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 调用 setup 并处理 setupResult</span></span><br><span class=\"line\">  <span class=\"title function_\">setupStatefulComponent</span>(instance);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后是把组件实例的 render 函数执行一遍，这里是通过 setupRenderEffect 来执行的。我们再看一下这个函数的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/renderer.ts</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">setupRenderEffect</span> = (<span class=\"params\">instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">componentUpdateFn</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!instance.<span class=\"property\">isMounted</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 渲染子树的 vnode</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> subTree = (instance.<span class=\"property\">subTree</span> = <span class=\"title function_\">renderComponentRoot</span>(instance))</span><br><span class=\"line\">      <span class=\"comment\">// 挂载子树 vnode 到 container 中</span></span><br><span class=\"line\">      <span class=\"title function_\">patch</span>(<span class=\"literal\">null</span>, subTree, container, anchor, instance, parentSuspense, isSVG)</span><br><span class=\"line\">      <span class=\"comment\">// 把渲染生成的子树根 DOM 节点存储到 el 属性上</span></span><br><span class=\"line\">      initialVNode.<span class=\"property\">el</span> = subTree.<span class=\"property\">el</span></span><br><span class=\"line\">      instance.<span class=\"property\">isMounted</span> = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 更新相关，后面介绍</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 创建副作用渲染函数</span></span><br><span class=\"line\">  instance.<span class=\"property\">update</span> = <span class=\"title function_\">effect</span>(componentUpdateFn, prodEffectOptions)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们再看一下 componentUpdateFn 这个函数，核心是调用了 renderComponentRoot 来生成 subTree，然后再把 subTree 挂载到 container 中。其实 renderComponentRoot 的核心工作就是执行 instance.render 方法，该方法前面我们已经说了，组件在编译时会生成组件对象，包含了 render 函数，该函数内部是一系列的渲染函数的执行：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; openBlock, createElementBlock &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;vue&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> _hoisted_1 = &#123; <span class=\"attr\">class</span>: <span class=\"string\">&quot;helloWorld&quot;</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">...</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"title function_\">openBlock</span>(), <span class=\"title function_\">createElementBlock</span>(<span class=\"string\">&quot;div&quot;</span>, _hoisted_1, <span class=\"string\">&quot; hello world &quot;</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么只需要看一下 createElementBlock 函数的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/vnode.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">createElementBlock</span> = (<span class=\"params\">...</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">setupBlock</span>(</span><br><span class=\"line\">    <span class=\"title function_\">createBaseVNode</span>(</span><br><span class=\"line\">      <span class=\"keyword\">type</span>,</span><br><span class=\"line\">      props,</span><br><span class=\"line\">      children,</span><br><span class=\"line\">      patchFlag,</span><br><span class=\"line\">      dynamicProps,</span><br><span class=\"line\">      shapeFlag,</span><br><span class=\"line\">      <span class=\"literal\">true</span> <span class=\"comment\">/* isBlock */</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到本质还是调用了 createBaseVNode 创新 vnode。所以，我们可以推导出 subtree 就是调用 render 函数而生产的 vnode 节点。这里需要注意的一点是，因为 subtree 调用的 createBaseVNode 创建时，传入的 type &#x3D; div 在这里是个 string，所以返回的 shapeFlags 的值是 ELEMENT。</p>\n<p>渲染生成子树 vnode 后，接下来就是继续调用 patch 函数把子树 vnode 挂载到 container 中了，前面说过了 patch 的实现，再来简单看一下当传入的 vnode 的 shapeFlags 是个 ELEMENT 时，会调用 processElement 这个函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (shapeFlag &amp; <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">ELEMENT</span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">processElement</span>(n1, n2, container, anchor, parentComponent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来看一下 processElement 的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/renderer.ts</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">processElement</span>(<span class=\"params\">n1, n2, container, anchor, parentComponent</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!n1) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 挂载元素节点</span></span><br><span class=\"line\">    <span class=\"title function_\">mountElement</span>(n2, container, anchor);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 更新元素节点</span></span><br><span class=\"line\">    <span class=\"title function_\">updateElement</span>(n1, n2, container, anchor, parentComponent);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为在初始化的过程中，n1 是 null，所以这里执行的是 mountElement 进行元素的初始化挂载。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/renderer.ts</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">mountElement</span> = (<span class=\"params\">vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> el</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">type</span>, props, shapeFlag, transition, patchFlag, dirs &#125; = vnode</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 根据 vnode 创建 DOM 节点</span></span><br><span class=\"line\">  el = vnode.<span class=\"property\">el</span> = <span class=\"title function_\">hostCreateElement</span>(vnode.<span class=\"property\">type</span>, isSVG, props &amp;&amp; props.<span class=\"property\">is</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (props) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理 props 属性</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> props) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"title function_\">isReservedProp</span>(key)) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">hostPatchProp</span>(el, key, <span class=\"literal\">null</span>, props[key], isSVG)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 文本节点处理</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shapeFlag &amp; <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">TEXT_CHILDREN</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">hostSetElementText</span>(el, vnode.<span class=\"property\">children</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (shapeFlag &amp; <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">ARRAY_CHILDREN</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果节点是个数据类型，则递归子节点</span></span><br><span class=\"line\">    <span class=\"title function_\">mountChildren</span>(vnode.<span class=\"property\">children</span>, el)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 把创建好的 el 元素挂载到容器中</span></span><br><span class=\"line\">  <span class=\"title function_\">hostInsert</span>(el, container, anchor)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>mountElemet 首先是通过 hostCreateElement 创建了一个 DOM 节点，然后处理一下 props 属性，接着根据 shapeFlag 判断子节点的类型，如果节点是个文本节点，则直接创建文本节点，如果子节点是个数组，比如这种情况：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> (<span class=\"title function_\">openBlock</span>(), <span class=\"title function_\">createElementBlock</span>(<span class=\"string\">&quot;div&quot;</span>, _hoisted_1, [</span><br><span class=\"line\">  hoisted_2,</span><br><span class=\"line\">  <span class=\"title function_\">createVNode</span>(_component_Hello)</span><br><span class=\"line\">]))</span><br></pre></td></tr></table></figure>\n\n<p>对于这种子节点是数组的情况时，它的 shapeFlag 将是一个数组类型 ARRAY_CHILDREN。此时会对该 vnode 节点的子节点调用 mountChildren 进行递归的 patch 渲染。</p>\n<p>最后，处理完所有子节点后，通过 hostInsert 方法把缓存在内存中的 DOM el 映射渲染到真实的 DOM Container 当中。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-dom/src/nodeOps.ts</span></span><br><span class=\"line\"><span class=\"attr\">insert</span>: (child, parent, anchor) &#123;</span><br><span class=\"line\">  parent.<span class=\"title function_\">insertBefore</span>(child, anchor || <span class=\"literal\">null</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>到这里，我们已经完成了从入口文件开始，分析根组件如何挂载渲染到真实 DOM 的流程，再简单通过一张流程图回顾一下上述内容，绿色部分是初始化的过程，也是本小节的内容，灰色部分我们后面章节再做介绍。</p>\n<p>然后我们再引用一下 Vue 官网上的一张渲染流程图：</p>\n<p>现在再来看这一张图，整体流程就会清晰了很多：在组件初始化挂载阶段，模板被编译成渲染函数的形式，交由渲染器执行，渲染器执行渲染函数得到 APP 组件对象的子树 vnode，子树 vnode 进行递归 patch 后生成不同类型的 DOM 节点，最后把这些 DOM 节点挂载到页面的 container 当中。</p>\n<p>关于具体的编译器和更新以及响应式的部分我们会在后续章节继续介绍。本节主要介绍了挂载过程，后面的小节我们接着介绍一下更新策略。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":"<!-- \ncreateApp\n  ensureRender\n    createRenderer\n      baseCreateRenderer\n        createAppAPI\n\n\napp.mount\n  mount\n    createVNode: createVNodeWithArgsTransform\n      _createVNode\n        createBaseVNode\n    render\n      patch\n        processComponent\n          mountComponent\n            setupRenderEffect\n              instance.update\n                run\n                  componentUpdateFn\n                    renderComponentRoot\n                      render(编译)\n            createComponentInstance \n            setupComponent\n              initProps\n              initSlots\n              setupStatefulComponent\n        processFragment\n          mountChildren\n        processElement\n          mountElement\n            createElement\n            patchProp\n            setElementText\n            hostInsert\n            mountChildren\n          updateElement\n          updateComponent\n -->\n\n<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>相对于传统的 jQuery 一把梭子撸到底的开发模式，组件化可以帮助我们实现 视图 和 逻辑 的复用，并且可以对每个部分进行单独的思考。对于一个大型的 Vue.js 应用，通常是由一个个组件组合而成：</p>\n<p>但是我们实际访问的页面，是由 DOM 元素构成的，而组件的 <code>&lt;template></code> 中的内容只是一个模板字符串而已。那模板字符串是如何被渲染成 DOM 的呢？接下来我们将从组件入手，揭秘 Vue 的组件是如何被渲染成真实的 DOM 的。</p>\n<h4 id=\"初始化一个-Vue-3-应用\"><a href=\"#初始化一个-Vue-3-应用\" class=\"headerlink\" title=\"初始化一个 Vue 3 应用\"></a>初始化一个 Vue 3 应用</h4><p>在开始本章节之前，我们先来简单初始化一个 Vue 3 的应用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 安装 vue cli </span><br><span class=\"line\">$ yarn global add @vue/cli</span><br><span class=\"line\"></span><br><span class=\"line\"># 创建 vue3 的基础脚手架 一路回车</span><br><span class=\"line\">$ vue create vue3-demo</span><br></pre></td></tr></table></figure>\n\n<p>接下来，打开项目，可以看到Vue.js 的入口文件 main.js 的内容如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createApp &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">App</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./App.vue&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">createApp</span>(<span class=\"title class_\">App</span>).<span class=\"title function_\">mount</span>(<span class=\"string\">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这里就有一个根组件 App.vue。为了更加简单地介绍 Vue 根组件的渲染过程，我把 App.vue 根组件进行了一个简单的修改：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;helloWorld&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    hello world</span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"title function_\">setup</span>(<span class=\"params\"></span>) &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"comment\">// ...</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">&#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"根组件模板编译\"><a href=\"#根组件模板编译\" class=\"headerlink\" title=\"根组件模板编译\"></a>根组件模板编译</h4><p>我们知道 .vue 类型的文件无法在 Web 端直接加载，我们通常会在 webpack 的编译阶段，通过 vue-loader 编译生成组件相关的 JavaScript 和 CSS，并把 template 部分编译转换成 render 函数添加到组件对象的属性中。</p>\n<p>上述的 App.vue 文件内的模板其实是会被编译工具在编译时转成一个渲染函数，大致如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; openBlock <span class=\"keyword\">as</span> _openBlock, createElementBlock <span class=\"keyword\">as</span> _createElementBlock &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;vue&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> _hoisted_1 = &#123; <span class=\"attr\">class</span>: <span class=\"string\">&quot;helloWorld&quot;</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"title function_\">_openBlock</span>(), <span class=\"title function_\">_createElementBlock</span>(<span class=\"string\">&quot;div&quot;</span>, _hoisted_1, <span class=\"string\">&quot; hello world &quot;</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于 &lt;template&gt; 中的模板字符串是如何被编译成 render 函数的，以及 _hoisted_1 是个什么玩意，我们将在后续章节中详细介绍。</p>\n<p>现在我们只需要知道 &lt;script&gt; 中的对象内容最终会和编译后的模板内容一起，生成一个 App 对象传入 createApp 函数中：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\">_ctx, _cache, $props, $setup, $data, $options</span>) &#123; </span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"title function_\">setup</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"对象组件渲染成真实的-DOM\"><a href=\"#对象组件渲染成真实的-DOM\" class=\"headerlink\" title=\"对象组件渲染成真实的 DOM\"></a>对象组件渲染成真实的 DOM</h4><p>接着回到 main.js 的入口文件，整个初始化的过程只剩下如下部分了：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">createApp</span>(<span class=\"title class_\">App</span>).<span class=\"title function_\">mount</span>(<span class=\"string\">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>打开源码，可以看一下 createApp 的过程：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-dom/src/index.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">createApp</span> = (<span class=\"params\">...args</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> app = <span class=\"title function_\">ensureRenderer</span>().<span class=\"title function_\">createApp</span>(...args);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> app;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>猜测一下，ensureRenderer().createApp(…args) 这个链式函数执行完成后肯定返回了 mount 函数，ensureRenderer 就是构造了一个带有 createApp 函数的渲染器 renderer 对象 ：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-dom/src/index.ts</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ensureRenderer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果 renderer 有值的话，那么以后都不会初始化了</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    renderer ||</span><br><span class=\"line\">    (renderer = <span class=\"title function_\">createRenderer</span>(rendererOptions)</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// renderOptions 包含以下函数：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> renderOptions = &#123;</span><br><span class=\"line\">  createElement,</span><br><span class=\"line\">  createText,</span><br><span class=\"line\">  setText,</span><br><span class=\"line\">  setElementText,</span><br><span class=\"line\">  patchProp,</span><br><span class=\"line\">  insert,</span><br><span class=\"line\">  remove,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里返回的 renderer 对象，可以认为是一个跨平台的渲染器对象，针对不同的平台，会创建出不同的 renderer 对象，上述是创建浏览器环境的 renderer 对象，对于服务端渲染的场景，则会创建 server render 的 renderer:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-dom/src/index.ts</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> enabledHydration = <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ensureHydrationRenderer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  renderer = enabledHydration</span><br><span class=\"line\">    ? renderer</span><br><span class=\"line\">    : <span class=\"title function_\">createHydrationRenderer</span>(rendererOptions)</span><br><span class=\"line\">  enabledHydration = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> renderer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再来看一下 createRenderer 返回的对象：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/renderer.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createRenderer</span>(<span class=\"params\">options</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 这里不介绍 hydrate 模式</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    render,</span><br><span class=\"line\">    hydrate,</span><br><span class=\"line\">    <span class=\"attr\">createApp</span>: <span class=\"title function_\">createAppAPI</span>(render, hydrate),</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，renderer 对象上包含了 createApp 和 render 方法。再来看一下 createApp 方法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/apiCreateApp.ts</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createAppAPI</span>(<span class=\"params\">render, hydrate</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// createApp createApp 方法接收的两个参数：根组件的对象和 prop</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createApp</span>(<span class=\"params\">rootComponent, rootProps = <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> app = &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... 省略很多不需要在这里介绍的属性</span></span><br><span class=\"line\">      <span class=\"attr\">_component</span>: rootComponent,</span><br><span class=\"line\">      <span class=\"attr\">_props</span>: rootProps,</span><br><span class=\"line\">      <span class=\"title function_\">mount</span>(<span class=\"params\">rootContainer, isHydrate, isSVG</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> app</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>直到这里，我们才真正拨开了 Vue 3 初始化根组件的核心方法，也就是入口文件 createApp 真正执行的内容就是这里的 createAppAPI 函数中的 createApp 函数，该函数接收了 <App /> 组件作为根组件 rootComponent，返回了一个包含 mount 方法的 app 对象。</p>\n<p>接下来再深入地看一下 mount 的内部实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/apiCreateApp.ts</span></span><br><span class=\"line\"><span class=\"title function_\">mount</span>(<span class=\"params\">rootContainer, isHydrate, isSVG</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isMounted) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... 省略部分不重要的代码</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. 创建根组件的 vnode</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> vnode = <span class=\"title function_\">createVNode</span>(</span><br><span class=\"line\">      rootComponent,</span><br><span class=\"line\">      rootProps</span><br><span class=\"line\">    )</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 2. 渲染根组件</span></span><br><span class=\"line\">    <span class=\"title function_\">render</span>(vnode, rootContainer, isSVG)</span><br><span class=\"line\">    isMounted = <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"1-创建根组件的-vnode\"><a href=\"#1-创建根组件的-vnode\" class=\"headerlink\" title=\"1. 创建根组件的 vnode\"></a>1. 创建根组件的 vnode</h5><p>什么是 vnode 节点呢？其实它和 Virtual DOM 是一个意思，就是将真实的 DOM 以普通对象形式的数据结构来表达，简化了很多 DOM 中内容。</p>\n<p>熟悉 JS DOM 编程的小伙伴都知道 JS 直接操作 DOM 往往会带来许多性能负担，所以 vnode 提供了对真实 DOM 上的一层虚拟映射，我们只需要操作这个虚拟的数据结构，那些真正费性能的活交给这些框架来操作就好了，框架会帮我们做很多性能优化的事情。这也是 vnode 带来的最大的优势之一。</p>\n<p>其次，因为 vnode 只是一种与平台无关的数据结构而已，所以理论上我们也可以将它渲染到不同平台上从而达到跨平台渲染的目的。这个也是 weex、mpvue 等跨端渲染框架的核心基础。</p>\n<p>上述例子中的 template 中的内容用 vnode 可以表示为：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> vnode = &#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&#x27;div&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123; </span><br><span class=\"line\">    <span class=\"string\">&#x27;class&#x27;</span>: <span class=\"string\">&#x27;helloWorld&#x27;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">children</span>: <span class=\"string\">&#x27;helloWorld&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>说了这么多，那么根节点是如何被创建成一个 vnode 的呢？核心也就在 createVNode 函数中：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/vnode.ts</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createBaseVNode</span>(<span class=\"params\">...</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> vnode = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">type</span>,</span><br><span class=\"line\">    props,</span><br><span class=\"line\">    <span class=\"attr\">key</span>: props &amp;&amp; <span class=\"title function_\">normalizeKey</span>(props),</span><br><span class=\"line\">    children,</span><br><span class=\"line\">    <span class=\"attr\">component</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    shapeFlag,</span><br><span class=\"line\">    patchFlag,</span><br><span class=\"line\">    dynamicProps,</span><br><span class=\"line\">    <span class=\"attr\">dynamicChildren</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"comment\">// ... 一些其他属性</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> vnode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createVNode</span>(<span class=\"params\"><span class=\"keyword\">type</span>, props = <span class=\"literal\">null</span>, children = <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (props) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果存在 props 则需要对 props 进行一些处理，这里先省略</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 处理 shapeFlag 类型</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> shapeFlag = <span class=\"title function_\">isString</span>(<span class=\"keyword\">type</span>)</span><br><span class=\"line\">    ? <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">ELEMENT</span></span><br><span class=\"line\">    : __FEATURE_SUSPENSE__ &amp;&amp; <span class=\"title function_\">isSuspense</span>(<span class=\"keyword\">type</span>)</span><br><span class=\"line\">    ? <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">SUSPENSE</span></span><br><span class=\"line\">    : <span class=\"title function_\">isTeleport</span>(<span class=\"keyword\">type</span>)</span><br><span class=\"line\">    ? <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">TELEPORT</span></span><br><span class=\"line\">    : <span class=\"title function_\">isObject</span>(<span class=\"keyword\">type</span>)</span><br><span class=\"line\">    ? <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">STATEFUL_COMPONENT</span></span><br><span class=\"line\">    : <span class=\"title function_\">isFunction</span>(<span class=\"keyword\">type</span>)</span><br><span class=\"line\">    ? <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">FUNCTIONAL_COMPONENT</span></span><br><span class=\"line\">    : <span class=\"number\">0</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">createBaseVNode</span>(</span><br><span class=\"line\">    <span class=\"keyword\">type</span>,</span><br><span class=\"line\">    props,</span><br><span class=\"line\">    children,</span><br><span class=\"line\">    patchFlag,</span><br><span class=\"line\">    dynamicProps,</span><br><span class=\"line\">    shapeFlag,</span><br><span class=\"line\">    isBlockNode,</span><br><span class=\"line\">    <span class=\"literal\">true</span></span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当进行根组件渲染的时候，createVNode 的第一个入参 type 是我们的 App 对象，也就是一个 Object，所以得到的 shapeFlag 的值是 STATEFUL_COMPONENT，代表的是一个有状态组件对象。（这里顺便提一下，如果传入的是个函数，那么就是一个函数式组件 FUNCTIONAL_COMPONENT，函数式组件和有状态的对象组件都是 Vue 可处理的组件类型，这个会在下面渲染阶段提及。）</p>\n<p>到这里，Vue 完成了对根组件的 Vnode 对象的创建，接下来要做的就是将该组件渲染到页面中。</p>\n<h5 id=\"2-VNode-渲染成真实的组件\"><a href=\"#2-VNode-渲染成真实的组件\" class=\"headerlink\" title=\"2. VNode 渲染成真实的组件\"></a>2. VNode 渲染成真实的组件</h5><p>回到 mount 函数中，接下来一步就是对 vnode 的渲染工作，核心代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">render</span>(vnode, rootContainer);</span><br></pre></td></tr></table></figure>\n\n<p>那么这里的 render 函数是什么呢？通过上面的代码我们发现，其实它是在调用 createAppAPI 时传入进来的，而 createAppAPI 则是在创建 renderer 渲染器的时候调用的。那么，接下来看看 render 函数的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/renderer.ts</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">render</span> = (<span class=\"params\">vnode, container</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (vnode == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 vnode 不存在，表示需要卸载组件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (container.<span class=\"property\">_vnode</span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">unmount</span>(container.<span class=\"property\">_vnode</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 否则进入更新流程（初始化创建也是特殊的一种更新）</span></span><br><span class=\"line\">    <span class=\"title function_\">patch</span>(container.<span class=\"property\">_vnode</span> || <span class=\"literal\">null</span>, vnode, container)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 缓存 vnode</span></span><br><span class=\"line\">  container.<span class=\"property\">_vnode</span> = vnode</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很明显，对于初始化根组件的过程中，传入了一个根组件的 vnode 对象，所以这里会执行 patch 相关的动作。patch 本意是补丁的意思，可以理解成为更新做一些补丁的活儿，其实初始的过程也可以看作是一个全量补丁，一种特殊的更新操作。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/renderer.ts</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">patch</span>(<span class=\"params\">n1,n2,container = <span class=\"literal\">null</span>,anchor = <span class=\"literal\">null</span>,parentComponent = <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 对于类型不同的新老节点，直接进行卸载</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n1 &amp;&amp; !<span class=\"title function_\">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class=\"line\">    anchor = <span class=\"title function_\">getNextHostNode</span>(n1)</span><br><span class=\"line\">    <span class=\"title function_\">unmount</span>(n1, parentComponent, parentSuspense, <span class=\"literal\">true</span>)</span><br><span class=\"line\">    n1 = <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 基于 n2 的类型来判断</span></span><br><span class=\"line\">  <span class=\"comment\">// 因为 n2 是新的 vnode</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">type</span>, shapeFlag &#125; = n2;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"title class_\">Text</span>:</span><br><span class=\"line\">       <span class=\"comment\">// 处理文本节点</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 其中还有几个类型比如： static fragment comment</span></span><br><span class=\"line\">    <span class=\"attr\">default</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 这里就基于 shapeFlag 来处理</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (shapeFlag &amp; <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">ELEMENT</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理普通 DOM 元素</span></span><br><span class=\"line\">        <span class=\"title function_\">processElement</span>(n1, n2, container, anchor, parentComponent);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (shapeFlag &amp; <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">COMPONENT</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理 component</span></span><br><span class=\"line\">        <span class=\"title function_\">processComponent</span>(n1, n2, container, parentComponent);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... 处理其他元素</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>patch 函数主要接收的参数说明如下：</p>\n<p>n1 表示老的 vnode 节点；<br>n2 表示新的 vnode 节点；<br>container 表示需要挂载的 dom 容器；<br>anchor 挂载的参考元素；<br>parentComponent 父组件。<br>这里我们主要关注前 3 个参数，因为是初始化的过程，所以 n1 本次值为空，核心看 n2 的值，n2 有一个 type 和 shapeFlag。当前 n2 的 type 是 App 组件对象，所以逻辑会进入 Switch 的 default 中。再比较 shapeFlag 属性，前面提到 shapeFlag 的值是 STATEFUL_COMPONENT。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">这里需要注意的是 ShapeFlags 是一个二进制左移操作符生成的对象，其中 ShapeFlags.COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT， 所以 shapeFlag &amp; ShapeFlags.COMPONENT 这里的值是 true，关于二进制左移操作符对象在 Vue 3 中会大量使用，后面也会详细介绍。</span><br></pre></td></tr></table></figure>\n\n<p>接着也就进入了 processComponent 的逻辑了：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/renderer.ts</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">processComponent</span>(<span class=\"params\">n1, n2, container, parentComponent</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果 n1 没有值的话，那么就是 mount</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!n1) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化 component</span></span><br><span class=\"line\">    <span class=\"title function_\">mountComponent</span>(n2, container, parentComponent);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">updateComponent</span>(n1, n2, container);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同理，这里我们只看初始化的逻辑，所以 n1 此时还是个空值，那么就会进入 mountComponent 函数对组件进行初始挂载过程。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/renderer.ts</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">mountComponent</span>(<span class=\"params\">initialVNode, container, parentComponent</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 先创建一个 component instance</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> instance = (initialVNode.<span class=\"property\">component</span> = <span class=\"title function_\">createComponentInstance</span>(</span><br><span class=\"line\">    initialVNode,</span><br><span class=\"line\">    parentComponent</span><br><span class=\"line\">  ));</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 2. 初始化 instance 上的 props, slots, 执行组件的 setup 函数...</span></span><br><span class=\"line\">  <span class=\"title function_\">setupComponent</span>(instance);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 设置并运行带副作用的渲染函数</span></span><br><span class=\"line\">  <span class=\"title function_\">setupRenderEffect</span>(instance, initialVNode, container);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该函数实现过程还是非常清晰的，思考一下，一个组件的初始化要做哪些内容呢？</p>\n<p>其实很容易想到，我们需要一个实例化的组件对象，该对象可以在 Vue 执行的运行时上下文中随时获取到，另外还需要对实例化后的组件中的属性做一些优化、处理、赋值等操作，最后，就是把组件实例的 render 函数执行一遍。</p>\n<p>上面也是 mountComponent 核心做的事情，我们一个个来看。</p>\n<p>第一步是组件实例化，在 Vue 3 中通过 createComponentInstance 的方法创建组件实例，返回的是一个组件实例的对象，大致包含以下属性：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/component.ts</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> instance = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里是组件对象</span></span><br><span class=\"line\">  <span class=\"attr\">type</span>: vnode.<span class=\"property\">type</span>, </span><br><span class=\"line\">  <span class=\"comment\">// 组件 vnode</span></span><br><span class=\"line\">  vnode,</span><br><span class=\"line\">  <span class=\"comment\">// 新的组件 vnode</span></span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"literal\">null</span>, </span><br><span class=\"line\">  <span class=\"comment\">// props 相关</span></span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123;&#125;, </span><br><span class=\"line\">  <span class=\"comment\">// 指向父组件</span></span><br><span class=\"line\">  parent,</span><br><span class=\"line\">  <span class=\"comment\">// 依赖注入相关</span></span><br><span class=\"line\">  <span class=\"attr\">provides</span>: parent ? parent.<span class=\"property\">provides</span> : &#123;&#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 渲染上下文代理</span></span><br><span class=\"line\">  <span class=\"attr\">proxy</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  <span class=\"comment\">// 标记是否被挂载</span></span><br><span class=\"line\">  <span class=\"attr\">isMounted</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"comment\">// attrs 相关</span></span><br><span class=\"line\">  <span class=\"attr\">attrs</span>: &#123;&#125;, </span><br><span class=\"line\">  <span class=\"comment\">// slots 相关</span></span><br><span class=\"line\">  <span class=\"attr\">slots</span>: &#123;&#125;, </span><br><span class=\"line\">  <span class=\"comment\">// context 相关</span></span><br><span class=\"line\">  <span class=\"attr\">ctx</span>: &#123;&#125;,</span><br><span class=\"line\">  <span class=\"comment\">// setup return 的状态数据</span></span><br><span class=\"line\">  <span class=\"attr\">setupState</span>: &#123;&#125;, </span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上述实例属性，相对源码而言，已经省略了很多内容了，这些属性现在看着肯定不知所云，头皮发麻。但相应的属性是 vue 在特定的场景和功能下才会用到的，相信你跟着本小册一起阅读后，回过头来再去看一遍这些属性，就会“顿悟”。</p>\n<p>然后是对实例化后的组件中的属性做一些优化、处理、赋值等操作，这里主要是初始化了 props、slots，并执行组件的 setup 函数，核心的实现和功能我们将在下一节介绍。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/component.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">setupComponent</span>(<span class=\"params\">instance</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 处理 props</span></span><br><span class=\"line\">  <span class=\"comment\">// 取出存在 vnode 里面的 props</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; props, children &#125; = instance.<span class=\"property\">vnode</span>;</span><br><span class=\"line\">  <span class=\"title function_\">initProps</span>(instance, props);</span><br><span class=\"line\">  <span class=\"comment\">// 2. 处理 slots</span></span><br><span class=\"line\">  <span class=\"title function_\">initSlots</span>(instance, children);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 调用 setup 并处理 setupResult</span></span><br><span class=\"line\">  <span class=\"title function_\">setupStatefulComponent</span>(instance);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后是把组件实例的 render 函数执行一遍，这里是通过 setupRenderEffect 来执行的。我们再看一下这个函数的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/renderer.ts</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">setupRenderEffect</span> = (<span class=\"params\">instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">componentUpdateFn</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!instance.<span class=\"property\">isMounted</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 渲染子树的 vnode</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> subTree = (instance.<span class=\"property\">subTree</span> = <span class=\"title function_\">renderComponentRoot</span>(instance))</span><br><span class=\"line\">      <span class=\"comment\">// 挂载子树 vnode 到 container 中</span></span><br><span class=\"line\">      <span class=\"title function_\">patch</span>(<span class=\"literal\">null</span>, subTree, container, anchor, instance, parentSuspense, isSVG)</span><br><span class=\"line\">      <span class=\"comment\">// 把渲染生成的子树根 DOM 节点存储到 el 属性上</span></span><br><span class=\"line\">      initialVNode.<span class=\"property\">el</span> = subTree.<span class=\"property\">el</span></span><br><span class=\"line\">      instance.<span class=\"property\">isMounted</span> = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 更新相关，后面介绍</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 创建副作用渲染函数</span></span><br><span class=\"line\">  instance.<span class=\"property\">update</span> = <span class=\"title function_\">effect</span>(componentUpdateFn, prodEffectOptions)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们再看一下 componentUpdateFn 这个函数，核心是调用了 renderComponentRoot 来生成 subTree，然后再把 subTree 挂载到 container 中。其实 renderComponentRoot 的核心工作就是执行 instance.render 方法，该方法前面我们已经说了，组件在编译时会生成组件对象，包含了 render 函数，该函数内部是一系列的渲染函数的执行：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; openBlock, createElementBlock &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;vue&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> _hoisted_1 = &#123; <span class=\"attr\">class</span>: <span class=\"string\">&quot;helloWorld&quot;</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">...</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"title function_\">openBlock</span>(), <span class=\"title function_\">createElementBlock</span>(<span class=\"string\">&quot;div&quot;</span>, _hoisted_1, <span class=\"string\">&quot; hello world &quot;</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么只需要看一下 createElementBlock 函数的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/vnode.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">createElementBlock</span> = (<span class=\"params\">...</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">setupBlock</span>(</span><br><span class=\"line\">    <span class=\"title function_\">createBaseVNode</span>(</span><br><span class=\"line\">      <span class=\"keyword\">type</span>,</span><br><span class=\"line\">      props,</span><br><span class=\"line\">      children,</span><br><span class=\"line\">      patchFlag,</span><br><span class=\"line\">      dynamicProps,</span><br><span class=\"line\">      shapeFlag,</span><br><span class=\"line\">      <span class=\"literal\">true</span> <span class=\"comment\">/* isBlock */</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到本质还是调用了 createBaseVNode 创新 vnode。所以，我们可以推导出 subtree 就是调用 render 函数而生产的 vnode 节点。这里需要注意的一点是，因为 subtree 调用的 createBaseVNode 创建时，传入的 type &#x3D; div 在这里是个 string，所以返回的 shapeFlags 的值是 ELEMENT。</p>\n<p>渲染生成子树 vnode 后，接下来就是继续调用 patch 函数把子树 vnode 挂载到 container 中了，前面说过了 patch 的实现，再来简单看一下当传入的 vnode 的 shapeFlags 是个 ELEMENT 时，会调用 processElement 这个函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (shapeFlag &amp; <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">ELEMENT</span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">processElement</span>(n1, n2, container, anchor, parentComponent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来看一下 processElement 的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/renderer.ts</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">processElement</span>(<span class=\"params\">n1, n2, container, anchor, parentComponent</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!n1) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 挂载元素节点</span></span><br><span class=\"line\">    <span class=\"title function_\">mountElement</span>(n2, container, anchor);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 更新元素节点</span></span><br><span class=\"line\">    <span class=\"title function_\">updateElement</span>(n1, n2, container, anchor, parentComponent);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为在初始化的过程中，n1 是 null，所以这里执行的是 mountElement 进行元素的初始化挂载。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-core/src/renderer.ts</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">mountElement</span> = (<span class=\"params\">vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> el</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">type</span>, props, shapeFlag, transition, patchFlag, dirs &#125; = vnode</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 根据 vnode 创建 DOM 节点</span></span><br><span class=\"line\">  el = vnode.<span class=\"property\">el</span> = <span class=\"title function_\">hostCreateElement</span>(vnode.<span class=\"property\">type</span>, isSVG, props &amp;&amp; props.<span class=\"property\">is</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (props) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理 props 属性</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> props) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"title function_\">isReservedProp</span>(key)) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">hostPatchProp</span>(el, key, <span class=\"literal\">null</span>, props[key], isSVG)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 文本节点处理</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shapeFlag &amp; <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">TEXT_CHILDREN</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">hostSetElementText</span>(el, vnode.<span class=\"property\">children</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (shapeFlag &amp; <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">ARRAY_CHILDREN</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果节点是个数据类型，则递归子节点</span></span><br><span class=\"line\">    <span class=\"title function_\">mountChildren</span>(vnode.<span class=\"property\">children</span>, el)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 把创建好的 el 元素挂载到容器中</span></span><br><span class=\"line\">  <span class=\"title function_\">hostInsert</span>(el, container, anchor)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>mountElemet 首先是通过 hostCreateElement 创建了一个 DOM 节点，然后处理一下 props 属性，接着根据 shapeFlag 判断子节点的类型，如果节点是个文本节点，则直接创建文本节点，如果子节点是个数组，比如这种情况：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> (<span class=\"title function_\">openBlock</span>(), <span class=\"title function_\">createElementBlock</span>(<span class=\"string\">&quot;div&quot;</span>, _hoisted_1, [</span><br><span class=\"line\">  hoisted_2,</span><br><span class=\"line\">  <span class=\"title function_\">createVNode</span>(_component_Hello)</span><br><span class=\"line\">]))</span><br></pre></td></tr></table></figure>\n\n<p>对于这种子节点是数组的情况时，它的 shapeFlag 将是一个数组类型 ARRAY_CHILDREN。此时会对该 vnode 节点的子节点调用 mountChildren 进行递归的 patch 渲染。</p>\n<p>最后，处理完所有子节点后，通过 hostInsert 方法把缓存在内存中的 DOM el 映射渲染到真实的 DOM Container 当中。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// packages/runtime-dom/src/nodeOps.ts</span></span><br><span class=\"line\"><span class=\"attr\">insert</span>: (child, parent, anchor) &#123;</span><br><span class=\"line\">  parent.<span class=\"title function_\">insertBefore</span>(child, anchor || <span class=\"literal\">null</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>到这里，我们已经完成了从入口文件开始，分析根组件如何挂载渲染到真实 DOM 的流程，再简单通过一张流程图回顾一下上述内容，绿色部分是初始化的过程，也是本小节的内容，灰色部分我们后面章节再做介绍。</p>\n<p>然后我们再引用一下 Vue 官网上的一张渲染流程图：</p>\n<p>现在再来看这一张图，整体流程就会清晰了很多：在组件初始化挂载阶段，模板被编译成渲染函数的形式，交由渲染器执行，渲染器执行渲染函数得到 APP 组件对象的子树 vnode，子树 vnode 进行递归 patch 后生成不同类型的 DOM 节点，最后把这些 DOM 节点挂载到页面的 container 当中。</p>\n<p>关于具体的编译器和更新以及响应式的部分我们会在后续章节继续介绍。本节主要介绍了挂载过程，后面的小节我们接着介绍一下更新策略。</p>\n"},{"_content":"<!-- \ncompile\n  baseCompile\n    isString\n    baseParse\n      createParserContext\n        extend\n      getCursor\n      createRoot\n      parseChildren\n        last\n        isEnd\n        startsWith\n        emitError\n        parseInterpolation\n          emitError\n          getCursor\n          advanceBy\n          parseTextData\n          advancePositionWithMutation\n          getSelection\n        parseComment\n        parseBogusComment\n        parseCDATA\n        parseBogusComment\n        advanceBy\n        parseTag\n          getCursor\n          context.options.getNamespace\n          advanceBy\n          advanceSpaces\n          parseAttributes\n          emitError\n          startsWith\n          isComponent\n          getSelection\n        parseElement\n          last\n          parseTag\n          context.options.isVoidTag\n          context.options.getTextMode\n          parseChildren\n          startsWithEndTagOpen\n          parseTag\n          getSelection\n        ErrorCodes\n        parseText\n          getCursor\n          parseTextData\n          getSelection\n        isArray\n        pushNode\n      getSelection\n    getBaseTransformPreset\n    transform\n    extend\n    generate\n  extend\n -->","source":"_drafts/technical-disclosure-of-vue3/12-template-to-ast.md","raw":"<!-- \ncompile\n  baseCompile\n    isString\n    baseParse\n      createParserContext\n        extend\n      getCursor\n      createRoot\n      parseChildren\n        last\n        isEnd\n        startsWith\n        emitError\n        parseInterpolation\n          emitError\n          getCursor\n          advanceBy\n          parseTextData\n          advancePositionWithMutation\n          getSelection\n        parseComment\n        parseBogusComment\n        parseCDATA\n        parseBogusComment\n        advanceBy\n        parseTag\n          getCursor\n          context.options.getNamespace\n          advanceBy\n          advanceSpaces\n          parseAttributes\n          emitError\n          startsWith\n          isComponent\n          getSelection\n        parseElement\n          last\n          parseTag\n          context.options.isVoidTag\n          context.options.getTextMode\n          parseChildren\n          startsWithEndTagOpen\n          parseTag\n          getSelection\n        ErrorCodes\n        parseText\n          getCursor\n          parseTextData\n          getSelection\n        isArray\n        pushNode\n      getSelection\n    getBaseTransformPreset\n    transform\n    extend\n    generate\n  extend\n -->","slug":"technical-disclosure-of-vue3/12-template-to-ast","published":0,"date":"2023-08-12T07:53:19.989Z","updated":"2023-08-12T07:53:19.989Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokd000bsovc771nccl5","content":"<!-- \ncompile\n  baseCompile\n    isString\n    baseParse\n      createParserContext\n        extend\n      getCursor\n      createRoot\n      parseChildren\n        last\n        isEnd\n        startsWith\n        emitError\n        parseInterpolation\n          emitError\n          getCursor\n          advanceBy\n          parseTextData\n          advancePositionWithMutation\n          getSelection\n        parseComment\n        parseBogusComment\n        parseCDATA\n        parseBogusComment\n        advanceBy\n        parseTag\n          getCursor\n          context.options.getNamespace\n          advanceBy\n          advanceSpaces\n          parseAttributes\n          emitError\n          startsWith\n          isComponent\n          getSelection\n        parseElement\n          last\n          parseTag\n          context.options.isVoidTag\n          context.options.getTextMode\n          parseChildren\n          startsWithEndTagOpen\n          parseTag\n          getSelection\n        ErrorCodes\n        parseText\n          getCursor\n          parseTextData\n          getSelection\n        isArray\n        pushNode\n      getSelection\n    getBaseTransformPreset\n    transform\n    extend\n    generate\n  extend\n -->","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#4ebde9","excerpt":"","more":"<!-- \ncompile\n  baseCompile\n    isString\n    baseParse\n      createParserContext\n        extend\n      getCursor\n      createRoot\n      parseChildren\n        last\n        isEnd\n        startsWith\n        emitError\n        parseInterpolation\n          emitError\n          getCursor\n          advanceBy\n          parseTextData\n          advancePositionWithMutation\n          getSelection\n        parseComment\n        parseBogusComment\n        parseCDATA\n        parseBogusComment\n        advanceBy\n        parseTag\n          getCursor\n          context.options.getNamespace\n          advanceBy\n          advanceSpaces\n          parseAttributes\n          emitError\n          startsWith\n          isComponent\n          getSelection\n        parseElement\n          last\n          parseTag\n          context.options.isVoidTag\n          context.options.getTextMode\n          parseChildren\n          startsWithEndTagOpen\n          parseTag\n          getSelection\n        ErrorCodes\n        parseText\n          getCursor\n          parseTextData\n          getSelection\n        isArray\n        pushNode\n      getSelection\n    getBaseTransformPreset\n    transform\n    extend\n    generate\n  extend\n -->"},{"_content":"<!-- \nbaseCompile\n  getBaseTransformPreset\n  transform\n    createTransformContext\n    traverseNode\n      isArray\n      context.helper\n      traverseNode\n    hoistStatic\n      walk\n        context.hoist\n          createSimpleExpression\n        getPatchFlag\n        getGeneratedPropsConstantType\n        getNodeProps\n        walk\n        context.transformHoist\n      isSingleElementRoot\n    createRootCodegen\n      isSingleElementRoot\n      makeBlock\n      createVNodeCall\n    context.helpers.keys\n  extend\n\ntransformElement\n  postTransformElement \n    createVNodeCall\n      context.helper\n      getVNodeBlockHelper\n      getVNodeHelper\n -->","source":"_drafts/technical-disclosure-of-vue3/13-ast-to-jsast.md","raw":"<!-- \nbaseCompile\n  getBaseTransformPreset\n  transform\n    createTransformContext\n    traverseNode\n      isArray\n      context.helper\n      traverseNode\n    hoistStatic\n      walk\n        context.hoist\n          createSimpleExpression\n        getPatchFlag\n        getGeneratedPropsConstantType\n        getNodeProps\n        walk\n        context.transformHoist\n      isSingleElementRoot\n    createRootCodegen\n      isSingleElementRoot\n      makeBlock\n      createVNodeCall\n    context.helpers.keys\n  extend\n\ntransformElement\n  postTransformElement \n    createVNodeCall\n      context.helper\n      getVNodeBlockHelper\n      getVNodeHelper\n -->","slug":"technical-disclosure-of-vue3/13-ast-to-jsast","published":0,"date":"2023-08-12T07:53:19.989Z","updated":"2023-08-12T07:53:19.989Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokf000esovcevnr0o6e","content":"<!-- \nbaseCompile\n  getBaseTransformPreset\n  transform\n    createTransformContext\n    traverseNode\n      isArray\n      context.helper\n      traverseNode\n    hoistStatic\n      walk\n        context.hoist\n          createSimpleExpression\n        getPatchFlag\n        getGeneratedPropsConstantType\n        getNodeProps\n        walk\n        context.transformHoist\n      isSingleElementRoot\n    createRootCodegen\n      isSingleElementRoot\n      makeBlock\n      createVNodeCall\n    context.helpers.keys\n  extend\n\ntransformElement\n  postTransformElement \n    createVNodeCall\n      context.helper\n      getVNodeBlockHelper\n      getVNodeHelper\n -->","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":"<!-- \nbaseCompile\n  getBaseTransformPreset\n  transform\n    createTransformContext\n    traverseNode\n      isArray\n      context.helper\n      traverseNode\n    hoistStatic\n      walk\n        context.hoist\n          createSimpleExpression\n        getPatchFlag\n        getGeneratedPropsConstantType\n        getNodeProps\n        walk\n        context.transformHoist\n      isSingleElementRoot\n    createRootCodegen\n      isSingleElementRoot\n      makeBlock\n      createVNodeCall\n    context.helpers.keys\n  extend\n\ntransformElement\n  postTransformElement \n    createVNodeCall\n      context.helper\n      getVNodeBlockHelper\n      getVNodeHelper\n -->"},{"_content":"<!-- \ngenerate\n  createCodegenContext\n  genModulePreamble\n    genHoists\n      newline\n      genNode\n        isString\n        isSymbol\n        context.helper\n        genNode\n        genText\n        genExpression\n        genInterpolation\n        genCompoundExpression\n        genComment\n        genVNodeCall\n          push\n          helper\n          getVNodeBlockHelper\n          getVNodeHelper\n          genNodeList\n          genNullableArgs\n          genNode\n        genCallExpression\n        genObjectExpression\n        genArrayExpression\n        genFunctionExpression\n        genConditionalExpression\n        genCacheExpression\n        genNodeList\n      push\n    push\n    newline\n  genFunctionPreamble\n  push\n  indent\n  newline\n  genAssets\n  genNode\n  deindent\n -->","source":"_drafts/technical-disclosure-of-vue3/14-jsast-to-render.md","raw":"<!-- \ngenerate\n  createCodegenContext\n  genModulePreamble\n    genHoists\n      newline\n      genNode\n        isString\n        isSymbol\n        context.helper\n        genNode\n        genText\n        genExpression\n        genInterpolation\n        genCompoundExpression\n        genComment\n        genVNodeCall\n          push\n          helper\n          getVNodeBlockHelper\n          getVNodeHelper\n          genNodeList\n          genNullableArgs\n          genNode\n        genCallExpression\n        genObjectExpression\n        genArrayExpression\n        genFunctionExpression\n        genConditionalExpression\n        genCacheExpression\n        genNodeList\n      push\n    push\n    newline\n  genFunctionPreamble\n  push\n  indent\n  newline\n  genAssets\n  genNode\n  deindent\n -->","slug":"technical-disclosure-of-vue3/14-jsast-to-render","published":0,"date":"2023-08-12T07:53:19.989Z","updated":"2023-08-12T07:53:19.989Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokg000gsovcgpiae9uj","content":"<!-- \ngenerate\n  createCodegenContext\n  genModulePreamble\n    genHoists\n      newline\n      genNode\n        isString\n        isSymbol\n        context.helper\n        genNode\n        genText\n        genExpression\n        genInterpolation\n        genCompoundExpression\n        genComment\n        genVNodeCall\n          push\n          helper\n          getVNodeBlockHelper\n          getVNodeHelper\n          genNodeList\n          genNullableArgs\n          genNode\n        genCallExpression\n        genObjectExpression\n        genArrayExpression\n        genFunctionExpression\n        genConditionalExpression\n        genCacheExpression\n        genNodeList\n      push\n    push\n    newline\n  genFunctionPreamble\n  push\n  indent\n  newline\n  genAssets\n  genNode\n  deindent\n -->","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#4ebde9","excerpt":"","more":"<!-- \ngenerate\n  createCodegenContext\n  genModulePreamble\n    genHoists\n      newline\n      genNode\n        isString\n        isSymbol\n        context.helper\n        genNode\n        genText\n        genExpression\n        genInterpolation\n        genCompoundExpression\n        genComment\n        genVNodeCall\n          push\n          helper\n          getVNodeBlockHelper\n          getVNodeHelper\n          genNodeList\n          genNullableArgs\n          genNode\n        genCallExpression\n        genObjectExpression\n        genArrayExpression\n        genFunctionExpression\n        genConditionalExpression\n        genCacheExpression\n        genNodeList\n      push\n    push\n    newline\n  genFunctionPreamble\n  push\n  indent\n  newline\n  genAssets\n  genNode\n  deindent\n -->"},{"_content":"<!-- \npatchElement \n  patchBlockChildren\n  patchChildren\n  patchProps\n  hostPatchProp\n  hostSetElementText\n -->","source":"_drafts/technical-disclosure-of-vue3/15-compile-optimize.md","raw":"<!-- \npatchElement \n  patchBlockChildren\n  patchChildren\n  patchProps\n  hostPatchProp\n  hostSetElementText\n -->","slug":"technical-disclosure-of-vue3/15-compile-optimize","published":0,"date":"2023-08-12T07:53:19.989Z","updated":"2023-08-12T07:53:19.989Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokh000isovc8hpt3o4c","content":"<!-- \npatchElement \n  patchBlockChildren\n  patchChildren\n  patchProps\n  hostPatchProp\n  hostSetElementText\n -->","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":"<!-- \npatchElement \n  patchBlockChildren\n  patchChildren\n  patchProps\n  hostPatchProp\n  hostSetElementText\n -->"},{"_content":"<!-- \nBaseTransitionImpl.setup\n  getCurrentInstance\n  useTransitionState\n    render\n      getTransitionRawChildren\n      slots.default\n      toRaw\n      getKeepAliveChild\n      emptyPlaceholder\n      resolveTransitionHooks\n        callHook \n          callWithAsyncErrorHandling\n          hook\n        hook.beforeEnter\n          onBeforeEnter\n        hooks.enter\n          onEnter\n        hooks.leave\n          onBeforeLeave\n        hooks.clone\n      setTransitionHooks\n      isSameVNodeType\n      leavingHooks.afterLeave\n        instance.update\n      leavingHooks.delayLeave\n        getLeavingNodesForType\n          el._leaveCb\n            earlyRemove\n\n\nresolveTransitionProps\n  extend\n  makeEnterHook\n    finishEnter\n    nextFrame\n    removeTransitionClass\n    addTransitionClass\n    whenTransitionEnds\n\nmountElement \n  transition.beforeEnter\n  queuePostRenderEffect\n  transition.enter\n\nremove \n  performRemove \n    hostRemove\n    transition.afterLeave\n  performLeave \n    leave\n    delayLeave\n    performLeave\n -->","source":"_drafts/technical-disclosure-of-vue3/16-transition.md","raw":"<!-- \nBaseTransitionImpl.setup\n  getCurrentInstance\n  useTransitionState\n    render\n      getTransitionRawChildren\n      slots.default\n      toRaw\n      getKeepAliveChild\n      emptyPlaceholder\n      resolveTransitionHooks\n        callHook \n          callWithAsyncErrorHandling\n          hook\n        hook.beforeEnter\n          onBeforeEnter\n        hooks.enter\n          onEnter\n        hooks.leave\n          onBeforeLeave\n        hooks.clone\n      setTransitionHooks\n      isSameVNodeType\n      leavingHooks.afterLeave\n        instance.update\n      leavingHooks.delayLeave\n        getLeavingNodesForType\n          el._leaveCb\n            earlyRemove\n\n\nresolveTransitionProps\n  extend\n  makeEnterHook\n    finishEnter\n    nextFrame\n    removeTransitionClass\n    addTransitionClass\n    whenTransitionEnds\n\nmountElement \n  transition.beforeEnter\n  queuePostRenderEffect\n  transition.enter\n\nremove \n  performRemove \n    hostRemove\n    transition.afterLeave\n  performLeave \n    leave\n    delayLeave\n    performLeave\n -->","slug":"technical-disclosure-of-vue3/16-transition","published":0,"date":"2023-08-12T07:53:19.989Z","updated":"2023-08-12T07:53:19.989Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzsloki000ksovcdmd1czbn","content":"<!-- \nBaseTransitionImpl.setup\n  getCurrentInstance\n  useTransitionState\n    render\n      getTransitionRawChildren\n      slots.default\n      toRaw\n      getKeepAliveChild\n      emptyPlaceholder\n      resolveTransitionHooks\n        callHook \n          callWithAsyncErrorHandling\n          hook\n        hook.beforeEnter\n          onBeforeEnter\n        hooks.enter\n          onEnter\n        hooks.leave\n          onBeforeLeave\n        hooks.clone\n      setTransitionHooks\n      isSameVNodeType\n      leavingHooks.afterLeave\n        instance.update\n      leavingHooks.delayLeave\n        getLeavingNodesForType\n          el._leaveCb\n            earlyRemove\n\n\nresolveTransitionProps\n  extend\n  makeEnterHook\n    finishEnter\n    nextFrame\n    removeTransitionClass\n    addTransitionClass\n    whenTransitionEnds\n\nmountElement \n  transition.beforeEnter\n  queuePostRenderEffect\n  transition.enter\n\nremove \n  performRemove \n    hostRemove\n    transition.afterLeave\n  performLeave \n    leave\n    delayLeave\n    performLeave\n -->","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":"<!-- \nBaseTransitionImpl.setup\n  getCurrentInstance\n  useTransitionState\n    render\n      getTransitionRawChildren\n      slots.default\n      toRaw\n      getKeepAliveChild\n      emptyPlaceholder\n      resolveTransitionHooks\n        callHook \n          callWithAsyncErrorHandling\n          hook\n        hook.beforeEnter\n          onBeforeEnter\n        hooks.enter\n          onEnter\n        hooks.leave\n          onBeforeLeave\n        hooks.clone\n      setTransitionHooks\n      isSameVNodeType\n      leavingHooks.afterLeave\n        instance.update\n      leavingHooks.delayLeave\n        getLeavingNodesForType\n          el._leaveCb\n            earlyRemove\n\n\nresolveTransitionProps\n  extend\n  makeEnterHook\n    finishEnter\n    nextFrame\n    removeTransitionClass\n    addTransitionClass\n    whenTransitionEnds\n\nmountElement \n  transition.beforeEnter\n  queuePostRenderEffect\n  transition.enter\n\nremove \n  performRemove \n    hostRemove\n    transition.afterLeave\n  performLeave \n    leave\n    delayLeave\n    performLeave\n -->"},{"_content":"<!-- \nKeepAliveImpl.setup\n  slots.default\n  isVNode\n  getInnerChild\n  getComponentName\n  isAsyncWrapper\n  matches\n  cache.get\n  cloneVNode\n  keys.delete\n  keys.add\n  pruneCacheEntry\n  isSuspense\n  move\n  patch\n  queuePostRenderEffect\n    invokeArrayFns\n    invokeVNodeHook\nprocessComponent\n  parentComponent.ctx.activate\n -->","source":"_drafts/technical-disclosure-of-vue3/17--keep-alive.md","raw":"<!-- \nKeepAliveImpl.setup\n  slots.default\n  isVNode\n  getInnerChild\n  getComponentName\n  isAsyncWrapper\n  matches\n  cache.get\n  cloneVNode\n  keys.delete\n  keys.add\n  pruneCacheEntry\n  isSuspense\n  move\n  patch\n  queuePostRenderEffect\n    invokeArrayFns\n    invokeVNodeHook\nprocessComponent\n  parentComponent.ctx.activate\n -->","slug":"technical-disclosure-of-vue3/17--keep-alive","published":0,"date":"2023-08-12T07:53:19.989Z","updated":"2023-08-12T07:53:19.989Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokj000msovc1zkze0q1","content":"<!-- \nKeepAliveImpl.setup\n  slots.default\n  isVNode\n  getInnerChild\n  getComponentName\n  isAsyncWrapper\n  matches\n  cache.get\n  cloneVNode\n  keys.delete\n  keys.add\n  pruneCacheEntry\n  isSuspense\n  move\n  patch\n  queuePostRenderEffect\n    invokeArrayFns\n    invokeVNodeHook\nprocessComponent\n  parentComponent.ctx.activate\n -->","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":"<!-- \nKeepAliveImpl.setup\n  slots.default\n  isVNode\n  getInnerChild\n  getComponentName\n  isAsyncWrapper\n  matches\n  cache.get\n  cloneVNode\n  keys.delete\n  keys.add\n  pruneCacheEntry\n  isSuspense\n  move\n  patch\n  queuePostRenderEffect\n    invokeArrayFns\n    invokeVNodeHook\nprocessComponent\n  parentComponent.ctx.activate\n -->"},{"_content":"<!-- \nTeleportImpl.process\n  isTeleportDisabled\n  createComment\n  createText\n  insert\n  resolveTarget\n  isTargetSVG\n  mount\n    mountChildren\n  patchBlockChildren\n  traverseStaticChildren\n  moveTeleport\n\nTeleportImpl.remove\n  hostRemove\n  unmount\n -->","source":"_drafts/technical-disclosure-of-vue3/18-teleport.md","raw":"<!-- \nTeleportImpl.process\n  isTeleportDisabled\n  createComment\n  createText\n  insert\n  resolveTarget\n  isTargetSVG\n  mount\n    mountChildren\n  patchBlockChildren\n  traverseStaticChildren\n  moveTeleport\n\nTeleportImpl.remove\n  hostRemove\n  unmount\n -->","slug":"technical-disclosure-of-vue3/18-teleport","published":0,"date":"2023-08-12T07:53:19.989Z","updated":"2023-08-12T07:53:19.989Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokk000psovc33ub3u8n","content":"<!-- \nTeleportImpl.process\n  isTeleportDisabled\n  createComment\n  createText\n  insert\n  resolveTarget\n  isTargetSVG\n  mount\n    mountChildren\n  patchBlockChildren\n  traverseStaticChildren\n  moveTeleport\n\nTeleportImpl.remove\n  hostRemove\n  unmount\n -->","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#e7817c","excerpt":"","more":"<!-- \nTeleportImpl.process\n  isTeleportDisabled\n  createComment\n  createText\n  insert\n  resolveTarget\n  isTargetSVG\n  mount\n    mountChildren\n  patchBlockChildren\n  traverseStaticChildren\n  moveTeleport\n\nTeleportImpl.remove\n  hostRemove\n  unmount\n -->"},{"_content":"<!-- \nmountSuspense\n  createElement\n  createSuspenseBoundary\n    suspense.registerDep\n      instance.asyncDep\n        handleError\n        handleSetupResult\n        setupRenderEffect\n        remove\n        updateHOCHostEl\n        suspense.resolve\n    suspense.resolve\n      next\n      unmount\n      move\n      setActiveBranch\n      parent.effects.push\n      queuePostFlushCb\n      triggerEvent\n  patch\n  triggerEvent\n  setActiveBranch\n  suspense.resolve\n\nsetupStatefulComponent\n  isPromise\n\nsetupRenderEffect \n  componentUpdateFn\n    queuePostRenderEffect\n\npatchSuspense\n  isSameVNodeType\n  patch\n  suspense.resolve\n  setActiveBranch\n  unmount\n  createElement\n -->","source":"_drafts/technical-disclosure-of-vue3/19-suspense.md","raw":"<!-- \nmountSuspense\n  createElement\n  createSuspenseBoundary\n    suspense.registerDep\n      instance.asyncDep\n        handleError\n        handleSetupResult\n        setupRenderEffect\n        remove\n        updateHOCHostEl\n        suspense.resolve\n    suspense.resolve\n      next\n      unmount\n      move\n      setActiveBranch\n      parent.effects.push\n      queuePostFlushCb\n      triggerEvent\n  patch\n  triggerEvent\n  setActiveBranch\n  suspense.resolve\n\nsetupStatefulComponent\n  isPromise\n\nsetupRenderEffect \n  componentUpdateFn\n    queuePostRenderEffect\n\npatchSuspense\n  isSameVNodeType\n  patch\n  suspense.resolve\n  setActiveBranch\n  unmount\n  createElement\n -->","slug":"technical-disclosure-of-vue3/19-suspense","published":0,"date":"2023-08-12T07:53:19.989Z","updated":"2023-08-12T07:53:19.989Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokl000rsovcea6041te","content":"<!-- \nmountSuspense\n  createElement\n  createSuspenseBoundary\n    suspense.registerDep\n      instance.asyncDep\n        handleError\n        handleSetupResult\n        setupRenderEffect\n        remove\n        updateHOCHostEl\n        suspense.resolve\n    suspense.resolve\n      next\n      unmount\n      move\n      setActiveBranch\n      parent.effects.push\n      queuePostFlushCb\n      triggerEvent\n  patch\n  triggerEvent\n  setActiveBranch\n  suspense.resolve\n\nsetupStatefulComponent\n  isPromise\n\nsetupRenderEffect \n  componentUpdateFn\n    queuePostRenderEffect\n\npatchSuspense\n  isSameVNodeType\n  patch\n  suspense.resolve\n  setActiveBranch\n  unmount\n  createElement\n -->","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#4ebde9","excerpt":"","more":"<!-- \nmountSuspense\n  createElement\n  createSuspenseBoundary\n    suspense.registerDep\n      instance.asyncDep\n        handleError\n        handleSetupResult\n        setupRenderEffect\n        remove\n        updateHOCHostEl\n        suspense.resolve\n    suspense.resolve\n      next\n      unmount\n      move\n      setActiveBranch\n      parent.effects.push\n      queuePostFlushCb\n      triggerEvent\n  patch\n  triggerEvent\n  setActiveBranch\n  suspense.resolve\n\nsetupStatefulComponent\n  isPromise\n\nsetupRenderEffect \n  componentUpdateFn\n    queuePostRenderEffect\n\npatchSuspense\n  isSameVNodeType\n  patch\n  suspense.resolve\n  setActiveBranch\n  unmount\n  createElement\n -->"},{"title":"渲染器：数据访问是如何被代理的？","_content":"\n<!-- \napp.mount\n  mount \n    render\n      patch\n        processComponent\n          mountComponent\n            setupComponent\n              setupStatefulComponent\n                markRaw\n                  def\n                    defineProperty\n                Proxy\n                createSetupContext\n                setup\n                handleSetupResult\n                  proxyRefs\n                  finishComponentSetup\n                    compile\n                finishComponentSetup\n                  applyOptions\n                    createWatcher\n                      watch\n                        doWatch\n                          run\n                            getter\n                              callWithErrorHandling\n                                getter\n                                  get\n\n -->\n\n#### 前言\n\n在开启本小节之前，我们先看一个有意思的示例，组件上有一个动态文本节点 {{ msg }}，但是却有 2 处定义了 msg 响应式数据；另外有一个按钮，点击后会修改响应式数据。\n\n```vue\n<template>\n  <p>{{ msg }}</p>\n  <button @click=\"changeMsg\">点击试试</button>\n</template>\n<script>\nimport { ref } from \"vue\";\nexport default {\n  data() {\n    return {\n      msg: \"msg from data\",\n    };\n  },\n  setup() {\n    const msg = ref(\"msg from setup\");\n    return {\n      msg,\n    };\n  },\n  methods: {\n    changeMsg() {\n      this.msg = \"change\";\n    },\n  },\n};\n</script>\n```\n\n思考一下：\n\n界面显示的内容是什么？\n点击按钮后，修改的是哪部分的数据？是 data 中定义的，还是 setup 中的呢？\n先别急着找答案，相信你阅读完这一节，一定会得到答案。\n\n上一节，我们知道了根组件在初始化渲染的过程中，会执行 mountComponent 的函数：\n\n```typescript\nfunction mountComponent(initialVNode, container, parentComponent) {\n  // 1. 先创建一个 component instance\n  const instance = (initialVNode.component = createComponentInstance(\n    initialVNode,\n    parentComponent\n  ));\n\n  // 2. 初始化组件实例\n\n  setupComponent(instance);\n\n  // 3. 设置并运行带副作用的渲染函数\n  setupRenderEffect(instance, initialVNode, container);\n}\n```\n\n上文，我们简单介绍了关于 setupComponent 函数的作用是为了对实例化后的组件中的属性做一些优化、处理、赋值等操作。本小节我们将重点介绍 setupComponent 的内部实现和作用。\n\n#### 初始化组件实例\n\n我们再来回顾一下 setupComponent 在源码中的实现：\n\n```typescript\nexport function setupComponent(instance, isSSR = false) {\n  const { props, children } = instance.vnode;\n\n  // 判断组件是否是有状态的组件\n  const isStateful = isStatefulComponent(instance);\n\n  // 初始化 props\n  initProps(instance, props, isStateful, isSSR);\n\n  // 初始化 slots\n  initSlots(instance, children);\n\n  // 如果是有状态组件，那么去设置有状态组件实例\n  const setupResult = isStateful\n    ? setupStatefulComponent(instance, isSSR)\n    : undefined;\n\n  return setupResult;\n}\n```\n\nsetupComponent 方法做了什么？\n\n通过 isStatefulComponent(instance) 判断是否是有状态的组件；\ninitProps 初始化 props；\ninitSlots 初始化 slots；\n根据组件是否是有状态的，来决定是否需要执行 setupStatefulComponent 函数。\n其中， isStatefulComponent 判断是否是有状态的组件的函数如下：\n\n```typescript\nfunction isStatefulComponent(instance) {\n  return instance.vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT;\n}\n```\n\n前面我们已经说过了，ShapeFlags 在遇到组件类型的 type = Object 时，vnode 的 shapeFlags = ShapeFlags.STATEFUL_COMPONENT。所以这里会执行 setupStatefulComponent 函数。\n\n```typescript\nfunction setupStatefulComponent(instance, isSSR) {\n  // 定义 Component 变量\n  const Component = instance.type;\n\n  // 1. 创建渲染代理的属性访问缓存\n  instance.accessCache = Object.create(null);\n  // 2. 创建渲染上下文代理, proxy 对象其实是代理了 instance.ctx 对象\n  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);\n  // 3. 执行 setup 函数\n  const { setup } = Component;\n  if (setup) {\n    // 如果 setup 函数带参数，则创建一个 setupContext\n    const setupContext = (instance.setupContext =\n      setup.length > 1 ? createSetupContext(instance) : null);\n    // 执行 setup 函数，获取结果\n    const setupResult = callWithErrorHandling(setup, instance, 0, [\n      instance.props,\n      setupContext,\n    ]);\n    // 处理 setup 执行结果\n    handleSetupResult(instance, setupResult);\n  } else {\n    // 4. 完成组件实例设置\n    finishComponentSetup(instance, isSSR);\n  }\n}\n```\n\nsetupStatefulComponent 字面意思就是设置有状态组件，那么什么是有状态组件呢？简单而言，就是对于有状态组件，Vue 内部会保留组件状态数据。相对于有状态组件而言，Vue 还存在一种函数组件 FUNCTIONAL_COMPONENT，一起看个示例：\n\n```typescript\nimport { ref } from \"vue\";\nexport default () => {\n  let num = ref(0);\n  const plusNum = () => {\n    num.value++;\n  };\n  return (\n    <div>\n      <button onClick={plusNum}>{num.value}</button>\n    </div>\n  );\n};\n```\n\n这个函数点击按钮时，num 的值并不会按照我们预期那样值会一直递增，因为它是一个函数组件，函数组件内部是没有状态保持的，所以 num 数据更新时，组件会重新渲染，num 的值永远不变一直是 0。\n\n所以在这个时候，为了能符合我们预期的结果，我们需要将其设置成有状态的组件。我们可以通过 defineComponent 函数包装一下：\n\n```typescript\nimport { ref, defineComponent } from \"vue\";\n\nexport default defineComponent(() => {\n  let num = ref(0);\n  const plusNum = () => {\n    num.value++;\n  };\n\n  return () => (\n    <div>\n      <button onClick={plusNum}>{num.value}</button>\n    </div>\n  );\n});\n```\n\ndefineComponent 返回的是个对象类型的 type，所以就变成了有状态组件。\n\n好了，搞清楚什么是有状态组件后，我们接着回到 setupStatefulComponent 实现中，来一步步地分析其核心实现的原理。\n\n#### 创建渲染上下文代理\n\n首先我们看 1-2 两个步骤，关于第一点：为什么要创建渲染代理的属性访问缓存呢？这里先卖个关子，先看第二步：创建渲染上下文代理，这里为什么要对 instance.ctx 做代理呢？如果熟悉 Vue 2 的小伙伴应该了解对于 Vue 2 的 Options API 的写法如下：\n\n```typescript\n<template>\n  <p>{{ num }}</p>\n</template>\n<script>\nexport default {\n  data() {\n    num: 1;\n  },\n  mounted() {\n    this.num = 2;\n  },\n};\n</script>\n```\n\nVue 2.x 是如何实现访问 this.num 获取到 num 的值，而不是通过 this.\\_data.num 来获取 num 的值呢？其实 Vue 2.x 版本中，为 \\_data 设置了一层代理：\n\n```typescript\n_proxy(options.data);\n\nfunction _proxy(data) {\n  const that = this;\n  Object.keys(data).forEach((key) => {\n    Object.defineProperty(that, key, {\n      configurable: true,\n      enumerable: true,\n      get: function proxyGetter() {\n        return that._data[key];\n      },\n      set: function proxySetter(val) {\n        that._data[key] = val;\n      },\n    });\n  });\n}\n```\n\n本质就是通过 Object.defineProperty 使在访问 this 上的某属性时从 this.\\_data 中读取（写入）。\n\n而 Vue 3 也在这里做了类似的事情，Vue 3 内部有很多状态属性，存储在不同的对象上，比如 setupState、ctx、data、props。这样用户取数据就会考虑具体从哪个对象中获取，这无疑增加了用户的使用负担，所以对 instance.ctx 进行代理，然后根据属性优先级关系依次完成从特定对象上获取值。\n\n##### get\n\n了解了代理的功能后，我们来具体看一下是如何实现代理功能的，也就是 proxy 的 PublicInstanceProxyHandlers 它的实现。先看一下 get 函数：\n\n```typescript\nexport const PublicInstanceProxyHandlers = {\n  get({ _: instance }, key) {\n    const { ctx, setupState, data, props, accessCache, type, appContext } =\n      instance;\n    let normalizedProps;\n    if (key[0] !== \"$\") {\n      // 从缓存中获取当前 key 存在于哪个属性中\n      const n = accessCache![key];\n      if (n !== undefined) {\n        switch (n) {\n          case AccessTypes.SETUP:\n            return setupState[key];\n          case AccessTypes.DATA:\n            return data[key];\n          case AccessTypes.CONTEXT:\n            return ctx[key];\n          case AccessTypes.PROPS:\n            return props![key];\n        }\n      } else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\n        // 从 setupState 中取\n        accessCache![key] = AccessTypes.SETUP;\n        return setupState[key];\n      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\n        // 从 data 中取\n        accessCache![key] = AccessTypes.DATA;\n        return data[key];\n      } else if (\n        (normalizedProps = instance.propsOptions[0]) &&\n        hasOwn(normalizedProps, key)\n      ) {\n        // 从 props 中取\n        accessCache![key] = AccessTypes.PROPS;\n        return props![key];\n      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\n        // 从 ctx 中取\n        accessCache![key] = AccessTypes.CONTEXT;\n        return ctx[key];\n      } else if (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) {\n        // 都取不到\n        accessCache![key] = AccessTypes.OTHER;\n      }\n    }\n\n    const publicGetter = publicPropertiesMap[key];\n    let cssModule, globalProperties;\n    if (publicGetter) {\n      // 以 $ 保留字开头的相关函数和方法\n      // ...\n    } else if (\n      // css module\n      (cssModule = type.__cssModules) &&\n      (cssModule = cssModule[key])\n    ) {\n      // ...\n    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\n      // ...\n    } else if (\n      // 全局属性\n      ((globalProperties = appContext.config.globalProperties),\n      hasOwn(globalProperties, key))\n    ) {\n      // ...\n    } else if (__DEV__) {\n      // 一些告警\n      // ...\n    }\n  },\n};\n```\n\n这里，可以回答我们的第一步 创建渲染代理的属性访问缓存 这个步骤的问题了。如果我们知道 key 存在于哪个对象上，那么就可以直接通过对象取值的操作获取属性上的值了。如果我们不知道用户访问的 key 存在于哪个属性上，那只能通过 hasOwn 的方法先判断存在于哪个属性上，再通过对象取值的操作获取属性值，这无疑是多操作了一步，而且这个判断是比较耗费性能的。如果遇到大量渲染取值的操作，那么这块就是个性能瓶颈，所以这里用了 accessCache 来标记缓存 key 存在于哪个属性上。这其实也相当于用一部分空间换时间的优化。\n\n接下来，函数首先判断 key[0] !== '$' 的情况（$ 开头的一般是 Vue 组件实例上的内置属性），在 Vue 3 源码中，会依次从 setupState、data、props、ctx 这几类数据中取状态值。\n\n这里的定义顺序，决定了后续取值的优先级顺序：setupState >data >props > ctx。\n\n如果 key 是以 $ 开头，则首先会判断是否是存在于组件实例上的内置属性：\n\nimage.png\n整体的获取顺序依次是：publicGetter > cssModule > ctx。最后，如果都取不到，那么在开发环境就会给一些告警提示。\n\n##### set\n\n接着继续看一下设置对象属性的代理函数：\n\n```typescript\nexport const PublicInstanceProxyHandlers = {\n  set({ _: instance }, key, value) {\n    const { data, setupState, ctx } = instance;\n    if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\n      // 设置 setupState\n      setupState[key] = value;\n      return true;\n    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\n      // 设置 data\n      data[key] = value;\n      return true;\n    } else if (hasOwn(instance.props, key)) {\n      // 不能给 props 赋值\n      return false;\n    }\n    if (key[0] === \"$\" && key.slice(1) in instance) {\n      // 不能给组件实例上的内置属性赋值\n      return false;\n    } else {\n      // 用户自定义数据赋值\n      ctx[key] = value;\n    }\n    return true;\n  },\n};\n```\n\n可以看到这里也是和前面 get 函数类似的通过调用顺序来实现对 set 函数不同属性设置优先级的，可以直观地看到优先级关系为：setupState > data > props。同时这里也有说明：就是如果直接对 props 或者组件实例上的内置属性赋值，则会告警。\n\n##### has\n\n最后，再看一个 proxy 属性 has 的实现：\n\n```typescript\nexport const PublicInstanceProxyHandlers = {\n  has(\n    { _: { data, setupState, accessCache, ctx, appContext, propsOptions } },\n    key\n  ) {\n    let normalizedProps;\n    return (\n      !!accessCache![key] ||\n      (data !== EMPTY_OBJ && hasOwn(data, key)) ||\n      (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) ||\n      ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||\n      hasOwn(ctx, key) ||\n      hasOwn(publicPropertiesMap, key) ||\n      hasOwn(appContext.config.globalProperties, key)\n    );\n  },\n};\n```\n\n这个函数则是依次判断 key 是否存在于 accessCache > data > setupState > prop > ctx > publicPropertiesMap > globalProperties，然后返回结果。\n\nhas 在业务代码的使用定义如下：\n\n```typescript\nexport default {\n  created() {\n    // 这里会触发 has 函数\n    console.log(\"msg\" in this);\n  },\n};\n```\n\n至此，我们就搞清楚了创建上下文代理的过程。\n\n#### 调用执行 setup 函数\n\n一个简单的包含 CompositionAPI 的 Vue 3 demo 如下：\n\n```html\n<template>\n  <p>{{ msg }}</p>\n</template>\n<script>\n  export default {\n    props: {\n      msg: String,\n    },\n    setup(props, setupContext) {\n      // todo\n    },\n  };\n</script>\n```\n\n这里的 setup 函数，正是在这里被调用执行的：\n\n```typescript\n// 获取 setup 函数\nconst { setup } = Component;\n// 存在 setup 函数\nif (setup) {\n  // 根据 setup 函数的入参长度，判断是否需要创建 setupContext 对象\n  const setupContext = (instance.setupContext =\n    setup.length > 1 ? createSetupContext(instance) : null);\n  // 调用 setup\n  const setupResult = callWithErrorHandling(setup, instance, 0, [\n    instance.props,\n    setupContext,\n  ]);\n  // 处理 setup 执行结果\n  handleSetupResult(instance, setupResult);\n}\n```\n\n##### createSetupContext\n\n因为 setupContext 是 setup 中的第二个参数，所以会判断 setup 函数参数的长度，如果大于 1，则会通过 createSetupContext 函数创建 setupContext 上下文。\n\n该上下文创建如下：\n\n```typescript\nfunction createSetupContext(instance) {\n  return {\n    get attrs() {\n      return attrs || (attrs = createAttrsProxy(instance));\n    },\n    slots: instance.slots,\n    emit: instance.emit,\n    expose,\n  };\n}\n```\n\n可以看到，setupContext 中包含了 attrs、slots、emit、expose 这些属性。这些属性分别代表着：组件的属性、插槽、派发事件的方法 emit、以及所有想从当前组件实例导出的内容 expose。\n\n这里有个小的知识点，就是可以通过函数的 length 属性来判断函数参数的个数：\n\n```typescript\nfunction foo() {}\n\nfoo.length; // 0\n\nfunction bar(a) {}\n\nbar.length; // 1\n```\n\n##### callWithErrorHandling\n\n第二步，通过 callWithErrorHandling 函数来间接执行 setup 函数，其实就是执行了以下代码：\n\n```typescript\nconst setupResult =\n  setup && setup(shallowReadonly(instance.props), setupContext);\n```\n\n只不过增加了对执行过程中 handleError 的捕获。\n\n在后续章节的阅读中，你会发现 Vue 3 很多函数的调用都是通过 callWithErrorHandling 来包裹的：\n\n```typescript\nexport function callWithErrorHandling(fn, instance, type, args = []) {\n  let res;\n  try {\n    res = args ? fn(...args) : fn();\n  } catch (err) {\n    handleError(err, instance, type);\n  }\n  return res;\n}\n```\n\n这样的好处一方面可以由 Vue 内部统一 try...catch 处理用户代码运行可能出现的错误。另一方面这些错误也可以交由用户统一注册的 errorHandler 进行处理，比如上报给监控系统。\n\n##### handleSetupResult\n\n最后执行 handleSetupResult 函数：\n\n```typescript\nfunction handleSetupResult(instance, setupResult) {\n  if (isFunction(setupResult)) {\n    // setup 返回渲染函数\n    instance.render = setupResult;\n  } else if (isObject(setupResult)) {\n    // proxyRefs 的作用就是把 setupResult 对象做一层代理\n    instance.setupState = proxyRefs(setupResult);\n  }\n  finishComponentSetup(instance);\n}\n```\n\nsetup 返回值不一样的话，会有不同的处理，如果 setupResult 是个函数，那么会把该函数绑定到 render 上。比如：\n\n```vue\n<script>\nimport { createVnode } from \"vue\";\nexport default {\n  props: {\n    msg: String,\n  },\n  setup(props, { emit }) {\n    return (ctx) => {\n      return [createVnode(\"p\", null, ctx.msg)];\n    };\n  },\n};\n</script>\n```\n\n当 setupResult 是一个对象的时候，我们为 setupResult 对象通过 proxyRefs 作了一层代理，方便用户直接访问 ref 类型的值。比如，在模板中访问 setupResult 中的数据，就可以省略 .value 的取值，而由代理来默认取 .value 的值。\n\n注意，这里 instance.setupState = proxyRefs(setupResult); 之前的 Vue 源码的写法是 instance.setupState = reactive(setupResult); ，至于为什么改成上面的，Vue 作者也有相关说明：Template auto ref unwrapping for setup() return object is now applied only to the root level refs.\n\n#### 完成组件实例设置\n\n最后，到了 finishComponentSetup 这个函数了：\n\n```typescript\nfunction finishComponentSetup(instance) {\n  // type 是个组件对象\n  const Component = instance.type;\n\n  if (!instance.render) {\n    // 如果组件没有 render 函数，那么就需要把 template 编译成 render 函数\n    if (compile && !Component.render) {\n      if (Component.template) {\n        // 这里就是 runtime 模块和 compile 模块结合点\n        // 运行时编译\n        Component.render = compile(Component.template, {\n          isCustomElement: instance.appContext.config.isCustomElement || NO,\n        });\n      }\n    }\n\n    instance.render = Component.render;\n  }\n  if (__FEATURE_OPTIONS_API__ && !(__COMPAT__ && skipOptions)) {\n    // 兼容选项式组件的调用逻辑\n  }\n}\n```\n\n这里主要做的就是根据 instance 上有没有 render 函数来判断是否需要进行运行时渲染，运行时渲染指的是在浏览器运行的过程中，动态编译 \\<template> 标签内的内容，产出渲染函数。对于编译时渲染，则是有渲染函数的，因为模板中的内容会被 webpack 中 vue-loader 这样的插件进行编译。\n\n另外需要注意的，这里有个 **FEATURE_OPTIONS_API** 变量用来标记是否是兼容 选项式 API 调用，如果我们只使用 Composition Api 那么就可以通过 webpack 静态变量注入的方式关闭此特性。然后交由 Tree-Shacking 删除无用的代码，从而减少引用代码包的体积。\n\n#### 总结\n\n有了上面的一些介绍，我们再来回答一下开篇中提到的问题：\n\n初始化渲染的时候，会从实例上获取状态 msg 的值，获取的优先级是：setupState >data >props > ctx。setupState 就是 setup 函数执行后返回的状态值，所以这里渲染的是：msg from setup。\n点击按钮的时候，会更新实例上的状态，更新的优先级是：setupState > data。所以会更新 setup 中的状态数据 msg。\n","source":"_drafts/technical-disclosure-of-vue3/2-data-broker.md","raw":"---\ntitle: 渲染器：数据访问是如何被代理的？\ncategories:\n  - Vue3 技术揭秘\n---\n\n<!-- \napp.mount\n  mount \n    render\n      patch\n        processComponent\n          mountComponent\n            setupComponent\n              setupStatefulComponent\n                markRaw\n                  def\n                    defineProperty\n                Proxy\n                createSetupContext\n                setup\n                handleSetupResult\n                  proxyRefs\n                  finishComponentSetup\n                    compile\n                finishComponentSetup\n                  applyOptions\n                    createWatcher\n                      watch\n                        doWatch\n                          run\n                            getter\n                              callWithErrorHandling\n                                getter\n                                  get\n\n -->\n\n#### 前言\n\n在开启本小节之前，我们先看一个有意思的示例，组件上有一个动态文本节点 {{ msg }}，但是却有 2 处定义了 msg 响应式数据；另外有一个按钮，点击后会修改响应式数据。\n\n```vue\n<template>\n  <p>{{ msg }}</p>\n  <button @click=\"changeMsg\">点击试试</button>\n</template>\n<script>\nimport { ref } from \"vue\";\nexport default {\n  data() {\n    return {\n      msg: \"msg from data\",\n    };\n  },\n  setup() {\n    const msg = ref(\"msg from setup\");\n    return {\n      msg,\n    };\n  },\n  methods: {\n    changeMsg() {\n      this.msg = \"change\";\n    },\n  },\n};\n</script>\n```\n\n思考一下：\n\n界面显示的内容是什么？\n点击按钮后，修改的是哪部分的数据？是 data 中定义的，还是 setup 中的呢？\n先别急着找答案，相信你阅读完这一节，一定会得到答案。\n\n上一节，我们知道了根组件在初始化渲染的过程中，会执行 mountComponent 的函数：\n\n```typescript\nfunction mountComponent(initialVNode, container, parentComponent) {\n  // 1. 先创建一个 component instance\n  const instance = (initialVNode.component = createComponentInstance(\n    initialVNode,\n    parentComponent\n  ));\n\n  // 2. 初始化组件实例\n\n  setupComponent(instance);\n\n  // 3. 设置并运行带副作用的渲染函数\n  setupRenderEffect(instance, initialVNode, container);\n}\n```\n\n上文，我们简单介绍了关于 setupComponent 函数的作用是为了对实例化后的组件中的属性做一些优化、处理、赋值等操作。本小节我们将重点介绍 setupComponent 的内部实现和作用。\n\n#### 初始化组件实例\n\n我们再来回顾一下 setupComponent 在源码中的实现：\n\n```typescript\nexport function setupComponent(instance, isSSR = false) {\n  const { props, children } = instance.vnode;\n\n  // 判断组件是否是有状态的组件\n  const isStateful = isStatefulComponent(instance);\n\n  // 初始化 props\n  initProps(instance, props, isStateful, isSSR);\n\n  // 初始化 slots\n  initSlots(instance, children);\n\n  // 如果是有状态组件，那么去设置有状态组件实例\n  const setupResult = isStateful\n    ? setupStatefulComponent(instance, isSSR)\n    : undefined;\n\n  return setupResult;\n}\n```\n\nsetupComponent 方法做了什么？\n\n通过 isStatefulComponent(instance) 判断是否是有状态的组件；\ninitProps 初始化 props；\ninitSlots 初始化 slots；\n根据组件是否是有状态的，来决定是否需要执行 setupStatefulComponent 函数。\n其中， isStatefulComponent 判断是否是有状态的组件的函数如下：\n\n```typescript\nfunction isStatefulComponent(instance) {\n  return instance.vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT;\n}\n```\n\n前面我们已经说过了，ShapeFlags 在遇到组件类型的 type = Object 时，vnode 的 shapeFlags = ShapeFlags.STATEFUL_COMPONENT。所以这里会执行 setupStatefulComponent 函数。\n\n```typescript\nfunction setupStatefulComponent(instance, isSSR) {\n  // 定义 Component 变量\n  const Component = instance.type;\n\n  // 1. 创建渲染代理的属性访问缓存\n  instance.accessCache = Object.create(null);\n  // 2. 创建渲染上下文代理, proxy 对象其实是代理了 instance.ctx 对象\n  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);\n  // 3. 执行 setup 函数\n  const { setup } = Component;\n  if (setup) {\n    // 如果 setup 函数带参数，则创建一个 setupContext\n    const setupContext = (instance.setupContext =\n      setup.length > 1 ? createSetupContext(instance) : null);\n    // 执行 setup 函数，获取结果\n    const setupResult = callWithErrorHandling(setup, instance, 0, [\n      instance.props,\n      setupContext,\n    ]);\n    // 处理 setup 执行结果\n    handleSetupResult(instance, setupResult);\n  } else {\n    // 4. 完成组件实例设置\n    finishComponentSetup(instance, isSSR);\n  }\n}\n```\n\nsetupStatefulComponent 字面意思就是设置有状态组件，那么什么是有状态组件呢？简单而言，就是对于有状态组件，Vue 内部会保留组件状态数据。相对于有状态组件而言，Vue 还存在一种函数组件 FUNCTIONAL_COMPONENT，一起看个示例：\n\n```typescript\nimport { ref } from \"vue\";\nexport default () => {\n  let num = ref(0);\n  const plusNum = () => {\n    num.value++;\n  };\n  return (\n    <div>\n      <button onClick={plusNum}>{num.value}</button>\n    </div>\n  );\n};\n```\n\n这个函数点击按钮时，num 的值并不会按照我们预期那样值会一直递增，因为它是一个函数组件，函数组件内部是没有状态保持的，所以 num 数据更新时，组件会重新渲染，num 的值永远不变一直是 0。\n\n所以在这个时候，为了能符合我们预期的结果，我们需要将其设置成有状态的组件。我们可以通过 defineComponent 函数包装一下：\n\n```typescript\nimport { ref, defineComponent } from \"vue\";\n\nexport default defineComponent(() => {\n  let num = ref(0);\n  const plusNum = () => {\n    num.value++;\n  };\n\n  return () => (\n    <div>\n      <button onClick={plusNum}>{num.value}</button>\n    </div>\n  );\n});\n```\n\ndefineComponent 返回的是个对象类型的 type，所以就变成了有状态组件。\n\n好了，搞清楚什么是有状态组件后，我们接着回到 setupStatefulComponent 实现中，来一步步地分析其核心实现的原理。\n\n#### 创建渲染上下文代理\n\n首先我们看 1-2 两个步骤，关于第一点：为什么要创建渲染代理的属性访问缓存呢？这里先卖个关子，先看第二步：创建渲染上下文代理，这里为什么要对 instance.ctx 做代理呢？如果熟悉 Vue 2 的小伙伴应该了解对于 Vue 2 的 Options API 的写法如下：\n\n```typescript\n<template>\n  <p>{{ num }}</p>\n</template>\n<script>\nexport default {\n  data() {\n    num: 1;\n  },\n  mounted() {\n    this.num = 2;\n  },\n};\n</script>\n```\n\nVue 2.x 是如何实现访问 this.num 获取到 num 的值，而不是通过 this.\\_data.num 来获取 num 的值呢？其实 Vue 2.x 版本中，为 \\_data 设置了一层代理：\n\n```typescript\n_proxy(options.data);\n\nfunction _proxy(data) {\n  const that = this;\n  Object.keys(data).forEach((key) => {\n    Object.defineProperty(that, key, {\n      configurable: true,\n      enumerable: true,\n      get: function proxyGetter() {\n        return that._data[key];\n      },\n      set: function proxySetter(val) {\n        that._data[key] = val;\n      },\n    });\n  });\n}\n```\n\n本质就是通过 Object.defineProperty 使在访问 this 上的某属性时从 this.\\_data 中读取（写入）。\n\n而 Vue 3 也在这里做了类似的事情，Vue 3 内部有很多状态属性，存储在不同的对象上，比如 setupState、ctx、data、props。这样用户取数据就会考虑具体从哪个对象中获取，这无疑增加了用户的使用负担，所以对 instance.ctx 进行代理，然后根据属性优先级关系依次完成从特定对象上获取值。\n\n##### get\n\n了解了代理的功能后，我们来具体看一下是如何实现代理功能的，也就是 proxy 的 PublicInstanceProxyHandlers 它的实现。先看一下 get 函数：\n\n```typescript\nexport const PublicInstanceProxyHandlers = {\n  get({ _: instance }, key) {\n    const { ctx, setupState, data, props, accessCache, type, appContext } =\n      instance;\n    let normalizedProps;\n    if (key[0] !== \"$\") {\n      // 从缓存中获取当前 key 存在于哪个属性中\n      const n = accessCache![key];\n      if (n !== undefined) {\n        switch (n) {\n          case AccessTypes.SETUP:\n            return setupState[key];\n          case AccessTypes.DATA:\n            return data[key];\n          case AccessTypes.CONTEXT:\n            return ctx[key];\n          case AccessTypes.PROPS:\n            return props![key];\n        }\n      } else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\n        // 从 setupState 中取\n        accessCache![key] = AccessTypes.SETUP;\n        return setupState[key];\n      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\n        // 从 data 中取\n        accessCache![key] = AccessTypes.DATA;\n        return data[key];\n      } else if (\n        (normalizedProps = instance.propsOptions[0]) &&\n        hasOwn(normalizedProps, key)\n      ) {\n        // 从 props 中取\n        accessCache![key] = AccessTypes.PROPS;\n        return props![key];\n      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\n        // 从 ctx 中取\n        accessCache![key] = AccessTypes.CONTEXT;\n        return ctx[key];\n      } else if (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) {\n        // 都取不到\n        accessCache![key] = AccessTypes.OTHER;\n      }\n    }\n\n    const publicGetter = publicPropertiesMap[key];\n    let cssModule, globalProperties;\n    if (publicGetter) {\n      // 以 $ 保留字开头的相关函数和方法\n      // ...\n    } else if (\n      // css module\n      (cssModule = type.__cssModules) &&\n      (cssModule = cssModule[key])\n    ) {\n      // ...\n    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\n      // ...\n    } else if (\n      // 全局属性\n      ((globalProperties = appContext.config.globalProperties),\n      hasOwn(globalProperties, key))\n    ) {\n      // ...\n    } else if (__DEV__) {\n      // 一些告警\n      // ...\n    }\n  },\n};\n```\n\n这里，可以回答我们的第一步 创建渲染代理的属性访问缓存 这个步骤的问题了。如果我们知道 key 存在于哪个对象上，那么就可以直接通过对象取值的操作获取属性上的值了。如果我们不知道用户访问的 key 存在于哪个属性上，那只能通过 hasOwn 的方法先判断存在于哪个属性上，再通过对象取值的操作获取属性值，这无疑是多操作了一步，而且这个判断是比较耗费性能的。如果遇到大量渲染取值的操作，那么这块就是个性能瓶颈，所以这里用了 accessCache 来标记缓存 key 存在于哪个属性上。这其实也相当于用一部分空间换时间的优化。\n\n接下来，函数首先判断 key[0] !== '$' 的情况（$ 开头的一般是 Vue 组件实例上的内置属性），在 Vue 3 源码中，会依次从 setupState、data、props、ctx 这几类数据中取状态值。\n\n这里的定义顺序，决定了后续取值的优先级顺序：setupState >data >props > ctx。\n\n如果 key 是以 $ 开头，则首先会判断是否是存在于组件实例上的内置属性：\n\nimage.png\n整体的获取顺序依次是：publicGetter > cssModule > ctx。最后，如果都取不到，那么在开发环境就会给一些告警提示。\n\n##### set\n\n接着继续看一下设置对象属性的代理函数：\n\n```typescript\nexport const PublicInstanceProxyHandlers = {\n  set({ _: instance }, key, value) {\n    const { data, setupState, ctx } = instance;\n    if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\n      // 设置 setupState\n      setupState[key] = value;\n      return true;\n    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\n      // 设置 data\n      data[key] = value;\n      return true;\n    } else if (hasOwn(instance.props, key)) {\n      // 不能给 props 赋值\n      return false;\n    }\n    if (key[0] === \"$\" && key.slice(1) in instance) {\n      // 不能给组件实例上的内置属性赋值\n      return false;\n    } else {\n      // 用户自定义数据赋值\n      ctx[key] = value;\n    }\n    return true;\n  },\n};\n```\n\n可以看到这里也是和前面 get 函数类似的通过调用顺序来实现对 set 函数不同属性设置优先级的，可以直观地看到优先级关系为：setupState > data > props。同时这里也有说明：就是如果直接对 props 或者组件实例上的内置属性赋值，则会告警。\n\n##### has\n\n最后，再看一个 proxy 属性 has 的实现：\n\n```typescript\nexport const PublicInstanceProxyHandlers = {\n  has(\n    { _: { data, setupState, accessCache, ctx, appContext, propsOptions } },\n    key\n  ) {\n    let normalizedProps;\n    return (\n      !!accessCache![key] ||\n      (data !== EMPTY_OBJ && hasOwn(data, key)) ||\n      (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) ||\n      ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||\n      hasOwn(ctx, key) ||\n      hasOwn(publicPropertiesMap, key) ||\n      hasOwn(appContext.config.globalProperties, key)\n    );\n  },\n};\n```\n\n这个函数则是依次判断 key 是否存在于 accessCache > data > setupState > prop > ctx > publicPropertiesMap > globalProperties，然后返回结果。\n\nhas 在业务代码的使用定义如下：\n\n```typescript\nexport default {\n  created() {\n    // 这里会触发 has 函数\n    console.log(\"msg\" in this);\n  },\n};\n```\n\n至此，我们就搞清楚了创建上下文代理的过程。\n\n#### 调用执行 setup 函数\n\n一个简单的包含 CompositionAPI 的 Vue 3 demo 如下：\n\n```html\n<template>\n  <p>{{ msg }}</p>\n</template>\n<script>\n  export default {\n    props: {\n      msg: String,\n    },\n    setup(props, setupContext) {\n      // todo\n    },\n  };\n</script>\n```\n\n这里的 setup 函数，正是在这里被调用执行的：\n\n```typescript\n// 获取 setup 函数\nconst { setup } = Component;\n// 存在 setup 函数\nif (setup) {\n  // 根据 setup 函数的入参长度，判断是否需要创建 setupContext 对象\n  const setupContext = (instance.setupContext =\n    setup.length > 1 ? createSetupContext(instance) : null);\n  // 调用 setup\n  const setupResult = callWithErrorHandling(setup, instance, 0, [\n    instance.props,\n    setupContext,\n  ]);\n  // 处理 setup 执行结果\n  handleSetupResult(instance, setupResult);\n}\n```\n\n##### createSetupContext\n\n因为 setupContext 是 setup 中的第二个参数，所以会判断 setup 函数参数的长度，如果大于 1，则会通过 createSetupContext 函数创建 setupContext 上下文。\n\n该上下文创建如下：\n\n```typescript\nfunction createSetupContext(instance) {\n  return {\n    get attrs() {\n      return attrs || (attrs = createAttrsProxy(instance));\n    },\n    slots: instance.slots,\n    emit: instance.emit,\n    expose,\n  };\n}\n```\n\n可以看到，setupContext 中包含了 attrs、slots、emit、expose 这些属性。这些属性分别代表着：组件的属性、插槽、派发事件的方法 emit、以及所有想从当前组件实例导出的内容 expose。\n\n这里有个小的知识点，就是可以通过函数的 length 属性来判断函数参数的个数：\n\n```typescript\nfunction foo() {}\n\nfoo.length; // 0\n\nfunction bar(a) {}\n\nbar.length; // 1\n```\n\n##### callWithErrorHandling\n\n第二步，通过 callWithErrorHandling 函数来间接执行 setup 函数，其实就是执行了以下代码：\n\n```typescript\nconst setupResult =\n  setup && setup(shallowReadonly(instance.props), setupContext);\n```\n\n只不过增加了对执行过程中 handleError 的捕获。\n\n在后续章节的阅读中，你会发现 Vue 3 很多函数的调用都是通过 callWithErrorHandling 来包裹的：\n\n```typescript\nexport function callWithErrorHandling(fn, instance, type, args = []) {\n  let res;\n  try {\n    res = args ? fn(...args) : fn();\n  } catch (err) {\n    handleError(err, instance, type);\n  }\n  return res;\n}\n```\n\n这样的好处一方面可以由 Vue 内部统一 try...catch 处理用户代码运行可能出现的错误。另一方面这些错误也可以交由用户统一注册的 errorHandler 进行处理，比如上报给监控系统。\n\n##### handleSetupResult\n\n最后执行 handleSetupResult 函数：\n\n```typescript\nfunction handleSetupResult(instance, setupResult) {\n  if (isFunction(setupResult)) {\n    // setup 返回渲染函数\n    instance.render = setupResult;\n  } else if (isObject(setupResult)) {\n    // proxyRefs 的作用就是把 setupResult 对象做一层代理\n    instance.setupState = proxyRefs(setupResult);\n  }\n  finishComponentSetup(instance);\n}\n```\n\nsetup 返回值不一样的话，会有不同的处理，如果 setupResult 是个函数，那么会把该函数绑定到 render 上。比如：\n\n```vue\n<script>\nimport { createVnode } from \"vue\";\nexport default {\n  props: {\n    msg: String,\n  },\n  setup(props, { emit }) {\n    return (ctx) => {\n      return [createVnode(\"p\", null, ctx.msg)];\n    };\n  },\n};\n</script>\n```\n\n当 setupResult 是一个对象的时候，我们为 setupResult 对象通过 proxyRefs 作了一层代理，方便用户直接访问 ref 类型的值。比如，在模板中访问 setupResult 中的数据，就可以省略 .value 的取值，而由代理来默认取 .value 的值。\n\n注意，这里 instance.setupState = proxyRefs(setupResult); 之前的 Vue 源码的写法是 instance.setupState = reactive(setupResult); ，至于为什么改成上面的，Vue 作者也有相关说明：Template auto ref unwrapping for setup() return object is now applied only to the root level refs.\n\n#### 完成组件实例设置\n\n最后，到了 finishComponentSetup 这个函数了：\n\n```typescript\nfunction finishComponentSetup(instance) {\n  // type 是个组件对象\n  const Component = instance.type;\n\n  if (!instance.render) {\n    // 如果组件没有 render 函数，那么就需要把 template 编译成 render 函数\n    if (compile && !Component.render) {\n      if (Component.template) {\n        // 这里就是 runtime 模块和 compile 模块结合点\n        // 运行时编译\n        Component.render = compile(Component.template, {\n          isCustomElement: instance.appContext.config.isCustomElement || NO,\n        });\n      }\n    }\n\n    instance.render = Component.render;\n  }\n  if (__FEATURE_OPTIONS_API__ && !(__COMPAT__ && skipOptions)) {\n    // 兼容选项式组件的调用逻辑\n  }\n}\n```\n\n这里主要做的就是根据 instance 上有没有 render 函数来判断是否需要进行运行时渲染，运行时渲染指的是在浏览器运行的过程中，动态编译 \\<template> 标签内的内容，产出渲染函数。对于编译时渲染，则是有渲染函数的，因为模板中的内容会被 webpack 中 vue-loader 这样的插件进行编译。\n\n另外需要注意的，这里有个 **FEATURE_OPTIONS_API** 变量用来标记是否是兼容 选项式 API 调用，如果我们只使用 Composition Api 那么就可以通过 webpack 静态变量注入的方式关闭此特性。然后交由 Tree-Shacking 删除无用的代码，从而减少引用代码包的体积。\n\n#### 总结\n\n有了上面的一些介绍，我们再来回答一下开篇中提到的问题：\n\n初始化渲染的时候，会从实例上获取状态 msg 的值，获取的优先级是：setupState >data >props > ctx。setupState 就是 setup 函数执行后返回的状态值，所以这里渲染的是：msg from setup。\n点击按钮的时候，会更新实例上的状态，更新的优先级是：setupState > data。所以会更新 setup 中的状态数据 msg。\n","slug":"technical-disclosure-of-vue3/2-data-broker","published":0,"date":"2023-08-12T07:53:19.989Z","updated":"2023-08-12T07:53:19.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokm000ssovc9es1f3ze","content":"<!-- \napp.mount\n  mount \n    render\n      patch\n        processComponent\n          mountComponent\n            setupComponent\n              setupStatefulComponent\n                markRaw\n                  def\n                    defineProperty\n                Proxy\n                createSetupContext\n                setup\n                handleSetupResult\n                  proxyRefs\n                  finishComponentSetup\n                    compile\n                finishComponentSetup\n                  applyOptions\n                    createWatcher\n                      watch\n                        doWatch\n                          run\n                            getter\n                              callWithErrorHandling\n                                getter\n                                  get\n\n -->\n\n<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>在开启本小节之前，我们先看一个有意思的示例，组件上有一个动态文本节点 ，但是却有 2 处定义了 msg 响应式数据；另外有一个按钮，点击后会修改响应式数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">  &lt;button @click=&quot;changeMsg&quot;&gt;点击试试&lt;/button&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      msg: &quot;msg from data&quot;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const msg = ref(&quot;msg from setup&quot;);</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      msg,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    changeMsg() &#123;</span><br><span class=\"line\">      this.msg = &quot;change&quot;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>思考一下：</p>\n<p>界面显示的内容是什么？<br>点击按钮后，修改的是哪部分的数据？是 data 中定义的，还是 setup 中的呢？<br>先别急着找答案，相信你阅读完这一节，一定会得到答案。</p>\n<p>上一节，我们知道了根组件在初始化渲染的过程中，会执行 mountComponent 的函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">mountComponent</span>(<span class=\"params\">initialVNode, container, parentComponent</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 先创建一个 component instance</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> instance = (initialVNode.<span class=\"property\">component</span> = <span class=\"title function_\">createComponentInstance</span>(</span><br><span class=\"line\">    initialVNode,</span><br><span class=\"line\">    parentComponent</span><br><span class=\"line\">  ));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2. 初始化组件实例</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">setupComponent</span>(instance);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 设置并运行带副作用的渲染函数</span></span><br><span class=\"line\">  <span class=\"title function_\">setupRenderEffect</span>(instance, initialVNode, container);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上文，我们简单介绍了关于 setupComponent 函数的作用是为了对实例化后的组件中的属性做一些优化、处理、赋值等操作。本小节我们将重点介绍 setupComponent 的内部实现和作用。</p>\n<h4 id=\"初始化组件实例\"><a href=\"#初始化组件实例\" class=\"headerlink\" title=\"初始化组件实例\"></a>初始化组件实例</h4><p>我们再来回顾一下 setupComponent 在源码中的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">setupComponent</span>(<span class=\"params\">instance, isSSR = <span class=\"literal\">false</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; props, children &#125; = instance.<span class=\"property\">vnode</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 判断组件是否是有状态的组件</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> isStateful = <span class=\"title function_\">isStatefulComponent</span>(instance);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 初始化 props</span></span><br><span class=\"line\">  <span class=\"title function_\">initProps</span>(instance, props, isStateful, isSSR);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 初始化 slots</span></span><br><span class=\"line\">  <span class=\"title function_\">initSlots</span>(instance, children);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 如果是有状态组件，那么去设置有状态组件实例</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> setupResult = isStateful</span><br><span class=\"line\">    ? <span class=\"title function_\">setupStatefulComponent</span>(instance, isSSR)</span><br><span class=\"line\">    : <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> setupResult;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>setupComponent 方法做了什么？</p>\n<p>通过 isStatefulComponent(instance) 判断是否是有状态的组件；<br>initProps 初始化 props；<br>initSlots 初始化 slots；<br>根据组件是否是有状态的，来决定是否需要执行 setupStatefulComponent 函数。<br>其中， isStatefulComponent 判断是否是有状态的组件的函数如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isStatefulComponent</span>(<span class=\"params\">instance</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> instance.<span class=\"property\">vnode</span>.<span class=\"property\">shapeFlag</span> &amp; <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">STATEFUL_COMPONENT</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前面我们已经说过了，ShapeFlags 在遇到组件类型的 type &#x3D; Object 时，vnode 的 shapeFlags &#x3D; ShapeFlags.STATEFUL_COMPONENT。所以这里会执行 setupStatefulComponent 函数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setupStatefulComponent</span>(<span class=\"params\">instance, isSSR</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义 Component 变量</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title class_\">Component</span> = instance.<span class=\"property\">type</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 1. 创建渲染代理的属性访问缓存</span></span><br><span class=\"line\">  instance.<span class=\"property\">accessCache</span> = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 2. 创建渲染上下文代理, proxy 对象其实是代理了 instance.ctx 对象</span></span><br><span class=\"line\">  instance.<span class=\"property\">proxy</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(instance.<span class=\"property\">ctx</span>, <span class=\"title class_\">PublicInstanceProxyHandlers</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 3. 执行 setup 函数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; setup &#125; = <span class=\"title class_\">Component</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (setup) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 setup 函数带参数，则创建一个 setupContext</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> setupContext = (instance.<span class=\"property\">setupContext</span> =</span><br><span class=\"line\">      setup.<span class=\"property\">length</span> &gt; <span class=\"number\">1</span> ? <span class=\"title function_\">createSetupContext</span>(instance) : <span class=\"literal\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 执行 setup 函数，获取结果</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> setupResult = <span class=\"title function_\">callWithErrorHandling</span>(setup, instance, <span class=\"number\">0</span>, [</span><br><span class=\"line\">      instance.<span class=\"property\">props</span>,</span><br><span class=\"line\">      setupContext,</span><br><span class=\"line\">    ]);</span><br><span class=\"line\">    <span class=\"comment\">// 处理 setup 执行结果</span></span><br><span class=\"line\">    <span class=\"title function_\">handleSetupResult</span>(instance, setupResult);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 4. 完成组件实例设置</span></span><br><span class=\"line\">    <span class=\"title function_\">finishComponentSetup</span>(instance, isSSR);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>setupStatefulComponent 字面意思就是设置有状态组件，那么什么是有状态组件呢？简单而言，就是对于有状态组件，Vue 内部会保留组件状态数据。相对于有状态组件而言，Vue 还存在一种函数组件 FUNCTIONAL_COMPONENT，一起看个示例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; ref &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;vue&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> num = <span class=\"title function_\">ref</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">plusNum</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    num.<span class=\"property\">value</span>++;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;plusNum&#125;</span>&gt;</span>&#123;num.value&#125;<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数点击按钮时，num 的值并不会按照我们预期那样值会一直递增，因为它是一个函数组件，函数组件内部是没有状态保持的，所以 num 数据更新时，组件会重新渲染，num 的值永远不变一直是 0。</p>\n<p>所以在这个时候，为了能符合我们预期的结果，我们需要将其设置成有状态的组件。我们可以通过 defineComponent 函数包装一下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; ref, defineComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;vue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineComponent</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> num = <span class=\"title function_\">ref</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">plusNum</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    num.<span class=\"property\">value</span>++;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;plusNum&#125;</span>&gt;</span>&#123;num.value&#125;<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>defineComponent 返回的是个对象类型的 type，所以就变成了有状态组件。</p>\n<p>好了，搞清楚什么是有状态组件后，我们接着回到 setupStatefulComponent 实现中，来一步步地分析其核心实现的原理。</p>\n<h4 id=\"创建渲染上下文代理\"><a href=\"#创建渲染上下文代理\" class=\"headerlink\" title=\"创建渲染上下文代理\"></a>创建渲染上下文代理</h4><p>首先我们看 1-2 两个步骤，关于第一点：为什么要创建渲染代理的属性访问缓存呢？这里先卖个关子，先看第二步：创建渲染上下文代理，这里为什么要对 instance.ctx 做代理呢？如果熟悉 Vue 2 的小伙伴应该了解对于 Vue 2 的 Options API 的写法如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; num &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"title function_\">data</span>(<span class=\"params\"></span>) &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"attr\">num</span>: <span class=\"number\">1</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125;,</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"variable language_\">this</span>.<span class=\"property\">num</span> = <span class=\"number\">2</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125;,</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">&#125;;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>Vue 2.x 是如何实现访问 this.num 获取到 num 的值，而不是通过 this._data.num 来获取 num 的值呢？其实 Vue 2.x 版本中，为 _data 设置了一层代理：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">_proxy</span>(options.<span class=\"property\">data</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">_proxy</span>(<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> that = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(data).<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(that, key, &#123;</span><br><span class=\"line\">      <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> <span class=\"title function_\">proxyGetter</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> that.<span class=\"property\">_data</span>[key];</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">set</span>: <span class=\"keyword\">function</span> <span class=\"title function_\">proxySetter</span>(<span class=\"params\">val</span>) &#123;</span><br><span class=\"line\">        that.<span class=\"property\">_data</span>[key] = val;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>本质就是通过 Object.defineProperty 使在访问 this 上的某属性时从 this._data 中读取（写入）。</p>\n<p>而 Vue 3 也在这里做了类似的事情，Vue 3 内部有很多状态属性，存储在不同的对象上，比如 setupState、ctx、data、props。这样用户取数据就会考虑具体从哪个对象中获取，这无疑增加了用户的使用负担，所以对 instance.ctx 进行代理，然后根据属性优先级关系依次完成从特定对象上获取值。</p>\n<h5 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h5><p>了解了代理的功能后，我们来具体看一下是如何实现代理功能的，也就是 proxy 的 PublicInstanceProxyHandlers 它的实现。先看一下 get 函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">PublicInstanceProxyHandlers</span> = &#123;</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\">&#123; _: instance &#125;, key</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; ctx, setupState, data, props, accessCache, <span class=\"keyword\">type</span>, appContext &#125; =</span><br><span class=\"line\">      instance;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> normalizedProps;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key[<span class=\"number\">0</span>] !== <span class=\"string\">&quot;$&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 从缓存中获取当前 key 存在于哪个属性中</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> n = accessCache![key];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (n !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (n) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"title class_\">AccessTypes</span>.<span class=\"property\">SETUP</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> setupState[key];</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"title class_\">AccessTypes</span>.<span class=\"property\">DATA</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> data[key];</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"title class_\">AccessTypes</span>.<span class=\"property\">CONTEXT</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ctx[key];</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"title class_\">AccessTypes</span>.<span class=\"property\">PROPS</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> props![key];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (setupState !== <span class=\"variable constant_\">EMPTY_OBJ</span> &amp;&amp; <span class=\"title function_\">hasOwn</span>(setupState, key)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从 setupState 中取</span></span><br><span class=\"line\">        accessCache![key] = <span class=\"title class_\">AccessTypes</span>.<span class=\"property\">SETUP</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> setupState[key];</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data !== <span class=\"variable constant_\">EMPTY_OBJ</span> &amp;&amp; <span class=\"title function_\">hasOwn</span>(data, key)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从 data 中取</span></span><br><span class=\"line\">        accessCache![key] = <span class=\"title class_\">AccessTypes</span>.<span class=\"property\">DATA</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data[key];</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        (normalizedProps = instance.<span class=\"property\">propsOptions</span>[<span class=\"number\">0</span>]) &amp;&amp;</span><br><span class=\"line\">        <span class=\"title function_\">hasOwn</span>(normalizedProps, key)</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从 props 中取</span></span><br><span class=\"line\">        accessCache![key] = <span class=\"title class_\">AccessTypes</span>.<span class=\"property\">PROPS</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> props![key];</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ctx !== <span class=\"variable constant_\">EMPTY_OBJ</span> &amp;&amp; <span class=\"title function_\">hasOwn</span>(ctx, key)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从 ctx 中取</span></span><br><span class=\"line\">        accessCache![key] = <span class=\"title class_\">AccessTypes</span>.<span class=\"property\">CONTEXT</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ctx[key];</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 都取不到</span></span><br><span class=\"line\">        accessCache![key] = <span class=\"title class_\">AccessTypes</span>.<span class=\"property\">OTHER</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> publicGetter = publicPropertiesMap[key];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cssModule, globalProperties;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (publicGetter) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 以 $ 保留字开头的相关函数和方法</span></span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      <span class=\"comment\">// css module</span></span><br><span class=\"line\">      (cssModule = <span class=\"keyword\">type</span>.<span class=\"property\">__cssModules</span>) &amp;&amp;</span><br><span class=\"line\">      (cssModule = cssModule[key])</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ctx !== <span class=\"variable constant_\">EMPTY_OBJ</span> &amp;&amp; <span class=\"title function_\">hasOwn</span>(ctx, key)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      <span class=\"comment\">// 全局属性</span></span><br><span class=\"line\">      ((globalProperties = appContext.<span class=\"property\">config</span>.<span class=\"property\">globalProperties</span>),</span><br><span class=\"line\">      <span class=\"title function_\">hasOwn</span>(globalProperties, key))</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (__DEV__) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 一些告警</span></span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里，可以回答我们的第一步 创建渲染代理的属性访问缓存 这个步骤的问题了。如果我们知道 key 存在于哪个对象上，那么就可以直接通过对象取值的操作获取属性上的值了。如果我们不知道用户访问的 key 存在于哪个属性上，那只能通过 hasOwn 的方法先判断存在于哪个属性上，再通过对象取值的操作获取属性值，这无疑是多操作了一步，而且这个判断是比较耗费性能的。如果遇到大量渲染取值的操作，那么这块就是个性能瓶颈，所以这里用了 accessCache 来标记缓存 key 存在于哪个属性上。这其实也相当于用一部分空间换时间的优化。</p>\n<p>接下来，函数首先判断 key[0] !&#x3D;&#x3D; ‘$’ 的情况（$ 开头的一般是 Vue 组件实例上的内置属性），在 Vue 3 源码中，会依次从 setupState、data、props、ctx 这几类数据中取状态值。</p>\n<p>这里的定义顺序，决定了后续取值的优先级顺序：setupState &gt;data &gt;props &gt; ctx。</p>\n<p>如果 key 是以 $ 开头，则首先会判断是否是存在于组件实例上的内置属性：</p>\n<p>image.png<br>整体的获取顺序依次是：publicGetter &gt; cssModule &gt; ctx。最后，如果都取不到，那么在开发环境就会给一些告警提示。</p>\n<h5 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h5><p>接着继续看一下设置对象属性的代理函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">PublicInstanceProxyHandlers</span> = &#123;</span><br><span class=\"line\">  <span class=\"title function_\">set</span>(<span class=\"params\">&#123; _: instance &#125;, key, value</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; data, setupState, ctx &#125; = instance;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (setupState !== <span class=\"variable constant_\">EMPTY_OBJ</span> &amp;&amp; <span class=\"title function_\">hasOwn</span>(setupState, key)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 设置 setupState</span></span><br><span class=\"line\">      setupState[key] = value;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data !== <span class=\"variable constant_\">EMPTY_OBJ</span> &amp;&amp; <span class=\"title function_\">hasOwn</span>(data, key)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 设置 data</span></span><br><span class=\"line\">      data[key] = value;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">hasOwn</span>(instance.<span class=\"property\">props</span>, key)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 不能给 props 赋值</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key[<span class=\"number\">0</span>] === <span class=\"string\">&quot;$&quot;</span> &amp;&amp; key.<span class=\"title function_\">slice</span>(<span class=\"number\">1</span>) <span class=\"keyword\">in</span> instance) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 不能给组件实例上的内置属性赋值</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 用户自定义数据赋值</span></span><br><span class=\"line\">      ctx[key] = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到这里也是和前面 get 函数类似的通过调用顺序来实现对 set 函数不同属性设置优先级的，可以直观地看到优先级关系为：setupState &gt; data &gt; props。同时这里也有说明：就是如果直接对 props 或者组件实例上的内置属性赋值，则会告警。</p>\n<h5 id=\"has\"><a href=\"#has\" class=\"headerlink\" title=\"has\"></a>has</h5><p>最后，再看一个 proxy 属性 has 的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">PublicInstanceProxyHandlers</span> = &#123;</span><br><span class=\"line\">  <span class=\"title function_\">has</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    &#123; _: &#123; data, setupState, accessCache, ctx, appContext, propsOptions &#125; &#125;,</span></span><br><span class=\"line\"><span class=\"params\">    key</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> normalizedProps;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      !!accessCache![key] ||</span><br><span class=\"line\">      (data !== <span class=\"variable constant_\">EMPTY_OBJ</span> &amp;&amp; <span class=\"title function_\">hasOwn</span>(data, key)) ||</span><br><span class=\"line\">      (setupState !== <span class=\"variable constant_\">EMPTY_OBJ</span> &amp;&amp; <span class=\"title function_\">hasOwn</span>(setupState, key)) ||</span><br><span class=\"line\">      ((normalizedProps = propsOptions[<span class=\"number\">0</span>]) &amp;&amp; <span class=\"title function_\">hasOwn</span>(normalizedProps, key)) ||</span><br><span class=\"line\">      <span class=\"title function_\">hasOwn</span>(ctx, key) ||</span><br><span class=\"line\">      <span class=\"title function_\">hasOwn</span>(publicPropertiesMap, key) ||</span><br><span class=\"line\">      <span class=\"title function_\">hasOwn</span>(appContext.<span class=\"property\">config</span>.<span class=\"property\">globalProperties</span>, key)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数则是依次判断 key 是否存在于 accessCache &gt; data &gt; setupState &gt; prop &gt; ctx &gt; publicPropertiesMap &gt; globalProperties，然后返回结果。</p>\n<p>has 在业务代码的使用定义如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">created</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里会触发 has 函数</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;msg&quot;</span> <span class=\"keyword\">in</span> <span class=\"variable language_\">this</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>至此，我们就搞清楚了创建上下文代理的过程。</p>\n<h4 id=\"调用执行-setup-函数\"><a href=\"#调用执行-setup-函数\" class=\"headerlink\" title=\"调用执行 setup 函数\"></a>调用执行 setup 函数</h4><p>一个简单的包含 CompositionAPI 的 Vue 3 demo 如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"attr\">props</span>: &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"attr\">msg</span>: <span class=\"title class_\">String</span>,</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"title function_\">setup</span>(<span class=\"params\">props, setupContext</span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"comment\">// todo</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这里的 setup 函数，正是在这里被调用执行的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取 setup 函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; setup &#125; = <span class=\"title class_\">Component</span>;</span><br><span class=\"line\"><span class=\"comment\">// 存在 setup 函数</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (setup) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 根据 setup 函数的入参长度，判断是否需要创建 setupContext 对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> setupContext = (instance.<span class=\"property\">setupContext</span> =</span><br><span class=\"line\">    setup.<span class=\"property\">length</span> &gt; <span class=\"number\">1</span> ? <span class=\"title function_\">createSetupContext</span>(instance) : <span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 调用 setup</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> setupResult = <span class=\"title function_\">callWithErrorHandling</span>(setup, instance, <span class=\"number\">0</span>, [</span><br><span class=\"line\">    instance.<span class=\"property\">props</span>,</span><br><span class=\"line\">    setupContext,</span><br><span class=\"line\">  ]);</span><br><span class=\"line\">  <span class=\"comment\">// 处理 setup 执行结果</span></span><br><span class=\"line\">  <span class=\"title function_\">handleSetupResult</span>(instance, setupResult);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"createSetupContext\"><a href=\"#createSetupContext\" class=\"headerlink\" title=\"createSetupContext\"></a>createSetupContext</h5><p>因为 setupContext 是 setup 中的第二个参数，所以会判断 setup 函数参数的长度，如果大于 1，则会通过 createSetupContext 函数创建 setupContext 上下文。</p>\n<p>该上下文创建如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createSetupContext</span>(<span class=\"params\">instance</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">attrs</span>() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> attrs || (attrs = <span class=\"title function_\">createAttrsProxy</span>(instance));</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">slots</span>: instance.<span class=\"property\">slots</span>,</span><br><span class=\"line\">    <span class=\"attr\">emit</span>: instance.<span class=\"property\">emit</span>,</span><br><span class=\"line\">    expose,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，setupContext 中包含了 attrs、slots、emit、expose 这些属性。这些属性分别代表着：组件的属性、插槽、派发事件的方法 emit、以及所有想从当前组件实例导出的内容 expose。</p>\n<p>这里有个小的知识点，就是可以通过函数的 length 属性来判断函数参数的个数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.<span class=\"property\">length</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">bar</span>(<span class=\"params\">a</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bar.<span class=\"property\">length</span>; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"callWithErrorHandling\"><a href=\"#callWithErrorHandling\" class=\"headerlink\" title=\"callWithErrorHandling\"></a>callWithErrorHandling</h5><p>第二步，通过 callWithErrorHandling 函数来间接执行 setup 函数，其实就是执行了以下代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> setupResult =</span><br><span class=\"line\">  setup &amp;&amp; <span class=\"title function_\">setup</span>(<span class=\"title function_\">shallowReadonly</span>(instance.<span class=\"property\">props</span>), setupContext);</span><br></pre></td></tr></table></figure>\n\n<p>只不过增加了对执行过程中 handleError 的捕获。</p>\n<p>在后续章节的阅读中，你会发现 Vue 3 很多函数的调用都是通过 callWithErrorHandling 来包裹的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">callWithErrorHandling</span>(<span class=\"params\">fn, instance, <span class=\"keyword\">type</span>, args = []</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    res = args ? <span class=\"title function_\">fn</span>(...args) : <span class=\"title function_\">fn</span>();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">handleError</span>(err, instance, <span class=\"keyword\">type</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样的好处一方面可以由 Vue 内部统一 try…catch 处理用户代码运行可能出现的错误。另一方面这些错误也可以交由用户统一注册的 errorHandler 进行处理，比如上报给监控系统。</p>\n<h5 id=\"handleSetupResult\"><a href=\"#handleSetupResult\" class=\"headerlink\" title=\"handleSetupResult\"></a>handleSetupResult</h5><p>最后执行 handleSetupResult 函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleSetupResult</span>(<span class=\"params\">instance, setupResult</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title function_\">isFunction</span>(setupResult)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// setup 返回渲染函数</span></span><br><span class=\"line\">    instance.<span class=\"property\">render</span> = setupResult;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isObject</span>(setupResult)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// proxyRefs 的作用就是把 setupResult 对象做一层代理</span></span><br><span class=\"line\">    instance.<span class=\"property\">setupState</span> = <span class=\"title function_\">proxyRefs</span>(setupResult);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">finishComponentSetup</span>(instance);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>setup 返回值不一样的话，会有不同的处理，如果 setupResult 是个函数，那么会把该函数绑定到 render 上。比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; createVnode &#125; from &quot;vue&quot;;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    msg: String,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setup(props, &#123; emit &#125;) &#123;</span><br><span class=\"line\">    return (ctx) =&gt; &#123;</span><br><span class=\"line\">      return [createVnode(&quot;p&quot;, null, ctx.msg)];</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>当 setupResult 是一个对象的时候，我们为 setupResult 对象通过 proxyRefs 作了一层代理，方便用户直接访问 ref 类型的值。比如，在模板中访问 setupResult 中的数据，就可以省略 .value 的取值，而由代理来默认取 .value 的值。</p>\n<p>注意，这里 instance.setupState &#x3D; proxyRefs(setupResult); 之前的 Vue 源码的写法是 instance.setupState &#x3D; reactive(setupResult); ，至于为什么改成上面的，Vue 作者也有相关说明：Template auto ref unwrapping for setup() return object is now applied only to the root level refs.</p>\n<h4 id=\"完成组件实例设置\"><a href=\"#完成组件实例设置\" class=\"headerlink\" title=\"完成组件实例设置\"></a>完成组件实例设置</h4><p>最后，到了 finishComponentSetup 这个函数了：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">finishComponentSetup</span>(<span class=\"params\">instance</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// type 是个组件对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title class_\">Component</span> = instance.<span class=\"property\">type</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!instance.<span class=\"property\">render</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果组件没有 render 函数，那么就需要把 template 编译成 render 函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compile &amp;&amp; !<span class=\"title class_\">Component</span>.<span class=\"property\">render</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"title class_\">Component</span>.<span class=\"property\">template</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里就是 runtime 模块和 compile 模块结合点</span></span><br><span class=\"line\">        <span class=\"comment\">// 运行时编译</span></span><br><span class=\"line\">        <span class=\"title class_\">Component</span>.<span class=\"property\">render</span> = <span class=\"title function_\">compile</span>(<span class=\"title class_\">Component</span>.<span class=\"property\">template</span>, &#123;</span><br><span class=\"line\">          <span class=\"attr\">isCustomElement</span>: instance.<span class=\"property\">appContext</span>.<span class=\"property\">config</span>.<span class=\"property\">isCustomElement</span> || <span class=\"variable constant_\">NO</span>,</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    instance.<span class=\"property\">render</span> = <span class=\"title class_\">Component</span>.<span class=\"property\">render</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__FEATURE_OPTIONS_API__ &amp;&amp; !(__COMPAT__ &amp;&amp; skipOptions)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 兼容选项式组件的调用逻辑</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里主要做的就是根据 instance 上有没有 render 函数来判断是否需要进行运行时渲染，运行时渲染指的是在浏览器运行的过程中，动态编译 &lt;template&gt; 标签内的内容，产出渲染函数。对于编译时渲染，则是有渲染函数的，因为模板中的内容会被 webpack 中 vue-loader 这样的插件进行编译。</p>\n<p>另外需要注意的，这里有个 <strong>FEATURE_OPTIONS_API</strong> 变量用来标记是否是兼容 选项式 API 调用，如果我们只使用 Composition Api 那么就可以通过 webpack 静态变量注入的方式关闭此特性。然后交由 Tree-Shacking 删除无用的代码，从而减少引用代码包的体积。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>有了上面的一些介绍，我们再来回答一下开篇中提到的问题：</p>\n<p>初始化渲染的时候，会从实例上获取状态 msg 的值，获取的优先级是：setupState &gt;data &gt;props &gt; ctx。setupState 就是 setup 函数执行后返回的状态值，所以这里渲染的是：msg from setup。<br>点击按钮的时候，会更新实例上的状态，更新的优先级是：setupState &gt; data。所以会更新 setup 中的状态数据 msg。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#e7817c","excerpt":"","more":"<!-- \napp.mount\n  mount \n    render\n      patch\n        processComponent\n          mountComponent\n            setupComponent\n              setupStatefulComponent\n                markRaw\n                  def\n                    defineProperty\n                Proxy\n                createSetupContext\n                setup\n                handleSetupResult\n                  proxyRefs\n                  finishComponentSetup\n                    compile\n                finishComponentSetup\n                  applyOptions\n                    createWatcher\n                      watch\n                        doWatch\n                          run\n                            getter\n                              callWithErrorHandling\n                                getter\n                                  get\n\n -->\n\n<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>在开启本小节之前，我们先看一个有意思的示例，组件上有一个动态文本节点 ，但是却有 2 处定义了 msg 响应式数据；另外有一个按钮，点击后会修改响应式数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">  &lt;button @click=&quot;changeMsg&quot;&gt;点击试试&lt;/button&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      msg: &quot;msg from data&quot;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const msg = ref(&quot;msg from setup&quot;);</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      msg,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    changeMsg() &#123;</span><br><span class=\"line\">      this.msg = &quot;change&quot;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>思考一下：</p>\n<p>界面显示的内容是什么？<br>点击按钮后，修改的是哪部分的数据？是 data 中定义的，还是 setup 中的呢？<br>先别急着找答案，相信你阅读完这一节，一定会得到答案。</p>\n<p>上一节，我们知道了根组件在初始化渲染的过程中，会执行 mountComponent 的函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">mountComponent</span>(<span class=\"params\">initialVNode, container, parentComponent</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 先创建一个 component instance</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> instance = (initialVNode.<span class=\"property\">component</span> = <span class=\"title function_\">createComponentInstance</span>(</span><br><span class=\"line\">    initialVNode,</span><br><span class=\"line\">    parentComponent</span><br><span class=\"line\">  ));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2. 初始化组件实例</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">setupComponent</span>(instance);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 设置并运行带副作用的渲染函数</span></span><br><span class=\"line\">  <span class=\"title function_\">setupRenderEffect</span>(instance, initialVNode, container);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上文，我们简单介绍了关于 setupComponent 函数的作用是为了对实例化后的组件中的属性做一些优化、处理、赋值等操作。本小节我们将重点介绍 setupComponent 的内部实现和作用。</p>\n<h4 id=\"初始化组件实例\"><a href=\"#初始化组件实例\" class=\"headerlink\" title=\"初始化组件实例\"></a>初始化组件实例</h4><p>我们再来回顾一下 setupComponent 在源码中的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">setupComponent</span>(<span class=\"params\">instance, isSSR = <span class=\"literal\">false</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; props, children &#125; = instance.<span class=\"property\">vnode</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 判断组件是否是有状态的组件</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> isStateful = <span class=\"title function_\">isStatefulComponent</span>(instance);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 初始化 props</span></span><br><span class=\"line\">  <span class=\"title function_\">initProps</span>(instance, props, isStateful, isSSR);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 初始化 slots</span></span><br><span class=\"line\">  <span class=\"title function_\">initSlots</span>(instance, children);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 如果是有状态组件，那么去设置有状态组件实例</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> setupResult = isStateful</span><br><span class=\"line\">    ? <span class=\"title function_\">setupStatefulComponent</span>(instance, isSSR)</span><br><span class=\"line\">    : <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> setupResult;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>setupComponent 方法做了什么？</p>\n<p>通过 isStatefulComponent(instance) 判断是否是有状态的组件；<br>initProps 初始化 props；<br>initSlots 初始化 slots；<br>根据组件是否是有状态的，来决定是否需要执行 setupStatefulComponent 函数。<br>其中， isStatefulComponent 判断是否是有状态的组件的函数如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isStatefulComponent</span>(<span class=\"params\">instance</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> instance.<span class=\"property\">vnode</span>.<span class=\"property\">shapeFlag</span> &amp; <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">STATEFUL_COMPONENT</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前面我们已经说过了，ShapeFlags 在遇到组件类型的 type &#x3D; Object 时，vnode 的 shapeFlags &#x3D; ShapeFlags.STATEFUL_COMPONENT。所以这里会执行 setupStatefulComponent 函数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setupStatefulComponent</span>(<span class=\"params\">instance, isSSR</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义 Component 变量</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title class_\">Component</span> = instance.<span class=\"property\">type</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 1. 创建渲染代理的属性访问缓存</span></span><br><span class=\"line\">  instance.<span class=\"property\">accessCache</span> = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 2. 创建渲染上下文代理, proxy 对象其实是代理了 instance.ctx 对象</span></span><br><span class=\"line\">  instance.<span class=\"property\">proxy</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(instance.<span class=\"property\">ctx</span>, <span class=\"title class_\">PublicInstanceProxyHandlers</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 3. 执行 setup 函数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; setup &#125; = <span class=\"title class_\">Component</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (setup) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 setup 函数带参数，则创建一个 setupContext</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> setupContext = (instance.<span class=\"property\">setupContext</span> =</span><br><span class=\"line\">      setup.<span class=\"property\">length</span> &gt; <span class=\"number\">1</span> ? <span class=\"title function_\">createSetupContext</span>(instance) : <span class=\"literal\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 执行 setup 函数，获取结果</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> setupResult = <span class=\"title function_\">callWithErrorHandling</span>(setup, instance, <span class=\"number\">0</span>, [</span><br><span class=\"line\">      instance.<span class=\"property\">props</span>,</span><br><span class=\"line\">      setupContext,</span><br><span class=\"line\">    ]);</span><br><span class=\"line\">    <span class=\"comment\">// 处理 setup 执行结果</span></span><br><span class=\"line\">    <span class=\"title function_\">handleSetupResult</span>(instance, setupResult);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 4. 完成组件实例设置</span></span><br><span class=\"line\">    <span class=\"title function_\">finishComponentSetup</span>(instance, isSSR);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>setupStatefulComponent 字面意思就是设置有状态组件，那么什么是有状态组件呢？简单而言，就是对于有状态组件，Vue 内部会保留组件状态数据。相对于有状态组件而言，Vue 还存在一种函数组件 FUNCTIONAL_COMPONENT，一起看个示例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; ref &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;vue&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> num = <span class=\"title function_\">ref</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">plusNum</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    num.<span class=\"property\">value</span>++;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;plusNum&#125;</span>&gt;</span>&#123;num.value&#125;<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数点击按钮时，num 的值并不会按照我们预期那样值会一直递增，因为它是一个函数组件，函数组件内部是没有状态保持的，所以 num 数据更新时，组件会重新渲染，num 的值永远不变一直是 0。</p>\n<p>所以在这个时候，为了能符合我们预期的结果，我们需要将其设置成有状态的组件。我们可以通过 defineComponent 函数包装一下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; ref, defineComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;vue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineComponent</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> num = <span class=\"title function_\">ref</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">plusNum</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    num.<span class=\"property\">value</span>++;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;plusNum&#125;</span>&gt;</span>&#123;num.value&#125;<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>defineComponent 返回的是个对象类型的 type，所以就变成了有状态组件。</p>\n<p>好了，搞清楚什么是有状态组件后，我们接着回到 setupStatefulComponent 实现中，来一步步地分析其核心实现的原理。</p>\n<h4 id=\"创建渲染上下文代理\"><a href=\"#创建渲染上下文代理\" class=\"headerlink\" title=\"创建渲染上下文代理\"></a>创建渲染上下文代理</h4><p>首先我们看 1-2 两个步骤，关于第一点：为什么要创建渲染代理的属性访问缓存呢？这里先卖个关子，先看第二步：创建渲染上下文代理，这里为什么要对 instance.ctx 做代理呢？如果熟悉 Vue 2 的小伙伴应该了解对于 Vue 2 的 Options API 的写法如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; num &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"title function_\">data</span>(<span class=\"params\"></span>) &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"attr\">num</span>: <span class=\"number\">1</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125;,</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"title function_\">mounted</span>(<span class=\"params\"></span>) &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"variable language_\">this</span>.<span class=\"property\">num</span> = <span class=\"number\">2</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125;,</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">&#125;;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>Vue 2.x 是如何实现访问 this.num 获取到 num 的值，而不是通过 this._data.num 来获取 num 的值呢？其实 Vue 2.x 版本中，为 _data 设置了一层代理：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">_proxy</span>(options.<span class=\"property\">data</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">_proxy</span>(<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> that = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(data).<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(that, key, &#123;</span><br><span class=\"line\">      <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> <span class=\"title function_\">proxyGetter</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> that.<span class=\"property\">_data</span>[key];</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">set</span>: <span class=\"keyword\">function</span> <span class=\"title function_\">proxySetter</span>(<span class=\"params\">val</span>) &#123;</span><br><span class=\"line\">        that.<span class=\"property\">_data</span>[key] = val;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>本质就是通过 Object.defineProperty 使在访问 this 上的某属性时从 this._data 中读取（写入）。</p>\n<p>而 Vue 3 也在这里做了类似的事情，Vue 3 内部有很多状态属性，存储在不同的对象上，比如 setupState、ctx、data、props。这样用户取数据就会考虑具体从哪个对象中获取，这无疑增加了用户的使用负担，所以对 instance.ctx 进行代理，然后根据属性优先级关系依次完成从特定对象上获取值。</p>\n<h5 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h5><p>了解了代理的功能后，我们来具体看一下是如何实现代理功能的，也就是 proxy 的 PublicInstanceProxyHandlers 它的实现。先看一下 get 函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">PublicInstanceProxyHandlers</span> = &#123;</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\">&#123; _: instance &#125;, key</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; ctx, setupState, data, props, accessCache, <span class=\"keyword\">type</span>, appContext &#125; =</span><br><span class=\"line\">      instance;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> normalizedProps;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key[<span class=\"number\">0</span>] !== <span class=\"string\">&quot;$&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 从缓存中获取当前 key 存在于哪个属性中</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> n = accessCache![key];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (n !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (n) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"title class_\">AccessTypes</span>.<span class=\"property\">SETUP</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> setupState[key];</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"title class_\">AccessTypes</span>.<span class=\"property\">DATA</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> data[key];</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"title class_\">AccessTypes</span>.<span class=\"property\">CONTEXT</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ctx[key];</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"title class_\">AccessTypes</span>.<span class=\"property\">PROPS</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> props![key];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (setupState !== <span class=\"variable constant_\">EMPTY_OBJ</span> &amp;&amp; <span class=\"title function_\">hasOwn</span>(setupState, key)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从 setupState 中取</span></span><br><span class=\"line\">        accessCache![key] = <span class=\"title class_\">AccessTypes</span>.<span class=\"property\">SETUP</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> setupState[key];</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data !== <span class=\"variable constant_\">EMPTY_OBJ</span> &amp;&amp; <span class=\"title function_\">hasOwn</span>(data, key)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从 data 中取</span></span><br><span class=\"line\">        accessCache![key] = <span class=\"title class_\">AccessTypes</span>.<span class=\"property\">DATA</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data[key];</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        (normalizedProps = instance.<span class=\"property\">propsOptions</span>[<span class=\"number\">0</span>]) &amp;&amp;</span><br><span class=\"line\">        <span class=\"title function_\">hasOwn</span>(normalizedProps, key)</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从 props 中取</span></span><br><span class=\"line\">        accessCache![key] = <span class=\"title class_\">AccessTypes</span>.<span class=\"property\">PROPS</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> props![key];</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ctx !== <span class=\"variable constant_\">EMPTY_OBJ</span> &amp;&amp; <span class=\"title function_\">hasOwn</span>(ctx, key)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从 ctx 中取</span></span><br><span class=\"line\">        accessCache![key] = <span class=\"title class_\">AccessTypes</span>.<span class=\"property\">CONTEXT</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ctx[key];</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 都取不到</span></span><br><span class=\"line\">        accessCache![key] = <span class=\"title class_\">AccessTypes</span>.<span class=\"property\">OTHER</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> publicGetter = publicPropertiesMap[key];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cssModule, globalProperties;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (publicGetter) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 以 $ 保留字开头的相关函数和方法</span></span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      <span class=\"comment\">// css module</span></span><br><span class=\"line\">      (cssModule = <span class=\"keyword\">type</span>.<span class=\"property\">__cssModules</span>) &amp;&amp;</span><br><span class=\"line\">      (cssModule = cssModule[key])</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ctx !== <span class=\"variable constant_\">EMPTY_OBJ</span> &amp;&amp; <span class=\"title function_\">hasOwn</span>(ctx, key)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      <span class=\"comment\">// 全局属性</span></span><br><span class=\"line\">      ((globalProperties = appContext.<span class=\"property\">config</span>.<span class=\"property\">globalProperties</span>),</span><br><span class=\"line\">      <span class=\"title function_\">hasOwn</span>(globalProperties, key))</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (__DEV__) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 一些告警</span></span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里，可以回答我们的第一步 创建渲染代理的属性访问缓存 这个步骤的问题了。如果我们知道 key 存在于哪个对象上，那么就可以直接通过对象取值的操作获取属性上的值了。如果我们不知道用户访问的 key 存在于哪个属性上，那只能通过 hasOwn 的方法先判断存在于哪个属性上，再通过对象取值的操作获取属性值，这无疑是多操作了一步，而且这个判断是比较耗费性能的。如果遇到大量渲染取值的操作，那么这块就是个性能瓶颈，所以这里用了 accessCache 来标记缓存 key 存在于哪个属性上。这其实也相当于用一部分空间换时间的优化。</p>\n<p>接下来，函数首先判断 key[0] !&#x3D;&#x3D; ‘$’ 的情况（$ 开头的一般是 Vue 组件实例上的内置属性），在 Vue 3 源码中，会依次从 setupState、data、props、ctx 这几类数据中取状态值。</p>\n<p>这里的定义顺序，决定了后续取值的优先级顺序：setupState &gt;data &gt;props &gt; ctx。</p>\n<p>如果 key 是以 $ 开头，则首先会判断是否是存在于组件实例上的内置属性：</p>\n<p>image.png<br>整体的获取顺序依次是：publicGetter &gt; cssModule &gt; ctx。最后，如果都取不到，那么在开发环境就会给一些告警提示。</p>\n<h5 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h5><p>接着继续看一下设置对象属性的代理函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">PublicInstanceProxyHandlers</span> = &#123;</span><br><span class=\"line\">  <span class=\"title function_\">set</span>(<span class=\"params\">&#123; _: instance &#125;, key, value</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; data, setupState, ctx &#125; = instance;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (setupState !== <span class=\"variable constant_\">EMPTY_OBJ</span> &amp;&amp; <span class=\"title function_\">hasOwn</span>(setupState, key)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 设置 setupState</span></span><br><span class=\"line\">      setupState[key] = value;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data !== <span class=\"variable constant_\">EMPTY_OBJ</span> &amp;&amp; <span class=\"title function_\">hasOwn</span>(data, key)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 设置 data</span></span><br><span class=\"line\">      data[key] = value;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">hasOwn</span>(instance.<span class=\"property\">props</span>, key)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 不能给 props 赋值</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key[<span class=\"number\">0</span>] === <span class=\"string\">&quot;$&quot;</span> &amp;&amp; key.<span class=\"title function_\">slice</span>(<span class=\"number\">1</span>) <span class=\"keyword\">in</span> instance) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 不能给组件实例上的内置属性赋值</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 用户自定义数据赋值</span></span><br><span class=\"line\">      ctx[key] = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到这里也是和前面 get 函数类似的通过调用顺序来实现对 set 函数不同属性设置优先级的，可以直观地看到优先级关系为：setupState &gt; data &gt; props。同时这里也有说明：就是如果直接对 props 或者组件实例上的内置属性赋值，则会告警。</p>\n<h5 id=\"has\"><a href=\"#has\" class=\"headerlink\" title=\"has\"></a>has</h5><p>最后，再看一个 proxy 属性 has 的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">PublicInstanceProxyHandlers</span> = &#123;</span><br><span class=\"line\">  <span class=\"title function_\">has</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    &#123; _: &#123; data, setupState, accessCache, ctx, appContext, propsOptions &#125; &#125;,</span></span><br><span class=\"line\"><span class=\"params\">    key</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> normalizedProps;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      !!accessCache![key] ||</span><br><span class=\"line\">      (data !== <span class=\"variable constant_\">EMPTY_OBJ</span> &amp;&amp; <span class=\"title function_\">hasOwn</span>(data, key)) ||</span><br><span class=\"line\">      (setupState !== <span class=\"variable constant_\">EMPTY_OBJ</span> &amp;&amp; <span class=\"title function_\">hasOwn</span>(setupState, key)) ||</span><br><span class=\"line\">      ((normalizedProps = propsOptions[<span class=\"number\">0</span>]) &amp;&amp; <span class=\"title function_\">hasOwn</span>(normalizedProps, key)) ||</span><br><span class=\"line\">      <span class=\"title function_\">hasOwn</span>(ctx, key) ||</span><br><span class=\"line\">      <span class=\"title function_\">hasOwn</span>(publicPropertiesMap, key) ||</span><br><span class=\"line\">      <span class=\"title function_\">hasOwn</span>(appContext.<span class=\"property\">config</span>.<span class=\"property\">globalProperties</span>, key)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数则是依次判断 key 是否存在于 accessCache &gt; data &gt; setupState &gt; prop &gt; ctx &gt; publicPropertiesMap &gt; globalProperties，然后返回结果。</p>\n<p>has 在业务代码的使用定义如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">created</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里会触发 has 函数</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;msg&quot;</span> <span class=\"keyword\">in</span> <span class=\"variable language_\">this</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>至此，我们就搞清楚了创建上下文代理的过程。</p>\n<h4 id=\"调用执行-setup-函数\"><a href=\"#调用执行-setup-函数\" class=\"headerlink\" title=\"调用执行 setup 函数\"></a>调用执行 setup 函数</h4><p>一个简单的包含 CompositionAPI 的 Vue 3 demo 如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"attr\">props</span>: &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"attr\">msg</span>: <span class=\"title class_\">String</span>,</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"title function_\">setup</span>(<span class=\"params\">props, setupContext</span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"comment\">// todo</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这里的 setup 函数，正是在这里被调用执行的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取 setup 函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; setup &#125; = <span class=\"title class_\">Component</span>;</span><br><span class=\"line\"><span class=\"comment\">// 存在 setup 函数</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (setup) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 根据 setup 函数的入参长度，判断是否需要创建 setupContext 对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> setupContext = (instance.<span class=\"property\">setupContext</span> =</span><br><span class=\"line\">    setup.<span class=\"property\">length</span> &gt; <span class=\"number\">1</span> ? <span class=\"title function_\">createSetupContext</span>(instance) : <span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 调用 setup</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> setupResult = <span class=\"title function_\">callWithErrorHandling</span>(setup, instance, <span class=\"number\">0</span>, [</span><br><span class=\"line\">    instance.<span class=\"property\">props</span>,</span><br><span class=\"line\">    setupContext,</span><br><span class=\"line\">  ]);</span><br><span class=\"line\">  <span class=\"comment\">// 处理 setup 执行结果</span></span><br><span class=\"line\">  <span class=\"title function_\">handleSetupResult</span>(instance, setupResult);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"createSetupContext\"><a href=\"#createSetupContext\" class=\"headerlink\" title=\"createSetupContext\"></a>createSetupContext</h5><p>因为 setupContext 是 setup 中的第二个参数，所以会判断 setup 函数参数的长度，如果大于 1，则会通过 createSetupContext 函数创建 setupContext 上下文。</p>\n<p>该上下文创建如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createSetupContext</span>(<span class=\"params\">instance</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">attrs</span>() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> attrs || (attrs = <span class=\"title function_\">createAttrsProxy</span>(instance));</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">slots</span>: instance.<span class=\"property\">slots</span>,</span><br><span class=\"line\">    <span class=\"attr\">emit</span>: instance.<span class=\"property\">emit</span>,</span><br><span class=\"line\">    expose,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，setupContext 中包含了 attrs、slots、emit、expose 这些属性。这些属性分别代表着：组件的属性、插槽、派发事件的方法 emit、以及所有想从当前组件实例导出的内容 expose。</p>\n<p>这里有个小的知识点，就是可以通过函数的 length 属性来判断函数参数的个数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.<span class=\"property\">length</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">bar</span>(<span class=\"params\">a</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bar.<span class=\"property\">length</span>; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"callWithErrorHandling\"><a href=\"#callWithErrorHandling\" class=\"headerlink\" title=\"callWithErrorHandling\"></a>callWithErrorHandling</h5><p>第二步，通过 callWithErrorHandling 函数来间接执行 setup 函数，其实就是执行了以下代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> setupResult =</span><br><span class=\"line\">  setup &amp;&amp; <span class=\"title function_\">setup</span>(<span class=\"title function_\">shallowReadonly</span>(instance.<span class=\"property\">props</span>), setupContext);</span><br></pre></td></tr></table></figure>\n\n<p>只不过增加了对执行过程中 handleError 的捕获。</p>\n<p>在后续章节的阅读中，你会发现 Vue 3 很多函数的调用都是通过 callWithErrorHandling 来包裹的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">callWithErrorHandling</span>(<span class=\"params\">fn, instance, <span class=\"keyword\">type</span>, args = []</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    res = args ? <span class=\"title function_\">fn</span>(...args) : <span class=\"title function_\">fn</span>();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">handleError</span>(err, instance, <span class=\"keyword\">type</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样的好处一方面可以由 Vue 内部统一 try…catch 处理用户代码运行可能出现的错误。另一方面这些错误也可以交由用户统一注册的 errorHandler 进行处理，比如上报给监控系统。</p>\n<h5 id=\"handleSetupResult\"><a href=\"#handleSetupResult\" class=\"headerlink\" title=\"handleSetupResult\"></a>handleSetupResult</h5><p>最后执行 handleSetupResult 函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleSetupResult</span>(<span class=\"params\">instance, setupResult</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title function_\">isFunction</span>(setupResult)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// setup 返回渲染函数</span></span><br><span class=\"line\">    instance.<span class=\"property\">render</span> = setupResult;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isObject</span>(setupResult)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// proxyRefs 的作用就是把 setupResult 对象做一层代理</span></span><br><span class=\"line\">    instance.<span class=\"property\">setupState</span> = <span class=\"title function_\">proxyRefs</span>(setupResult);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">finishComponentSetup</span>(instance);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>setup 返回值不一样的话，会有不同的处理，如果 setupResult 是个函数，那么会把该函数绑定到 render 上。比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; createVnode &#125; from &quot;vue&quot;;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    msg: String,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setup(props, &#123; emit &#125;) &#123;</span><br><span class=\"line\">    return (ctx) =&gt; &#123;</span><br><span class=\"line\">      return [createVnode(&quot;p&quot;, null, ctx.msg)];</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>当 setupResult 是一个对象的时候，我们为 setupResult 对象通过 proxyRefs 作了一层代理，方便用户直接访问 ref 类型的值。比如，在模板中访问 setupResult 中的数据，就可以省略 .value 的取值，而由代理来默认取 .value 的值。</p>\n<p>注意，这里 instance.setupState &#x3D; proxyRefs(setupResult); 之前的 Vue 源码的写法是 instance.setupState &#x3D; reactive(setupResult); ，至于为什么改成上面的，Vue 作者也有相关说明：Template auto ref unwrapping for setup() return object is now applied only to the root level refs.</p>\n<h4 id=\"完成组件实例设置\"><a href=\"#完成组件实例设置\" class=\"headerlink\" title=\"完成组件实例设置\"></a>完成组件实例设置</h4><p>最后，到了 finishComponentSetup 这个函数了：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">finishComponentSetup</span>(<span class=\"params\">instance</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// type 是个组件对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title class_\">Component</span> = instance.<span class=\"property\">type</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!instance.<span class=\"property\">render</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果组件没有 render 函数，那么就需要把 template 编译成 render 函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compile &amp;&amp; !<span class=\"title class_\">Component</span>.<span class=\"property\">render</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"title class_\">Component</span>.<span class=\"property\">template</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里就是 runtime 模块和 compile 模块结合点</span></span><br><span class=\"line\">        <span class=\"comment\">// 运行时编译</span></span><br><span class=\"line\">        <span class=\"title class_\">Component</span>.<span class=\"property\">render</span> = <span class=\"title function_\">compile</span>(<span class=\"title class_\">Component</span>.<span class=\"property\">template</span>, &#123;</span><br><span class=\"line\">          <span class=\"attr\">isCustomElement</span>: instance.<span class=\"property\">appContext</span>.<span class=\"property\">config</span>.<span class=\"property\">isCustomElement</span> || <span class=\"variable constant_\">NO</span>,</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    instance.<span class=\"property\">render</span> = <span class=\"title class_\">Component</span>.<span class=\"property\">render</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__FEATURE_OPTIONS_API__ &amp;&amp; !(__COMPAT__ &amp;&amp; skipOptions)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 兼容选项式组件的调用逻辑</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里主要做的就是根据 instance 上有没有 render 函数来判断是否需要进行运行时渲染，运行时渲染指的是在浏览器运行的过程中，动态编译 &lt;template&gt; 标签内的内容，产出渲染函数。对于编译时渲染，则是有渲染函数的，因为模板中的内容会被 webpack 中 vue-loader 这样的插件进行编译。</p>\n<p>另外需要注意的，这里有个 <strong>FEATURE_OPTIONS_API</strong> 变量用来标记是否是兼容 选项式 API 调用，如果我们只使用 Composition Api 那么就可以通过 webpack 静态变量注入的方式关闭此特性。然后交由 Tree-Shacking 删除无用的代码，从而减少引用代码包的体积。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>有了上面的一些介绍，我们再来回答一下开篇中提到的问题：</p>\n<p>初始化渲染的时候，会从实例上获取状态 msg 的值，获取的优先级是：setupState &gt;data &gt;props &gt; ctx。setupState 就是 setup 函数执行后返回的状态值，所以这里渲染的是：msg from setup。<br>点击按钮的时候，会更新实例上的状态，更新的优先级是：setupState &gt; data。所以会更新 setup 中的状态数据 msg。</p>\n"},{"_content":"<!-- \nwithDirectives\n  getExposeProxy\n  isFunction\n  traverse\n  bindings.push\n\nvModelText.created\n  getModelAssigner\n  addEventListener\n  domValue.trim\n  looseToNumber\n  el._assign\nvModelText.beforeUpdate\n  getModelAssigner\n  el.value.trim\n  looseToNumber\n\nmountElement \n  invokeDirectiveHook\n  hostInsert\n  queuePostRenderEffect\n    invokeVNodeHook\n\nemit\n  toHandlerKey\n  camelize\n  callWithAsyncErrorHandling\n -->","source":"_drafts/technical-disclosure-of-vue3/20-v-model.md","raw":"<!-- \nwithDirectives\n  getExposeProxy\n  isFunction\n  traverse\n  bindings.push\n\nvModelText.created\n  getModelAssigner\n  addEventListener\n  domValue.trim\n  looseToNumber\n  el._assign\nvModelText.beforeUpdate\n  getModelAssigner\n  el.value.trim\n  looseToNumber\n\nmountElement \n  invokeDirectiveHook\n  hostInsert\n  queuePostRenderEffect\n    invokeVNodeHook\n\nemit\n  toHandlerKey\n  camelize\n  callWithAsyncErrorHandling\n -->","slug":"technical-disclosure-of-vue3/20-v-model","published":0,"date":"2023-08-12T07:53:19.989Z","updated":"2023-08-12T07:53:19.989Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokm000tsovcd6d07i71","content":"<!-- \nwithDirectives\n  getExposeProxy\n  isFunction\n  traverse\n  bindings.push\n\nvModelText.created\n  getModelAssigner\n  addEventListener\n  domValue.trim\n  looseToNumber\n  el._assign\nvModelText.beforeUpdate\n  getModelAssigner\n  el.value.trim\n  looseToNumber\n\nmountElement \n  invokeDirectiveHook\n  hostInsert\n  queuePostRenderEffect\n    invokeVNodeHook\n\nemit\n  toHandlerKey\n  camelize\n  callWithAsyncErrorHandling\n -->","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#e7817c","excerpt":"","more":"<!-- \nwithDirectives\n  getExposeProxy\n  isFunction\n  traverse\n  bindings.push\n\nvModelText.created\n  getModelAssigner\n  addEventListener\n  domValue.trim\n  looseToNumber\n  el._assign\nvModelText.beforeUpdate\n  getModelAssigner\n  el.value.trim\n  looseToNumber\n\nmountElement \n  invokeDirectiveHook\n  hostInsert\n  queuePostRenderEffect\n    invokeVNodeHook\n\nemit\n  toHandlerKey\n  camelize\n  callWithAsyncErrorHandling\n -->"},{"_content":"<!-- \n_createVNode\n  isVNode\n  cloneVNode\n  normalizeChildren\n    isArray\n    normalizeChildren\n    InternalObjectKey \n\nsetupComponent\n  initProps\n  initSlots\n    toRaw\n    def\n  setupStatefulComponent\n\nrenderSlot\n  openBlock\n  ensureValidVNode\n  createBlock\n\nwithCtx\n  renderFnWithContext\n    setBlockTracking\n    setCurrentRenderingInstance\n -->","source":"_drafts/technical-disclosure-of-vue3/21-slot.md","raw":"<!-- \n_createVNode\n  isVNode\n  cloneVNode\n  normalizeChildren\n    isArray\n    normalizeChildren\n    InternalObjectKey \n\nsetupComponent\n  initProps\n  initSlots\n    toRaw\n    def\n  setupStatefulComponent\n\nrenderSlot\n  openBlock\n  ensureValidVNode\n  createBlock\n\nwithCtx\n  renderFnWithContext\n    setBlockTracking\n    setCurrentRenderingInstance\n -->","slug":"technical-disclosure-of-vue3/21-slot","published":0,"date":"2023-08-12T07:53:19.989Z","updated":"2023-08-12T07:53:19.989Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokn000usovc236f8ulj","content":"<!-- \n_createVNode\n  isVNode\n  cloneVNode\n  normalizeChildren\n    isArray\n    normalizeChildren\n    InternalObjectKey \n\nsetupComponent\n  initProps\n  initSlots\n    toRaw\n    def\n  setupStatefulComponent\n\nrenderSlot\n  openBlock\n  ensureValidVNode\n  createBlock\n\nwithCtx\n  renderFnWithContext\n    setBlockTracking\n    setCurrentRenderingInstance\n -->","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#4ebde9","excerpt":"","more":"<!-- \n_createVNode\n  isVNode\n  cloneVNode\n  normalizeChildren\n    isArray\n    normalizeChildren\n    InternalObjectKey \n\nsetupComponent\n  initProps\n  initSlots\n    toRaw\n    def\n  setupStatefulComponent\n\nrenderSlot\n  openBlock\n  ensureValidVNode\n  createBlock\n\nwithCtx\n  renderFnWithContext\n    setBlockTracking\n    setCurrentRenderingInstance\n -->"},{"title":"渲染器：组件是如何完成更新的？","_content":"\n#### 前言\n上一小节，我们介绍了数据访问代理的过程以及组件实例初始化的过程，接下来，我们将介绍组件的更新逻辑，这部分逻辑主要包含在 setupRenderEffect 这个函数中。\n\n#### 组件更新\n```typescript\nconst setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\n  function componentUpdateFn() {\n    if (!instance.isMounted) {\n      // 初始化组件\n    }\n    else {\n      // 更新组件\n    }\n  }\n  // 创建响应式的副作用渲染函数\n  instance.update = effect(componentUpdateFn, prodEffectOptions)\n}\n```\n\n在前面的小节中，我们说完了关于 mounted 的流程。接下来我们将着重来看一下组件更新的逻辑：\n\n```typescript\nconst setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\n  function componentUpdateFn() {\n    if (!instance.isMounted) {\n      // 初始化组件\n    }\n    else {\n      // 更新组件\n      let { next, vnode } = instance\n      // 如果有 next 的话说明需要更新组件的数组（props, slot 等）\n      if (next) {\n        next.el = vnode.el\n        // 更新组件实例信息\n        updateComponentPreRender(instance, next, optimized)\n      } else {\n        next = vnode\n      }\n      // 获取新的子树 vnode\n      const nextTree = renderComponentRoot(instance)\n      // 获取旧的子树 vnode\n      const prevTree = instance.subTree\n      // 更新子树 vnode\n      instance.subTree = nextTree\n      // patch 新老子树的 vnode\n      patch(\n        prevTree, \n        nextTree,\n        // 处理 teleport 相关\n        hostParentNode(prevTree.el),\n        // 处理 fragment 相关\n        getNextHostNode(prevTree),\n        instance,\n        parentSuspense,\n        isSVG)\n      // 缓存更新后的 DOM 节点\n      next.el = nextTree.el\n    }\n  }\n  // 创建响应式的副作用渲染函数\n  instance.update = effect(componentUpdateFn, prodEffectOptions)\n}\n```\n\n这里的核心流程是通过 next 来判断当前是否需要更新 vnode 的节点信息，然后渲染出新的子树 nextTree，再进行比对新旧子树并找出需要更新的点，进行 DOM 更新。我们先来看一下 patch 的更新流程：\n\n```typescript\nfunction patch(n1, n2, container = null, anchor = null, parentComponent = null) {\n  // 对于类型不同的新老节点，直接进行卸载\n  if (n1 && !isSameVNodeType(n1, n2)) {\n    anchor = getNextHostNode(n1)\n    unmount(n1, parentComponent, parentSuspense, true)\n    n1 = null\n  }\n  // 基于 n2 的类型来判断\n  // 因为 n2 是新的 vnode\n  const { type, shapeFlag } = n2;\n  switch (type) {\n    case Text:\n      processText(n1, n2, container);\n      break;\n    // 其中还有几个类型比如： static fragment comment\n    case Fragment:\n      processFragment(n1, n2, container);\n      break;\n    default:\n      // 这里就基于 shapeFlag 来处理\n      if (shapeFlag & ShapeFlags.ELEMENT) {\n        processElement(n1, n2, container, anchor, parentComponent);\n      } else if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {\n        processComponent(n1, n2, container, parentComponent);\n      }\n  }\n}\n```\n\n首先判断当 n1 存在，即存在老节点，但新节点和老节点不是同类型的节点情况，那么执行销毁老节点，新增新节点。那么 Vue 如何判断是否是不同类型的节点呢？答案就在 isSameVNodeType 函数中：\n\n```typescript\nexport function isSameVNodeType(n1, n2) {\n  // 新老节点的 type 和 key 都相同\n  return n1.type === n2.type && n1.key === n2.key\n}\n```\n\n这里比如从 div 变成了 p 标签，那么 isSameVNodeType 就会是个 false。\n\n如果当新老节点是同类型的节点，则会根据 shapeFlag不同走到不同的逻辑，如果是普通元素更新，那么就会走到 processElement 的逻辑中；如果是组件更新，则会走到 processComponent 中。\n\n接下来分别看看这两种更新机制有什么不同。\n\n#### processElement\n这里我们也着重看一下 processElement 的更新流程：\n\n```typescript\nconst processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  isSVG = isSVG || n2.type === 'svg'\n  if (n1 == null) {\n    // 初始化的过程\n  }\n  else {\n    // 更新的过程\n    patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized)\n  }\n}\n```\n\nprocessElement 更新逻辑调用 patchElement 函数：\n\n```typescript\nconst patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, optimized) => {\n  const el = (n2.el = n1.el)\n  let { patchFlag, dynamicChildren, dirs } = n2\n  // ...\n  // 旧节点的 props\n  const oldProps = (n1 && n1.props) || EMPTY_OBJ\n  // 新节点的 props\n  const newProps = n2.props || EMPTY_OBJ\n  // 对比 props 并更新\n  patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG)  \n  // 先省略 dynamicChildren 的逻辑，后续介绍... \n  // 全量比对子节点更新\n  patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG)\n}\n```\n\n可以看到普通元素的更新主要做的就是先更新 props ，当 props 更新完成后，然后再统一更新子节点。关于如何进行 patchProps 做节点的属性更新不是本小节的重点，这里先跳过。\n\n这里省略了对 dynamicChildren 存在时，执行 patchBlockChildren 的优化 diff 过程，我们直接先看全量 diff 也就是 patchChildren 函数。关于 patchBlockChildren 我们将在编译过程中的优化小节中进行详细介绍\n\n接着来看 patchChildren 更新子节点的函数：\n\n```typescript\nconst patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized = false) => {\n  // c1 代表旧节点的子节点元素\n  const c1 = n1 && n1.children\n  const prevShapeFlag = n1 ? n1.shapeFlag : 0\n  // c2 代表新节点的子节点元素\n  const c2 = n2.children\n  const { patchFlag, shapeFlag } = n2\n  // 新节点是文本\n  // 3 + 2 + 4\n  if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n    // 旧节点是数组\n    if (prevShapeFlag & ARRAY_CHILDREN) {\n      // 卸载旧节点\n      unmountChildren(c1, parentComponent, parentSuspense)\n    }\n    if (c2 !== c1) {\n      // 新旧节点都是文本，但内容不一样，则替换\n      hostSetElementText(container, c2)\n    }\n  } else {\n    // 新节点不为文本\n    // 旧节点是数组\n    if (prevShapeFlag & ARRAY_CHILDREN) {\n      // 新节点也是数组\n      if (shapeFlag & ARRAY_CHILDREN) {\n        // 进行新旧节点的 diff\n        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)\n      } else {\n        // 卸载旧节点\n        unmountChildren(c1, parentComponent, parentSuspense, true)\n      }\n    } else {\n      // 新节点不为文本\n      // 旧节点不是数组\n      // 旧节点是文本\n      if (prevShapeFlag & TEXT_CHILDREN) {\n        // 则把它清空\n        hostSetElementText(container, '')\n      }\n      // 新节点是数组\n      if (shapeFlag & ARRAY_CHILDREN) {\n        // 挂载新节点\n        mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)\n      }\n    }\n  }\n}\n```\n\n对于子节点来说，节点类型只会有三种可能，分别是：文本节点、数组节点、空节点。所以这个方法里所有的 if else 分支就是在考虑新旧节点可能的全部情况，并进行相应的处理。这里流程分支有点多，画个图大家就明白在做啥了：\n\nimage.png\n\n其中新旧节点都是数组的情况涉及到我们平常所说的 diff 算法，会放到后面专门去解析。\n\n看完处理DOM元素的情况，接下来看处理vue组件。\n\n##### processComponent\n```typescript\nconst processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  if (n1 == null) {\n    // 初始化的过程\n  }\n  else {\n    // 更新的过程\n    updateComponent(n1, n2, parentComponent, optimized)\n  }\n}\n```\n\nprocessComponent 更新逻辑调用 updateComponent 函数：\n\n```typescript\nconst updateComponent = (n1, n2, optimized) => {\n  const instance = (n2.component = n1.component)!\n   // 根据新老节点判断是否需要更新子组件\n  if (shouldUpdateComponent(n1, n2, optimized)) {\n    //...\n    // 如果需要更新，则将新节点 vnode 赋值给 next\n    instance.next = n2\n    // 执行前面定义在 instance 上的 update 函数。\n    instance.update()\n  } else {\n    // 如果不需要更新，则将就节点的内容更新到新节点上即可\n    n2.el = n1.el\n    instance.vnode = n2\n  }\n}\n```\n\nupdateComponent 函数首先通过 shouldUpdateComponent 函数来判断当前是否需要更新。 因为有些 VNode 值的变化并不需要立即显示更新子组件，举个例子：\n\n```html\n<template>\n   <div>{{msg}}</div>\n   <Child />\n</template>\n<script setup>\nimport { ref } from 'vue'\n\nconst msg = ref('hello')\n<script>\n```\n\n因为子组件不依赖父组件的状态数据，所以子组件是不需要更新的。这也从侧面反映出 Vue 的更新不仅是组件层面的细粒度更新，更在源码层面帮我们处理了一些不必要的子节点更新！\n\n最后执行的 instance.update，这个函数其实就是在 setupRenderEffect 内创建的。最终子组件的更新还会走一遍自己副作用函数的渲染，然后 patch 子组件的子模板 DOM，接上上面的流程。\n\n回过头来再看这里我们多次出现了 next 变量。为了更好地理解整体的流程，我们再来看一个 demo：\n\n```html\n<template>\n  <div>\n    hello world\n    <hello :msg=\"msg\" />\n    <button @click=\"changeMsg\">修改 msg</button>\n  </div>\n</template>\n<script>\nimport { ref } from 'vue'\nexport default {\n  setup () {\n    const msg = ref('你好')\n    function changeMsg() {\n      msg.value = '你好啊，我变了'\n    }\n    return {\n      msg,\n      changeMsg\n    }\n  }\n}\n</script>\n\n\n<template>\n  <div>\n    {{msg}}\n  </div>\n</template>\n<script>\nexport default {\n  props: {\n    msg: String\n  }\n}\n</script>\n```\n\n这里有个 App.vue 组件，内部有一个 hello 组件，我们来从头再捋一下整体的流程，就清楚了 next 的作用。\n\n当点击 修改 msg 后， App 组件自身的数据变化，导致 App 组件进入 update 逻辑，此时是没有 next 的，接下来渲染新的子组件vnode，得到真实的模板vnode nextTree，用新旧subTree进行patch。\n此时patch的元素类型是 div，进入更新普通元素的流程，先更新props，再更新子节点，当前div下的子节点有Hello组件时，进入组件的的更新流程。\n在更新 Hello 组件时，根据 updateComponent 函数执行的逻辑，会先将Hello组件 instance.next 赋值为最新的子组件 vnode，之后再主动调用instance.update 进入上面的副作用渲染函数，这次的实例是 Hello 组件自身的渲染，且 next 存在值。\n当 next 存在时，会执行 updateComponentPreRender 函数：\n\n```typescript\nconst updateComponentPreRender = (instance, nextVNode, optimized) => {\n  // 新节点 vnode.component 赋值为 instance\n  nextVNode.component = instance\n  // 获取老节点的 props\n  const prevProps = instance.vnode.props\n  // 为 instance.vnode 赋值为新的组件 vnode \n  instance.vnode = nextVNode\n  instance.next = null\n  // 更新 props\n  updateProps(instance, nextVNode.props, prevProps, optimized)\n  // 更新 slots\n  updateSlots(instance, nextVNode.children)\n}\n```\n\nupdateComponentPreRender 函数核心功能就是完成了对实例上的属性、vnode 信息、slots 进行更新，当后续组件渲染的时候，得到的就是最新的值。\n\n总而言之，next 就是用来标记接下来需要渲染的子组件，如果 next 存在，则会进行子组件实例相关内容属性的更新操作，再进行子组件的更新流程。\n\n#### 总结\n本节着重介绍了组件的更新逻辑，我们再补齐一下第二节中的流程图：\n\nimage.png\n\n本节介绍了关于普通元素的简单更新过程，那关于复杂的更新过程的逻辑，也就是新老子节点都是数组的普通元素，应该如何进行更新呢？这就涉及到了 diff 算法，我们下节接着介绍。","source":"_drafts/technical-disclosure-of-vue3/component-update.md","raw":"---\ntitle: 渲染器：组件是如何完成更新的？\ncategories:\n  - Vue3 技术揭秘\n---\n\n#### 前言\n上一小节，我们介绍了数据访问代理的过程以及组件实例初始化的过程，接下来，我们将介绍组件的更新逻辑，这部分逻辑主要包含在 setupRenderEffect 这个函数中。\n\n#### 组件更新\n```typescript\nconst setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\n  function componentUpdateFn() {\n    if (!instance.isMounted) {\n      // 初始化组件\n    }\n    else {\n      // 更新组件\n    }\n  }\n  // 创建响应式的副作用渲染函数\n  instance.update = effect(componentUpdateFn, prodEffectOptions)\n}\n```\n\n在前面的小节中，我们说完了关于 mounted 的流程。接下来我们将着重来看一下组件更新的逻辑：\n\n```typescript\nconst setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\n  function componentUpdateFn() {\n    if (!instance.isMounted) {\n      // 初始化组件\n    }\n    else {\n      // 更新组件\n      let { next, vnode } = instance\n      // 如果有 next 的话说明需要更新组件的数组（props, slot 等）\n      if (next) {\n        next.el = vnode.el\n        // 更新组件实例信息\n        updateComponentPreRender(instance, next, optimized)\n      } else {\n        next = vnode\n      }\n      // 获取新的子树 vnode\n      const nextTree = renderComponentRoot(instance)\n      // 获取旧的子树 vnode\n      const prevTree = instance.subTree\n      // 更新子树 vnode\n      instance.subTree = nextTree\n      // patch 新老子树的 vnode\n      patch(\n        prevTree, \n        nextTree,\n        // 处理 teleport 相关\n        hostParentNode(prevTree.el),\n        // 处理 fragment 相关\n        getNextHostNode(prevTree),\n        instance,\n        parentSuspense,\n        isSVG)\n      // 缓存更新后的 DOM 节点\n      next.el = nextTree.el\n    }\n  }\n  // 创建响应式的副作用渲染函数\n  instance.update = effect(componentUpdateFn, prodEffectOptions)\n}\n```\n\n这里的核心流程是通过 next 来判断当前是否需要更新 vnode 的节点信息，然后渲染出新的子树 nextTree，再进行比对新旧子树并找出需要更新的点，进行 DOM 更新。我们先来看一下 patch 的更新流程：\n\n```typescript\nfunction patch(n1, n2, container = null, anchor = null, parentComponent = null) {\n  // 对于类型不同的新老节点，直接进行卸载\n  if (n1 && !isSameVNodeType(n1, n2)) {\n    anchor = getNextHostNode(n1)\n    unmount(n1, parentComponent, parentSuspense, true)\n    n1 = null\n  }\n  // 基于 n2 的类型来判断\n  // 因为 n2 是新的 vnode\n  const { type, shapeFlag } = n2;\n  switch (type) {\n    case Text:\n      processText(n1, n2, container);\n      break;\n    // 其中还有几个类型比如： static fragment comment\n    case Fragment:\n      processFragment(n1, n2, container);\n      break;\n    default:\n      // 这里就基于 shapeFlag 来处理\n      if (shapeFlag & ShapeFlags.ELEMENT) {\n        processElement(n1, n2, container, anchor, parentComponent);\n      } else if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {\n        processComponent(n1, n2, container, parentComponent);\n      }\n  }\n}\n```\n\n首先判断当 n1 存在，即存在老节点，但新节点和老节点不是同类型的节点情况，那么执行销毁老节点，新增新节点。那么 Vue 如何判断是否是不同类型的节点呢？答案就在 isSameVNodeType 函数中：\n\n```typescript\nexport function isSameVNodeType(n1, n2) {\n  // 新老节点的 type 和 key 都相同\n  return n1.type === n2.type && n1.key === n2.key\n}\n```\n\n这里比如从 div 变成了 p 标签，那么 isSameVNodeType 就会是个 false。\n\n如果当新老节点是同类型的节点，则会根据 shapeFlag不同走到不同的逻辑，如果是普通元素更新，那么就会走到 processElement 的逻辑中；如果是组件更新，则会走到 processComponent 中。\n\n接下来分别看看这两种更新机制有什么不同。\n\n#### processElement\n这里我们也着重看一下 processElement 的更新流程：\n\n```typescript\nconst processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  isSVG = isSVG || n2.type === 'svg'\n  if (n1 == null) {\n    // 初始化的过程\n  }\n  else {\n    // 更新的过程\n    patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized)\n  }\n}\n```\n\nprocessElement 更新逻辑调用 patchElement 函数：\n\n```typescript\nconst patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, optimized) => {\n  const el = (n2.el = n1.el)\n  let { patchFlag, dynamicChildren, dirs } = n2\n  // ...\n  // 旧节点的 props\n  const oldProps = (n1 && n1.props) || EMPTY_OBJ\n  // 新节点的 props\n  const newProps = n2.props || EMPTY_OBJ\n  // 对比 props 并更新\n  patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG)  \n  // 先省略 dynamicChildren 的逻辑，后续介绍... \n  // 全量比对子节点更新\n  patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG)\n}\n```\n\n可以看到普通元素的更新主要做的就是先更新 props ，当 props 更新完成后，然后再统一更新子节点。关于如何进行 patchProps 做节点的属性更新不是本小节的重点，这里先跳过。\n\n这里省略了对 dynamicChildren 存在时，执行 patchBlockChildren 的优化 diff 过程，我们直接先看全量 diff 也就是 patchChildren 函数。关于 patchBlockChildren 我们将在编译过程中的优化小节中进行详细介绍\n\n接着来看 patchChildren 更新子节点的函数：\n\n```typescript\nconst patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized = false) => {\n  // c1 代表旧节点的子节点元素\n  const c1 = n1 && n1.children\n  const prevShapeFlag = n1 ? n1.shapeFlag : 0\n  // c2 代表新节点的子节点元素\n  const c2 = n2.children\n  const { patchFlag, shapeFlag } = n2\n  // 新节点是文本\n  // 3 + 2 + 4\n  if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n    // 旧节点是数组\n    if (prevShapeFlag & ARRAY_CHILDREN) {\n      // 卸载旧节点\n      unmountChildren(c1, parentComponent, parentSuspense)\n    }\n    if (c2 !== c1) {\n      // 新旧节点都是文本，但内容不一样，则替换\n      hostSetElementText(container, c2)\n    }\n  } else {\n    // 新节点不为文本\n    // 旧节点是数组\n    if (prevShapeFlag & ARRAY_CHILDREN) {\n      // 新节点也是数组\n      if (shapeFlag & ARRAY_CHILDREN) {\n        // 进行新旧节点的 diff\n        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)\n      } else {\n        // 卸载旧节点\n        unmountChildren(c1, parentComponent, parentSuspense, true)\n      }\n    } else {\n      // 新节点不为文本\n      // 旧节点不是数组\n      // 旧节点是文本\n      if (prevShapeFlag & TEXT_CHILDREN) {\n        // 则把它清空\n        hostSetElementText(container, '')\n      }\n      // 新节点是数组\n      if (shapeFlag & ARRAY_CHILDREN) {\n        // 挂载新节点\n        mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)\n      }\n    }\n  }\n}\n```\n\n对于子节点来说，节点类型只会有三种可能，分别是：文本节点、数组节点、空节点。所以这个方法里所有的 if else 分支就是在考虑新旧节点可能的全部情况，并进行相应的处理。这里流程分支有点多，画个图大家就明白在做啥了：\n\nimage.png\n\n其中新旧节点都是数组的情况涉及到我们平常所说的 diff 算法，会放到后面专门去解析。\n\n看完处理DOM元素的情况，接下来看处理vue组件。\n\n##### processComponent\n```typescript\nconst processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  if (n1 == null) {\n    // 初始化的过程\n  }\n  else {\n    // 更新的过程\n    updateComponent(n1, n2, parentComponent, optimized)\n  }\n}\n```\n\nprocessComponent 更新逻辑调用 updateComponent 函数：\n\n```typescript\nconst updateComponent = (n1, n2, optimized) => {\n  const instance = (n2.component = n1.component)!\n   // 根据新老节点判断是否需要更新子组件\n  if (shouldUpdateComponent(n1, n2, optimized)) {\n    //...\n    // 如果需要更新，则将新节点 vnode 赋值给 next\n    instance.next = n2\n    // 执行前面定义在 instance 上的 update 函数。\n    instance.update()\n  } else {\n    // 如果不需要更新，则将就节点的内容更新到新节点上即可\n    n2.el = n1.el\n    instance.vnode = n2\n  }\n}\n```\n\nupdateComponent 函数首先通过 shouldUpdateComponent 函数来判断当前是否需要更新。 因为有些 VNode 值的变化并不需要立即显示更新子组件，举个例子：\n\n```html\n<template>\n   <div>{{msg}}</div>\n   <Child />\n</template>\n<script setup>\nimport { ref } from 'vue'\n\nconst msg = ref('hello')\n<script>\n```\n\n因为子组件不依赖父组件的状态数据，所以子组件是不需要更新的。这也从侧面反映出 Vue 的更新不仅是组件层面的细粒度更新，更在源码层面帮我们处理了一些不必要的子节点更新！\n\n最后执行的 instance.update，这个函数其实就是在 setupRenderEffect 内创建的。最终子组件的更新还会走一遍自己副作用函数的渲染，然后 patch 子组件的子模板 DOM，接上上面的流程。\n\n回过头来再看这里我们多次出现了 next 变量。为了更好地理解整体的流程，我们再来看一个 demo：\n\n```html\n<template>\n  <div>\n    hello world\n    <hello :msg=\"msg\" />\n    <button @click=\"changeMsg\">修改 msg</button>\n  </div>\n</template>\n<script>\nimport { ref } from 'vue'\nexport default {\n  setup () {\n    const msg = ref('你好')\n    function changeMsg() {\n      msg.value = '你好啊，我变了'\n    }\n    return {\n      msg,\n      changeMsg\n    }\n  }\n}\n</script>\n\n\n<template>\n  <div>\n    {{msg}}\n  </div>\n</template>\n<script>\nexport default {\n  props: {\n    msg: String\n  }\n}\n</script>\n```\n\n这里有个 App.vue 组件，内部有一个 hello 组件，我们来从头再捋一下整体的流程，就清楚了 next 的作用。\n\n当点击 修改 msg 后， App 组件自身的数据变化，导致 App 组件进入 update 逻辑，此时是没有 next 的，接下来渲染新的子组件vnode，得到真实的模板vnode nextTree，用新旧subTree进行patch。\n此时patch的元素类型是 div，进入更新普通元素的流程，先更新props，再更新子节点，当前div下的子节点有Hello组件时，进入组件的的更新流程。\n在更新 Hello 组件时，根据 updateComponent 函数执行的逻辑，会先将Hello组件 instance.next 赋值为最新的子组件 vnode，之后再主动调用instance.update 进入上面的副作用渲染函数，这次的实例是 Hello 组件自身的渲染，且 next 存在值。\n当 next 存在时，会执行 updateComponentPreRender 函数：\n\n```typescript\nconst updateComponentPreRender = (instance, nextVNode, optimized) => {\n  // 新节点 vnode.component 赋值为 instance\n  nextVNode.component = instance\n  // 获取老节点的 props\n  const prevProps = instance.vnode.props\n  // 为 instance.vnode 赋值为新的组件 vnode \n  instance.vnode = nextVNode\n  instance.next = null\n  // 更新 props\n  updateProps(instance, nextVNode.props, prevProps, optimized)\n  // 更新 slots\n  updateSlots(instance, nextVNode.children)\n}\n```\n\nupdateComponentPreRender 函数核心功能就是完成了对实例上的属性、vnode 信息、slots 进行更新，当后续组件渲染的时候，得到的就是最新的值。\n\n总而言之，next 就是用来标记接下来需要渲染的子组件，如果 next 存在，则会进行子组件实例相关内容属性的更新操作，再进行子组件的更新流程。\n\n#### 总结\n本节着重介绍了组件的更新逻辑，我们再补齐一下第二节中的流程图：\n\nimage.png\n\n本节介绍了关于普通元素的简单更新过程，那关于复杂的更新过程的逻辑，也就是新老子节点都是数组的普通元素，应该如何进行更新呢？这就涉及到了 diff 算法，我们下节接着介绍。","slug":"technical-disclosure-of-vue3/component-update","published":0,"date":"2023-08-12T07:53:19.989Z","updated":"2023-08-12T07:53:19.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokn000vsovc2sykerah","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>上一小节，我们介绍了数据访问代理的过程以及组件实例初始化的过程，接下来，我们将介绍组件的更新逻辑，这部分逻辑主要包含在 setupRenderEffect 这个函数中。</p>\n<h4 id=\"组件更新\"><a href=\"#组件更新\" class=\"headerlink\" title=\"组件更新\"></a>组件更新</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">setupRenderEffect</span> = (<span class=\"params\">instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">componentUpdateFn</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!instance.<span class=\"property\">isMounted</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 初始化组件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 更新组件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 创建响应式的副作用渲染函数</span></span><br><span class=\"line\">  instance.<span class=\"property\">update</span> = <span class=\"title function_\">effect</span>(componentUpdateFn, prodEffectOptions)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在前面的小节中，我们说完了关于 mounted 的流程。接下来我们将着重来看一下组件更新的逻辑：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">setupRenderEffect</span> = (<span class=\"params\">instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">componentUpdateFn</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!instance.<span class=\"property\">isMounted</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 初始化组件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 更新组件</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> &#123; next, vnode &#125; = instance</span><br><span class=\"line\">      <span class=\"comment\">// 如果有 next 的话说明需要更新组件的数组（props, slot 等）</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (next) &#123;</span><br><span class=\"line\">        next.<span class=\"property\">el</span> = vnode.<span class=\"property\">el</span></span><br><span class=\"line\">        <span class=\"comment\">// 更新组件实例信息</span></span><br><span class=\"line\">        <span class=\"title function_\">updateComponentPreRender</span>(instance, next, optimized)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        next = vnode</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 获取新的子树 vnode</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> nextTree = <span class=\"title function_\">renderComponentRoot</span>(instance)</span><br><span class=\"line\">      <span class=\"comment\">// 获取旧的子树 vnode</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> prevTree = instance.<span class=\"property\">subTree</span></span><br><span class=\"line\">      <span class=\"comment\">// 更新子树 vnode</span></span><br><span class=\"line\">      instance.<span class=\"property\">subTree</span> = nextTree</span><br><span class=\"line\">      <span class=\"comment\">// patch 新老子树的 vnode</span></span><br><span class=\"line\">      <span class=\"title function_\">patch</span>(</span><br><span class=\"line\">        prevTree, </span><br><span class=\"line\">        nextTree,</span><br><span class=\"line\">        <span class=\"comment\">// 处理 teleport 相关</span></span><br><span class=\"line\">        <span class=\"title function_\">hostParentNode</span>(prevTree.<span class=\"property\">el</span>),</span><br><span class=\"line\">        <span class=\"comment\">// 处理 fragment 相关</span></span><br><span class=\"line\">        <span class=\"title function_\">getNextHostNode</span>(prevTree),</span><br><span class=\"line\">        instance,</span><br><span class=\"line\">        parentSuspense,</span><br><span class=\"line\">        isSVG)</span><br><span class=\"line\">      <span class=\"comment\">// 缓存更新后的 DOM 节点</span></span><br><span class=\"line\">      next.<span class=\"property\">el</span> = nextTree.<span class=\"property\">el</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 创建响应式的副作用渲染函数</span></span><br><span class=\"line\">  instance.<span class=\"property\">update</span> = <span class=\"title function_\">effect</span>(componentUpdateFn, prodEffectOptions)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的核心流程是通过 next 来判断当前是否需要更新 vnode 的节点信息，然后渲染出新的子树 nextTree，再进行比对新旧子树并找出需要更新的点，进行 DOM 更新。我们先来看一下 patch 的更新流程：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">patch</span>(<span class=\"params\">n1, n2, container = <span class=\"literal\">null</span>, anchor = <span class=\"literal\">null</span>, parentComponent = <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 对于类型不同的新老节点，直接进行卸载</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n1 &amp;&amp; !<span class=\"title function_\">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class=\"line\">    anchor = <span class=\"title function_\">getNextHostNode</span>(n1)</span><br><span class=\"line\">    <span class=\"title function_\">unmount</span>(n1, parentComponent, parentSuspense, <span class=\"literal\">true</span>)</span><br><span class=\"line\">    n1 = <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 基于 n2 的类型来判断</span></span><br><span class=\"line\">  <span class=\"comment\">// 因为 n2 是新的 vnode</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">type</span>, shapeFlag &#125; = n2;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"title class_\">Text</span>:</span><br><span class=\"line\">      <span class=\"title function_\">processText</span>(n1, n2, container);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 其中还有几个类型比如： static fragment comment</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"title class_\">Fragment</span>:</span><br><span class=\"line\">      <span class=\"title function_\">processFragment</span>(n1, n2, container);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"attr\">default</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 这里就基于 shapeFlag 来处理</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (shapeFlag &amp; <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">ELEMENT</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">processElement</span>(n1, n2, container, anchor, parentComponent);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (shapeFlag &amp; <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">STATEFUL_COMPONENT</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">processComponent</span>(n1, n2, container, parentComponent);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先判断当 n1 存在，即存在老节点，但新节点和老节点不是同类型的节点情况，那么执行销毁老节点，新增新节点。那么 Vue 如何判断是否是不同类型的节点呢？答案就在 isSameVNodeType 函数中：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">isSameVNodeType</span>(<span class=\"params\">n1, n2</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 新老节点的 type 和 key 都相同</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> n1.<span class=\"property\">type</span> === n2.<span class=\"property\">type</span> &amp;&amp; n1.<span class=\"property\">key</span> === n2.<span class=\"property\">key</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里比如从 div 变成了 p 标签，那么 isSameVNodeType 就会是个 false。</p>\n<p>如果当新老节点是同类型的节点，则会根据 shapeFlag不同走到不同的逻辑，如果是普通元素更新，那么就会走到 processElement 的逻辑中；如果是组件更新，则会走到 processComponent 中。</p>\n<p>接下来分别看看这两种更新机制有什么不同。</p>\n<h4 id=\"processElement\"><a href=\"#processElement\" class=\"headerlink\" title=\"processElement\"></a>processElement</h4><p>这里我们也着重看一下 processElement 的更新流程：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">processElement</span> = (<span class=\"params\">n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  isSVG = isSVG || n2.<span class=\"property\">type</span> === <span class=\"string\">&#x27;svg&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n1 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化的过程</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 更新的过程</span></span><br><span class=\"line\">    <span class=\"title function_\">patchElement</span>(n1, n2, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>processElement 更新逻辑调用 patchElement 函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchElement</span> = (<span class=\"params\">n1, n2, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> el = (n2.<span class=\"property\">el</span> = n1.<span class=\"property\">el</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123; patchFlag, dynamicChildren, dirs &#125; = n2</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 旧节点的 props</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldProps = (n1 &amp;&amp; n1.<span class=\"property\">props</span>) || <span class=\"variable constant_\">EMPTY_OBJ</span></span><br><span class=\"line\">  <span class=\"comment\">// 新节点的 props</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> newProps = n2.<span class=\"property\">props</span> || <span class=\"variable constant_\">EMPTY_OBJ</span></span><br><span class=\"line\">  <span class=\"comment\">// 对比 props 并更新</span></span><br><span class=\"line\">  <span class=\"title function_\">patchProps</span>(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG)  </span><br><span class=\"line\">  <span class=\"comment\">// 先省略 dynamicChildren 的逻辑，后续介绍... </span></span><br><span class=\"line\">  <span class=\"comment\">// 全量比对子节点更新</span></span><br><span class=\"line\">  <span class=\"title function_\">patchChildren</span>(n1, n2, el, <span class=\"literal\">null</span>, parentComponent, parentSuspense, areChildrenSVG)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到普通元素的更新主要做的就是先更新 props ，当 props 更新完成后，然后再统一更新子节点。关于如何进行 patchProps 做节点的属性更新不是本小节的重点，这里先跳过。</p>\n<p>这里省略了对 dynamicChildren 存在时，执行 patchBlockChildren 的优化 diff 过程，我们直接先看全量 diff 也就是 patchChildren 函数。关于 patchBlockChildren 我们将在编译过程中的优化小节中进行详细介绍</p>\n<p>接着来看 patchChildren 更新子节点的函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchChildren</span> = (<span class=\"params\">n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized = <span class=\"literal\">false</span></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// c1 代表旧节点的子节点元素</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> c1 = n1 &amp;&amp; n1.<span class=\"property\">children</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> prevShapeFlag = n1 ? n1.<span class=\"property\">shapeFlag</span> : <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"comment\">// c2 代表新节点的子节点元素</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> c2 = n2.<span class=\"property\">children</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; patchFlag, shapeFlag &#125; = n2</span><br><span class=\"line\">  <span class=\"comment\">// 新节点是文本</span></span><br><span class=\"line\">  <span class=\"comment\">// 3 + 2 + 4</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shapeFlag &amp; <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">TEXT_CHILDREN</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 旧节点是数组</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prevShapeFlag &amp; <span class=\"variable constant_\">ARRAY_CHILDREN</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 卸载旧节点</span></span><br><span class=\"line\">      <span class=\"title function_\">unmountChildren</span>(c1, parentComponent, parentSuspense)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c2 !== c1) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 新旧节点都是文本，但内容不一样，则替换</span></span><br><span class=\"line\">      <span class=\"title function_\">hostSetElementText</span>(container, c2)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 新节点不为文本</span></span><br><span class=\"line\">    <span class=\"comment\">// 旧节点是数组</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prevShapeFlag &amp; <span class=\"variable constant_\">ARRAY_CHILDREN</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 新节点也是数组</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (shapeFlag &amp; <span class=\"variable constant_\">ARRAY_CHILDREN</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 进行新旧节点的 diff</span></span><br><span class=\"line\">        <span class=\"title function_\">patchKeyedChildren</span>(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 卸载旧节点</span></span><br><span class=\"line\">        <span class=\"title function_\">unmountChildren</span>(c1, parentComponent, parentSuspense, <span class=\"literal\">true</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 新节点不为文本</span></span><br><span class=\"line\">      <span class=\"comment\">// 旧节点不是数组</span></span><br><span class=\"line\">      <span class=\"comment\">// 旧节点是文本</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (prevShapeFlag &amp; <span class=\"variable constant_\">TEXT_CHILDREN</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 则把它清空</span></span><br><span class=\"line\">        <span class=\"title function_\">hostSetElementText</span>(container, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 新节点是数组</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (shapeFlag &amp; <span class=\"variable constant_\">ARRAY_CHILDREN</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 挂载新节点</span></span><br><span class=\"line\">        <span class=\"title function_\">mountChildren</span>(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于子节点来说，节点类型只会有三种可能，分别是：文本节点、数组节点、空节点。所以这个方法里所有的 if else 分支就是在考虑新旧节点可能的全部情况，并进行相应的处理。这里流程分支有点多，画个图大家就明白在做啥了：</p>\n<p>image.png</p>\n<p>其中新旧节点都是数组的情况涉及到我们平常所说的 diff 算法，会放到后面专门去解析。</p>\n<p>看完处理DOM元素的情况，接下来看处理vue组件。</p>\n<h5 id=\"processComponent\"><a href=\"#processComponent\" class=\"headerlink\" title=\"processComponent\"></a>processComponent</h5><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">processComponent</span> = (<span class=\"params\">n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n1 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化的过程</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 更新的过程</span></span><br><span class=\"line\">    <span class=\"title function_\">updateComponent</span>(n1, n2, parentComponent, optimized)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>processComponent 更新逻辑调用 updateComponent 函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">updateComponent</span> = (<span class=\"params\">n1, n2, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> instance = (n2.<span class=\"property\">component</span> = n1.<span class=\"property\">component</span>)!</span><br><span class=\"line\">   <span class=\"comment\">// 根据新老节点判断是否需要更新子组件</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title function_\">shouldUpdateComponent</span>(n1, n2, optimized)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果需要更新，则将新节点 vnode 赋值给 next</span></span><br><span class=\"line\">    instance.<span class=\"property\">next</span> = n2</span><br><span class=\"line\">    <span class=\"comment\">// 执行前面定义在 instance 上的 update 函数。</span></span><br><span class=\"line\">    instance.<span class=\"title function_\">update</span>()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果不需要更新，则将就节点的内容更新到新节点上即可</span></span><br><span class=\"line\">    n2.<span class=\"property\">el</span> = n1.<span class=\"property\">el</span></span><br><span class=\"line\">    instance.<span class=\"property\">vnode</span> = n2</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>updateComponent 函数首先通过 shouldUpdateComponent 函数来判断当前是否需要更新。 因为有些 VNode 值的变化并不需要立即显示更新子组件，举个例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">Child</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">setup</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; ref &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">const</span> msg = <span class=\"title function_\">ref</span>(<span class=\"string\">&#x27;hello&#x27;</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">&lt;script&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>因为子组件不依赖父组件的状态数据，所以子组件是不需要更新的。这也从侧面反映出 Vue 的更新不仅是组件层面的细粒度更新，更在源码层面帮我们处理了一些不必要的子节点更新！</p>\n<p>最后执行的 instance.update，这个函数其实就是在 setupRenderEffect 内创建的。最终子组件的更新还会走一遍自己副作用函数的渲染，然后 patch 子组件的子模板 DOM，接上上面的流程。</p>\n<p>回过头来再看这里我们多次出现了 next 变量。为了更好地理解整体的流程，我们再来看一个 demo：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    hello world</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">hello</span> <span class=\"attr\">:msg</span>=<span class=\"string\">&quot;msg&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;changeMsg&quot;</span>&gt;</span>修改 msg<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; ref &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  setup () &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">const</span> msg = <span class=\"title function_\">ref</span>(<span class=\"string\">&#x27;你好&#x27;</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">function</span> <span class=\"title function_\">changeMsg</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      msg.<span class=\"property\">value</span> = <span class=\"string\">&#x27;你好啊，我变了&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      msg,</span></span><br><span class=\"line\"><span class=\"language-javascript\">      changeMsg</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    &#123;&#123;msg&#125;&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"attr\">props</span>: &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"attr\">msg</span>: <span class=\"title class_\">String</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这里有个 App.vue 组件，内部有一个 hello 组件，我们来从头再捋一下整体的流程，就清楚了 next 的作用。</p>\n<p>当点击 修改 msg 后， App 组件自身的数据变化，导致 App 组件进入 update 逻辑，此时是没有 next 的，接下来渲染新的子组件vnode，得到真实的模板vnode nextTree，用新旧subTree进行patch。<br>此时patch的元素类型是 div，进入更新普通元素的流程，先更新props，再更新子节点，当前div下的子节点有Hello组件时，进入组件的的更新流程。<br>在更新 Hello 组件时，根据 updateComponent 函数执行的逻辑，会先将Hello组件 instance.next 赋值为最新的子组件 vnode，之后再主动调用instance.update 进入上面的副作用渲染函数，这次的实例是 Hello 组件自身的渲染，且 next 存在值。<br>当 next 存在时，会执行 updateComponentPreRender 函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">updateComponentPreRender</span> = (<span class=\"params\">instance, nextVNode, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 新节点 vnode.component 赋值为 instance</span></span><br><span class=\"line\">  nextVNode.<span class=\"property\">component</span> = instance</span><br><span class=\"line\">  <span class=\"comment\">// 获取老节点的 props</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> prevProps = instance.<span class=\"property\">vnode</span>.<span class=\"property\">props</span></span><br><span class=\"line\">  <span class=\"comment\">// 为 instance.vnode 赋值为新的组件 vnode </span></span><br><span class=\"line\">  instance.<span class=\"property\">vnode</span> = nextVNode</span><br><span class=\"line\">  instance.<span class=\"property\">next</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"comment\">// 更新 props</span></span><br><span class=\"line\">  <span class=\"title function_\">updateProps</span>(instance, nextVNode.<span class=\"property\">props</span>, prevProps, optimized)</span><br><span class=\"line\">  <span class=\"comment\">// 更新 slots</span></span><br><span class=\"line\">  <span class=\"title function_\">updateSlots</span>(instance, nextVNode.<span class=\"property\">children</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>updateComponentPreRender 函数核心功能就是完成了对实例上的属性、vnode 信息、slots 进行更新，当后续组件渲染的时候，得到的就是最新的值。</p>\n<p>总而言之，next 就是用来标记接下来需要渲染的子组件，如果 next 存在，则会进行子组件实例相关内容属性的更新操作，再进行子组件的更新流程。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>本节着重介绍了组件的更新逻辑，我们再补齐一下第二节中的流程图：</p>\n<p>image.png</p>\n<p>本节介绍了关于普通元素的简单更新过程，那关于复杂的更新过程的逻辑，也就是新老子节点都是数组的普通元素，应该如何进行更新呢？这就涉及到了 diff 算法，我们下节接着介绍。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#e7817c","excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>上一小节，我们介绍了数据访问代理的过程以及组件实例初始化的过程，接下来，我们将介绍组件的更新逻辑，这部分逻辑主要包含在 setupRenderEffect 这个函数中。</p>\n<h4 id=\"组件更新\"><a href=\"#组件更新\" class=\"headerlink\" title=\"组件更新\"></a>组件更新</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">setupRenderEffect</span> = (<span class=\"params\">instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">componentUpdateFn</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!instance.<span class=\"property\">isMounted</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 初始化组件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 更新组件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 创建响应式的副作用渲染函数</span></span><br><span class=\"line\">  instance.<span class=\"property\">update</span> = <span class=\"title function_\">effect</span>(componentUpdateFn, prodEffectOptions)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在前面的小节中，我们说完了关于 mounted 的流程。接下来我们将着重来看一下组件更新的逻辑：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">setupRenderEffect</span> = (<span class=\"params\">instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">componentUpdateFn</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!instance.<span class=\"property\">isMounted</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 初始化组件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 更新组件</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> &#123; next, vnode &#125; = instance</span><br><span class=\"line\">      <span class=\"comment\">// 如果有 next 的话说明需要更新组件的数组（props, slot 等）</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (next) &#123;</span><br><span class=\"line\">        next.<span class=\"property\">el</span> = vnode.<span class=\"property\">el</span></span><br><span class=\"line\">        <span class=\"comment\">// 更新组件实例信息</span></span><br><span class=\"line\">        <span class=\"title function_\">updateComponentPreRender</span>(instance, next, optimized)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        next = vnode</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 获取新的子树 vnode</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> nextTree = <span class=\"title function_\">renderComponentRoot</span>(instance)</span><br><span class=\"line\">      <span class=\"comment\">// 获取旧的子树 vnode</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> prevTree = instance.<span class=\"property\">subTree</span></span><br><span class=\"line\">      <span class=\"comment\">// 更新子树 vnode</span></span><br><span class=\"line\">      instance.<span class=\"property\">subTree</span> = nextTree</span><br><span class=\"line\">      <span class=\"comment\">// patch 新老子树的 vnode</span></span><br><span class=\"line\">      <span class=\"title function_\">patch</span>(</span><br><span class=\"line\">        prevTree, </span><br><span class=\"line\">        nextTree,</span><br><span class=\"line\">        <span class=\"comment\">// 处理 teleport 相关</span></span><br><span class=\"line\">        <span class=\"title function_\">hostParentNode</span>(prevTree.<span class=\"property\">el</span>),</span><br><span class=\"line\">        <span class=\"comment\">// 处理 fragment 相关</span></span><br><span class=\"line\">        <span class=\"title function_\">getNextHostNode</span>(prevTree),</span><br><span class=\"line\">        instance,</span><br><span class=\"line\">        parentSuspense,</span><br><span class=\"line\">        isSVG)</span><br><span class=\"line\">      <span class=\"comment\">// 缓存更新后的 DOM 节点</span></span><br><span class=\"line\">      next.<span class=\"property\">el</span> = nextTree.<span class=\"property\">el</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 创建响应式的副作用渲染函数</span></span><br><span class=\"line\">  instance.<span class=\"property\">update</span> = <span class=\"title function_\">effect</span>(componentUpdateFn, prodEffectOptions)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的核心流程是通过 next 来判断当前是否需要更新 vnode 的节点信息，然后渲染出新的子树 nextTree，再进行比对新旧子树并找出需要更新的点，进行 DOM 更新。我们先来看一下 patch 的更新流程：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">patch</span>(<span class=\"params\">n1, n2, container = <span class=\"literal\">null</span>, anchor = <span class=\"literal\">null</span>, parentComponent = <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 对于类型不同的新老节点，直接进行卸载</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n1 &amp;&amp; !<span class=\"title function_\">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class=\"line\">    anchor = <span class=\"title function_\">getNextHostNode</span>(n1)</span><br><span class=\"line\">    <span class=\"title function_\">unmount</span>(n1, parentComponent, parentSuspense, <span class=\"literal\">true</span>)</span><br><span class=\"line\">    n1 = <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 基于 n2 的类型来判断</span></span><br><span class=\"line\">  <span class=\"comment\">// 因为 n2 是新的 vnode</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">type</span>, shapeFlag &#125; = n2;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"title class_\">Text</span>:</span><br><span class=\"line\">      <span class=\"title function_\">processText</span>(n1, n2, container);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 其中还有几个类型比如： static fragment comment</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"title class_\">Fragment</span>:</span><br><span class=\"line\">      <span class=\"title function_\">processFragment</span>(n1, n2, container);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"attr\">default</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 这里就基于 shapeFlag 来处理</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (shapeFlag &amp; <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">ELEMENT</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">processElement</span>(n1, n2, container, anchor, parentComponent);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (shapeFlag &amp; <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">STATEFUL_COMPONENT</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">processComponent</span>(n1, n2, container, parentComponent);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先判断当 n1 存在，即存在老节点，但新节点和老节点不是同类型的节点情况，那么执行销毁老节点，新增新节点。那么 Vue 如何判断是否是不同类型的节点呢？答案就在 isSameVNodeType 函数中：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">isSameVNodeType</span>(<span class=\"params\">n1, n2</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 新老节点的 type 和 key 都相同</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> n1.<span class=\"property\">type</span> === n2.<span class=\"property\">type</span> &amp;&amp; n1.<span class=\"property\">key</span> === n2.<span class=\"property\">key</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里比如从 div 变成了 p 标签，那么 isSameVNodeType 就会是个 false。</p>\n<p>如果当新老节点是同类型的节点，则会根据 shapeFlag不同走到不同的逻辑，如果是普通元素更新，那么就会走到 processElement 的逻辑中；如果是组件更新，则会走到 processComponent 中。</p>\n<p>接下来分别看看这两种更新机制有什么不同。</p>\n<h4 id=\"processElement\"><a href=\"#processElement\" class=\"headerlink\" title=\"processElement\"></a>processElement</h4><p>这里我们也着重看一下 processElement 的更新流程：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">processElement</span> = (<span class=\"params\">n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  isSVG = isSVG || n2.<span class=\"property\">type</span> === <span class=\"string\">&#x27;svg&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n1 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化的过程</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 更新的过程</span></span><br><span class=\"line\">    <span class=\"title function_\">patchElement</span>(n1, n2, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>processElement 更新逻辑调用 patchElement 函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchElement</span> = (<span class=\"params\">n1, n2, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> el = (n2.<span class=\"property\">el</span> = n1.<span class=\"property\">el</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123; patchFlag, dynamicChildren, dirs &#125; = n2</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 旧节点的 props</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldProps = (n1 &amp;&amp; n1.<span class=\"property\">props</span>) || <span class=\"variable constant_\">EMPTY_OBJ</span></span><br><span class=\"line\">  <span class=\"comment\">// 新节点的 props</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> newProps = n2.<span class=\"property\">props</span> || <span class=\"variable constant_\">EMPTY_OBJ</span></span><br><span class=\"line\">  <span class=\"comment\">// 对比 props 并更新</span></span><br><span class=\"line\">  <span class=\"title function_\">patchProps</span>(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG)  </span><br><span class=\"line\">  <span class=\"comment\">// 先省略 dynamicChildren 的逻辑，后续介绍... </span></span><br><span class=\"line\">  <span class=\"comment\">// 全量比对子节点更新</span></span><br><span class=\"line\">  <span class=\"title function_\">patchChildren</span>(n1, n2, el, <span class=\"literal\">null</span>, parentComponent, parentSuspense, areChildrenSVG)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到普通元素的更新主要做的就是先更新 props ，当 props 更新完成后，然后再统一更新子节点。关于如何进行 patchProps 做节点的属性更新不是本小节的重点，这里先跳过。</p>\n<p>这里省略了对 dynamicChildren 存在时，执行 patchBlockChildren 的优化 diff 过程，我们直接先看全量 diff 也就是 patchChildren 函数。关于 patchBlockChildren 我们将在编译过程中的优化小节中进行详细介绍</p>\n<p>接着来看 patchChildren 更新子节点的函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchChildren</span> = (<span class=\"params\">n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized = <span class=\"literal\">false</span></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// c1 代表旧节点的子节点元素</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> c1 = n1 &amp;&amp; n1.<span class=\"property\">children</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> prevShapeFlag = n1 ? n1.<span class=\"property\">shapeFlag</span> : <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"comment\">// c2 代表新节点的子节点元素</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> c2 = n2.<span class=\"property\">children</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; patchFlag, shapeFlag &#125; = n2</span><br><span class=\"line\">  <span class=\"comment\">// 新节点是文本</span></span><br><span class=\"line\">  <span class=\"comment\">// 3 + 2 + 4</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shapeFlag &amp; <span class=\"title class_\">ShapeFlags</span>.<span class=\"property\">TEXT_CHILDREN</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 旧节点是数组</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prevShapeFlag &amp; <span class=\"variable constant_\">ARRAY_CHILDREN</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 卸载旧节点</span></span><br><span class=\"line\">      <span class=\"title function_\">unmountChildren</span>(c1, parentComponent, parentSuspense)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c2 !== c1) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 新旧节点都是文本，但内容不一样，则替换</span></span><br><span class=\"line\">      <span class=\"title function_\">hostSetElementText</span>(container, c2)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 新节点不为文本</span></span><br><span class=\"line\">    <span class=\"comment\">// 旧节点是数组</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prevShapeFlag &amp; <span class=\"variable constant_\">ARRAY_CHILDREN</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 新节点也是数组</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (shapeFlag &amp; <span class=\"variable constant_\">ARRAY_CHILDREN</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 进行新旧节点的 diff</span></span><br><span class=\"line\">        <span class=\"title function_\">patchKeyedChildren</span>(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 卸载旧节点</span></span><br><span class=\"line\">        <span class=\"title function_\">unmountChildren</span>(c1, parentComponent, parentSuspense, <span class=\"literal\">true</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 新节点不为文本</span></span><br><span class=\"line\">      <span class=\"comment\">// 旧节点不是数组</span></span><br><span class=\"line\">      <span class=\"comment\">// 旧节点是文本</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (prevShapeFlag &amp; <span class=\"variable constant_\">TEXT_CHILDREN</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 则把它清空</span></span><br><span class=\"line\">        <span class=\"title function_\">hostSetElementText</span>(container, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 新节点是数组</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (shapeFlag &amp; <span class=\"variable constant_\">ARRAY_CHILDREN</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 挂载新节点</span></span><br><span class=\"line\">        <span class=\"title function_\">mountChildren</span>(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于子节点来说，节点类型只会有三种可能，分别是：文本节点、数组节点、空节点。所以这个方法里所有的 if else 分支就是在考虑新旧节点可能的全部情况，并进行相应的处理。这里流程分支有点多，画个图大家就明白在做啥了：</p>\n<p>image.png</p>\n<p>其中新旧节点都是数组的情况涉及到我们平常所说的 diff 算法，会放到后面专门去解析。</p>\n<p>看完处理DOM元素的情况，接下来看处理vue组件。</p>\n<h5 id=\"processComponent\"><a href=\"#processComponent\" class=\"headerlink\" title=\"processComponent\"></a>processComponent</h5><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">processComponent</span> = (<span class=\"params\">n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n1 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化的过程</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 更新的过程</span></span><br><span class=\"line\">    <span class=\"title function_\">updateComponent</span>(n1, n2, parentComponent, optimized)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>processComponent 更新逻辑调用 updateComponent 函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">updateComponent</span> = (<span class=\"params\">n1, n2, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> instance = (n2.<span class=\"property\">component</span> = n1.<span class=\"property\">component</span>)!</span><br><span class=\"line\">   <span class=\"comment\">// 根据新老节点判断是否需要更新子组件</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title function_\">shouldUpdateComponent</span>(n1, n2, optimized)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果需要更新，则将新节点 vnode 赋值给 next</span></span><br><span class=\"line\">    instance.<span class=\"property\">next</span> = n2</span><br><span class=\"line\">    <span class=\"comment\">// 执行前面定义在 instance 上的 update 函数。</span></span><br><span class=\"line\">    instance.<span class=\"title function_\">update</span>()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果不需要更新，则将就节点的内容更新到新节点上即可</span></span><br><span class=\"line\">    n2.<span class=\"property\">el</span> = n1.<span class=\"property\">el</span></span><br><span class=\"line\">    instance.<span class=\"property\">vnode</span> = n2</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>updateComponent 函数首先通过 shouldUpdateComponent 函数来判断当前是否需要更新。 因为有些 VNode 值的变化并不需要立即显示更新子组件，举个例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">Child</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">setup</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; ref &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">const</span> msg = <span class=\"title function_\">ref</span>(<span class=\"string\">&#x27;hello&#x27;</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">&lt;script&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>因为子组件不依赖父组件的状态数据，所以子组件是不需要更新的。这也从侧面反映出 Vue 的更新不仅是组件层面的细粒度更新，更在源码层面帮我们处理了一些不必要的子节点更新！</p>\n<p>最后执行的 instance.update，这个函数其实就是在 setupRenderEffect 内创建的。最终子组件的更新还会走一遍自己副作用函数的渲染，然后 patch 子组件的子模板 DOM，接上上面的流程。</p>\n<p>回过头来再看这里我们多次出现了 next 变量。为了更好地理解整体的流程，我们再来看一个 demo：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    hello world</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">hello</span> <span class=\"attr\">:msg</span>=<span class=\"string\">&quot;msg&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;changeMsg&quot;</span>&gt;</span>修改 msg<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; ref &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  setup () &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">const</span> msg = <span class=\"title function_\">ref</span>(<span class=\"string\">&#x27;你好&#x27;</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">function</span> <span class=\"title function_\">changeMsg</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      msg.<span class=\"property\">value</span> = <span class=\"string\">&#x27;你好啊，我变了&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      msg,</span></span><br><span class=\"line\"><span class=\"language-javascript\">      changeMsg</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    &#123;&#123;msg&#125;&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"attr\">props</span>: &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"attr\">msg</span>: <span class=\"title class_\">String</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这里有个 App.vue 组件，内部有一个 hello 组件，我们来从头再捋一下整体的流程，就清楚了 next 的作用。</p>\n<p>当点击 修改 msg 后， App 组件自身的数据变化，导致 App 组件进入 update 逻辑，此时是没有 next 的，接下来渲染新的子组件vnode，得到真实的模板vnode nextTree，用新旧subTree进行patch。<br>此时patch的元素类型是 div，进入更新普通元素的流程，先更新props，再更新子节点，当前div下的子节点有Hello组件时，进入组件的的更新流程。<br>在更新 Hello 组件时，根据 updateComponent 函数执行的逻辑，会先将Hello组件 instance.next 赋值为最新的子组件 vnode，之后再主动调用instance.update 进入上面的副作用渲染函数，这次的实例是 Hello 组件自身的渲染，且 next 存在值。<br>当 next 存在时，会执行 updateComponentPreRender 函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">updateComponentPreRender</span> = (<span class=\"params\">instance, nextVNode, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 新节点 vnode.component 赋值为 instance</span></span><br><span class=\"line\">  nextVNode.<span class=\"property\">component</span> = instance</span><br><span class=\"line\">  <span class=\"comment\">// 获取老节点的 props</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> prevProps = instance.<span class=\"property\">vnode</span>.<span class=\"property\">props</span></span><br><span class=\"line\">  <span class=\"comment\">// 为 instance.vnode 赋值为新的组件 vnode </span></span><br><span class=\"line\">  instance.<span class=\"property\">vnode</span> = nextVNode</span><br><span class=\"line\">  instance.<span class=\"property\">next</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"comment\">// 更新 props</span></span><br><span class=\"line\">  <span class=\"title function_\">updateProps</span>(instance, nextVNode.<span class=\"property\">props</span>, prevProps, optimized)</span><br><span class=\"line\">  <span class=\"comment\">// 更新 slots</span></span><br><span class=\"line\">  <span class=\"title function_\">updateSlots</span>(instance, nextVNode.<span class=\"property\">children</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>updateComponentPreRender 函数核心功能就是完成了对实例上的属性、vnode 信息、slots 进行更新，当后续组件渲染的时候，得到的就是最新的值。</p>\n<p>总而言之，next 就是用来标记接下来需要渲染的子组件，如果 next 存在，则会进行子组件实例相关内容属性的更新操作，再进行子组件的更新流程。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>本节着重介绍了组件的更新逻辑，我们再补齐一下第二节中的流程图：</p>\n<p>image.png</p>\n<p>本节介绍了关于普通元素的简单更新过程，那关于复杂的更新过程的逻辑，也就是新老子节点都是数组的普通元素，应该如何进行更新呢？这就涉及到了 diff 算法，我们下节接着介绍。</p>\n"},{"title":"响应式原理：Computed 函数和普通函数有什么不同？","_content":"\n#### 前言\n计算属性接受一个 getter 函数，返回一个只读的响应式 ref 对象。该 ref 通过 .value 暴露 getter 函数的返回值。\n\n```typescript\nconst count = ref(1)\nconst plusOne = computed(() => count.value + 1)\n\nconsole.log(plusOne.value) // 2\n\nplusOne.value++ // 错误\n```\n\n它也可以接受一个带有 get 和 set 函数的对象来创建一个可写的 ref 对象。\n\n```typescript\nconst count = ref(1)\nconst plusOne = computed({\n  get: () => count.value + 1,\n  set: (val) => {\n    count.value = val - 1\n  }\n})\n\nplusOne.value = 1\nconsole.log(count.value) // 0\n```\n\n接下来看看源码里是如何实现 computed 的 API。\n\n#### 构造 setter 和 getter\n```typescript\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter\n  let setter\n  // 判断第一个参数是不是一个函数\n  const onlyGetter = isFunction(getterOrOptions)\n  \n  // 构造 setter 和 getter 函数\n  if (onlyGetter) {\n    getter = getterOrOptions\n    // 如果第一个参数是一个函数，那么就是只读的\n    setter = __DEV__\n      ? () => {\n          console.warn('Write operation failed: computed value is readonly')\n        }\n      : NOOP\n  } else {\n    getter = getterOrOptions.get\n    setter = getterOrOptions.set\n  }\n  // 构造 ref 响应式对象\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR)\n  // 返回响应式 ref\n  return cRef\n}\n```\n\n可以看到，这段 computed 函数体最初就是需要格式化传入的参数，根据第一个参数入参的类型来构造统一的 setter 和 getter 函数，并传入 ComputedRefImpl 类中，进行实例化 ref 响应式对象。\n\n接下来一起看看 ComputedRefImpl 是如何构造 cRef 响应式对象的。\n\n#### 构造 cRef 响应式对象\n\n```typescript\nclass ComputedRefImpl {\n  public dep = undefined\n\n  private _value\n  public readonly effect\n  //表示 ref 类型\n  public readonly __v_isRef = true\n  //是否只读\n  public readonly [ReactiveFlags.IS_READONLY] = false\n  //用于控制是否进行值更新(代表是否脏值)\n  public _dirty = true\n  // 缓存\n  public _cacheable\n\n  constructor(\n    getter,\n    _setter,\n    isReadonly,\n    isSSR\n  ) {\n    // 把 getter 作为响应式依赖函数 fn 参数\n    this.effect = new ReactiveEffect(getter, () => {\n      if (!this._dirty) {\n        this._dirty = true\n        // 触发更新\n        triggerRefValue(this)\n      }\n    })\n    // 标记 effect 的 computed 属性\n    this.effect.computed = this\n    this.effect.active = this._cacheable = !isSSR\n    this[ReactiveFlags.IS_READONLY] = isReadonly\n  }\n\n  get value() {\n    const self = toRaw(this)\n    // 依赖收集\n    trackRefValue(self)\n    // 脏值则进行更新\n    if (self._dirty || !self._cacheable) {\n      self._dirty = false\n      // 更新值\n      self._value = self.effect.run()!\n    }\n    return self._value\n  }\n  // 执行 setter\n  set value(newValue) {\n    this._setter(newValue)\n  }\n}\n```\n\n简单看一下该类的实现：在构造函数的时候，创建了一个副作用对象 effect。并为 effect 额外定义了一个 computed 属性执行当前响应式对象 cRef。\n\n另外，定义了一个 get 方法，当我们通过 ref.value 取值的时候可以进行依赖收集，将定义的 effect 收集起来。\n\n其次，定义了一个 set 方法，该方法就是执行传入进来的 setter 函数。\n\n最后，熟悉 Vue 的开发者都知道 computed 的特性就在于能够缓存计算的值（提升性能），只有当 computed 的依赖发生变化时才会重新计算，否则读取 computed 的值则一直是之前的值。在源码这里，实现上述功能相关的变量分别是 _dirty 和 _cacheable 这 2 个，用来控制缓存的实现。\n\n有了上面的介绍，我们来看一个具体的例子，看看 computed 是如何执行的：\n\n```html\n<template> \n  <div> \n    {{ plusOne }} \n  </div> \n  <button @click=\"plus\">plus</button> \n</template> \n<script> \n  import { ref, computed } from 'vue' \n  export default { \n    setup() { \n      const num = ref(0) \n      const plusOne = computed(() => { \n        return num.value + 1 \n      }) \n\n      function plus() { \n        num.value++ \n      } \n      return { \n        plusOne, \n        plus \n      } \n    } \n  } \n</script>\n```\n\nStep 1：setup 函数体内，computed 函数执行，初始的过程中，生成了一个 computed effect。\n\nStep 2：初始化渲染的时候，render 函数访问了 plusOne.value，触发了收集，此时收集的副作用为 render effect，因为是首次访问，所以此时的 self._dirty = true 执行 effect.run() 也就是执行了 getter 函数，得到 _value = 1。\n\nStep 3：getter 函数体内访问了 num.value 触发了对 num 的依赖收集，此时收集到的依赖为 computed effect。\n\nStep 4：点击按钮，此时 num = 1 触发了 computed effect 的 schduler 调度，因为 _dirty = false，所以触发了 triggerRefValue 的执行，同时，设置 _dirty = true。\n\nStep 5：triggerRefValue 执行过程中，会执行 computed effect.run() 触发 getter 函数的执行。因为此时的 _dirty = true，所以 get value 会重新计算 _value 的值为 plusOne.value = 2。\n\nStep 6：plusOne.value 值变化后，触发了 render effect.run 重新渲染。\n\n可以看到 computed 函数通过 _dirty 把 computed 的缓存特性表现得淋漓尽致，只有当 _dirty = true 的时候，才会进行重新计算求值，而 _dirty = true 只有在首次取值或者取值内部依赖发生变化时才会执行。\n\n#### 计算属性的执行顺序\n这里，我们介绍完了 computed 的核心流程，但是细心的同学可能发现，这里我们还漏了一个小的知识点没有介绍，就是在类 ComputedRefImpl 的构造函数中，执行了这样一行代码：\n\n```typescript\nthis.effect.computed = this\n```\n\n那么这行代码的作用是什么呢？在说这个作用之前，我们先来看一个 demo:\n\n```typescript\nconst { ref, effect, computed } = Vue\n\nconst n = ref(0)\nconst plusOne = computed(() => n.value + 1)\neffect(() => {\n  n.value\n  console.log(plusOne.value)\n})\nn.value++\n```\n\n小伙伴们可以猜测一下上述代码的打印结果。\n\n可能有些小伙伴猜测应该是：\n\n```\n1\n1\n2\n```\n首先是 effect 函数先执行，触发 n 的依赖收集，然后访问了 plusOne.value，再收集 computed effect。然后执行 n.value++ 按照顺序触发 effect 执行，所以理论上先触发 effect 函数内部的回调，再去执行 computed 的重新求值。所以输出是上述结果。\n\n但事实确实：\n\n```\n1\n2\n2\n```\n\n这就是因为上面那一行代码的作用。effect.computed 的标记保障了 computed effect 会优先于其他普通副作用函数先执行，关于具体的实现，可以看一下 triggerEffects 函数体内对 computed 的特殊处理：\n\n```typescript\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\n  const effects = isArray(dep) ? dep : [...dep]\n  // 确保执行完所有的 computed\n  for (const effect of effects) {\n    if (effect.computed) {\n      triggerEffect(effect, debuggerEventExtraInfo)\n    }\n  }\n  // 再执行其他的副作用函数\n  for (const effect of effects) {\n    if (!effect.computed) {\n      triggerEffect(effect, debuggerEventExtraInfo)\n    }\n  }\n}\n```\n\n#### 总结\n总而言之，计算属性可以从状态数据中计算出新数据，computed 和 methods 的最大差异是它具备缓存性，如果依赖项不变时不会重新计算，而是直接返回缓存的值。\n\n搞懂了本小节关于 computed 函数的介绍后，相信你已经知道计算属性相对于普通函数的不同之处的原理，在以后的开发中，可以更合理地使用计算属性！","source":"_drafts/technical-disclosure-of-vue3/computed.md","raw":"---\ntitle: 响应式原理：computed 函数和普通函数有什么不同？\ncategories:\n  - Vue3 技术揭秘\n---\n\n#### 前言\n计算属性接受一个 getter 函数，返回一个只读的响应式 ref 对象。该 ref 通过 .value 暴露 getter 函数的返回值。\n\n```typescript\nconst count = ref(1)\nconst plusOne = computed(() => count.value + 1)\n\nconsole.log(plusOne.value) // 2\n\nplusOne.value++ // 错误\n```\n\n它也可以接受一个带有 get 和 set 函数的对象来创建一个可写的 ref 对象。\n\n```typescript\nconst count = ref(1)\nconst plusOne = computed({\n  get: () => count.value + 1,\n  set: (val) => {\n    count.value = val - 1\n  }\n})\n\nplusOne.value = 1\nconsole.log(count.value) // 0\n```\n\n接下来看看源码里是如何实现 computed 的 API。\n\n#### 构造 setter 和 getter\n```typescript\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter\n  let setter\n  // 判断第一个参数是不是一个函数\n  const onlyGetter = isFunction(getterOrOptions)\n  \n  // 构造 setter 和 getter 函数\n  if (onlyGetter) {\n    getter = getterOrOptions\n    // 如果第一个参数是一个函数，那么就是只读的\n    setter = __DEV__\n      ? () => {\n          console.warn('Write operation failed: computed value is readonly')\n        }\n      : NOOP\n  } else {\n    getter = getterOrOptions.get\n    setter = getterOrOptions.set\n  }\n  // 构造 ref 响应式对象\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR)\n  // 返回响应式 ref\n  return cRef\n}\n```\n\n可以看到，这段 computed 函数体最初就是需要格式化传入的参数，根据第一个参数入参的类型来构造统一的 setter 和 getter 函数，并传入 ComputedRefImpl 类中，进行实例化 ref 响应式对象。\n\n接下来一起看看 ComputedRefImpl 是如何构造 cRef 响应式对象的。\n\n#### 构造 cRef 响应式对象\n\n```typescript\nclass ComputedRefImpl {\n  public dep = undefined\n\n  private _value\n  public readonly effect\n  //表示 ref 类型\n  public readonly __v_isRef = true\n  //是否只读\n  public readonly [ReactiveFlags.IS_READONLY] = false\n  //用于控制是否进行值更新(代表是否脏值)\n  public _dirty = true\n  // 缓存\n  public _cacheable\n\n  constructor(\n    getter,\n    _setter,\n    isReadonly,\n    isSSR\n  ) {\n    // 把 getter 作为响应式依赖函数 fn 参数\n    this.effect = new ReactiveEffect(getter, () => {\n      if (!this._dirty) {\n        this._dirty = true\n        // 触发更新\n        triggerRefValue(this)\n      }\n    })\n    // 标记 effect 的 computed 属性\n    this.effect.computed = this\n    this.effect.active = this._cacheable = !isSSR\n    this[ReactiveFlags.IS_READONLY] = isReadonly\n  }\n\n  get value() {\n    const self = toRaw(this)\n    // 依赖收集\n    trackRefValue(self)\n    // 脏值则进行更新\n    if (self._dirty || !self._cacheable) {\n      self._dirty = false\n      // 更新值\n      self._value = self.effect.run()!\n    }\n    return self._value\n  }\n  // 执行 setter\n  set value(newValue) {\n    this._setter(newValue)\n  }\n}\n```\n\n简单看一下该类的实现：在构造函数的时候，创建了一个副作用对象 effect。并为 effect 额外定义了一个 computed 属性执行当前响应式对象 cRef。\n\n另外，定义了一个 get 方法，当我们通过 ref.value 取值的时候可以进行依赖收集，将定义的 effect 收集起来。\n\n其次，定义了一个 set 方法，该方法就是执行传入进来的 setter 函数。\n\n最后，熟悉 Vue 的开发者都知道 computed 的特性就在于能够缓存计算的值（提升性能），只有当 computed 的依赖发生变化时才会重新计算，否则读取 computed 的值则一直是之前的值。在源码这里，实现上述功能相关的变量分别是 _dirty 和 _cacheable 这 2 个，用来控制缓存的实现。\n\n有了上面的介绍，我们来看一个具体的例子，看看 computed 是如何执行的：\n\n```html\n<template> \n  <div> \n    {{ plusOne }} \n  </div> \n  <button @click=\"plus\">plus</button> \n</template> \n<script> \n  import { ref, computed } from 'vue' \n  export default { \n    setup() { \n      const num = ref(0) \n      const plusOne = computed(() => { \n        return num.value + 1 \n      }) \n\n      function plus() { \n        num.value++ \n      } \n      return { \n        plusOne, \n        plus \n      } \n    } \n  } \n</script>\n```\n\nStep 1：setup 函数体内，computed 函数执行，初始的过程中，生成了一个 computed effect。\n\nStep 2：初始化渲染的时候，render 函数访问了 plusOne.value，触发了收集，此时收集的副作用为 render effect，因为是首次访问，所以此时的 self._dirty = true 执行 effect.run() 也就是执行了 getter 函数，得到 _value = 1。\n\nStep 3：getter 函数体内访问了 num.value 触发了对 num 的依赖收集，此时收集到的依赖为 computed effect。\n\nStep 4：点击按钮，此时 num = 1 触发了 computed effect 的 schduler 调度，因为 _dirty = false，所以触发了 triggerRefValue 的执行，同时，设置 _dirty = true。\n\nStep 5：triggerRefValue 执行过程中，会执行 computed effect.run() 触发 getter 函数的执行。因为此时的 _dirty = true，所以 get value 会重新计算 _value 的值为 plusOne.value = 2。\n\nStep 6：plusOne.value 值变化后，触发了 render effect.run 重新渲染。\n\n可以看到 computed 函数通过 _dirty 把 computed 的缓存特性表现得淋漓尽致，只有当 _dirty = true 的时候，才会进行重新计算求值，而 _dirty = true 只有在首次取值或者取值内部依赖发生变化时才会执行。\n\n#### 计算属性的执行顺序\n这里，我们介绍完了 computed 的核心流程，但是细心的同学可能发现，这里我们还漏了一个小的知识点没有介绍，就是在类 ComputedRefImpl 的构造函数中，执行了这样一行代码：\n\n```typescript\nthis.effect.computed = this\n```\n\n那么这行代码的作用是什么呢？在说这个作用之前，我们先来看一个 demo:\n\n```typescript\nconst { ref, effect, computed } = Vue\n\nconst n = ref(0)\nconst plusOne = computed(() => n.value + 1)\neffect(() => {\n  n.value\n  console.log(plusOne.value)\n})\nn.value++\n```\n\n小伙伴们可以猜测一下上述代码的打印结果。\n\n可能有些小伙伴猜测应该是：\n\n```\n1\n1\n2\n```\n首先是 effect 函数先执行，触发 n 的依赖收集，然后访问了 plusOne.value，再收集 computed effect。然后执行 n.value++ 按照顺序触发 effect 执行，所以理论上先触发 effect 函数内部的回调，再去执行 computed 的重新求值。所以输出是上述结果。\n\n但事实确实：\n\n```\n1\n2\n2\n```\n\n这就是因为上面那一行代码的作用。effect.computed 的标记保障了 computed effect 会优先于其他普通副作用函数先执行，关于具体的实现，可以看一下 triggerEffects 函数体内对 computed 的特殊处理：\n\n```typescript\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\n  const effects = isArray(dep) ? dep : [...dep]\n  // 确保执行完所有的 computed\n  for (const effect of effects) {\n    if (effect.computed) {\n      triggerEffect(effect, debuggerEventExtraInfo)\n    }\n  }\n  // 再执行其他的副作用函数\n  for (const effect of effects) {\n    if (!effect.computed) {\n      triggerEffect(effect, debuggerEventExtraInfo)\n    }\n  }\n}\n```\n\n#### 总结\n总而言之，计算属性可以从状态数据中计算出新数据，computed 和 methods 的最大差异是它具备缓存性，如果依赖项不变时不会重新计算，而是直接返回缓存的值。\n\n搞懂了本小节关于 computed 函数的介绍后，相信你已经知道计算属性相对于普通函数的不同之处的原理，在以后的开发中，可以更合理地使用计算属性！","slug":"technical-disclosure-of-vue3/computed","published":0,"date":"2023-08-12T07:53:19.989Z","updated":"2023-08-12T07:53:19.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzsloko000xsovc5m0t21hn","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>计算属性接受一个 getter 函数，返回一个只读的响应式 ref 对象。该 ref 通过 .value 暴露 getter 函数的返回值。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = <span class=\"title function_\">ref</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> plusOne = <span class=\"title function_\">computed</span>(<span class=\"function\">() =&gt;</span> count.<span class=\"property\">value</span> + <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(plusOne.<span class=\"property\">value</span>) <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">plusOne.<span class=\"property\">value</span>++ <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<p>它也可以接受一个带有 get 和 set 函数的对象来创建一个可写的 ref 对象。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = <span class=\"title function_\">ref</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> plusOne = <span class=\"title function_\">computed</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">get</span>: <span class=\"function\">() =&gt;</span> count.<span class=\"property\">value</span> + <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"attr\">set</span>: <span class=\"function\">(<span class=\"params\">val</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    count.<span class=\"property\">value</span> = val - <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">plusOne.<span class=\"property\">value</span> = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(count.<span class=\"property\">value</span>) <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<p>接下来看看源码里是如何实现 computed 的 API。</p>\n<h4 id=\"构造-setter-和-getter\"><a href=\"#构造-setter-和-getter\" class=\"headerlink\" title=\"构造 setter 和 getter\"></a>构造 setter 和 getter</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">computed</span>(<span class=\"params\">getterOrOptions, debugOptions, isSSR = <span class=\"literal\">false</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> getter</span><br><span class=\"line\">  <span class=\"keyword\">let</span> setter</span><br><span class=\"line\">  <span class=\"comment\">// 判断第一个参数是不是一个函数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> onlyGetter = <span class=\"title function_\">isFunction</span>(getterOrOptions)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 构造 setter 和 getter 函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (onlyGetter) &#123;</span><br><span class=\"line\">    getter = getterOrOptions</span><br><span class=\"line\">    <span class=\"comment\">// 如果第一个参数是一个函数，那么就是只读的</span></span><br><span class=\"line\">    setter = __DEV__</span><br><span class=\"line\">      ? <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">console</span>.<span class=\"title function_\">warn</span>(<span class=\"string\">&#x27;Write operation failed: computed value is readonly&#x27;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      : <span class=\"variable constant_\">NOOP</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    getter = getterOrOptions.<span class=\"property\">get</span></span><br><span class=\"line\">    setter = getterOrOptions.<span class=\"property\">set</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 构造 ref 响应式对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> cRef = <span class=\"keyword\">new</span> <span class=\"title class_\">ComputedRefImpl</span>(getter, setter, onlyGetter || !setter, isSSR)</span><br><span class=\"line\">  <span class=\"comment\">// 返回响应式 ref</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> cRef</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这段 computed 函数体最初就是需要格式化传入的参数，根据第一个参数入参的类型来构造统一的 setter 和 getter 函数，并传入 ComputedRefImpl 类中，进行实例化 ref 响应式对象。</p>\n<p>接下来一起看看 ComputedRefImpl 是如何构造 cRef 响应式对象的。</p>\n<h4 id=\"构造-cRef-响应式对象\"><a href=\"#构造-cRef-响应式对象\" class=\"headerlink\" title=\"构造 cRef 响应式对象\"></a>构造 cRef 响应式对象</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ComputedRefImpl</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> dep = <span class=\"literal\">undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> _value</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">readonly</span> effect</span><br><span class=\"line\">  <span class=\"comment\">//表示 ref 类型</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">readonly</span> __v_isRef = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"comment\">//是否只读</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">readonly</span> [<span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">IS_READONLY</span>] = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"comment\">//用于控制是否进行值更新(代表是否脏值)</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> _dirty = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"comment\">// 缓存</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> _cacheable</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    getter,</span></span><br><span class=\"line\"><span class=\"params\">    _setter,</span></span><br><span class=\"line\"><span class=\"params\">    isReadonly,</span></span><br><span class=\"line\"><span class=\"params\">    isSSR</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 把 getter 作为响应式依赖函数 fn 参数</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">effect</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(getter, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"variable language_\">this</span>.<span class=\"property\">_dirty</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_dirty</span> = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"comment\">// 触发更新</span></span><br><span class=\"line\">        <span class=\"title function_\">triggerRefValue</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">// 标记 effect 的 computed 属性</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">effect</span>.<span class=\"property\">computed</span> = <span class=\"variable language_\">this</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">effect</span>.<span class=\"property\">active</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">_cacheable</span> = !isSSR</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>[<span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">IS_READONLY</span>] = isReadonly</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> self = <span class=\"title function_\">toRaw</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 依赖收集</span></span><br><span class=\"line\">    <span class=\"title function_\">trackRefValue</span>(self)</span><br><span class=\"line\">    <span class=\"comment\">// 脏值则进行更新</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (self.<span class=\"property\">_dirty</span> || !self.<span class=\"property\">_cacheable</span>) &#123;</span><br><span class=\"line\">      self.<span class=\"property\">_dirty</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">      <span class=\"comment\">// 更新值</span></span><br><span class=\"line\">      self.<span class=\"property\">_value</span> = self.<span class=\"property\">effect</span>.<span class=\"title function_\">run</span>()!</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.<span class=\"property\">_value</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 执行 setter</span></span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title function_\">value</span>(<span class=\"params\">newValue</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">_setter</span>(newValue)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>简单看一下该类的实现：在构造函数的时候，创建了一个副作用对象 effect。并为 effect 额外定义了一个 computed 属性执行当前响应式对象 cRef。</p>\n<p>另外，定义了一个 get 方法，当我们通过 ref.value 取值的时候可以进行依赖收集，将定义的 effect 收集起来。</p>\n<p>其次，定义了一个 set 方法，该方法就是执行传入进来的 setter 函数。</p>\n<p>最后，熟悉 Vue 的开发者都知道 computed 的特性就在于能够缓存计算的值（提升性能），只有当 computed 的依赖发生变化时才会重新计算，否则读取 computed 的值则一直是之前的值。在源码这里，实现上述功能相关的变量分别是 _dirty 和 _cacheable 这 2 个，用来控制缓存的实现。</p>\n<p>有了上面的介绍，我们来看一个具体的例子，看看 computed 是如何执行的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    &#123;&#123; plusOne &#125;&#125; </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;plus&quot;</span>&gt;</span>plus<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"> </span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">import</span> &#123; ref, computed &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span> </span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123; </span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"title function_\">setup</span>(<span class=\"params\"></span>) &#123; </span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">const</span> num = <span class=\"title function_\">ref</span>(<span class=\"number\">0</span>) </span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">const</span> plusOne = <span class=\"title function_\">computed</span>(<span class=\"function\">() =&gt;</span> &#123; </span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">return</span> num.<span class=\"property\">value</span> + <span class=\"number\">1</span> </span></span><br><span class=\"line\"><span class=\"language-javascript\">      &#125;) </span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">function</span> <span class=\"title function_\">plus</span>(<span class=\"params\"></span>) &#123; </span></span><br><span class=\"line\"><span class=\"language-javascript\">        num.<span class=\"property\">value</span>++ </span></span><br><span class=\"line\"><span class=\"language-javascript\">      &#125; </span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">return</span> &#123; </span></span><br><span class=\"line\"><span class=\"language-javascript\">        plusOne, </span></span><br><span class=\"line\"><span class=\"language-javascript\">        plus </span></span><br><span class=\"line\"><span class=\"language-javascript\">      &#125; </span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125; </span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125; </span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>Step 1：setup 函数体内，computed 函数执行，初始的过程中，生成了一个 computed effect。</p>\n<p>Step 2：初始化渲染的时候，render 函数访问了 plusOne.value，触发了收集，此时收集的副作用为 render effect，因为是首次访问，所以此时的 self._dirty &#x3D; true 执行 effect.run() 也就是执行了 getter 函数，得到 _value &#x3D; 1。</p>\n<p>Step 3：getter 函数体内访问了 num.value 触发了对 num 的依赖收集，此时收集到的依赖为 computed effect。</p>\n<p>Step 4：点击按钮，此时 num &#x3D; 1 触发了 computed effect 的 schduler 调度，因为 _dirty &#x3D; false，所以触发了 triggerRefValue 的执行，同时，设置 _dirty &#x3D; true。</p>\n<p>Step 5：triggerRefValue 执行过程中，会执行 computed effect.run() 触发 getter 函数的执行。因为此时的 _dirty &#x3D; true，所以 get value 会重新计算 _value 的值为 plusOne.value &#x3D; 2。</p>\n<p>Step 6：plusOne.value 值变化后，触发了 render effect.run 重新渲染。</p>\n<p>可以看到 computed 函数通过 _dirty 把 computed 的缓存特性表现得淋漓尽致，只有当 _dirty &#x3D; true 的时候，才会进行重新计算求值，而 _dirty &#x3D; true 只有在首次取值或者取值内部依赖发生变化时才会执行。</p>\n<h4 id=\"计算属性的执行顺序\"><a href=\"#计算属性的执行顺序\" class=\"headerlink\" title=\"计算属性的执行顺序\"></a>计算属性的执行顺序</h4><p>这里，我们介绍完了 computed 的核心流程，但是细心的同学可能发现，这里我们还漏了一个小的知识点没有介绍，就是在类 ComputedRefImpl 的构造函数中，执行了这样一行代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">effect</span>.<span class=\"property\">computed</span> = <span class=\"variable language_\">this</span></span><br></pre></td></tr></table></figure>\n\n<p>那么这行代码的作用是什么呢？在说这个作用之前，我们先来看一个 demo:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; ref, effect, computed &#125; = <span class=\"title class_\">Vue</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> n = <span class=\"title function_\">ref</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> plusOne = <span class=\"title function_\">computed</span>(<span class=\"function\">() =&gt;</span> n.<span class=\"property\">value</span> + <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  n.<span class=\"property\">value</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(plusOne.<span class=\"property\">value</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">n.<span class=\"property\">value</span>++</span><br></pre></td></tr></table></figure>\n\n<p>小伙伴们可以猜测一下上述代码的打印结果。</p>\n<p>可能有些小伙伴猜测应该是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n<p>首先是 effect 函数先执行，触发 n 的依赖收集，然后访问了 plusOne.value，再收集 computed effect。然后执行 n.value++ 按照顺序触发 effect 执行，所以理论上先触发 effect 函数内部的回调，再去执行 computed 的重新求值。所以输出是上述结果。</p>\n<p>但事实确实：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n\n<p>这就是因为上面那一行代码的作用。effect.computed 的标记保障了 computed effect 会优先于其他普通副作用函数先执行，关于具体的实现，可以看一下 triggerEffects 函数体内对 computed 的特殊处理：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">triggerEffects</span>(<span class=\"params\">dep, debuggerEventExtraInfo</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> effects = <span class=\"title function_\">isArray</span>(dep) ? dep : [...dep]</span><br><span class=\"line\">  <span class=\"comment\">// 确保执行完所有的 computed</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> effect <span class=\"keyword\">of</span> effects) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (effect.<span class=\"property\">computed</span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">triggerEffect</span>(effect, debuggerEventExtraInfo)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 再执行其他的副作用函数</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> effect <span class=\"keyword\">of</span> effects) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!effect.<span class=\"property\">computed</span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">triggerEffect</span>(effect, debuggerEventExtraInfo)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>总而言之，计算属性可以从状态数据中计算出新数据，computed 和 methods 的最大差异是它具备缓存性，如果依赖项不变时不会重新计算，而是直接返回缓存的值。</p>\n<p>搞懂了本小节关于 computed 函数的介绍后，相信你已经知道计算属性相对于普通函数的不同之处的原理，在以后的开发中，可以更合理地使用计算属性！</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>计算属性接受一个 getter 函数，返回一个只读的响应式 ref 对象。该 ref 通过 .value 暴露 getter 函数的返回值。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = <span class=\"title function_\">ref</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> plusOne = <span class=\"title function_\">computed</span>(<span class=\"function\">() =&gt;</span> count.<span class=\"property\">value</span> + <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(plusOne.<span class=\"property\">value</span>) <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">plusOne.<span class=\"property\">value</span>++ <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<p>它也可以接受一个带有 get 和 set 函数的对象来创建一个可写的 ref 对象。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = <span class=\"title function_\">ref</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> plusOne = <span class=\"title function_\">computed</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">get</span>: <span class=\"function\">() =&gt;</span> count.<span class=\"property\">value</span> + <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"attr\">set</span>: <span class=\"function\">(<span class=\"params\">val</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    count.<span class=\"property\">value</span> = val - <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">plusOne.<span class=\"property\">value</span> = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(count.<span class=\"property\">value</span>) <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<p>接下来看看源码里是如何实现 computed 的 API。</p>\n<h4 id=\"构造-setter-和-getter\"><a href=\"#构造-setter-和-getter\" class=\"headerlink\" title=\"构造 setter 和 getter\"></a>构造 setter 和 getter</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">computed</span>(<span class=\"params\">getterOrOptions, debugOptions, isSSR = <span class=\"literal\">false</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> getter</span><br><span class=\"line\">  <span class=\"keyword\">let</span> setter</span><br><span class=\"line\">  <span class=\"comment\">// 判断第一个参数是不是一个函数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> onlyGetter = <span class=\"title function_\">isFunction</span>(getterOrOptions)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 构造 setter 和 getter 函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (onlyGetter) &#123;</span><br><span class=\"line\">    getter = getterOrOptions</span><br><span class=\"line\">    <span class=\"comment\">// 如果第一个参数是一个函数，那么就是只读的</span></span><br><span class=\"line\">    setter = __DEV__</span><br><span class=\"line\">      ? <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">console</span>.<span class=\"title function_\">warn</span>(<span class=\"string\">&#x27;Write operation failed: computed value is readonly&#x27;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      : <span class=\"variable constant_\">NOOP</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    getter = getterOrOptions.<span class=\"property\">get</span></span><br><span class=\"line\">    setter = getterOrOptions.<span class=\"property\">set</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 构造 ref 响应式对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> cRef = <span class=\"keyword\">new</span> <span class=\"title class_\">ComputedRefImpl</span>(getter, setter, onlyGetter || !setter, isSSR)</span><br><span class=\"line\">  <span class=\"comment\">// 返回响应式 ref</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> cRef</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这段 computed 函数体最初就是需要格式化传入的参数，根据第一个参数入参的类型来构造统一的 setter 和 getter 函数，并传入 ComputedRefImpl 类中，进行实例化 ref 响应式对象。</p>\n<p>接下来一起看看 ComputedRefImpl 是如何构造 cRef 响应式对象的。</p>\n<h4 id=\"构造-cRef-响应式对象\"><a href=\"#构造-cRef-响应式对象\" class=\"headerlink\" title=\"构造 cRef 响应式对象\"></a>构造 cRef 响应式对象</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ComputedRefImpl</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> dep = <span class=\"literal\">undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> _value</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">readonly</span> effect</span><br><span class=\"line\">  <span class=\"comment\">//表示 ref 类型</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">readonly</span> __v_isRef = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"comment\">//是否只读</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">readonly</span> [<span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">IS_READONLY</span>] = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"comment\">//用于控制是否进行值更新(代表是否脏值)</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> _dirty = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"comment\">// 缓存</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> _cacheable</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    getter,</span></span><br><span class=\"line\"><span class=\"params\">    _setter,</span></span><br><span class=\"line\"><span class=\"params\">    isReadonly,</span></span><br><span class=\"line\"><span class=\"params\">    isSSR</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 把 getter 作为响应式依赖函数 fn 参数</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">effect</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(getter, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"variable language_\">this</span>.<span class=\"property\">_dirty</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_dirty</span> = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"comment\">// 触发更新</span></span><br><span class=\"line\">        <span class=\"title function_\">triggerRefValue</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">// 标记 effect 的 computed 属性</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">effect</span>.<span class=\"property\">computed</span> = <span class=\"variable language_\">this</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">effect</span>.<span class=\"property\">active</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">_cacheable</span> = !isSSR</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>[<span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">IS_READONLY</span>] = isReadonly</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> self = <span class=\"title function_\">toRaw</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 依赖收集</span></span><br><span class=\"line\">    <span class=\"title function_\">trackRefValue</span>(self)</span><br><span class=\"line\">    <span class=\"comment\">// 脏值则进行更新</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (self.<span class=\"property\">_dirty</span> || !self.<span class=\"property\">_cacheable</span>) &#123;</span><br><span class=\"line\">      self.<span class=\"property\">_dirty</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">      <span class=\"comment\">// 更新值</span></span><br><span class=\"line\">      self.<span class=\"property\">_value</span> = self.<span class=\"property\">effect</span>.<span class=\"title function_\">run</span>()!</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.<span class=\"property\">_value</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 执行 setter</span></span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title function_\">value</span>(<span class=\"params\">newValue</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">_setter</span>(newValue)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>简单看一下该类的实现：在构造函数的时候，创建了一个副作用对象 effect。并为 effect 额外定义了一个 computed 属性执行当前响应式对象 cRef。</p>\n<p>另外，定义了一个 get 方法，当我们通过 ref.value 取值的时候可以进行依赖收集，将定义的 effect 收集起来。</p>\n<p>其次，定义了一个 set 方法，该方法就是执行传入进来的 setter 函数。</p>\n<p>最后，熟悉 Vue 的开发者都知道 computed 的特性就在于能够缓存计算的值（提升性能），只有当 computed 的依赖发生变化时才会重新计算，否则读取 computed 的值则一直是之前的值。在源码这里，实现上述功能相关的变量分别是 _dirty 和 _cacheable 这 2 个，用来控制缓存的实现。</p>\n<p>有了上面的介绍，我们来看一个具体的例子，看看 computed 是如何执行的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    &#123;&#123; plusOne &#125;&#125; </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;plus&quot;</span>&gt;</span>plus<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"> </span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">import</span> &#123; ref, computed &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span> </span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123; </span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"title function_\">setup</span>(<span class=\"params\"></span>) &#123; </span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">const</span> num = <span class=\"title function_\">ref</span>(<span class=\"number\">0</span>) </span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">const</span> plusOne = <span class=\"title function_\">computed</span>(<span class=\"function\">() =&gt;</span> &#123; </span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">return</span> num.<span class=\"property\">value</span> + <span class=\"number\">1</span> </span></span><br><span class=\"line\"><span class=\"language-javascript\">      &#125;) </span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">function</span> <span class=\"title function_\">plus</span>(<span class=\"params\"></span>) &#123; </span></span><br><span class=\"line\"><span class=\"language-javascript\">        num.<span class=\"property\">value</span>++ </span></span><br><span class=\"line\"><span class=\"language-javascript\">      &#125; </span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">return</span> &#123; </span></span><br><span class=\"line\"><span class=\"language-javascript\">        plusOne, </span></span><br><span class=\"line\"><span class=\"language-javascript\">        plus </span></span><br><span class=\"line\"><span class=\"language-javascript\">      &#125; </span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125; </span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125; </span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>Step 1：setup 函数体内，computed 函数执行，初始的过程中，生成了一个 computed effect。</p>\n<p>Step 2：初始化渲染的时候，render 函数访问了 plusOne.value，触发了收集，此时收集的副作用为 render effect，因为是首次访问，所以此时的 self._dirty &#x3D; true 执行 effect.run() 也就是执行了 getter 函数，得到 _value &#x3D; 1。</p>\n<p>Step 3：getter 函数体内访问了 num.value 触发了对 num 的依赖收集，此时收集到的依赖为 computed effect。</p>\n<p>Step 4：点击按钮，此时 num &#x3D; 1 触发了 computed effect 的 schduler 调度，因为 _dirty &#x3D; false，所以触发了 triggerRefValue 的执行，同时，设置 _dirty &#x3D; true。</p>\n<p>Step 5：triggerRefValue 执行过程中，会执行 computed effect.run() 触发 getter 函数的执行。因为此时的 _dirty &#x3D; true，所以 get value 会重新计算 _value 的值为 plusOne.value &#x3D; 2。</p>\n<p>Step 6：plusOne.value 值变化后，触发了 render effect.run 重新渲染。</p>\n<p>可以看到 computed 函数通过 _dirty 把 computed 的缓存特性表现得淋漓尽致，只有当 _dirty &#x3D; true 的时候，才会进行重新计算求值，而 _dirty &#x3D; true 只有在首次取值或者取值内部依赖发生变化时才会执行。</p>\n<h4 id=\"计算属性的执行顺序\"><a href=\"#计算属性的执行顺序\" class=\"headerlink\" title=\"计算属性的执行顺序\"></a>计算属性的执行顺序</h4><p>这里，我们介绍完了 computed 的核心流程，但是细心的同学可能发现，这里我们还漏了一个小的知识点没有介绍，就是在类 ComputedRefImpl 的构造函数中，执行了这样一行代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">effect</span>.<span class=\"property\">computed</span> = <span class=\"variable language_\">this</span></span><br></pre></td></tr></table></figure>\n\n<p>那么这行代码的作用是什么呢？在说这个作用之前，我们先来看一个 demo:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; ref, effect, computed &#125; = <span class=\"title class_\">Vue</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> n = <span class=\"title function_\">ref</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> plusOne = <span class=\"title function_\">computed</span>(<span class=\"function\">() =&gt;</span> n.<span class=\"property\">value</span> + <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  n.<span class=\"property\">value</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(plusOne.<span class=\"property\">value</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">n.<span class=\"property\">value</span>++</span><br></pre></td></tr></table></figure>\n\n<p>小伙伴们可以猜测一下上述代码的打印结果。</p>\n<p>可能有些小伙伴猜测应该是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n<p>首先是 effect 函数先执行，触发 n 的依赖收集，然后访问了 plusOne.value，再收集 computed effect。然后执行 n.value++ 按照顺序触发 effect 执行，所以理论上先触发 effect 函数内部的回调，再去执行 computed 的重新求值。所以输出是上述结果。</p>\n<p>但事实确实：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n\n<p>这就是因为上面那一行代码的作用。effect.computed 的标记保障了 computed effect 会优先于其他普通副作用函数先执行，关于具体的实现，可以看一下 triggerEffects 函数体内对 computed 的特殊处理：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">triggerEffects</span>(<span class=\"params\">dep, debuggerEventExtraInfo</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> effects = <span class=\"title function_\">isArray</span>(dep) ? dep : [...dep]</span><br><span class=\"line\">  <span class=\"comment\">// 确保执行完所有的 computed</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> effect <span class=\"keyword\">of</span> effects) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (effect.<span class=\"property\">computed</span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">triggerEffect</span>(effect, debuggerEventExtraInfo)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 再执行其他的副作用函数</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> effect <span class=\"keyword\">of</span> effects) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!effect.<span class=\"property\">computed</span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">triggerEffect</span>(effect, debuggerEventExtraInfo)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>总而言之，计算属性可以从状态数据中计算出新数据，computed 和 methods 的最大差异是它具备缓存性，如果依赖项不变时不会重新计算，而是直接返回缓存的值。</p>\n<p>搞懂了本小节关于 computed 函数的介绍后，相信你已经知道计算属性相对于普通函数的不同之处的原理，在以后的开发中，可以更合理地使用计算属性！</p>\n"},{"title":"响应式原理：副作用函数探秘","_content":"\n#### 前言\n上一小节我们说到了 Reactive 会在 proxy getter 的时候收集 effect 依赖，在 proxy setter 的时候触发 effect 的执行。那么 effect 副作用函数到底是个什么？以及是如何被收集起来的呢？\n\n#### effect\n找到源码中关于 effect 部分的定义：\n\n```typescript\nexport function effect (fn, options) {\n  // 如果 fn 已经是一个 effect 函数了，则指向原始函数\n  if (fn.effect) {\n    fn = fn.effect.fn\n  }\n  // 构造 _effect 实例\n  const _effect = new ReactiveEffect(fn)\n  \n  // options 初始化\n  if (options) {\n    extend(_effect, options)\n    if (options.scope) recordEffectScope(_effect, options.scope)\n  }\n  \n  // 如有 options 或者 不是懒加载，执行 _effect.run()\n  if (!options || !options.lazy) {\n    _effect.run()\n  }\n  \n  // 返回 _effect.run\n  const runner = _effect.run.bind(_effect)\n  runner.effect = _effect\n  return runner\n}\n```\n\n这个 effect 函数内部核心是通过 ReactiveEffect 类创建了一个 _effect 实例，从代码来看，_effect 上包含了一个 run 函数。默认 effect 是没有传入 options 参数的，所以这里直接执行了 _effect.run()。我们知道，fn 函数是在 effect 函数中的一个入参，比如：\n\n```typescript\nconst state = reactive({a: 1})\n\neffect(() => console.log(state.a))\n```\n\n根据上一小节，我们知道因为这里我们访问了 state.a 所以收集了副作用函数，但是需要知道的是这里的 effect 传入的是一个 fn，所以要想访问 state.a 那这个 fn 必须要执行才可以。那是在哪里执行的呢？接下来看一下 ReactiveEffect 的实现：\n\n```typescript\n// 用于记录位于响应上下文中的effect嵌套层次数\nlet effectTrackDepth = 0\n// 二进制位，每一位用于标识当前effect嵌套层级的依赖收集的启用状态\nexport left trackOpBit = 1\n// 表示最大标记的位数\nconst maxMarkerBits = 30\n\n// 当前活跃的 effect\nlet activeEffect;\n\nexport class ReactiveEffect {\n  // 用于标识副作用函数是否位于响应式上下文中被执行\n  active = true\n  // 副作用函数持有它所在的所有依赖集合的引用，用于从这些依赖集合删除自身\n  deps = []\n  // 指针为，用于嵌套 effect 执行后动态切换 activeEffect\n  parent = undefined\n  // ...\n  run() {\n    // 若当前 ReactiveEffect 对象脱离响应式上下文\n    // 那么其对应的副作用函数被执行时不会再收集依赖\n    if (!this.active) {\n      return this.fn()\n    }\n    \n    // 缓存是否需要收集依赖\n    let lastShouldTrack = shouldTrack\n    \n    try {\n      // 保存上一个 activeEffect 到当前的 parent 上\n      this.parent = activeEffect\n      // activeEffect 指向当前的 effect\n      activeEffect = this\n      // shouldTrack 置成 true\n      shouldTrack = true\n      // 左移操作符 << 将第一个操作数向左移动指定位数\n      // 左边超出的位数将会被清除，右边将会补零。\n      // trackOpBit 是基于 1 左移 effectTrackDepth 位\n      trackOpBit = 1 << ++effectTrackDepth\n      \n      // 如果未超过最大嵌套层数，则执行 initDepMarkers\n      if (effectTrackDepth <= maxMarkerBits) {\n        initDepMarkers(this)\n      } else {\n        cleanupEffect(this)\n      }\n      // 这里执行了 fn\n      return this.fn()\n    } finally {\n      if (effectTrackDepth <= maxMarkerBits) {\n        // 用于对曾经跟踪过，但本次副作用函数执行时没有跟踪的依赖采取删除操作。\n        // 新跟踪的 和 本轮跟踪过的都会被保留\n        finalizeDepMarkers(this)\n      }\n      \n      // << --effectTrackDepth 右移动 effectTrackDepth 位\n      trackOpBit = 1 << --effectTrackDepth\n      \n      // 返回上个 activeEffect\n      activeEffect = this.parent\n      // 返回上个 shouldTrack\n      shouldTrack = lastShouldTrack\n      // 情况本次的 parent 指向\n      this.parent = undefined\n    }\n  }\n}\n```\n\n大致看一眼，我们可以看到在 ReactiveEffect 中是执行了 this.fn() 的，这也就解释了 effect 中的回调函数 fn 是在这里被调用的。接下来详细研究一下这个 ReactiveEffect。\n\n但这段代码看起来不是很长，但涉及了好几个概念，我们来一个个看。\n##### 1. parent 的作用\n为什么 ReactiveEffect 要设计一个 parent 这样一个看似没啥用的变量指针来存储上一次的 activeEffect 呢？如果改成下面这样不是更简单吗？\n\n```typescript\nrun() {\n  if (!this.active) {\n    return this.fn();\n  }\n  // 初始化\n  shouldTrack = true;\n  activeEffect = this;\n\n  const result = this.fn();\n  \n  // 重置\n  shouldTrack = false;\n  \n  return result;\n}\n```\n\n其实对于下面这样的代码：\n\n```typescript\nconst state = reactive({a: 1})\n\neffect(() => console.log(state.a))\n\nstate.a++\n```\n\neffect 函数内调用 ReactiveEffect 实例的 run 函数。run 函数执行的时候，把 activeEffect 指向 this。然后执行 effect 传入的 fn 函数，函数在执行的时候访问了 state.a 触发了 getter 钩子。回顾一下上一节的内容，getter 的时候有触发添加 activeEffect 的功能：\n\n```typescript\n// 把 activeEffect 添加到 dep 中\ndep.add(activeEffect!)\n```\n\n而 activeEffect 正是这里的 this。当执行 state.a++ 时，访问了state.a 的 setter。上一节也说了，setter 的执行会调用 effect.run 函数：\n\n```typescript\n// triggerEffects\neffect.run();\n```\n\n所以又会执行 fn。\n\n到这里看似很完美，那么我们再来看另外一个例子🌰：\n\n```typescript\nconst state = reactive({\n  a: 1,\n  b: 2\n});\n\n// ef1\neffect(() => {\n  // ef2\n  effect(() => console.log(`b: ${state.b}`))\n  console.log(`a: ${state.a}`)\n});\n```\n\nstate.a ++\n按照上面的逻辑，在第一次 effect 执行的时候，activeEffect = ef1 然后再执行内部的 effect， 此时 activeEffect = ef2 然后 ef2 执行完成回到 ef1 函数体内，此时再访问 state.a 触发对 a 的依赖收集，但收集到的却是 ef2。那么最终打印的是：\n\n```\nb: 2\na: 1\nb: 2\n```\n\n很明显不符合我们的要求，我们期望的是输出：\n\n```\nb: 2\na: 1\nb: 2\na: 2\n```\n\n这时候 parent 就排上用场了，当为 effect 加上 parent 属性后，我们再来捋一下整体的流程。\n\n执行 ef1 的时候，activeEffect 指向 ef1，此时 parent 是 undefined。\n执行 ef1 fn 遇到了 ef2，调用 ef2 此时 ef2 的 parent 指向 ef1， activeEffect 指向 ef2。然后执行 ef2 的 fn。\nef2 的 fn 执行的时候，访问了 state.b 依赖收集 ef2。执行完成后，activeEffect = this.parent 又把 activeEffect 指向了 ef1。\n返回 ef1 的 fn 体继续执行，此时访问 state.a 依赖收集 activeEffect 为 ef1。\n触发 state.a 的 setter，调用 a 的副作用 ef1，依次打印……\n到这里相信各位小伙伴已经清楚了 parent 的作用了，那就是通过 parent 这个标记，来回切换 activeEffect 的指向，从而完成对嵌套 effect 的正确的依赖收集。\n\n##### 2. 依赖清理\n在说依赖清理之前，再来看一个有意思的例子：\n\n```typescript\nconst state = reactive({\n  a: 1,\n  show: true\n});\n\neffect(() => {\n  if (state.show) {\n    console.log(`a: ${state.a}`)\n  }\n});\n\nstate.a ++\n\nsetTimeout(() => {\n  state.show = false\n  state.a ++\n}, 1000)\n```\n\n\n上面的例子中，我们在 effect 中完成了对 show 和 a 的依赖收集，然后 1s 后，我们改变了 show 的状态为 false。此时 effect 内的函数中的 console.log 将永远不会执行，然后再触发 state.a++ 的动作，访问 a 的 getter，如果没有依赖清理，那么按照之前的做法，测试也会触发 effect.fn 的执行，但这个执行其实没意义的，因为 a 已经没有被使用了，是一个永远不会被访问到的变量，造成了性能浪费。所以我们需要删除 a 的副作用函数，让它不要执行。\n\n接下来一起来看看 Vue 是怎么做的吧！这里涉及到的内容有点多，我们先一个个解释，首先补习一下关于 js 的一些操作符的基础知识。\n\n###### 1. 左移（<<）\n\n左移操作符 (<<) 将第一个操作数转换成 2 进制后向左移动指定位数，左边超出的位数将会被清除，右边将会补零。\n\n```typescript\nconst a = 1;         // 00000000000000000000000000000001\nconst b = 1;       \n\nconsole.log(a << b); // 00000000000000000000000000000010\n// expected output: 2\n```\n\n###### 2. 位或操作（|）\n\n位或操作符（|）， 如果两位之一为 1，则设置每位为 1。\n\n```typescript\nconst a = 5;        // 00000000000000000000000000000101\nconst b = 3;        // 00000000000000000000000000000011\n\nconsole.log(a | b); // 00000000000000000000000000000111\n// expected output: 7\n```\n\n###### 3. 按位与（&）\n\n按位与运算符 (&) 在两个操作数对应的二进位都为 1 时，该位的结果值才为 1，否则为 0。\n\n```typescript\nconst a = 5;        // 00000000000000000000000000000101\nconst b = 3;        // 00000000000000000000000000000011\n\nconsole.log(a & b); // 00000000000000000000000000000001\n// expected output: 1\n```\n\n###### 4. 按位非（~）\n\n按位非运算符（~），反转操作数的位。\n\n```typescript\nconst a = 5;     // 00000000000000000000000000000101\nconst b = -3;    // 11111111111111111111111111111101\n\nconsole.log(~a); // 11111111111111111111111111111010\n// expected output: -6\n\nconsole.log(~b); // 00000000000000000000000000000010\n// expected output: 2\n```\n\n有了这些基础的知识点后，再来认识几个变量。\n\n###### 1. effectTrackDepth\n\n用于记录位于响应上下文中的 effect 嵌套层次数，默认值为 0。\n\n```typescript\n// effectTrackDepth = 0\neffect(() => {\n  // effectTrackDepth = 1\n  effect(() => {})\n})\n```\n\n###### 2. trackOpBit\n\n二进制位，每一位用于标识当前 effect 嵌套层级的依赖收集的启用状态。默认值为 1，即 00000000000000000000000000000001。\n\n###### 3. maxMarkerBits\n\n表示最大的 effect 嵌套的层次数，最大值为 30。\n\n好了，搞懂了这些操作符之后，我们来看看 Vue 的依赖清理是如何实现的，先来看不超过 maxMarkerBits 层级数的嵌套 effect 的依赖收集的过程，还以上面那个 demo 作为示例：\n\n```typescript\nconst state = reactive({\n  a: 1,\n  show: true\n});\n\neffect(() => {\n  if (state.show) {\n    console.log(`a: ${state.a}`)\n  }\n});\n\nstate.a ++\n\nsetTimeout(() => {\n  state.show = false\n  state.a ++\n}, 1000)\n```\n\nStep 1：run 函数执行的时候，trackOpBit = 1 << ++effectTrackDepth 这个语句执行完成后，得到 effectTrackDepth = 1；trackOpBit.toString(2) = 00000000000000000000000000000010。\n\nStep 2：因为 effectTrackDepth < maxMarkerBits ，所以执行 initDepMarkers 函数，因为这里的 deps 在初始化的时候还是个空数组，所以此函数未执行。\n\n```typescript\nexport const initDepMarkers = ({ deps }) => {\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].w |= trackOpBit // set was tracked\n    }\n  }\n}\n```\n\nStep 3：执行 this.fn 函数，先访问 state.show，触发了 trackEffects。\n\n```typescript\nexport function trackEffects(dep) {\n  let shouldTrack = false\n  if (effectTrackDepth <= maxMarkerBits) {\n    // 如果本轮副作用函数执行过程中已经访问并收集过，则不用再收集该依赖\n    if (!newTracked(dep)) {\n      // 设置 dep.n\n      dep.n |= trackOpBit\n      shouldTrack = !wasTracked(dep)\n    }\n  } else {\n    // Full cleanup mode.\n    shouldTrack = !dep.has(activeEffect!)\n  }\n\n  if (shouldTrack) {\n    dep.add(activeEffect!)\n    activeEffect!.deps.push(dep)\n  }\n}\n```\n\n这里需要额外了解 2 个函数：wasTracked（已经被收集过，缩写是 w） 和 newTracked（新收集的依赖，缩写是 n）。\n\n```typescript\nexport const wasTracked = dep => (dep.w & trackOpBit) > 0\n\nexport const newTracked = dep => (dep.n & trackOpBit) > 0\n```\n\n进入 trackEffects 时，因为此时还没有为 dep.n 进行或运算赋值，所以 state.show 的 newTracked = false，wasTracked = false。\n\n所以计算得到 shouldTrack = true，最后将 activeEffect 收集进入 dep 中，同时执行了 activeEffect.deps.push(dep) 将 dep 存入了 activeEffect 的 deps 中。然后访问 state.a 重复上述操作。上述步骤执行完成后的 activeEffect.deps 如下：\n\n```\n[\n  {\"w\":0,\"n\": 00000000000000000000000000000010, [effect]},\n  {\"w\":0,\"n\": 00000000000000000000000000000010, [effect]}\n]\n```\n\nStep 4：最后执行 finalizeDepMarkers 函数，根据第 3 步，此时 effect 中的 deps 包含了 2 个 dep，分别是 state.show 和 state.a。 finalizeDepMarkers 函数内部执行了 wasTracked（已经被收集过，缩写是 w） 和 newTracked（新收集的依赖，缩写是 n） 函数，因为 dep.w = 0 所以 wasTracked = false。\n\n```typescript\nexport const finalizeDepMarkers = (effect: ReactiveEffect) => {\n  const { deps } = effect\n  if (deps.length) {\n    let ptr = 0\n    for (let i = 0; i < deps.length; i++) {\n      const dep = deps[i]\n      if (wasTracked(dep) && !newTracked(dep)) {\n        dep.delete(effect)\n      } else {\n        // 缩小依赖集合的大小\n        deps[ptr++] = dep\n      }\n      // clear bits\n      dep.w &= ~trackOpBit\n      dep.n &= ~trackOpBit\n    }\n    deps.length = ptr\n  }\n}\n```\n\n因为 wasTracked = false，因此 finalizeDepMarkers 处理后仍然将副作用函数保留在这两个属性对应的依赖集合中，同时把 dep.w 和 dep.n 重置回 0。\n\n```\n[{\"w\":0, \"n\":0, [effect]},{\"w\":0, \"n\":0, [effect]}]\n```\n\nStep 5：当执行 state.show = false 的时候，触发 effect.run 的执行，此时执行 initDepMarkers 时，因为已经存在了 dep，所以先访问 state.show。\n\n当执行到 trackEffects 时，此时的 newTracked = false，执行逻辑和之前一致。只不过因为 state.show = false，所以没有触发 state.a 的这一部分逻辑的处理，最后得到的结果为：\n\n```\n[\n  {\n    \"w\": 00000000000000000000000000000010,\n    \"n\": 00000000000000000000000000000010,\n    [effect]\n  },\n  {\n    \"w\": 00000000000000000000000000000010, \n    \"n\": 0,\n    [effect]\n  }\n]\n```\n\nStep 6：最后执行 finalizeDepMarkers 时，如下。\n\n```\nif (wasTracked(dep) && !newTracked(dep)) {\n  dep.delete(effect)\n}\n```\n\n因为这里的 state.a 的 wasTracked = true 且 newTracked 为 false，所以执行了 dep.delete(effect) 将 effect 从 dep 中踢掉。\n\nStep 7：1s 后执行 state.a++ 的操作，由于 state.a 中没有 effect 了，所以不会执行副作用函数。\n\n##### 总结： Vue 在组件的 effect 执行之前，会根据 dep 的收集标记位 w 和 n 来进行清理依赖，删除之前 state.a 收集的 effect 依赖。这样当我们修改 state.a 时，由于已经没有依赖了，就不会触发 effect 重新执行。\n\n另外，为了更容易帮助小伙伴们理解上述的流程，我也精心制作了一个动画演示上述流程和过程：\n\n依赖清理过程.gif\n\n注意，当 effectTrackDepth 大于 30 时，会调用 cleanup 来清理依赖，其实 cleanup 的原理就是依赖收集前全部删除所有的 dep，依赖收集时再一个个加进来，这个性能其实是比较差的，所以 Vue 3.2 改成了通过二进制标记位的方式来选择性删除和添加，提升了性能。关于这部分更多的细节，可以参考这个PR。\n\n#### 总结\n到这里，我们基本上讲完了 Vue 3 的响应式原理基础，如果有小伙伴了解 Vue 2 的响应式原理，应该清楚 Vue2 的响应式原理可以理解成如下一幅图：\n\nimage.png\n\n在 Vue 2 中，Watcher 就是依赖，有专门针对组件渲染的 render watcher。\n\n依赖收集：组件在 render 的时候会访问模板中的数据，触发 getter 把 watcher 作为依赖收集。\n触发渲染：当修改数据时，会触发 setter，通知 watcher 更新，进而触发了组件的重新渲染。\n相应地，在 Vue 3 中的响应式流程如下：\n\nimage.png\n\n可以看到，Vue 3 相对于 Vue 2 的响应式差别不大，主要就是劫持数据的方式改成用 Proxy 实现，以及收集的依赖由 watcher 实例变成了组件副作用函数 effect。另外，值得一提的是 Vue 3 在响应式设计上又多考虑了层级嵌套的依赖收集问题和不必要的依赖清理问题。","source":"_drafts/technical-disclosure-of-vue3/effect.md","raw":"---\ntitle: 响应式原理：副作用函数探秘\ncategories:\n  - Vue3 技术揭秘\n---\n\n#### 前言\n上一小节我们说到了 Reactive 会在 proxy getter 的时候收集 effect 依赖，在 proxy setter 的时候触发 effect 的执行。那么 effect 副作用函数到底是个什么？以及是如何被收集起来的呢？\n\n#### effect\n找到源码中关于 effect 部分的定义：\n\n```typescript\nexport function effect (fn, options) {\n  // 如果 fn 已经是一个 effect 函数了，则指向原始函数\n  if (fn.effect) {\n    fn = fn.effect.fn\n  }\n  // 构造 _effect 实例\n  const _effect = new ReactiveEffect(fn)\n  \n  // options 初始化\n  if (options) {\n    extend(_effect, options)\n    if (options.scope) recordEffectScope(_effect, options.scope)\n  }\n  \n  // 如有 options 或者 不是懒加载，执行 _effect.run()\n  if (!options || !options.lazy) {\n    _effect.run()\n  }\n  \n  // 返回 _effect.run\n  const runner = _effect.run.bind(_effect)\n  runner.effect = _effect\n  return runner\n}\n```\n\n这个 effect 函数内部核心是通过 ReactiveEffect 类创建了一个 _effect 实例，从代码来看，_effect 上包含了一个 run 函数。默认 effect 是没有传入 options 参数的，所以这里直接执行了 _effect.run()。我们知道，fn 函数是在 effect 函数中的一个入参，比如：\n\n```typescript\nconst state = reactive({a: 1})\n\neffect(() => console.log(state.a))\n```\n\n根据上一小节，我们知道因为这里我们访问了 state.a 所以收集了副作用函数，但是需要知道的是这里的 effect 传入的是一个 fn，所以要想访问 state.a 那这个 fn 必须要执行才可以。那是在哪里执行的呢？接下来看一下 ReactiveEffect 的实现：\n\n```typescript\n// 用于记录位于响应上下文中的effect嵌套层次数\nlet effectTrackDepth = 0\n// 二进制位，每一位用于标识当前effect嵌套层级的依赖收集的启用状态\nexport left trackOpBit = 1\n// 表示最大标记的位数\nconst maxMarkerBits = 30\n\n// 当前活跃的 effect\nlet activeEffect;\n\nexport class ReactiveEffect {\n  // 用于标识副作用函数是否位于响应式上下文中被执行\n  active = true\n  // 副作用函数持有它所在的所有依赖集合的引用，用于从这些依赖集合删除自身\n  deps = []\n  // 指针为，用于嵌套 effect 执行后动态切换 activeEffect\n  parent = undefined\n  // ...\n  run() {\n    // 若当前 ReactiveEffect 对象脱离响应式上下文\n    // 那么其对应的副作用函数被执行时不会再收集依赖\n    if (!this.active) {\n      return this.fn()\n    }\n    \n    // 缓存是否需要收集依赖\n    let lastShouldTrack = shouldTrack\n    \n    try {\n      // 保存上一个 activeEffect 到当前的 parent 上\n      this.parent = activeEffect\n      // activeEffect 指向当前的 effect\n      activeEffect = this\n      // shouldTrack 置成 true\n      shouldTrack = true\n      // 左移操作符 << 将第一个操作数向左移动指定位数\n      // 左边超出的位数将会被清除，右边将会补零。\n      // trackOpBit 是基于 1 左移 effectTrackDepth 位\n      trackOpBit = 1 << ++effectTrackDepth\n      \n      // 如果未超过最大嵌套层数，则执行 initDepMarkers\n      if (effectTrackDepth <= maxMarkerBits) {\n        initDepMarkers(this)\n      } else {\n        cleanupEffect(this)\n      }\n      // 这里执行了 fn\n      return this.fn()\n    } finally {\n      if (effectTrackDepth <= maxMarkerBits) {\n        // 用于对曾经跟踪过，但本次副作用函数执行时没有跟踪的依赖采取删除操作。\n        // 新跟踪的 和 本轮跟踪过的都会被保留\n        finalizeDepMarkers(this)\n      }\n      \n      // << --effectTrackDepth 右移动 effectTrackDepth 位\n      trackOpBit = 1 << --effectTrackDepth\n      \n      // 返回上个 activeEffect\n      activeEffect = this.parent\n      // 返回上个 shouldTrack\n      shouldTrack = lastShouldTrack\n      // 情况本次的 parent 指向\n      this.parent = undefined\n    }\n  }\n}\n```\n\n大致看一眼，我们可以看到在 ReactiveEffect 中是执行了 this.fn() 的，这也就解释了 effect 中的回调函数 fn 是在这里被调用的。接下来详细研究一下这个 ReactiveEffect。\n\n但这段代码看起来不是很长，但涉及了好几个概念，我们来一个个看。\n##### 1. parent 的作用\n为什么 ReactiveEffect 要设计一个 parent 这样一个看似没啥用的变量指针来存储上一次的 activeEffect 呢？如果改成下面这样不是更简单吗？\n\n```typescript\nrun() {\n  if (!this.active) {\n    return this.fn();\n  }\n  // 初始化\n  shouldTrack = true;\n  activeEffect = this;\n\n  const result = this.fn();\n  \n  // 重置\n  shouldTrack = false;\n  \n  return result;\n}\n```\n\n其实对于下面这样的代码：\n\n```typescript\nconst state = reactive({a: 1})\n\neffect(() => console.log(state.a))\n\nstate.a++\n```\n\neffect 函数内调用 ReactiveEffect 实例的 run 函数。run 函数执行的时候，把 activeEffect 指向 this。然后执行 effect 传入的 fn 函数，函数在执行的时候访问了 state.a 触发了 getter 钩子。回顾一下上一节的内容，getter 的时候有触发添加 activeEffect 的功能：\n\n```typescript\n// 把 activeEffect 添加到 dep 中\ndep.add(activeEffect!)\n```\n\n而 activeEffect 正是这里的 this。当执行 state.a++ 时，访问了state.a 的 setter。上一节也说了，setter 的执行会调用 effect.run 函数：\n\n```typescript\n// triggerEffects\neffect.run();\n```\n\n所以又会执行 fn。\n\n到这里看似很完美，那么我们再来看另外一个例子🌰：\n\n```typescript\nconst state = reactive({\n  a: 1,\n  b: 2\n});\n\n// ef1\neffect(() => {\n  // ef2\n  effect(() => console.log(`b: ${state.b}`))\n  console.log(`a: ${state.a}`)\n});\n```\n\nstate.a ++\n按照上面的逻辑，在第一次 effect 执行的时候，activeEffect = ef1 然后再执行内部的 effect， 此时 activeEffect = ef2 然后 ef2 执行完成回到 ef1 函数体内，此时再访问 state.a 触发对 a 的依赖收集，但收集到的却是 ef2。那么最终打印的是：\n\n```\nb: 2\na: 1\nb: 2\n```\n\n很明显不符合我们的要求，我们期望的是输出：\n\n```\nb: 2\na: 1\nb: 2\na: 2\n```\n\n这时候 parent 就排上用场了，当为 effect 加上 parent 属性后，我们再来捋一下整体的流程。\n\n执行 ef1 的时候，activeEffect 指向 ef1，此时 parent 是 undefined。\n执行 ef1 fn 遇到了 ef2，调用 ef2 此时 ef2 的 parent 指向 ef1， activeEffect 指向 ef2。然后执行 ef2 的 fn。\nef2 的 fn 执行的时候，访问了 state.b 依赖收集 ef2。执行完成后，activeEffect = this.parent 又把 activeEffect 指向了 ef1。\n返回 ef1 的 fn 体继续执行，此时访问 state.a 依赖收集 activeEffect 为 ef1。\n触发 state.a 的 setter，调用 a 的副作用 ef1，依次打印……\n到这里相信各位小伙伴已经清楚了 parent 的作用了，那就是通过 parent 这个标记，来回切换 activeEffect 的指向，从而完成对嵌套 effect 的正确的依赖收集。\n\n##### 2. 依赖清理\n在说依赖清理之前，再来看一个有意思的例子：\n\n```typescript\nconst state = reactive({\n  a: 1,\n  show: true\n});\n\neffect(() => {\n  if (state.show) {\n    console.log(`a: ${state.a}`)\n  }\n});\n\nstate.a ++\n\nsetTimeout(() => {\n  state.show = false\n  state.a ++\n}, 1000)\n```\n\n\n上面的例子中，我们在 effect 中完成了对 show 和 a 的依赖收集，然后 1s 后，我们改变了 show 的状态为 false。此时 effect 内的函数中的 console.log 将永远不会执行，然后再触发 state.a++ 的动作，访问 a 的 getter，如果没有依赖清理，那么按照之前的做法，测试也会触发 effect.fn 的执行，但这个执行其实没意义的，因为 a 已经没有被使用了，是一个永远不会被访问到的变量，造成了性能浪费。所以我们需要删除 a 的副作用函数，让它不要执行。\n\n接下来一起来看看 Vue 是怎么做的吧！这里涉及到的内容有点多，我们先一个个解释，首先补习一下关于 js 的一些操作符的基础知识。\n\n###### 1. 左移（<<）\n\n左移操作符 (<<) 将第一个操作数转换成 2 进制后向左移动指定位数，左边超出的位数将会被清除，右边将会补零。\n\n```typescript\nconst a = 1;         // 00000000000000000000000000000001\nconst b = 1;       \n\nconsole.log(a << b); // 00000000000000000000000000000010\n// expected output: 2\n```\n\n###### 2. 位或操作（|）\n\n位或操作符（|）， 如果两位之一为 1，则设置每位为 1。\n\n```typescript\nconst a = 5;        // 00000000000000000000000000000101\nconst b = 3;        // 00000000000000000000000000000011\n\nconsole.log(a | b); // 00000000000000000000000000000111\n// expected output: 7\n```\n\n###### 3. 按位与（&）\n\n按位与运算符 (&) 在两个操作数对应的二进位都为 1 时，该位的结果值才为 1，否则为 0。\n\n```typescript\nconst a = 5;        // 00000000000000000000000000000101\nconst b = 3;        // 00000000000000000000000000000011\n\nconsole.log(a & b); // 00000000000000000000000000000001\n// expected output: 1\n```\n\n###### 4. 按位非（~）\n\n按位非运算符（~），反转操作数的位。\n\n```typescript\nconst a = 5;     // 00000000000000000000000000000101\nconst b = -3;    // 11111111111111111111111111111101\n\nconsole.log(~a); // 11111111111111111111111111111010\n// expected output: -6\n\nconsole.log(~b); // 00000000000000000000000000000010\n// expected output: 2\n```\n\n有了这些基础的知识点后，再来认识几个变量。\n\n###### 1. effectTrackDepth\n\n用于记录位于响应上下文中的 effect 嵌套层次数，默认值为 0。\n\n```typescript\n// effectTrackDepth = 0\neffect(() => {\n  // effectTrackDepth = 1\n  effect(() => {})\n})\n```\n\n###### 2. trackOpBit\n\n二进制位，每一位用于标识当前 effect 嵌套层级的依赖收集的启用状态。默认值为 1，即 00000000000000000000000000000001。\n\n###### 3. maxMarkerBits\n\n表示最大的 effect 嵌套的层次数，最大值为 30。\n\n好了，搞懂了这些操作符之后，我们来看看 Vue 的依赖清理是如何实现的，先来看不超过 maxMarkerBits 层级数的嵌套 effect 的依赖收集的过程，还以上面那个 demo 作为示例：\n\n```typescript\nconst state = reactive({\n  a: 1,\n  show: true\n});\n\neffect(() => {\n  if (state.show) {\n    console.log(`a: ${state.a}`)\n  }\n});\n\nstate.a ++\n\nsetTimeout(() => {\n  state.show = false\n  state.a ++\n}, 1000)\n```\n\nStep 1：run 函数执行的时候，trackOpBit = 1 << ++effectTrackDepth 这个语句执行完成后，得到 effectTrackDepth = 1；trackOpBit.toString(2) = 00000000000000000000000000000010。\n\nStep 2：因为 effectTrackDepth < maxMarkerBits ，所以执行 initDepMarkers 函数，因为这里的 deps 在初始化的时候还是个空数组，所以此函数未执行。\n\n```typescript\nexport const initDepMarkers = ({ deps }) => {\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].w |= trackOpBit // set was tracked\n    }\n  }\n}\n```\n\nStep 3：执行 this.fn 函数，先访问 state.show，触发了 trackEffects。\n\n```typescript\nexport function trackEffects(dep) {\n  let shouldTrack = false\n  if (effectTrackDepth <= maxMarkerBits) {\n    // 如果本轮副作用函数执行过程中已经访问并收集过，则不用再收集该依赖\n    if (!newTracked(dep)) {\n      // 设置 dep.n\n      dep.n |= trackOpBit\n      shouldTrack = !wasTracked(dep)\n    }\n  } else {\n    // Full cleanup mode.\n    shouldTrack = !dep.has(activeEffect!)\n  }\n\n  if (shouldTrack) {\n    dep.add(activeEffect!)\n    activeEffect!.deps.push(dep)\n  }\n}\n```\n\n这里需要额外了解 2 个函数：wasTracked（已经被收集过，缩写是 w） 和 newTracked（新收集的依赖，缩写是 n）。\n\n```typescript\nexport const wasTracked = dep => (dep.w & trackOpBit) > 0\n\nexport const newTracked = dep => (dep.n & trackOpBit) > 0\n```\n\n进入 trackEffects 时，因为此时还没有为 dep.n 进行或运算赋值，所以 state.show 的 newTracked = false，wasTracked = false。\n\n所以计算得到 shouldTrack = true，最后将 activeEffect 收集进入 dep 中，同时执行了 activeEffect.deps.push(dep) 将 dep 存入了 activeEffect 的 deps 中。然后访问 state.a 重复上述操作。上述步骤执行完成后的 activeEffect.deps 如下：\n\n```\n[\n  {\"w\":0,\"n\": 00000000000000000000000000000010, [effect]},\n  {\"w\":0,\"n\": 00000000000000000000000000000010, [effect]}\n]\n```\n\nStep 4：最后执行 finalizeDepMarkers 函数，根据第 3 步，此时 effect 中的 deps 包含了 2 个 dep，分别是 state.show 和 state.a。 finalizeDepMarkers 函数内部执行了 wasTracked（已经被收集过，缩写是 w） 和 newTracked（新收集的依赖，缩写是 n） 函数，因为 dep.w = 0 所以 wasTracked = false。\n\n```typescript\nexport const finalizeDepMarkers = (effect: ReactiveEffect) => {\n  const { deps } = effect\n  if (deps.length) {\n    let ptr = 0\n    for (let i = 0; i < deps.length; i++) {\n      const dep = deps[i]\n      if (wasTracked(dep) && !newTracked(dep)) {\n        dep.delete(effect)\n      } else {\n        // 缩小依赖集合的大小\n        deps[ptr++] = dep\n      }\n      // clear bits\n      dep.w &= ~trackOpBit\n      dep.n &= ~trackOpBit\n    }\n    deps.length = ptr\n  }\n}\n```\n\n因为 wasTracked = false，因此 finalizeDepMarkers 处理后仍然将副作用函数保留在这两个属性对应的依赖集合中，同时把 dep.w 和 dep.n 重置回 0。\n\n```\n[{\"w\":0, \"n\":0, [effect]},{\"w\":0, \"n\":0, [effect]}]\n```\n\nStep 5：当执行 state.show = false 的时候，触发 effect.run 的执行，此时执行 initDepMarkers 时，因为已经存在了 dep，所以先访问 state.show。\n\n当执行到 trackEffects 时，此时的 newTracked = false，执行逻辑和之前一致。只不过因为 state.show = false，所以没有触发 state.a 的这一部分逻辑的处理，最后得到的结果为：\n\n```\n[\n  {\n    \"w\": 00000000000000000000000000000010,\n    \"n\": 00000000000000000000000000000010,\n    [effect]\n  },\n  {\n    \"w\": 00000000000000000000000000000010, \n    \"n\": 0,\n    [effect]\n  }\n]\n```\n\nStep 6：最后执行 finalizeDepMarkers 时，如下。\n\n```\nif (wasTracked(dep) && !newTracked(dep)) {\n  dep.delete(effect)\n}\n```\n\n因为这里的 state.a 的 wasTracked = true 且 newTracked 为 false，所以执行了 dep.delete(effect) 将 effect 从 dep 中踢掉。\n\nStep 7：1s 后执行 state.a++ 的操作，由于 state.a 中没有 effect 了，所以不会执行副作用函数。\n\n##### 总结： Vue 在组件的 effect 执行之前，会根据 dep 的收集标记位 w 和 n 来进行清理依赖，删除之前 state.a 收集的 effect 依赖。这样当我们修改 state.a 时，由于已经没有依赖了，就不会触发 effect 重新执行。\n\n另外，为了更容易帮助小伙伴们理解上述的流程，我也精心制作了一个动画演示上述流程和过程：\n\n依赖清理过程.gif\n\n注意，当 effectTrackDepth 大于 30 时，会调用 cleanup 来清理依赖，其实 cleanup 的原理就是依赖收集前全部删除所有的 dep，依赖收集时再一个个加进来，这个性能其实是比较差的，所以 Vue 3.2 改成了通过二进制标记位的方式来选择性删除和添加，提升了性能。关于这部分更多的细节，可以参考这个PR。\n\n#### 总结\n到这里，我们基本上讲完了 Vue 3 的响应式原理基础，如果有小伙伴了解 Vue 2 的响应式原理，应该清楚 Vue2 的响应式原理可以理解成如下一幅图：\n\nimage.png\n\n在 Vue 2 中，Watcher 就是依赖，有专门针对组件渲染的 render watcher。\n\n依赖收集：组件在 render 的时候会访问模板中的数据，触发 getter 把 watcher 作为依赖收集。\n触发渲染：当修改数据时，会触发 setter，通知 watcher 更新，进而触发了组件的重新渲染。\n相应地，在 Vue 3 中的响应式流程如下：\n\nimage.png\n\n可以看到，Vue 3 相对于 Vue 2 的响应式差别不大，主要就是劫持数据的方式改成用 Proxy 实现，以及收集的依赖由 watcher 实例变成了组件副作用函数 effect。另外，值得一提的是 Vue 3 在响应式设计上又多考虑了层级嵌套的依赖收集问题和不必要的依赖清理问题。","slug":"technical-disclosure-of-vue3/effect","published":0,"date":"2023-08-12T07:53:19.989Z","updated":"2023-08-12T07:53:19.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzsloko000ysovc5td00ul0","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>上一小节我们说到了 Reactive 会在 proxy getter 的时候收集 effect 依赖，在 proxy setter 的时候触发 effect 的执行。那么 effect 副作用函数到底是个什么？以及是如何被收集起来的呢？</p>\n<h4 id=\"effect\"><a href=\"#effect\" class=\"headerlink\" title=\"effect\"></a>effect</h4><p>找到源码中关于 effect 部分的定义：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">effect</span> (fn, options) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果 fn 已经是一个 effect 函数了，则指向原始函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fn.<span class=\"property\">effect</span>) &#123;</span><br><span class=\"line\">    fn = fn.<span class=\"property\">effect</span>.<span class=\"property\">fn</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 构造 _effect 实例</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _effect = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(fn)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// options 初始化</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">extend</span>(_effect, options)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options.<span class=\"property\">scope</span>) <span class=\"title function_\">recordEffectScope</span>(_effect, options.<span class=\"property\">scope</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 如有 options 或者 不是懒加载，执行 _effect.run()</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!options || !options.<span class=\"property\">lazy</span>) &#123;</span><br><span class=\"line\">    _effect.<span class=\"title function_\">run</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 返回 _effect.run</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> runner = _effect.<span class=\"property\">run</span>.<span class=\"title function_\">bind</span>(_effect)</span><br><span class=\"line\">  runner.<span class=\"property\">effect</span> = _effect</span><br><span class=\"line\">  <span class=\"keyword\">return</span> runner</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个 effect 函数内部核心是通过 ReactiveEffect 类创建了一个 _effect 实例，从代码来看，_effect 上包含了一个 run 函数。默认 effect 是没有传入 options 参数的，所以这里直接执行了 _effect.run()。我们知道，fn 函数是在 effect 函数中的一个入参，比如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> state = <span class=\"title function_\">reactive</span>(&#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(state.<span class=\"property\">a</span>))</span><br></pre></td></tr></table></figure>\n\n<p>根据上一小节，我们知道因为这里我们访问了 state.a 所以收集了副作用函数，但是需要知道的是这里的 effect 传入的是一个 fn，所以要想访问 state.a 那这个 fn 必须要执行才可以。那是在哪里执行的呢？接下来看一下 ReactiveEffect 的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于记录位于响应上下文中的effect嵌套层次数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> effectTrackDepth = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">// 二进制位，每一位用于标识当前effect嵌套层级的依赖收集的启用状态</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> left trackOpBit = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">// 表示最大标记的位数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> maxMarkerBits = <span class=\"number\">30</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当前活跃的 effect</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> activeEffect;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReactiveEffect</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 用于标识副作用函数是否位于响应式上下文中被执行</span></span><br><span class=\"line\">  active = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"comment\">// 副作用函数持有它所在的所有依赖集合的引用，用于从这些依赖集合删除自身</span></span><br><span class=\"line\">  deps = []</span><br><span class=\"line\">  <span class=\"comment\">// 指针为，用于嵌套 effect 执行后动态切换 activeEffect</span></span><br><span class=\"line\">  parent = <span class=\"literal\">undefined</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"title function_\">run</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 若当前 ReactiveEffect 对象脱离响应式上下文</span></span><br><span class=\"line\">    <span class=\"comment\">// 那么其对应的副作用函数被执行时不会再收集依赖</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"variable language_\">this</span>.<span class=\"property\">active</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">fn</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 缓存是否需要收集依赖</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> lastShouldTrack = shouldTrack</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 保存上一个 activeEffect 到当前的 parent 上</span></span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">parent</span> = activeEffect</span><br><span class=\"line\">      <span class=\"comment\">// activeEffect 指向当前的 effect</span></span><br><span class=\"line\">      activeEffect = <span class=\"variable language_\">this</span></span><br><span class=\"line\">      <span class=\"comment\">// shouldTrack 置成 true</span></span><br><span class=\"line\">      shouldTrack = <span class=\"literal\">true</span></span><br><span class=\"line\">      <span class=\"comment\">// 左移操作符 &lt;&lt; 将第一个操作数向左移动指定位数</span></span><br><span class=\"line\">      <span class=\"comment\">// 左边超出的位数将会被清除，右边将会补零。</span></span><br><span class=\"line\">      <span class=\"comment\">// trackOpBit 是基于 1 左移 effectTrackDepth 位</span></span><br><span class=\"line\">      trackOpBit = <span class=\"number\">1</span> &lt;&lt; ++effectTrackDepth</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// 如果未超过最大嵌套层数，则执行 initDepMarkers</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (effectTrackDepth &lt;= maxMarkerBits) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">initDepMarkers</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"title function_\">cleanupEffect</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 这里执行了 fn</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">fn</span>()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (effectTrackDepth &lt;= maxMarkerBits) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用于对曾经跟踪过，但本次副作用函数执行时没有跟踪的依赖采取删除操作。</span></span><br><span class=\"line\">        <span class=\"comment\">// 新跟踪的 和 本轮跟踪过的都会被保留</span></span><br><span class=\"line\">        <span class=\"title function_\">finalizeDepMarkers</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// &lt;&lt; --effectTrackDepth 右移动 effectTrackDepth 位</span></span><br><span class=\"line\">      trackOpBit = <span class=\"number\">1</span> &lt;&lt; --effectTrackDepth</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// 返回上个 activeEffect</span></span><br><span class=\"line\">      activeEffect = <span class=\"variable language_\">this</span>.<span class=\"property\">parent</span></span><br><span class=\"line\">      <span class=\"comment\">// 返回上个 shouldTrack</span></span><br><span class=\"line\">      shouldTrack = lastShouldTrack</span><br><span class=\"line\">      <span class=\"comment\">// 情况本次的 parent 指向</span></span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">parent</span> = <span class=\"literal\">undefined</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大致看一眼，我们可以看到在 ReactiveEffect 中是执行了 this.fn() 的，这也就解释了 effect 中的回调函数 fn 是在这里被调用的。接下来详细研究一下这个 ReactiveEffect。</p>\n<p>但这段代码看起来不是很长，但涉及了好几个概念，我们来一个个看。</p>\n<h5 id=\"1-parent-的作用\"><a href=\"#1-parent-的作用\" class=\"headerlink\" title=\"1. parent 的作用\"></a>1. parent 的作用</h5><p>为什么 ReactiveEffect 要设计一个 parent 这样一个看似没啥用的变量指针来存储上一次的 activeEffect 呢？如果改成下面这样不是更简单吗？</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">run</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"variable language_\">this</span>.<span class=\"property\">active</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">fn</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">  shouldTrack = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  activeEffect = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"variable language_\">this</span>.<span class=\"title function_\">fn</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 重置</span></span><br><span class=\"line\">  shouldTrack = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实对于下面这样的代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> state = <span class=\"title function_\">reactive</span>(&#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(state.<span class=\"property\">a</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">state.<span class=\"property\">a</span>++</span><br></pre></td></tr></table></figure>\n\n<p>effect 函数内调用 ReactiveEffect 实例的 run 函数。run 函数执行的时候，把 activeEffect 指向 this。然后执行 effect 传入的 fn 函数，函数在执行的时候访问了 state.a 触发了 getter 钩子。回顾一下上一节的内容，getter 的时候有触发添加 activeEffect 的功能：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 把 activeEffect 添加到 dep 中</span></span><br><span class=\"line\">dep.<span class=\"title function_\">add</span>(activeEffect!)</span><br></pre></td></tr></table></figure>\n\n<p>而 activeEffect 正是这里的 this。当执行 state.a++ 时，访问了state.a 的 setter。上一节也说了，setter 的执行会调用 effect.run 函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// triggerEffects</span></span><br><span class=\"line\">effect.<span class=\"title function_\">run</span>();</span><br></pre></td></tr></table></figure>\n\n<p>所以又会执行 fn。</p>\n<p>到这里看似很完美，那么我们再来看另外一个例子🌰：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> state = <span class=\"title function_\">reactive</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ef1</span></span><br><span class=\"line\"><span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ef2</span></span><br><span class=\"line\">  <span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`b: <span class=\"subst\">$&#123;state.b&#125;</span>`</span>))</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`a: <span class=\"subst\">$&#123;state.a&#125;</span>`</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>state.a ++<br>按照上面的逻辑，在第一次 effect 执行的时候，activeEffect &#x3D; ef1 然后再执行内部的 effect， 此时 activeEffect &#x3D; ef2 然后 ef2 执行完成回到 ef1 函数体内，此时再访问 state.a 触发对 a 的依赖收集，但收集到的却是 ef2。那么最终打印的是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">b: 2</span><br><span class=\"line\">a: 1</span><br><span class=\"line\">b: 2</span><br></pre></td></tr></table></figure>\n\n<p>很明显不符合我们的要求，我们期望的是输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">b: 2</span><br><span class=\"line\">a: 1</span><br><span class=\"line\">b: 2</span><br><span class=\"line\">a: 2</span><br></pre></td></tr></table></figure>\n\n<p>这时候 parent 就排上用场了，当为 effect 加上 parent 属性后，我们再来捋一下整体的流程。</p>\n<p>执行 ef1 的时候，activeEffect 指向 ef1，此时 parent 是 undefined。<br>执行 ef1 fn 遇到了 ef2，调用 ef2 此时 ef2 的 parent 指向 ef1， activeEffect 指向 ef2。然后执行 ef2 的 fn。<br>ef2 的 fn 执行的时候，访问了 state.b 依赖收集 ef2。执行完成后，activeEffect &#x3D; this.parent 又把 activeEffect 指向了 ef1。<br>返回 ef1 的 fn 体继续执行，此时访问 state.a 依赖收集 activeEffect 为 ef1。<br>触发 state.a 的 setter，调用 a 的副作用 ef1，依次打印……<br>到这里相信各位小伙伴已经清楚了 parent 的作用了，那就是通过 parent 这个标记，来回切换 activeEffect 的指向，从而完成对嵌套 effect 的正确的依赖收集。</p>\n<h5 id=\"2-依赖清理\"><a href=\"#2-依赖清理\" class=\"headerlink\" title=\"2. 依赖清理\"></a>2. 依赖清理</h5><p>在说依赖清理之前，再来看一个有意思的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> state = <span class=\"title function_\">reactive</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"attr\">show</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (state.<span class=\"property\">show</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`a: <span class=\"subst\">$&#123;state.a&#125;</span>`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">state.<span class=\"property\">a</span> ++</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  state.<span class=\"property\">show</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">  state.<span class=\"property\">a</span> ++</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure>\n\n\n<p>上面的例子中，我们在 effect 中完成了对 show 和 a 的依赖收集，然后 1s 后，我们改变了 show 的状态为 false。此时 effect 内的函数中的 console.log 将永远不会执行，然后再触发 state.a++ 的动作，访问 a 的 getter，如果没有依赖清理，那么按照之前的做法，测试也会触发 effect.fn 的执行，但这个执行其实没意义的，因为 a 已经没有被使用了，是一个永远不会被访问到的变量，造成了性能浪费。所以我们需要删除 a 的副作用函数，让它不要执行。</p>\n<p>接下来一起来看看 Vue 是怎么做的吧！这里涉及到的内容有点多，我们先一个个解释，首先补习一下关于 js 的一些操作符的基础知识。</p>\n<h6 id=\"1-左移（\"><a href=\"#1-左移（\" class=\"headerlink\" title=\"1. 左移（&lt;&lt;）\"></a>1. 左移（&lt;&lt;）</h6><p>左移操作符 (&lt;&lt;) 将第一个操作数转换成 2 进制后向左移动指定位数，左边超出的位数将会被清除，右边将会补零。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">1</span>;         <span class=\"comment\">// 00000000000000000000000000000001</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"number\">1</span>;       </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a &lt;&lt; b); <span class=\"comment\">// 00000000000000000000000000000010</span></span><br><span class=\"line\"><span class=\"comment\">// expected output: 2</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-位或操作（-）\"><a href=\"#2-位或操作（-）\" class=\"headerlink\" title=\"2. 位或操作（|）\"></a>2. 位或操作（|）</h6><p>位或操作符（|）， 如果两位之一为 1，则设置每位为 1。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">5</span>;        <span class=\"comment\">// 00000000000000000000000000000101</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"number\">3</span>;        <span class=\"comment\">// 00000000000000000000000000000011</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a | b); <span class=\"comment\">// 00000000000000000000000000000111</span></span><br><span class=\"line\"><span class=\"comment\">// expected output: 7</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"3-按位与（-）\"><a href=\"#3-按位与（-）\" class=\"headerlink\" title=\"3. 按位与（&amp;）\"></a>3. 按位与（&amp;）</h6><p>按位与运算符 (&amp;) 在两个操作数对应的二进位都为 1 时，该位的结果值才为 1，否则为 0。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">5</span>;        <span class=\"comment\">// 00000000000000000000000000000101</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"number\">3</span>;        <span class=\"comment\">// 00000000000000000000000000000011</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a &amp; b); <span class=\"comment\">// 00000000000000000000000000000001</span></span><br><span class=\"line\"><span class=\"comment\">// expected output: 1</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"4-按位非（-）\"><a href=\"#4-按位非（-）\" class=\"headerlink\" title=\"4. 按位非（~）\"></a>4. 按位非（~）</h6><p>按位非运算符（~），反转操作数的位。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">5</span>;     <span class=\"comment\">// 00000000000000000000000000000101</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = -<span class=\"number\">3</span>;    <span class=\"comment\">// 11111111111111111111111111111101</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(~a); <span class=\"comment\">// 11111111111111111111111111111010</span></span><br><span class=\"line\"><span class=\"comment\">// expected output: -6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(~b); <span class=\"comment\">// 00000000000000000000000000000010</span></span><br><span class=\"line\"><span class=\"comment\">// expected output: 2</span></span><br></pre></td></tr></table></figure>\n\n<p>有了这些基础的知识点后，再来认识几个变量。</p>\n<h6 id=\"1-effectTrackDepth\"><a href=\"#1-effectTrackDepth\" class=\"headerlink\" title=\"1. effectTrackDepth\"></a>1. effectTrackDepth</h6><p>用于记录位于响应上下文中的 effect 嵌套层次数，默认值为 0。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// effectTrackDepth = 0</span></span><br><span class=\"line\"><span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// effectTrackDepth = 1</span></span><br><span class=\"line\">  <span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> &#123;&#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-trackOpBit\"><a href=\"#2-trackOpBit\" class=\"headerlink\" title=\"2. trackOpBit\"></a>2. trackOpBit</h6><p>二进制位，每一位用于标识当前 effect 嵌套层级的依赖收集的启用状态。默认值为 1，即 00000000000000000000000000000001。</p>\n<h6 id=\"3-maxMarkerBits\"><a href=\"#3-maxMarkerBits\" class=\"headerlink\" title=\"3. maxMarkerBits\"></a>3. maxMarkerBits</h6><p>表示最大的 effect 嵌套的层次数，最大值为 30。</p>\n<p>好了，搞懂了这些操作符之后，我们来看看 Vue 的依赖清理是如何实现的，先来看不超过 maxMarkerBits 层级数的嵌套 effect 的依赖收集的过程，还以上面那个 demo 作为示例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> state = <span class=\"title function_\">reactive</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"attr\">show</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (state.<span class=\"property\">show</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`a: <span class=\"subst\">$&#123;state.a&#125;</span>`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">state.<span class=\"property\">a</span> ++</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  state.<span class=\"property\">show</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">  state.<span class=\"property\">a</span> ++</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure>\n\n<p>Step 1：run 函数执行的时候，trackOpBit &#x3D; 1 &lt;&lt; ++effectTrackDepth 这个语句执行完成后，得到 effectTrackDepth &#x3D; 1；trackOpBit.toString(2) &#x3D; 00000000000000000000000000000010。</p>\n<p>Step 2：因为 effectTrackDepth &lt; maxMarkerBits ，所以执行 initDepMarkers 函数，因为这里的 deps 在初始化的时候还是个空数组，所以此函数未执行。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">initDepMarkers</span> = (<span class=\"params\">&#123; deps &#125;</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (deps.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; deps.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">      deps[i].<span class=\"property\">w</span> |= trackOpBit <span class=\"comment\">// set was tracked</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Step 3：执行 this.fn 函数，先访问 state.show，触发了 trackEffects。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">trackEffects</span>(<span class=\"params\">dep</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> shouldTrack = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (effectTrackDepth &lt;= maxMarkerBits) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果本轮副作用函数执行过程中已经访问并收集过，则不用再收集该依赖</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"title function_\">newTracked</span>(dep)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 设置 dep.n</span></span><br><span class=\"line\">      dep.<span class=\"property\">n</span> |= trackOpBit</span><br><span class=\"line\">      shouldTrack = !<span class=\"title function_\">wasTracked</span>(dep)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Full cleanup mode.</span></span><br><span class=\"line\">    shouldTrack = !dep.<span class=\"title function_\">has</span>(activeEffect!)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldTrack) &#123;</span><br><span class=\"line\">    dep.<span class=\"title function_\">add</span>(activeEffect!)</span><br><span class=\"line\">    activeEffect!.<span class=\"property\">deps</span>.<span class=\"title function_\">push</span>(dep)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要额外了解 2 个函数：wasTracked（已经被收集过，缩写是 w） 和 newTracked（新收集的依赖，缩写是 n）。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">wasTracked</span> = dep =&gt; (dep.<span class=\"property\">w</span> &amp; trackOpBit) &gt; <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">newTracked</span> = dep =&gt; (dep.<span class=\"property\">n</span> &amp; trackOpBit) &gt; <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>进入 trackEffects 时，因为此时还没有为 dep.n 进行或运算赋值，所以 state.show 的 newTracked &#x3D; false，wasTracked &#x3D; false。</p>\n<p>所以计算得到 shouldTrack &#x3D; true，最后将 activeEffect 收集进入 dep 中，同时执行了 activeEffect.deps.push(dep) 将 dep 存入了 activeEffect 的 deps 中。然后访问 state.a 重复上述操作。上述步骤执行完成后的 activeEffect.deps 如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  &#123;&quot;w&quot;:0,&quot;n&quot;: 00000000000000000000000000000010, [effect]&#125;,</span><br><span class=\"line\">  &#123;&quot;w&quot;:0,&quot;n&quot;: 00000000000000000000000000000010, [effect]&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>Step 4：最后执行 finalizeDepMarkers 函数，根据第 3 步，此时 effect 中的 deps 包含了 2 个 dep，分别是 state.show 和 state.a。 finalizeDepMarkers 函数内部执行了 wasTracked（已经被收集过，缩写是 w） 和 newTracked（新收集的依赖，缩写是 n） 函数，因为 dep.w &#x3D; 0 所以 wasTracked &#x3D; false。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">finalizeDepMarkers</span> = (<span class=\"params\">effect: ReactiveEffect</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; deps &#125; = effect</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (deps.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ptr = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; deps.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> dep = deps[i]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"title function_\">wasTracked</span>(dep) &amp;&amp; !<span class=\"title function_\">newTracked</span>(dep)) &#123;</span><br><span class=\"line\">        dep.<span class=\"title function_\">delete</span>(effect)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 缩小依赖集合的大小</span></span><br><span class=\"line\">        deps[ptr++] = dep</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// clear bits</span></span><br><span class=\"line\">      dep.<span class=\"property\">w</span> &amp;= ~trackOpBit</span><br><span class=\"line\">      dep.<span class=\"property\">n</span> &amp;= ~trackOpBit</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    deps.<span class=\"property\">length</span> = ptr</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为 wasTracked &#x3D; false，因此 finalizeDepMarkers 处理后仍然将副作用函数保留在这两个属性对应的依赖集合中，同时把 dep.w 和 dep.n 重置回 0。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[&#123;&quot;w&quot;:0, &quot;n&quot;:0, [effect]&#125;,&#123;&quot;w&quot;:0, &quot;n&quot;:0, [effect]&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>Step 5：当执行 state.show &#x3D; false 的时候，触发 effect.run 的执行，此时执行 initDepMarkers 时，因为已经存在了 dep，所以先访问 state.show。</p>\n<p>当执行到 trackEffects 时，此时的 newTracked &#x3D; false，执行逻辑和之前一致。只不过因为 state.show &#x3D; false，所以没有触发 state.a 的这一部分逻辑的处理，最后得到的结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    &quot;w&quot;: 00000000000000000000000000000010,</span><br><span class=\"line\">    &quot;n&quot;: 00000000000000000000000000000010,</span><br><span class=\"line\">    [effect]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    &quot;w&quot;: 00000000000000000000000000000010, </span><br><span class=\"line\">    &quot;n&quot;: 0,</span><br><span class=\"line\">    [effect]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>Step 6：最后执行 finalizeDepMarkers 时，如下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (wasTracked(dep) &amp;&amp; !newTracked(dep)) &#123;</span><br><span class=\"line\">  dep.delete(effect)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为这里的 state.a 的 wasTracked &#x3D; true 且 newTracked 为 false，所以执行了 dep.delete(effect) 将 effect 从 dep 中踢掉。</p>\n<p>Step 7：1s 后执行 state.a++ 的操作，由于 state.a 中没有 effect 了，所以不会执行副作用函数。</p>\n<h5 id=\"总结：-Vue-在组件的-effect-执行之前，会根据-dep-的收集标记位-w-和-n-来进行清理依赖，删除之前-state-a-收集的-effect-依赖。这样当我们修改-state-a-时，由于已经没有依赖了，就不会触发-effect-重新执行。\"><a href=\"#总结：-Vue-在组件的-effect-执行之前，会根据-dep-的收集标记位-w-和-n-来进行清理依赖，删除之前-state-a-收集的-effect-依赖。这样当我们修改-state-a-时，由于已经没有依赖了，就不会触发-effect-重新执行。\" class=\"headerlink\" title=\"总结： Vue 在组件的 effect 执行之前，会根据 dep 的收集标记位 w 和 n 来进行清理依赖，删除之前 state.a 收集的 effect 依赖。这样当我们修改 state.a 时，由于已经没有依赖了，就不会触发 effect 重新执行。\"></a>总结： Vue 在组件的 effect 执行之前，会根据 dep 的收集标记位 w 和 n 来进行清理依赖，删除之前 state.a 收集的 effect 依赖。这样当我们修改 state.a 时，由于已经没有依赖了，就不会触发 effect 重新执行。</h5><p>另外，为了更容易帮助小伙伴们理解上述的流程，我也精心制作了一个动画演示上述流程和过程：</p>\n<p>依赖清理过程.gif</p>\n<p>注意，当 effectTrackDepth 大于 30 时，会调用 cleanup 来清理依赖，其实 cleanup 的原理就是依赖收集前全部删除所有的 dep，依赖收集时再一个个加进来，这个性能其实是比较差的，所以 Vue 3.2 改成了通过二进制标记位的方式来选择性删除和添加，提升了性能。关于这部分更多的细节，可以参考这个PR。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>到这里，我们基本上讲完了 Vue 3 的响应式原理基础，如果有小伙伴了解 Vue 2 的响应式原理，应该清楚 Vue2 的响应式原理可以理解成如下一幅图：</p>\n<p>image.png</p>\n<p>在 Vue 2 中，Watcher 就是依赖，有专门针对组件渲染的 render watcher。</p>\n<p>依赖收集：组件在 render 的时候会访问模板中的数据，触发 getter 把 watcher 作为依赖收集。<br>触发渲染：当修改数据时，会触发 setter，通知 watcher 更新，进而触发了组件的重新渲染。<br>相应地，在 Vue 3 中的响应式流程如下：</p>\n<p>image.png</p>\n<p>可以看到，Vue 3 相对于 Vue 2 的响应式差别不大，主要就是劫持数据的方式改成用 Proxy 实现，以及收集的依赖由 watcher 实例变成了组件副作用函数 effect。另外，值得一提的是 Vue 3 在响应式设计上又多考虑了层级嵌套的依赖收集问题和不必要的依赖清理问题。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>上一小节我们说到了 Reactive 会在 proxy getter 的时候收集 effect 依赖，在 proxy setter 的时候触发 effect 的执行。那么 effect 副作用函数到底是个什么？以及是如何被收集起来的呢？</p>\n<h4 id=\"effect\"><a href=\"#effect\" class=\"headerlink\" title=\"effect\"></a>effect</h4><p>找到源码中关于 effect 部分的定义：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">effect</span> (fn, options) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果 fn 已经是一个 effect 函数了，则指向原始函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fn.<span class=\"property\">effect</span>) &#123;</span><br><span class=\"line\">    fn = fn.<span class=\"property\">effect</span>.<span class=\"property\">fn</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 构造 _effect 实例</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _effect = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(fn)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// options 初始化</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">extend</span>(_effect, options)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options.<span class=\"property\">scope</span>) <span class=\"title function_\">recordEffectScope</span>(_effect, options.<span class=\"property\">scope</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 如有 options 或者 不是懒加载，执行 _effect.run()</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!options || !options.<span class=\"property\">lazy</span>) &#123;</span><br><span class=\"line\">    _effect.<span class=\"title function_\">run</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 返回 _effect.run</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> runner = _effect.<span class=\"property\">run</span>.<span class=\"title function_\">bind</span>(_effect)</span><br><span class=\"line\">  runner.<span class=\"property\">effect</span> = _effect</span><br><span class=\"line\">  <span class=\"keyword\">return</span> runner</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个 effect 函数内部核心是通过 ReactiveEffect 类创建了一个 _effect 实例，从代码来看，_effect 上包含了一个 run 函数。默认 effect 是没有传入 options 参数的，所以这里直接执行了 _effect.run()。我们知道，fn 函数是在 effect 函数中的一个入参，比如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> state = <span class=\"title function_\">reactive</span>(&#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(state.<span class=\"property\">a</span>))</span><br></pre></td></tr></table></figure>\n\n<p>根据上一小节，我们知道因为这里我们访问了 state.a 所以收集了副作用函数，但是需要知道的是这里的 effect 传入的是一个 fn，所以要想访问 state.a 那这个 fn 必须要执行才可以。那是在哪里执行的呢？接下来看一下 ReactiveEffect 的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于记录位于响应上下文中的effect嵌套层次数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> effectTrackDepth = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">// 二进制位，每一位用于标识当前effect嵌套层级的依赖收集的启用状态</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> left trackOpBit = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">// 表示最大标记的位数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> maxMarkerBits = <span class=\"number\">30</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当前活跃的 effect</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> activeEffect;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReactiveEffect</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 用于标识副作用函数是否位于响应式上下文中被执行</span></span><br><span class=\"line\">  active = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"comment\">// 副作用函数持有它所在的所有依赖集合的引用，用于从这些依赖集合删除自身</span></span><br><span class=\"line\">  deps = []</span><br><span class=\"line\">  <span class=\"comment\">// 指针为，用于嵌套 effect 执行后动态切换 activeEffect</span></span><br><span class=\"line\">  parent = <span class=\"literal\">undefined</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"title function_\">run</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 若当前 ReactiveEffect 对象脱离响应式上下文</span></span><br><span class=\"line\">    <span class=\"comment\">// 那么其对应的副作用函数被执行时不会再收集依赖</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"variable language_\">this</span>.<span class=\"property\">active</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">fn</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 缓存是否需要收集依赖</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> lastShouldTrack = shouldTrack</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 保存上一个 activeEffect 到当前的 parent 上</span></span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">parent</span> = activeEffect</span><br><span class=\"line\">      <span class=\"comment\">// activeEffect 指向当前的 effect</span></span><br><span class=\"line\">      activeEffect = <span class=\"variable language_\">this</span></span><br><span class=\"line\">      <span class=\"comment\">// shouldTrack 置成 true</span></span><br><span class=\"line\">      shouldTrack = <span class=\"literal\">true</span></span><br><span class=\"line\">      <span class=\"comment\">// 左移操作符 &lt;&lt; 将第一个操作数向左移动指定位数</span></span><br><span class=\"line\">      <span class=\"comment\">// 左边超出的位数将会被清除，右边将会补零。</span></span><br><span class=\"line\">      <span class=\"comment\">// trackOpBit 是基于 1 左移 effectTrackDepth 位</span></span><br><span class=\"line\">      trackOpBit = <span class=\"number\">1</span> &lt;&lt; ++effectTrackDepth</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// 如果未超过最大嵌套层数，则执行 initDepMarkers</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (effectTrackDepth &lt;= maxMarkerBits) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">initDepMarkers</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"title function_\">cleanupEffect</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 这里执行了 fn</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">fn</span>()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (effectTrackDepth &lt;= maxMarkerBits) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用于对曾经跟踪过，但本次副作用函数执行时没有跟踪的依赖采取删除操作。</span></span><br><span class=\"line\">        <span class=\"comment\">// 新跟踪的 和 本轮跟踪过的都会被保留</span></span><br><span class=\"line\">        <span class=\"title function_\">finalizeDepMarkers</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// &lt;&lt; --effectTrackDepth 右移动 effectTrackDepth 位</span></span><br><span class=\"line\">      trackOpBit = <span class=\"number\">1</span> &lt;&lt; --effectTrackDepth</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// 返回上个 activeEffect</span></span><br><span class=\"line\">      activeEffect = <span class=\"variable language_\">this</span>.<span class=\"property\">parent</span></span><br><span class=\"line\">      <span class=\"comment\">// 返回上个 shouldTrack</span></span><br><span class=\"line\">      shouldTrack = lastShouldTrack</span><br><span class=\"line\">      <span class=\"comment\">// 情况本次的 parent 指向</span></span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">parent</span> = <span class=\"literal\">undefined</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大致看一眼，我们可以看到在 ReactiveEffect 中是执行了 this.fn() 的，这也就解释了 effect 中的回调函数 fn 是在这里被调用的。接下来详细研究一下这个 ReactiveEffect。</p>\n<p>但这段代码看起来不是很长，但涉及了好几个概念，我们来一个个看。</p>\n<h5 id=\"1-parent-的作用\"><a href=\"#1-parent-的作用\" class=\"headerlink\" title=\"1. parent 的作用\"></a>1. parent 的作用</h5><p>为什么 ReactiveEffect 要设计一个 parent 这样一个看似没啥用的变量指针来存储上一次的 activeEffect 呢？如果改成下面这样不是更简单吗？</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">run</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"variable language_\">this</span>.<span class=\"property\">active</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">fn</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">  shouldTrack = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  activeEffect = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"variable language_\">this</span>.<span class=\"title function_\">fn</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 重置</span></span><br><span class=\"line\">  shouldTrack = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实对于下面这样的代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> state = <span class=\"title function_\">reactive</span>(&#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(state.<span class=\"property\">a</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">state.<span class=\"property\">a</span>++</span><br></pre></td></tr></table></figure>\n\n<p>effect 函数内调用 ReactiveEffect 实例的 run 函数。run 函数执行的时候，把 activeEffect 指向 this。然后执行 effect 传入的 fn 函数，函数在执行的时候访问了 state.a 触发了 getter 钩子。回顾一下上一节的内容，getter 的时候有触发添加 activeEffect 的功能：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 把 activeEffect 添加到 dep 中</span></span><br><span class=\"line\">dep.<span class=\"title function_\">add</span>(activeEffect!)</span><br></pre></td></tr></table></figure>\n\n<p>而 activeEffect 正是这里的 this。当执行 state.a++ 时，访问了state.a 的 setter。上一节也说了，setter 的执行会调用 effect.run 函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// triggerEffects</span></span><br><span class=\"line\">effect.<span class=\"title function_\">run</span>();</span><br></pre></td></tr></table></figure>\n\n<p>所以又会执行 fn。</p>\n<p>到这里看似很完美，那么我们再来看另外一个例子🌰：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> state = <span class=\"title function_\">reactive</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ef1</span></span><br><span class=\"line\"><span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ef2</span></span><br><span class=\"line\">  <span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`b: <span class=\"subst\">$&#123;state.b&#125;</span>`</span>))</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`a: <span class=\"subst\">$&#123;state.a&#125;</span>`</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>state.a ++<br>按照上面的逻辑，在第一次 effect 执行的时候，activeEffect &#x3D; ef1 然后再执行内部的 effect， 此时 activeEffect &#x3D; ef2 然后 ef2 执行完成回到 ef1 函数体内，此时再访问 state.a 触发对 a 的依赖收集，但收集到的却是 ef2。那么最终打印的是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">b: 2</span><br><span class=\"line\">a: 1</span><br><span class=\"line\">b: 2</span><br></pre></td></tr></table></figure>\n\n<p>很明显不符合我们的要求，我们期望的是输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">b: 2</span><br><span class=\"line\">a: 1</span><br><span class=\"line\">b: 2</span><br><span class=\"line\">a: 2</span><br></pre></td></tr></table></figure>\n\n<p>这时候 parent 就排上用场了，当为 effect 加上 parent 属性后，我们再来捋一下整体的流程。</p>\n<p>执行 ef1 的时候，activeEffect 指向 ef1，此时 parent 是 undefined。<br>执行 ef1 fn 遇到了 ef2，调用 ef2 此时 ef2 的 parent 指向 ef1， activeEffect 指向 ef2。然后执行 ef2 的 fn。<br>ef2 的 fn 执行的时候，访问了 state.b 依赖收集 ef2。执行完成后，activeEffect &#x3D; this.parent 又把 activeEffect 指向了 ef1。<br>返回 ef1 的 fn 体继续执行，此时访问 state.a 依赖收集 activeEffect 为 ef1。<br>触发 state.a 的 setter，调用 a 的副作用 ef1，依次打印……<br>到这里相信各位小伙伴已经清楚了 parent 的作用了，那就是通过 parent 这个标记，来回切换 activeEffect 的指向，从而完成对嵌套 effect 的正确的依赖收集。</p>\n<h5 id=\"2-依赖清理\"><a href=\"#2-依赖清理\" class=\"headerlink\" title=\"2. 依赖清理\"></a>2. 依赖清理</h5><p>在说依赖清理之前，再来看一个有意思的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> state = <span class=\"title function_\">reactive</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"attr\">show</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (state.<span class=\"property\">show</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`a: <span class=\"subst\">$&#123;state.a&#125;</span>`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">state.<span class=\"property\">a</span> ++</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  state.<span class=\"property\">show</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">  state.<span class=\"property\">a</span> ++</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure>\n\n\n<p>上面的例子中，我们在 effect 中完成了对 show 和 a 的依赖收集，然后 1s 后，我们改变了 show 的状态为 false。此时 effect 内的函数中的 console.log 将永远不会执行，然后再触发 state.a++ 的动作，访问 a 的 getter，如果没有依赖清理，那么按照之前的做法，测试也会触发 effect.fn 的执行，但这个执行其实没意义的，因为 a 已经没有被使用了，是一个永远不会被访问到的变量，造成了性能浪费。所以我们需要删除 a 的副作用函数，让它不要执行。</p>\n<p>接下来一起来看看 Vue 是怎么做的吧！这里涉及到的内容有点多，我们先一个个解释，首先补习一下关于 js 的一些操作符的基础知识。</p>\n<h6 id=\"1-左移（\"><a href=\"#1-左移（\" class=\"headerlink\" title=\"1. 左移（&lt;&lt;）\"></a>1. 左移（&lt;&lt;）</h6><p>左移操作符 (&lt;&lt;) 将第一个操作数转换成 2 进制后向左移动指定位数，左边超出的位数将会被清除，右边将会补零。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">1</span>;         <span class=\"comment\">// 00000000000000000000000000000001</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"number\">1</span>;       </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a &lt;&lt; b); <span class=\"comment\">// 00000000000000000000000000000010</span></span><br><span class=\"line\"><span class=\"comment\">// expected output: 2</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-位或操作（-）\"><a href=\"#2-位或操作（-）\" class=\"headerlink\" title=\"2. 位或操作（|）\"></a>2. 位或操作（|）</h6><p>位或操作符（|）， 如果两位之一为 1，则设置每位为 1。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">5</span>;        <span class=\"comment\">// 00000000000000000000000000000101</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"number\">3</span>;        <span class=\"comment\">// 00000000000000000000000000000011</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a | b); <span class=\"comment\">// 00000000000000000000000000000111</span></span><br><span class=\"line\"><span class=\"comment\">// expected output: 7</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"3-按位与（-）\"><a href=\"#3-按位与（-）\" class=\"headerlink\" title=\"3. 按位与（&amp;）\"></a>3. 按位与（&amp;）</h6><p>按位与运算符 (&amp;) 在两个操作数对应的二进位都为 1 时，该位的结果值才为 1，否则为 0。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">5</span>;        <span class=\"comment\">// 00000000000000000000000000000101</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"number\">3</span>;        <span class=\"comment\">// 00000000000000000000000000000011</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a &amp; b); <span class=\"comment\">// 00000000000000000000000000000001</span></span><br><span class=\"line\"><span class=\"comment\">// expected output: 1</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"4-按位非（-）\"><a href=\"#4-按位非（-）\" class=\"headerlink\" title=\"4. 按位非（~）\"></a>4. 按位非（~）</h6><p>按位非运算符（~），反转操作数的位。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">5</span>;     <span class=\"comment\">// 00000000000000000000000000000101</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = -<span class=\"number\">3</span>;    <span class=\"comment\">// 11111111111111111111111111111101</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(~a); <span class=\"comment\">// 11111111111111111111111111111010</span></span><br><span class=\"line\"><span class=\"comment\">// expected output: -6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(~b); <span class=\"comment\">// 00000000000000000000000000000010</span></span><br><span class=\"line\"><span class=\"comment\">// expected output: 2</span></span><br></pre></td></tr></table></figure>\n\n<p>有了这些基础的知识点后，再来认识几个变量。</p>\n<h6 id=\"1-effectTrackDepth\"><a href=\"#1-effectTrackDepth\" class=\"headerlink\" title=\"1. effectTrackDepth\"></a>1. effectTrackDepth</h6><p>用于记录位于响应上下文中的 effect 嵌套层次数，默认值为 0。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// effectTrackDepth = 0</span></span><br><span class=\"line\"><span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// effectTrackDepth = 1</span></span><br><span class=\"line\">  <span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> &#123;&#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-trackOpBit\"><a href=\"#2-trackOpBit\" class=\"headerlink\" title=\"2. trackOpBit\"></a>2. trackOpBit</h6><p>二进制位，每一位用于标识当前 effect 嵌套层级的依赖收集的启用状态。默认值为 1，即 00000000000000000000000000000001。</p>\n<h6 id=\"3-maxMarkerBits\"><a href=\"#3-maxMarkerBits\" class=\"headerlink\" title=\"3. maxMarkerBits\"></a>3. maxMarkerBits</h6><p>表示最大的 effect 嵌套的层次数，最大值为 30。</p>\n<p>好了，搞懂了这些操作符之后，我们来看看 Vue 的依赖清理是如何实现的，先来看不超过 maxMarkerBits 层级数的嵌套 effect 的依赖收集的过程，还以上面那个 demo 作为示例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> state = <span class=\"title function_\">reactive</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"attr\">show</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (state.<span class=\"property\">show</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`a: <span class=\"subst\">$&#123;state.a&#125;</span>`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">state.<span class=\"property\">a</span> ++</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  state.<span class=\"property\">show</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">  state.<span class=\"property\">a</span> ++</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure>\n\n<p>Step 1：run 函数执行的时候，trackOpBit &#x3D; 1 &lt;&lt; ++effectTrackDepth 这个语句执行完成后，得到 effectTrackDepth &#x3D; 1；trackOpBit.toString(2) &#x3D; 00000000000000000000000000000010。</p>\n<p>Step 2：因为 effectTrackDepth &lt; maxMarkerBits ，所以执行 initDepMarkers 函数，因为这里的 deps 在初始化的时候还是个空数组，所以此函数未执行。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">initDepMarkers</span> = (<span class=\"params\">&#123; deps &#125;</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (deps.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; deps.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">      deps[i].<span class=\"property\">w</span> |= trackOpBit <span class=\"comment\">// set was tracked</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Step 3：执行 this.fn 函数，先访问 state.show，触发了 trackEffects。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">trackEffects</span>(<span class=\"params\">dep</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> shouldTrack = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (effectTrackDepth &lt;= maxMarkerBits) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果本轮副作用函数执行过程中已经访问并收集过，则不用再收集该依赖</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"title function_\">newTracked</span>(dep)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 设置 dep.n</span></span><br><span class=\"line\">      dep.<span class=\"property\">n</span> |= trackOpBit</span><br><span class=\"line\">      shouldTrack = !<span class=\"title function_\">wasTracked</span>(dep)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Full cleanup mode.</span></span><br><span class=\"line\">    shouldTrack = !dep.<span class=\"title function_\">has</span>(activeEffect!)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldTrack) &#123;</span><br><span class=\"line\">    dep.<span class=\"title function_\">add</span>(activeEffect!)</span><br><span class=\"line\">    activeEffect!.<span class=\"property\">deps</span>.<span class=\"title function_\">push</span>(dep)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要额外了解 2 个函数：wasTracked（已经被收集过，缩写是 w） 和 newTracked（新收集的依赖，缩写是 n）。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">wasTracked</span> = dep =&gt; (dep.<span class=\"property\">w</span> &amp; trackOpBit) &gt; <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">newTracked</span> = dep =&gt; (dep.<span class=\"property\">n</span> &amp; trackOpBit) &gt; <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>进入 trackEffects 时，因为此时还没有为 dep.n 进行或运算赋值，所以 state.show 的 newTracked &#x3D; false，wasTracked &#x3D; false。</p>\n<p>所以计算得到 shouldTrack &#x3D; true，最后将 activeEffect 收集进入 dep 中，同时执行了 activeEffect.deps.push(dep) 将 dep 存入了 activeEffect 的 deps 中。然后访问 state.a 重复上述操作。上述步骤执行完成后的 activeEffect.deps 如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  &#123;&quot;w&quot;:0,&quot;n&quot;: 00000000000000000000000000000010, [effect]&#125;,</span><br><span class=\"line\">  &#123;&quot;w&quot;:0,&quot;n&quot;: 00000000000000000000000000000010, [effect]&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>Step 4：最后执行 finalizeDepMarkers 函数，根据第 3 步，此时 effect 中的 deps 包含了 2 个 dep，分别是 state.show 和 state.a。 finalizeDepMarkers 函数内部执行了 wasTracked（已经被收集过，缩写是 w） 和 newTracked（新收集的依赖，缩写是 n） 函数，因为 dep.w &#x3D; 0 所以 wasTracked &#x3D; false。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">finalizeDepMarkers</span> = (<span class=\"params\">effect: ReactiveEffect</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; deps &#125; = effect</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (deps.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ptr = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; deps.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> dep = deps[i]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"title function_\">wasTracked</span>(dep) &amp;&amp; !<span class=\"title function_\">newTracked</span>(dep)) &#123;</span><br><span class=\"line\">        dep.<span class=\"title function_\">delete</span>(effect)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 缩小依赖集合的大小</span></span><br><span class=\"line\">        deps[ptr++] = dep</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// clear bits</span></span><br><span class=\"line\">      dep.<span class=\"property\">w</span> &amp;= ~trackOpBit</span><br><span class=\"line\">      dep.<span class=\"property\">n</span> &amp;= ~trackOpBit</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    deps.<span class=\"property\">length</span> = ptr</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为 wasTracked &#x3D; false，因此 finalizeDepMarkers 处理后仍然将副作用函数保留在这两个属性对应的依赖集合中，同时把 dep.w 和 dep.n 重置回 0。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[&#123;&quot;w&quot;:0, &quot;n&quot;:0, [effect]&#125;,&#123;&quot;w&quot;:0, &quot;n&quot;:0, [effect]&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>Step 5：当执行 state.show &#x3D; false 的时候，触发 effect.run 的执行，此时执行 initDepMarkers 时，因为已经存在了 dep，所以先访问 state.show。</p>\n<p>当执行到 trackEffects 时，此时的 newTracked &#x3D; false，执行逻辑和之前一致。只不过因为 state.show &#x3D; false，所以没有触发 state.a 的这一部分逻辑的处理，最后得到的结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    &quot;w&quot;: 00000000000000000000000000000010,</span><br><span class=\"line\">    &quot;n&quot;: 00000000000000000000000000000010,</span><br><span class=\"line\">    [effect]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    &quot;w&quot;: 00000000000000000000000000000010, </span><br><span class=\"line\">    &quot;n&quot;: 0,</span><br><span class=\"line\">    [effect]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>Step 6：最后执行 finalizeDepMarkers 时，如下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (wasTracked(dep) &amp;&amp; !newTracked(dep)) &#123;</span><br><span class=\"line\">  dep.delete(effect)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为这里的 state.a 的 wasTracked &#x3D; true 且 newTracked 为 false，所以执行了 dep.delete(effect) 将 effect 从 dep 中踢掉。</p>\n<p>Step 7：1s 后执行 state.a++ 的操作，由于 state.a 中没有 effect 了，所以不会执行副作用函数。</p>\n<h5 id=\"总结：-Vue-在组件的-effect-执行之前，会根据-dep-的收集标记位-w-和-n-来进行清理依赖，删除之前-state-a-收集的-effect-依赖。这样当我们修改-state-a-时，由于已经没有依赖了，就不会触发-effect-重新执行。\"><a href=\"#总结：-Vue-在组件的-effect-执行之前，会根据-dep-的收集标记位-w-和-n-来进行清理依赖，删除之前-state-a-收集的-effect-依赖。这样当我们修改-state-a-时，由于已经没有依赖了，就不会触发-effect-重新执行。\" class=\"headerlink\" title=\"总结： Vue 在组件的 effect 执行之前，会根据 dep 的收集标记位 w 和 n 来进行清理依赖，删除之前 state.a 收集的 effect 依赖。这样当我们修改 state.a 时，由于已经没有依赖了，就不会触发 effect 重新执行。\"></a>总结： Vue 在组件的 effect 执行之前，会根据 dep 的收集标记位 w 和 n 来进行清理依赖，删除之前 state.a 收集的 effect 依赖。这样当我们修改 state.a 时，由于已经没有依赖了，就不会触发 effect 重新执行。</h5><p>另外，为了更容易帮助小伙伴们理解上述的流程，我也精心制作了一个动画演示上述流程和过程：</p>\n<p>依赖清理过程.gif</p>\n<p>注意，当 effectTrackDepth 大于 30 时，会调用 cleanup 来清理依赖，其实 cleanup 的原理就是依赖收集前全部删除所有的 dep，依赖收集时再一个个加进来，这个性能其实是比较差的，所以 Vue 3.2 改成了通过二进制标记位的方式来选择性删除和添加，提升了性能。关于这部分更多的细节，可以参考这个PR。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>到这里，我们基本上讲完了 Vue 3 的响应式原理基础，如果有小伙伴了解 Vue 2 的响应式原理，应该清楚 Vue2 的响应式原理可以理解成如下一幅图：</p>\n<p>image.png</p>\n<p>在 Vue 2 中，Watcher 就是依赖，有专门针对组件渲染的 render watcher。</p>\n<p>依赖收集：组件在 render 的时候会访问模板中的数据，触发 getter 把 watcher 作为依赖收集。<br>触发渲染：当修改数据时，会触发 setter，通知 watcher 更新，进而触发了组件的重新渲染。<br>相应地，在 Vue 3 中的响应式流程如下：</p>\n<p>image.png</p>\n<p>可以看到，Vue 3 相对于 Vue 2 的响应式差别不大，主要就是劫持数据的方式改成用 Proxy 实现，以及收集的依赖由 watcher 实例变成了组件副作用函数 effect。另外，值得一提的是 Vue 3 在响应式设计上又多考虑了层级嵌套的依赖收集问题和不必要的依赖清理问题。</p>\n"},{"title":"响应式原理：Vue 3 的 nextTick ？","_content":"\n#### 前言\n通过前面的几个章节的学习，我们大致了解了对于 Vue 3 中的响应式原理：我们通过对 state 数据的响应式拦截，当触发 proxy setter 的时候，执行对应状态的 effect 函数。接下来看一个经典的例子：\n\n```html\n<template>\n  <div>{{number}}</div>\n  <button @click=\"handleClick\">click</button>\n</template>\n<script>\nimport { ref } from 'vue';\nexport default {\n  setup() {\n    const number = ref(0)\n    function handleClick() {\n      for (let i = 0; i < 1000; i++) {\n        number.value ++;\n      }\n    }\n    return {\n      number,\n      handleClick\n    }\n  }\n}\n</script>\n```\n\n当我们按下 click 按钮的时候，number 会被循环增加 1000 次。那么 Vue 的视图会在点击按钮的时候，从 1 -> 1000 刷新 1000 次吗？这一小节，我们将一起探探究竟。\n\n#### queueJob\n我们小册第四节介绍关于“组件更新策略”的时候，提到了 setupRenderEffect 函数：\n\n```typescript\nconst setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\n  function componentUpdateFn() {\n    if (!instance.isMounted) {\n      // 初始化组件\n    }\n    else {\n      // 更新组件\n    }\n  }\n  // 创建响应式的副作用渲染函数\n  instance.update = effect(componentUpdateFn, prodEffectOptions)\n}\n```\n\n当时这里为了方便介绍组件的更新策略，我们简写了 instance.update 的函数创建过程，现在我们来详细看一下 instance.update 这个函数的创建：\n\n```typescript\nconst setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\n  function componentUpdateFn() {\n    // ...\n  }\n  // 创建响应式的副作用渲染函数\n  const effect = (instance.effect = new ReactiveEffect(\n    componentUpdateFn,\n    () => queueJob(update),\n    instance.scope\n  ))\n  \n  // 生成 instance.update 函数\n  const update = (instance.update = () => effect.run())\n  update.id = instance.uid\n  \n  // 组件允许递归更新\n  toggleRecurse(instance, true)\n\n  // 执行更新\n  update()\n}\n```\n\n可以看到在创建 effect 副作用函数的时候，会给 ReactiveEffect 传入一个 scheduler 调度函数，这样生成的 effect 中就包含了 scheduler 属性。同时为组件实例生成了一个 update 属性，该属性的值就是执行 effect.run 的函数，另外需要注意的一点是 update 中包含了一个 id 信息，该值是一个初始值为 0 的自增数字，下文我们再详细介绍其作用。\n\n当我们触发 proxy setter 的时候，触发执行了 triggerEffect 函数，这次，我们补全 triggerEffect 函数的实现：\n\n```typescript\nfunction triggerEffect(effect, debuggerEventExtraInfo) {\n  if (effect !== activeEffect || effect.allowRecurse) {\n    // effect 上存在 scheduler\n    if (effect.scheduler) {\n      effect.scheduler()\n    } else {\n      effect.run()\n    }\n  }\n}\n```\n\n可以看到，如果 effect 上有 scheduler 属性时，执行的是 effect.scheduler 函数，否则执行 effect.run 进行视图更新。而这里显然我们需要先执行调度函数 scheduler。通过上面的信息，我们也清楚地知道 scheduler 函数的本质就是执行了 queueJob(update) 函数，一起来看一下 queueJob 的实现：\n\n```typescript\nexport function queueJob(job) {\n  // 去重判断\n  if (\n    !queue.length ||\n    !queue.includes(\n      job,\n      isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex\n    )\n  ) {\n    // 添加到队列尾部\n    if (job.id == null) {\n      queue.push(job)\n    } else {\n      // 按照 job id 自增的顺序添加\n      queue.splice(findInsertionIndex(job.id), 0, job)\n    }\n    queueFlush()\n  }\n}\n```\n\nqueueJob 就是维护了一个 queue 队列，目的是向 queue 队列中添加 job 对象，这里的 job 就是我们前面的 update 对象。\n\n这里有几点需要说明一下。\n\n第一个是该函数会有一个 isFlushing && job.allowRecurse 判断，这个作用是啥呢？简单点说就是当队列正处于更新状态中（isFlushing = true） 且允许递归调用（ job.allowRecurse = true）时，将搜索起始位置加一，无法搜索到自身，也就是允许递归调用了。什么情况下会出现递归调用？\n\n```html\n<!-- 父组件 -->\n<template>\n  <div>{{msg}}</div>\n  <Child />\n</template>\n<script>\nimport { ref, provide } from 'vue';\nimport Child from './components/Child.vue';\nexport default {\n  setup() {\n    const msg = ref(\"initial\");\n    provide(\"CONTEXT\", { msg });\n    return {\n      msg\n    };\n  },\n  components: {\n    Child\n  }\n}\n</script>\n\n<!-- 子组件 Child -->\n<template>\n  <div>child</div>\n</template>\n<script>\nimport { inject } from 'vue';\nexport default {\n  setup() {\n    const ctx = inject(\"CONTEXT\");\n    ctx.msg.value = \"updated\";\n  }\n}\n</script>\n```\n\n对于这种情况，首先是父组件进入 job 然后渲染父组件，接着进入子组件渲染，但是子组件内部修改了父组件的状态 msg。此时父组件需要支持递归渲染，也就是递归更新。\n\n注意，这里的更新已经不属于单选数据流了，如果过多地打破单向数据流，会导致多次递归执行更新，可能会导致性能下降。\n\n第二个是，queueJob 函数向 queue 队列中添加的 job 是按照 id 排序的，id 小的 Job 先被推入 queue 中执行，这保证了，父组件永远比子组件先更新（因为先创建父组件，再创建子组件，子组件可能依赖父组件的数据）。\n\n再回到函数的本身来说，当我们执行 for 循环 1000 次 setter 的时候，因为在第一步进行了去重判断，所以 update 函数只会被添加一次到 queue 中。这里的 update 函数就是组件的渲染函数。所以无论这里执行多少次循环，渲染更新函数只会被执行一次。\n\n##### queueFlush\n上面说到了无论循环多少次 setter，这里相同 id 的 update 只会被添加一次到 queue 中。\n\n细心的小伙伴可能会有这样的疑问：那么为什么视图不是从 0 -> 1 而是直接从 0 -> 1000 了呢？\n\n要回答上面的问题，就得了解一下 queue 的执行更新相关的内容了，也就是 queueJob 的最后一步 queueFlush：\n\n```typescript\nfunction queueFlush() {\n  // 是否正处于刷新状态\n  if (!isFlushing && !isFlushPending) {\n    isFlushPending = true\n    currentFlushPromise = resolvedPromise.then(flushJobs)\n  }\n}\n```\n\n可以看到这里，vue 3 完全抛弃了除了 promise 之外的异步方案，不再支持vue 2 的 Promise > MutationObserver > setImmediate > setTimeout 其他三种异步操作了。\n\n所以这里，vue 3 直接通过 promise 创建了一个微任务 flushJobs 进行异步调度更新，只要在浏览器当前 tick 内的所有更新任务都会被推入 queue 中，然后在下一个 tick 中统一执行更新。\n\n```typescript\nfunction flushJobs(seen) {\n  // 是否正在等待执行\n  isFlushPending = false\n  // 正在执行\n  isFlushing = true\n\n  // 在更新前，重新排序好更新队列 queue 的顺序\n  // 这确保了:\n  // 1. 组件都是从父组件向子组件进行更新的。（因为父组件都在子组件之前创建的\n  // 所以子组件的渲染的 effect 的优先级比较低）\n  // 2. 如果父组件在更新前卸载了组件，这次更新将会被跳过。\n  queue.sort(comparator)\n  \n  try {\n    // 遍历主任务队列，批量执行更新任务\n    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\n      const job = queue[flushIndex]\n      if (job && job.active !== false) {\n        callWithErrorHandling(job, null, ErrorCodes.SCHEDULER)\n      }\n    }\n  } finally {\n    // 队列任务执行完，重置队列索引\n    flushIndex = 0\n    // 清空队列\n    queue.length = 0\n    // 执行后置队列任务\n    flushPostFlushCbs(seen)\n    // 重置队列执行状态\n    isFlushing = false\n    // 重置当前微任务为 Null\n    currentFlushPromise = null\n    // 如果主任务队列、后置任务队列还有没被清空，就继续递归执行\n    if (queue.length || pendingPostFlushCbs.length) {\n      flushJobs(seen)\n    }\n  }\n}\n```\n\n在详细介绍 flushJobs 之前，我想先简单介绍一下 Vue 的更新任务执行机制中的一个重要概念：更新时机。 Vue 整个更新过程分成了三个部分：\n\n更新前，称之为 pre 阶段；\n更新中，也就是 flushing 中，执行 update 更新；\n更新后，称之为 flushPost 阶段。\n\n###### 更新前\n什么是 pre 阶段呢？拿组件更新举例，就是在 Vue 组件更新之前被调用执行的阶段。默认情况下，Vue 的 watch 和 watchEffect 函数中的 callback 函数都是在这个阶段被执行的，我们简单看一下 watch 中的源码实现：\n\n```typescript\nfunction watch(surce, cb, {immediate, deep, flush, onTrack, onTrigger} = {}) {\n  // ...\n  if (flush === 'sync') {\n    scheduler = job\n  } else if (flush === 'post') {\n    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense)\n  } else {\n    // 默认会给 job 打上 pre 的标记\n    job.pre = true\n    if (instance) job.id = instance.uid\n    scheduler = () => queueJob(job)\n  }\n}\n```\n\n可以看到 watch 的 job 会被默认打上 pre 的标签。而带 pre 标签的 job 则会在渲染前被执行：\n\n```typescript\nconst updateComponent = () => {\n  // ... 省略 n 行代码\n  updateComponentPreRender(instance, n2, optimized)\n}\n\nfunction updateComponentPreRender() {\n  // ... 省略 n 行代码\n  flushPreFlushCbs()\n}\n\nexport function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {\n  for (; i < queue.length; i++) {\n    const cb = queue[i]\n    if (cb && cb.pre) {\n      queue.splice(i, 1)\n      i--\n      cb()\n    }\n  }\n}\n```\n\n可以看到，在执行 updateComponent 更新组件之前，会调用 flushPreFlushCbs 函数，执行所有带上 pre 标签的 job。\n\n###### 更新中\n更新中的过程就是 flushJobs 函数体前面的部分，首先会通过一个 comparator 函数对 queue 队列进行排序，这里排序的目的主要是保证父组件优先于子组件执行，另外在执行后续循环执行 job 任务的时候，通过判断 job.active !== false 来剔除被 unmount 卸载的组件，卸载的组件会有 active = false 的标记。\n\n最后即通过 callWithErrorHandling 函数执行 queue 队列中的每一个 job:\n\n```typescript\nexport function callWithErrorHandling(fn, instance, type, args) {\n  let res\n  try {\n    res = args ? fn(...args) : fn()\n  } catch (err) {\n    handleError(err, instance, type)\n  }\n  return res\n}\n```\n\n###### 更新后\n当页面更新后，需要执行的一些回调函数都存储在 pendingPostFlushCbs 中，通过 flushPostFlushCbs 函数来进行回调执行：\n\n```typescript\nexport function flushPostFlushCbs(seen) {\n  // 存在 job 才执行\n  if (pendingPostFlushCbs.length) {\n    // 去重\n    const deduped = [...new Set(pendingPostFlushCbs)]\n    pendingPostFlushCbs.length = 0\n    \n    // #1947 already has active queue, nested flushPostFlushCbs call\n    // 已经存在activePostFlushCbs，嵌套flushPostFlushCbs调用，直接return\n    if (activePostFlushCbs) {\n      activePostFlushCbs.push(...deduped)\n      return\n    }\n    \n    activePostFlushCbs = deduped\n\n    // 按job.id升序\n    activePostFlushCbs.sort((a, b) => getId(a) - getId(b))\n    \n    // 循环执行job\n    for (\n      postFlushIndex = 0;\n      postFlushIndex < activePostFlushCbs.length;\n      postFlushIndex++\n    ) {\n      activePostFlushCbs[postFlushIndex]()\n    }\n    activePostFlushCbs = null\n    postFlushIndex = 0\n  }\n}\n```\n\n一些需要渲染完成后再执行的钩子函数都会在这个阶段执行，比如 mounted hook 等等。\n\n#### 总结\n通过上面的一些介绍，我们可以了解到本小节开头的示例中，number 的更新函数只会被同步地添加一次到更新队列 queue 中，但更新是异步的，会在 nextTick 也就是 Promise.then 的微任务中执行 update，所以更新会直接从 0 -> 1000。\n\n另外，需要注意的是一个组件内的相同 update 只会有一个被推入 queue 中。比如下面的例子：\n\n```html\n<template>\n  <div>{{number}}</div>\n  <div>{{msg}}</div>\n  <button @click=\"handleClick\">click</button>\n</template>\n<script>\nimport { ref } from 'vue'\nexport default {\n  setup() {\n    const number = ref(0)\n    const msg = ref('init')\n    function handleClick() {\n      for (let i = 0; i < 1000; i++) {\n        number.value ++;\n      }\n      msg.value = 'hello world'\n    }\n    return {\n      number,\n      msg,\n      handleClick\n    }\n  }\n}\n</script>\n```\n\n当点击按钮时，因为 update 内部执行的是当前组件的同一个 componentUpdateFn 函数，状态 msg 和 number 的 update 的 id 是一致的，所以 queue 中，只有一个 update 函数，只会进行一次统一的更新。","source":"_drafts/technical-disclosure-of-vue3/next-tick.md","raw":"---\ntitle: 响应式原理：Vue 3 的 nextTick ？\ncategories:\n  - Vue3 技术揭秘\n---\n\n#### 前言\n通过前面的几个章节的学习，我们大致了解了对于 Vue 3 中的响应式原理：我们通过对 state 数据的响应式拦截，当触发 proxy setter 的时候，执行对应状态的 effect 函数。接下来看一个经典的例子：\n\n```html\n<template>\n  <div>{{number}}</div>\n  <button @click=\"handleClick\">click</button>\n</template>\n<script>\nimport { ref } from 'vue';\nexport default {\n  setup() {\n    const number = ref(0)\n    function handleClick() {\n      for (let i = 0; i < 1000; i++) {\n        number.value ++;\n      }\n    }\n    return {\n      number,\n      handleClick\n    }\n  }\n}\n</script>\n```\n\n当我们按下 click 按钮的时候，number 会被循环增加 1000 次。那么 Vue 的视图会在点击按钮的时候，从 1 -> 1000 刷新 1000 次吗？这一小节，我们将一起探探究竟。\n\n#### queueJob\n我们小册第四节介绍关于“组件更新策略”的时候，提到了 setupRenderEffect 函数：\n\n```typescript\nconst setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\n  function componentUpdateFn() {\n    if (!instance.isMounted) {\n      // 初始化组件\n    }\n    else {\n      // 更新组件\n    }\n  }\n  // 创建响应式的副作用渲染函数\n  instance.update = effect(componentUpdateFn, prodEffectOptions)\n}\n```\n\n当时这里为了方便介绍组件的更新策略，我们简写了 instance.update 的函数创建过程，现在我们来详细看一下 instance.update 这个函数的创建：\n\n```typescript\nconst setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\n  function componentUpdateFn() {\n    // ...\n  }\n  // 创建响应式的副作用渲染函数\n  const effect = (instance.effect = new ReactiveEffect(\n    componentUpdateFn,\n    () => queueJob(update),\n    instance.scope\n  ))\n  \n  // 生成 instance.update 函数\n  const update = (instance.update = () => effect.run())\n  update.id = instance.uid\n  \n  // 组件允许递归更新\n  toggleRecurse(instance, true)\n\n  // 执行更新\n  update()\n}\n```\n\n可以看到在创建 effect 副作用函数的时候，会给 ReactiveEffect 传入一个 scheduler 调度函数，这样生成的 effect 中就包含了 scheduler 属性。同时为组件实例生成了一个 update 属性，该属性的值就是执行 effect.run 的函数，另外需要注意的一点是 update 中包含了一个 id 信息，该值是一个初始值为 0 的自增数字，下文我们再详细介绍其作用。\n\n当我们触发 proxy setter 的时候，触发执行了 triggerEffect 函数，这次，我们补全 triggerEffect 函数的实现：\n\n```typescript\nfunction triggerEffect(effect, debuggerEventExtraInfo) {\n  if (effect !== activeEffect || effect.allowRecurse) {\n    // effect 上存在 scheduler\n    if (effect.scheduler) {\n      effect.scheduler()\n    } else {\n      effect.run()\n    }\n  }\n}\n```\n\n可以看到，如果 effect 上有 scheduler 属性时，执行的是 effect.scheduler 函数，否则执行 effect.run 进行视图更新。而这里显然我们需要先执行调度函数 scheduler。通过上面的信息，我们也清楚地知道 scheduler 函数的本质就是执行了 queueJob(update) 函数，一起来看一下 queueJob 的实现：\n\n```typescript\nexport function queueJob(job) {\n  // 去重判断\n  if (\n    !queue.length ||\n    !queue.includes(\n      job,\n      isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex\n    )\n  ) {\n    // 添加到队列尾部\n    if (job.id == null) {\n      queue.push(job)\n    } else {\n      // 按照 job id 自增的顺序添加\n      queue.splice(findInsertionIndex(job.id), 0, job)\n    }\n    queueFlush()\n  }\n}\n```\n\nqueueJob 就是维护了一个 queue 队列，目的是向 queue 队列中添加 job 对象，这里的 job 就是我们前面的 update 对象。\n\n这里有几点需要说明一下。\n\n第一个是该函数会有一个 isFlushing && job.allowRecurse 判断，这个作用是啥呢？简单点说就是当队列正处于更新状态中（isFlushing = true） 且允许递归调用（ job.allowRecurse = true）时，将搜索起始位置加一，无法搜索到自身，也就是允许递归调用了。什么情况下会出现递归调用？\n\n```html\n<!-- 父组件 -->\n<template>\n  <div>{{msg}}</div>\n  <Child />\n</template>\n<script>\nimport { ref, provide } from 'vue';\nimport Child from './components/Child.vue';\nexport default {\n  setup() {\n    const msg = ref(\"initial\");\n    provide(\"CONTEXT\", { msg });\n    return {\n      msg\n    };\n  },\n  components: {\n    Child\n  }\n}\n</script>\n\n<!-- 子组件 Child -->\n<template>\n  <div>child</div>\n</template>\n<script>\nimport { inject } from 'vue';\nexport default {\n  setup() {\n    const ctx = inject(\"CONTEXT\");\n    ctx.msg.value = \"updated\";\n  }\n}\n</script>\n```\n\n对于这种情况，首先是父组件进入 job 然后渲染父组件，接着进入子组件渲染，但是子组件内部修改了父组件的状态 msg。此时父组件需要支持递归渲染，也就是递归更新。\n\n注意，这里的更新已经不属于单选数据流了，如果过多地打破单向数据流，会导致多次递归执行更新，可能会导致性能下降。\n\n第二个是，queueJob 函数向 queue 队列中添加的 job 是按照 id 排序的，id 小的 Job 先被推入 queue 中执行，这保证了，父组件永远比子组件先更新（因为先创建父组件，再创建子组件，子组件可能依赖父组件的数据）。\n\n再回到函数的本身来说，当我们执行 for 循环 1000 次 setter 的时候，因为在第一步进行了去重判断，所以 update 函数只会被添加一次到 queue 中。这里的 update 函数就是组件的渲染函数。所以无论这里执行多少次循环，渲染更新函数只会被执行一次。\n\n##### queueFlush\n上面说到了无论循环多少次 setter，这里相同 id 的 update 只会被添加一次到 queue 中。\n\n细心的小伙伴可能会有这样的疑问：那么为什么视图不是从 0 -> 1 而是直接从 0 -> 1000 了呢？\n\n要回答上面的问题，就得了解一下 queue 的执行更新相关的内容了，也就是 queueJob 的最后一步 queueFlush：\n\n```typescript\nfunction queueFlush() {\n  // 是否正处于刷新状态\n  if (!isFlushing && !isFlushPending) {\n    isFlushPending = true\n    currentFlushPromise = resolvedPromise.then(flushJobs)\n  }\n}\n```\n\n可以看到这里，vue 3 完全抛弃了除了 promise 之外的异步方案，不再支持vue 2 的 Promise > MutationObserver > setImmediate > setTimeout 其他三种异步操作了。\n\n所以这里，vue 3 直接通过 promise 创建了一个微任务 flushJobs 进行异步调度更新，只要在浏览器当前 tick 内的所有更新任务都会被推入 queue 中，然后在下一个 tick 中统一执行更新。\n\n```typescript\nfunction flushJobs(seen) {\n  // 是否正在等待执行\n  isFlushPending = false\n  // 正在执行\n  isFlushing = true\n\n  // 在更新前，重新排序好更新队列 queue 的顺序\n  // 这确保了:\n  // 1. 组件都是从父组件向子组件进行更新的。（因为父组件都在子组件之前创建的\n  // 所以子组件的渲染的 effect 的优先级比较低）\n  // 2. 如果父组件在更新前卸载了组件，这次更新将会被跳过。\n  queue.sort(comparator)\n  \n  try {\n    // 遍历主任务队列，批量执行更新任务\n    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\n      const job = queue[flushIndex]\n      if (job && job.active !== false) {\n        callWithErrorHandling(job, null, ErrorCodes.SCHEDULER)\n      }\n    }\n  } finally {\n    // 队列任务执行完，重置队列索引\n    flushIndex = 0\n    // 清空队列\n    queue.length = 0\n    // 执行后置队列任务\n    flushPostFlushCbs(seen)\n    // 重置队列执行状态\n    isFlushing = false\n    // 重置当前微任务为 Null\n    currentFlushPromise = null\n    // 如果主任务队列、后置任务队列还有没被清空，就继续递归执行\n    if (queue.length || pendingPostFlushCbs.length) {\n      flushJobs(seen)\n    }\n  }\n}\n```\n\n在详细介绍 flushJobs 之前，我想先简单介绍一下 Vue 的更新任务执行机制中的一个重要概念：更新时机。 Vue 整个更新过程分成了三个部分：\n\n更新前，称之为 pre 阶段；\n更新中，也就是 flushing 中，执行 update 更新；\n更新后，称之为 flushPost 阶段。\n\n###### 更新前\n什么是 pre 阶段呢？拿组件更新举例，就是在 Vue 组件更新之前被调用执行的阶段。默认情况下，Vue 的 watch 和 watchEffect 函数中的 callback 函数都是在这个阶段被执行的，我们简单看一下 watch 中的源码实现：\n\n```typescript\nfunction watch(surce, cb, {immediate, deep, flush, onTrack, onTrigger} = {}) {\n  // ...\n  if (flush === 'sync') {\n    scheduler = job\n  } else if (flush === 'post') {\n    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense)\n  } else {\n    // 默认会给 job 打上 pre 的标记\n    job.pre = true\n    if (instance) job.id = instance.uid\n    scheduler = () => queueJob(job)\n  }\n}\n```\n\n可以看到 watch 的 job 会被默认打上 pre 的标签。而带 pre 标签的 job 则会在渲染前被执行：\n\n```typescript\nconst updateComponent = () => {\n  // ... 省略 n 行代码\n  updateComponentPreRender(instance, n2, optimized)\n}\n\nfunction updateComponentPreRender() {\n  // ... 省略 n 行代码\n  flushPreFlushCbs()\n}\n\nexport function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {\n  for (; i < queue.length; i++) {\n    const cb = queue[i]\n    if (cb && cb.pre) {\n      queue.splice(i, 1)\n      i--\n      cb()\n    }\n  }\n}\n```\n\n可以看到，在执行 updateComponent 更新组件之前，会调用 flushPreFlushCbs 函数，执行所有带上 pre 标签的 job。\n\n###### 更新中\n更新中的过程就是 flushJobs 函数体前面的部分，首先会通过一个 comparator 函数对 queue 队列进行排序，这里排序的目的主要是保证父组件优先于子组件执行，另外在执行后续循环执行 job 任务的时候，通过判断 job.active !== false 来剔除被 unmount 卸载的组件，卸载的组件会有 active = false 的标记。\n\n最后即通过 callWithErrorHandling 函数执行 queue 队列中的每一个 job:\n\n```typescript\nexport function callWithErrorHandling(fn, instance, type, args) {\n  let res\n  try {\n    res = args ? fn(...args) : fn()\n  } catch (err) {\n    handleError(err, instance, type)\n  }\n  return res\n}\n```\n\n###### 更新后\n当页面更新后，需要执行的一些回调函数都存储在 pendingPostFlushCbs 中，通过 flushPostFlushCbs 函数来进行回调执行：\n\n```typescript\nexport function flushPostFlushCbs(seen) {\n  // 存在 job 才执行\n  if (pendingPostFlushCbs.length) {\n    // 去重\n    const deduped = [...new Set(pendingPostFlushCbs)]\n    pendingPostFlushCbs.length = 0\n    \n    // #1947 already has active queue, nested flushPostFlushCbs call\n    // 已经存在activePostFlushCbs，嵌套flushPostFlushCbs调用，直接return\n    if (activePostFlushCbs) {\n      activePostFlushCbs.push(...deduped)\n      return\n    }\n    \n    activePostFlushCbs = deduped\n\n    // 按job.id升序\n    activePostFlushCbs.sort((a, b) => getId(a) - getId(b))\n    \n    // 循环执行job\n    for (\n      postFlushIndex = 0;\n      postFlushIndex < activePostFlushCbs.length;\n      postFlushIndex++\n    ) {\n      activePostFlushCbs[postFlushIndex]()\n    }\n    activePostFlushCbs = null\n    postFlushIndex = 0\n  }\n}\n```\n\n一些需要渲染完成后再执行的钩子函数都会在这个阶段执行，比如 mounted hook 等等。\n\n#### 总结\n通过上面的一些介绍，我们可以了解到本小节开头的示例中，number 的更新函数只会被同步地添加一次到更新队列 queue 中，但更新是异步的，会在 nextTick 也就是 Promise.then 的微任务中执行 update，所以更新会直接从 0 -> 1000。\n\n另外，需要注意的是一个组件内的相同 update 只会有一个被推入 queue 中。比如下面的例子：\n\n```html\n<template>\n  <div>{{number}}</div>\n  <div>{{msg}}</div>\n  <button @click=\"handleClick\">click</button>\n</template>\n<script>\nimport { ref } from 'vue'\nexport default {\n  setup() {\n    const number = ref(0)\n    const msg = ref('init')\n    function handleClick() {\n      for (let i = 0; i < 1000; i++) {\n        number.value ++;\n      }\n      msg.value = 'hello world'\n    }\n    return {\n      number,\n      msg,\n      handleClick\n    }\n  }\n}\n</script>\n```\n\n当点击按钮时，因为 update 内部执行的是当前组件的同一个 componentUpdateFn 函数，状态 msg 和 number 的 update 的 id 是一致的，所以 queue 中，只有一个 update 函数，只会进行一次统一的更新。","slug":"technical-disclosure-of-vue3/next-tick","published":0,"date":"2023-08-12T07:53:19.989Z","updated":"2023-08-12T07:53:19.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokp000zsovc551g6yl0","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>通过前面的几个章节的学习，我们大致了解了对于 Vue 3 中的响应式原理：我们通过对 state 数据的响应式拦截，当触发 proxy setter 的时候，执行对应状态的 effect 函数。接下来看一个经典的例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;number&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;handleClick&quot;</span>&gt;</span>click<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; ref &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title function_\">setup</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">const</span> number = <span class=\"title function_\">ref</span>(<span class=\"number\">0</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">function</span> <span class=\"title function_\">handleClick</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        number.<span class=\"property\">value</span> ++;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      number,</span></span><br><span class=\"line\"><span class=\"language-javascript\">      handleClick</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>当我们按下 click 按钮的时候，number 会被循环增加 1000 次。那么 Vue 的视图会在点击按钮的时候，从 1 -&gt; 1000 刷新 1000 次吗？这一小节，我们将一起探探究竟。</p>\n<h4 id=\"queueJob\"><a href=\"#queueJob\" class=\"headerlink\" title=\"queueJob\"></a>queueJob</h4><p>我们小册第四节介绍关于“组件更新策略”的时候，提到了 setupRenderEffect 函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">setupRenderEffect</span> = (<span class=\"params\">instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">componentUpdateFn</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!instance.<span class=\"property\">isMounted</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 初始化组件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 更新组件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 创建响应式的副作用渲染函数</span></span><br><span class=\"line\">  instance.<span class=\"property\">update</span> = <span class=\"title function_\">effect</span>(componentUpdateFn, prodEffectOptions)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当时这里为了方便介绍组件的更新策略，我们简写了 instance.update 的函数创建过程，现在我们来详细看一下 instance.update 这个函数的创建：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">setupRenderEffect</span> = (<span class=\"params\">instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">componentUpdateFn</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 创建响应式的副作用渲染函数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> effect = (instance.<span class=\"property\">effect</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(</span><br><span class=\"line\">    componentUpdateFn,</span><br><span class=\"line\">    <span class=\"function\">() =&gt;</span> <span class=\"title function_\">queueJob</span>(update),</span><br><span class=\"line\">    instance.<span class=\"property\">scope</span></span><br><span class=\"line\">  ))</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 生成 instance.update 函数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> update = (instance.<span class=\"property\">update</span> = <span class=\"function\">() =&gt;</span> effect.<span class=\"title function_\">run</span>())</span><br><span class=\"line\">  update.<span class=\"property\">id</span> = instance.<span class=\"property\">uid</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 组件允许递归更新</span></span><br><span class=\"line\">  <span class=\"title function_\">toggleRecurse</span>(instance, <span class=\"literal\">true</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 执行更新</span></span><br><span class=\"line\">  <span class=\"title function_\">update</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到在创建 effect 副作用函数的时候，会给 ReactiveEffect 传入一个 scheduler 调度函数，这样生成的 effect 中就包含了 scheduler 属性。同时为组件实例生成了一个 update 属性，该属性的值就是执行 effect.run 的函数，另外需要注意的一点是 update 中包含了一个 id 信息，该值是一个初始值为 0 的自增数字，下文我们再详细介绍其作用。</p>\n<p>当我们触发 proxy setter 的时候，触发执行了 triggerEffect 函数，这次，我们补全 triggerEffect 函数的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">triggerEffect</span>(<span class=\"params\">effect, debuggerEventExtraInfo</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (effect !== activeEffect || effect.<span class=\"property\">allowRecurse</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// effect 上存在 scheduler</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (effect.<span class=\"property\">scheduler</span>) &#123;</span><br><span class=\"line\">      effect.<span class=\"title function_\">scheduler</span>()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      effect.<span class=\"title function_\">run</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，如果 effect 上有 scheduler 属性时，执行的是 effect.scheduler 函数，否则执行 effect.run 进行视图更新。而这里显然我们需要先执行调度函数 scheduler。通过上面的信息，我们也清楚地知道 scheduler 函数的本质就是执行了 queueJob(update) 函数，一起来看一下 queueJob 的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">queueJob</span>(<span class=\"params\">job</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 去重判断</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    !queue.<span class=\"property\">length</span> ||</span><br><span class=\"line\">    !queue.<span class=\"title function_\">includes</span>(</span><br><span class=\"line\">      job,</span><br><span class=\"line\">      isFlushing &amp;&amp; job.<span class=\"property\">allowRecurse</span> ? flushIndex + <span class=\"number\">1</span> : flushIndex</span><br><span class=\"line\">    )</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加到队列尾部</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (job.<span class=\"property\">id</span> == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      queue.<span class=\"title function_\">push</span>(job)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 按照 job id 自增的顺序添加</span></span><br><span class=\"line\">      queue.<span class=\"title function_\">splice</span>(<span class=\"title function_\">findInsertionIndex</span>(job.<span class=\"property\">id</span>), <span class=\"number\">0</span>, job)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">queueFlush</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>queueJob 就是维护了一个 queue 队列，目的是向 queue 队列中添加 job 对象，这里的 job 就是我们前面的 update 对象。</p>\n<p>这里有几点需要说明一下。</p>\n<p>第一个是该函数会有一个 isFlushing &amp;&amp; job.allowRecurse 判断，这个作用是啥呢？简单点说就是当队列正处于更新状态中（isFlushing &#x3D; true） 且允许递归调用（ job.allowRecurse &#x3D; true）时，将搜索起始位置加一，无法搜索到自身，也就是允许递归调用了。什么情况下会出现递归调用？</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 父组件 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">Child</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; ref, provide &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> <span class=\"title class_\">Child</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./components/Child.vue&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title function_\">setup</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">const</span> msg = <span class=\"title function_\">ref</span>(<span class=\"string\">&quot;initial&quot;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"title function_\">provide</span>(<span class=\"string\">&quot;CONTEXT&quot;</span>, &#123; msg &#125;);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      msg</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"attr\">components</span>: &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"title class_\">Child</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 子组件 Child --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>child<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; inject &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title function_\">setup</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">const</span> ctx = <span class=\"title function_\">inject</span>(<span class=\"string\">&quot;CONTEXT&quot;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    ctx.<span class=\"property\">msg</span>.<span class=\"property\">value</span> = <span class=\"string\">&quot;updated&quot;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>对于这种情况，首先是父组件进入 job 然后渲染父组件，接着进入子组件渲染，但是子组件内部修改了父组件的状态 msg。此时父组件需要支持递归渲染，也就是递归更新。</p>\n<p>注意，这里的更新已经不属于单选数据流了，如果过多地打破单向数据流，会导致多次递归执行更新，可能会导致性能下降。</p>\n<p>第二个是，queueJob 函数向 queue 队列中添加的 job 是按照 id 排序的，id 小的 Job 先被推入 queue 中执行，这保证了，父组件永远比子组件先更新（因为先创建父组件，再创建子组件，子组件可能依赖父组件的数据）。</p>\n<p>再回到函数的本身来说，当我们执行 for 循环 1000 次 setter 的时候，因为在第一步进行了去重判断，所以 update 函数只会被添加一次到 queue 中。这里的 update 函数就是组件的渲染函数。所以无论这里执行多少次循环，渲染更新函数只会被执行一次。</p>\n<h5 id=\"queueFlush\"><a href=\"#queueFlush\" class=\"headerlink\" title=\"queueFlush\"></a>queueFlush</h5><p>上面说到了无论循环多少次 setter，这里相同 id 的 update 只会被添加一次到 queue 中。</p>\n<p>细心的小伙伴可能会有这样的疑问：那么为什么视图不是从 0 -&gt; 1 而是直接从 0 -&gt; 1000 了呢？</p>\n<p>要回答上面的问题，就得了解一下 queue 的执行更新相关的内容了，也就是 queueJob 的最后一步 queueFlush：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">queueFlush</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 是否正处于刷新状态</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isFlushing &amp;&amp; !isFlushPending) &#123;</span><br><span class=\"line\">    isFlushPending = <span class=\"literal\">true</span></span><br><span class=\"line\">    currentFlushPromise = resolvedPromise.<span class=\"title function_\">then</span>(flushJobs)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到这里，vue 3 完全抛弃了除了 promise 之外的异步方案，不再支持vue 2 的 Promise &gt; MutationObserver &gt; setImmediate &gt; setTimeout 其他三种异步操作了。</p>\n<p>所以这里，vue 3 直接通过 promise 创建了一个微任务 flushJobs 进行异步调度更新，只要在浏览器当前 tick 内的所有更新任务都会被推入 queue 中，然后在下一个 tick 中统一执行更新。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">flushJobs</span>(<span class=\"params\">seen</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 是否正在等待执行</span></span><br><span class=\"line\">  isFlushPending = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"comment\">// 正在执行</span></span><br><span class=\"line\">  isFlushing = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 在更新前，重新排序好更新队列 queue 的顺序</span></span><br><span class=\"line\">  <span class=\"comment\">// 这确保了:</span></span><br><span class=\"line\">  <span class=\"comment\">// 1. 组件都是从父组件向子组件进行更新的。（因为父组件都在子组件之前创建的</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以子组件的渲染的 effect 的优先级比较低）</span></span><br><span class=\"line\">  <span class=\"comment\">// 2. 如果父组件在更新前卸载了组件，这次更新将会被跳过。</span></span><br><span class=\"line\">  queue.<span class=\"title function_\">sort</span>(comparator)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历主任务队列，批量执行更新任务</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (flushIndex = <span class=\"number\">0</span>; flushIndex &lt; queue.<span class=\"property\">length</span>; flushIndex++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> job = queue[flushIndex]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (job &amp;&amp; job.<span class=\"property\">active</span> !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">callWithErrorHandling</span>(job, <span class=\"literal\">null</span>, <span class=\"title class_\">ErrorCodes</span>.<span class=\"property\">SCHEDULER</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 队列任务执行完，重置队列索引</span></span><br><span class=\"line\">    flushIndex = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 清空队列</span></span><br><span class=\"line\">    queue.<span class=\"property\">length</span> = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 执行后置队列任务</span></span><br><span class=\"line\">    <span class=\"title function_\">flushPostFlushCbs</span>(seen)</span><br><span class=\"line\">    <span class=\"comment\">// 重置队列执行状态</span></span><br><span class=\"line\">    isFlushing = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"comment\">// 重置当前微任务为 Null</span></span><br><span class=\"line\">    currentFlushPromise = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果主任务队列、后置任务队列还有没被清空，就继续递归执行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue.<span class=\"property\">length</span> || pendingPostFlushCbs.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">flushJobs</span>(seen)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在详细介绍 flushJobs 之前，我想先简单介绍一下 Vue 的更新任务执行机制中的一个重要概念：更新时机。 Vue 整个更新过程分成了三个部分：</p>\n<p>更新前，称之为 pre 阶段；<br>更新中，也就是 flushing 中，执行 update 更新；<br>更新后，称之为 flushPost 阶段。</p>\n<h6 id=\"更新前\"><a href=\"#更新前\" class=\"headerlink\" title=\"更新前\"></a>更新前</h6><p>什么是 pre 阶段呢？拿组件更新举例，就是在 Vue 组件更新之前被调用执行的阶段。默认情况下，Vue 的 watch 和 watchEffect 函数中的 callback 函数都是在这个阶段被执行的，我们简单看一下 watch 中的源码实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">watch</span>(<span class=\"params\">surce, cb, &#123;immediate, deep, flush, onTrack, onTrigger&#125; = &#123;&#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (flush === <span class=\"string\">&#x27;sync&#x27;</span>) &#123;</span><br><span class=\"line\">    scheduler = job</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (flush === <span class=\"string\">&#x27;post&#x27;</span>) &#123;</span><br><span class=\"line\">    scheduler = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">queuePostRenderEffect</span>(job, instance &amp;&amp; instance.<span class=\"property\">suspense</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 默认会给 job 打上 pre 的标记</span></span><br><span class=\"line\">    job.<span class=\"property\">pre</span> = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance) job.<span class=\"property\">id</span> = instance.<span class=\"property\">uid</span></span><br><span class=\"line\">    scheduler = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">queueJob</span>(job)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 watch 的 job 会被默认打上 pre 的标签。而带 pre 标签的 job 则会在渲染前被执行：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">updateComponent</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... 省略 n 行代码</span></span><br><span class=\"line\">  <span class=\"title function_\">updateComponentPreRender</span>(instance, n2, optimized)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateComponentPreRender</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... 省略 n 行代码</span></span><br><span class=\"line\">  <span class=\"title function_\">flushPreFlushCbs</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">flushPreFlushCbs</span>(<span class=\"params\">seen, i = isFlushing ? flushIndex + <span class=\"number\">1</span> : <span class=\"number\">0</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (; i &lt; queue.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cb = queue[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cb &amp;&amp; cb.<span class=\"property\">pre</span>) &#123;</span><br><span class=\"line\">      queue.<span class=\"title function_\">splice</span>(i, <span class=\"number\">1</span>)</span><br><span class=\"line\">      i--</span><br><span class=\"line\">      <span class=\"title function_\">cb</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，在执行 updateComponent 更新组件之前，会调用 flushPreFlushCbs 函数，执行所有带上 pre 标签的 job。</p>\n<h6 id=\"更新中\"><a href=\"#更新中\" class=\"headerlink\" title=\"更新中\"></a>更新中</h6><p>更新中的过程就是 flushJobs 函数体前面的部分，首先会通过一个 comparator 函数对 queue 队列进行排序，这里排序的目的主要是保证父组件优先于子组件执行，另外在执行后续循环执行 job 任务的时候，通过判断 job.active !&#x3D;&#x3D; false 来剔除被 unmount 卸载的组件，卸载的组件会有 active &#x3D; false 的标记。</p>\n<p>最后即通过 callWithErrorHandling 函数执行 queue 队列中的每一个 job:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">callWithErrorHandling</span>(<span class=\"params\">fn, instance, <span class=\"keyword\">type</span>, args</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    res = args ? <span class=\"title function_\">fn</span>(...args) : <span class=\"title function_\">fn</span>()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">handleError</span>(err, instance, <span class=\"keyword\">type</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"更新后\"><a href=\"#更新后\" class=\"headerlink\" title=\"更新后\"></a>更新后</h6><p>当页面更新后，需要执行的一些回调函数都存储在 pendingPostFlushCbs 中，通过 flushPostFlushCbs 函数来进行回调执行：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">flushPostFlushCbs</span>(<span class=\"params\">seen</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 存在 job 才执行</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pendingPostFlushCbs.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 去重</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> deduped = [...<span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>(pendingPostFlushCbs)]</span><br><span class=\"line\">    pendingPostFlushCbs.<span class=\"property\">length</span> = <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// #1947 already has active queue, nested flushPostFlushCbs call</span></span><br><span class=\"line\">    <span class=\"comment\">// 已经存在activePostFlushCbs，嵌套flushPostFlushCbs调用，直接return</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activePostFlushCbs) &#123;</span><br><span class=\"line\">      activePostFlushCbs.<span class=\"title function_\">push</span>(...deduped)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    activePostFlushCbs = deduped</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 按job.id升序</span></span><br><span class=\"line\">    activePostFlushCbs.<span class=\"title function_\">sort</span>(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> <span class=\"title function_\">getId</span>(a) - <span class=\"title function_\">getId</span>(b))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 循环执行job</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (</span><br><span class=\"line\">      postFlushIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">      postFlushIndex &lt; activePostFlushCbs.<span class=\"property\">length</span>;</span><br><span class=\"line\">      postFlushIndex++</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      activePostFlushCbs[postFlushIndex]()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    activePostFlushCbs = <span class=\"literal\">null</span></span><br><span class=\"line\">    postFlushIndex = <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一些需要渲染完成后再执行的钩子函数都会在这个阶段执行，比如 mounted hook 等等。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>通过上面的一些介绍，我们可以了解到本小节开头的示例中，number 的更新函数只会被同步地添加一次到更新队列 queue 中，但更新是异步的，会在 nextTick 也就是 Promise.then 的微任务中执行 update，所以更新会直接从 0 -&gt; 1000。</p>\n<p>另外，需要注意的是一个组件内的相同 update 只会有一个被推入 queue 中。比如下面的例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;number&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;handleClick&quot;</span>&gt;</span>click<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; ref &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title function_\">setup</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">const</span> number = <span class=\"title function_\">ref</span>(<span class=\"number\">0</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">const</span> msg = <span class=\"title function_\">ref</span>(<span class=\"string\">&#x27;init&#x27;</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">function</span> <span class=\"title function_\">handleClick</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        number.<span class=\"property\">value</span> ++;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      msg.<span class=\"property\">value</span> = <span class=\"string\">&#x27;hello world&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      number,</span></span><br><span class=\"line\"><span class=\"language-javascript\">      msg,</span></span><br><span class=\"line\"><span class=\"language-javascript\">      handleClick</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>当点击按钮时，因为 update 内部执行的是当前组件的同一个 componentUpdateFn 函数，状态 msg 和 number 的 update 的 id 是一致的，所以 queue 中，只有一个 update 函数，只会进行一次统一的更新。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#e7817c","excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>通过前面的几个章节的学习，我们大致了解了对于 Vue 3 中的响应式原理：我们通过对 state 数据的响应式拦截，当触发 proxy setter 的时候，执行对应状态的 effect 函数。接下来看一个经典的例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;number&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;handleClick&quot;</span>&gt;</span>click<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; ref &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title function_\">setup</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">const</span> number = <span class=\"title function_\">ref</span>(<span class=\"number\">0</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">function</span> <span class=\"title function_\">handleClick</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        number.<span class=\"property\">value</span> ++;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      number,</span></span><br><span class=\"line\"><span class=\"language-javascript\">      handleClick</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>当我们按下 click 按钮的时候，number 会被循环增加 1000 次。那么 Vue 的视图会在点击按钮的时候，从 1 -&gt; 1000 刷新 1000 次吗？这一小节，我们将一起探探究竟。</p>\n<h4 id=\"queueJob\"><a href=\"#queueJob\" class=\"headerlink\" title=\"queueJob\"></a>queueJob</h4><p>我们小册第四节介绍关于“组件更新策略”的时候，提到了 setupRenderEffect 函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">setupRenderEffect</span> = (<span class=\"params\">instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">componentUpdateFn</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!instance.<span class=\"property\">isMounted</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 初始化组件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 更新组件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 创建响应式的副作用渲染函数</span></span><br><span class=\"line\">  instance.<span class=\"property\">update</span> = <span class=\"title function_\">effect</span>(componentUpdateFn, prodEffectOptions)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当时这里为了方便介绍组件的更新策略，我们简写了 instance.update 的函数创建过程，现在我们来详细看一下 instance.update 这个函数的创建：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">setupRenderEffect</span> = (<span class=\"params\">instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">componentUpdateFn</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 创建响应式的副作用渲染函数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> effect = (instance.<span class=\"property\">effect</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(</span><br><span class=\"line\">    componentUpdateFn,</span><br><span class=\"line\">    <span class=\"function\">() =&gt;</span> <span class=\"title function_\">queueJob</span>(update),</span><br><span class=\"line\">    instance.<span class=\"property\">scope</span></span><br><span class=\"line\">  ))</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 生成 instance.update 函数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> update = (instance.<span class=\"property\">update</span> = <span class=\"function\">() =&gt;</span> effect.<span class=\"title function_\">run</span>())</span><br><span class=\"line\">  update.<span class=\"property\">id</span> = instance.<span class=\"property\">uid</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 组件允许递归更新</span></span><br><span class=\"line\">  <span class=\"title function_\">toggleRecurse</span>(instance, <span class=\"literal\">true</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 执行更新</span></span><br><span class=\"line\">  <span class=\"title function_\">update</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到在创建 effect 副作用函数的时候，会给 ReactiveEffect 传入一个 scheduler 调度函数，这样生成的 effect 中就包含了 scheduler 属性。同时为组件实例生成了一个 update 属性，该属性的值就是执行 effect.run 的函数，另外需要注意的一点是 update 中包含了一个 id 信息，该值是一个初始值为 0 的自增数字，下文我们再详细介绍其作用。</p>\n<p>当我们触发 proxy setter 的时候，触发执行了 triggerEffect 函数，这次，我们补全 triggerEffect 函数的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">triggerEffect</span>(<span class=\"params\">effect, debuggerEventExtraInfo</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (effect !== activeEffect || effect.<span class=\"property\">allowRecurse</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// effect 上存在 scheduler</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (effect.<span class=\"property\">scheduler</span>) &#123;</span><br><span class=\"line\">      effect.<span class=\"title function_\">scheduler</span>()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      effect.<span class=\"title function_\">run</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，如果 effect 上有 scheduler 属性时，执行的是 effect.scheduler 函数，否则执行 effect.run 进行视图更新。而这里显然我们需要先执行调度函数 scheduler。通过上面的信息，我们也清楚地知道 scheduler 函数的本质就是执行了 queueJob(update) 函数，一起来看一下 queueJob 的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">queueJob</span>(<span class=\"params\">job</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 去重判断</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    !queue.<span class=\"property\">length</span> ||</span><br><span class=\"line\">    !queue.<span class=\"title function_\">includes</span>(</span><br><span class=\"line\">      job,</span><br><span class=\"line\">      isFlushing &amp;&amp; job.<span class=\"property\">allowRecurse</span> ? flushIndex + <span class=\"number\">1</span> : flushIndex</span><br><span class=\"line\">    )</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加到队列尾部</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (job.<span class=\"property\">id</span> == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      queue.<span class=\"title function_\">push</span>(job)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 按照 job id 自增的顺序添加</span></span><br><span class=\"line\">      queue.<span class=\"title function_\">splice</span>(<span class=\"title function_\">findInsertionIndex</span>(job.<span class=\"property\">id</span>), <span class=\"number\">0</span>, job)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">queueFlush</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>queueJob 就是维护了一个 queue 队列，目的是向 queue 队列中添加 job 对象，这里的 job 就是我们前面的 update 对象。</p>\n<p>这里有几点需要说明一下。</p>\n<p>第一个是该函数会有一个 isFlushing &amp;&amp; job.allowRecurse 判断，这个作用是啥呢？简单点说就是当队列正处于更新状态中（isFlushing &#x3D; true） 且允许递归调用（ job.allowRecurse &#x3D; true）时，将搜索起始位置加一，无法搜索到自身，也就是允许递归调用了。什么情况下会出现递归调用？</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 父组件 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">Child</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; ref, provide &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> <span class=\"title class_\">Child</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./components/Child.vue&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title function_\">setup</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">const</span> msg = <span class=\"title function_\">ref</span>(<span class=\"string\">&quot;initial&quot;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"title function_\">provide</span>(<span class=\"string\">&quot;CONTEXT&quot;</span>, &#123; msg &#125;);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      msg</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"attr\">components</span>: &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"title class_\">Child</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 子组件 Child --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>child<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; inject &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title function_\">setup</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">const</span> ctx = <span class=\"title function_\">inject</span>(<span class=\"string\">&quot;CONTEXT&quot;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    ctx.<span class=\"property\">msg</span>.<span class=\"property\">value</span> = <span class=\"string\">&quot;updated&quot;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>对于这种情况，首先是父组件进入 job 然后渲染父组件，接着进入子组件渲染，但是子组件内部修改了父组件的状态 msg。此时父组件需要支持递归渲染，也就是递归更新。</p>\n<p>注意，这里的更新已经不属于单选数据流了，如果过多地打破单向数据流，会导致多次递归执行更新，可能会导致性能下降。</p>\n<p>第二个是，queueJob 函数向 queue 队列中添加的 job 是按照 id 排序的，id 小的 Job 先被推入 queue 中执行，这保证了，父组件永远比子组件先更新（因为先创建父组件，再创建子组件，子组件可能依赖父组件的数据）。</p>\n<p>再回到函数的本身来说，当我们执行 for 循环 1000 次 setter 的时候，因为在第一步进行了去重判断，所以 update 函数只会被添加一次到 queue 中。这里的 update 函数就是组件的渲染函数。所以无论这里执行多少次循环，渲染更新函数只会被执行一次。</p>\n<h5 id=\"queueFlush\"><a href=\"#queueFlush\" class=\"headerlink\" title=\"queueFlush\"></a>queueFlush</h5><p>上面说到了无论循环多少次 setter，这里相同 id 的 update 只会被添加一次到 queue 中。</p>\n<p>细心的小伙伴可能会有这样的疑问：那么为什么视图不是从 0 -&gt; 1 而是直接从 0 -&gt; 1000 了呢？</p>\n<p>要回答上面的问题，就得了解一下 queue 的执行更新相关的内容了，也就是 queueJob 的最后一步 queueFlush：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">queueFlush</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 是否正处于刷新状态</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isFlushing &amp;&amp; !isFlushPending) &#123;</span><br><span class=\"line\">    isFlushPending = <span class=\"literal\">true</span></span><br><span class=\"line\">    currentFlushPromise = resolvedPromise.<span class=\"title function_\">then</span>(flushJobs)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到这里，vue 3 完全抛弃了除了 promise 之外的异步方案，不再支持vue 2 的 Promise &gt; MutationObserver &gt; setImmediate &gt; setTimeout 其他三种异步操作了。</p>\n<p>所以这里，vue 3 直接通过 promise 创建了一个微任务 flushJobs 进行异步调度更新，只要在浏览器当前 tick 内的所有更新任务都会被推入 queue 中，然后在下一个 tick 中统一执行更新。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">flushJobs</span>(<span class=\"params\">seen</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 是否正在等待执行</span></span><br><span class=\"line\">  isFlushPending = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"comment\">// 正在执行</span></span><br><span class=\"line\">  isFlushing = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 在更新前，重新排序好更新队列 queue 的顺序</span></span><br><span class=\"line\">  <span class=\"comment\">// 这确保了:</span></span><br><span class=\"line\">  <span class=\"comment\">// 1. 组件都是从父组件向子组件进行更新的。（因为父组件都在子组件之前创建的</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以子组件的渲染的 effect 的优先级比较低）</span></span><br><span class=\"line\">  <span class=\"comment\">// 2. 如果父组件在更新前卸载了组件，这次更新将会被跳过。</span></span><br><span class=\"line\">  queue.<span class=\"title function_\">sort</span>(comparator)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历主任务队列，批量执行更新任务</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (flushIndex = <span class=\"number\">0</span>; flushIndex &lt; queue.<span class=\"property\">length</span>; flushIndex++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> job = queue[flushIndex]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (job &amp;&amp; job.<span class=\"property\">active</span> !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">callWithErrorHandling</span>(job, <span class=\"literal\">null</span>, <span class=\"title class_\">ErrorCodes</span>.<span class=\"property\">SCHEDULER</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 队列任务执行完，重置队列索引</span></span><br><span class=\"line\">    flushIndex = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 清空队列</span></span><br><span class=\"line\">    queue.<span class=\"property\">length</span> = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 执行后置队列任务</span></span><br><span class=\"line\">    <span class=\"title function_\">flushPostFlushCbs</span>(seen)</span><br><span class=\"line\">    <span class=\"comment\">// 重置队列执行状态</span></span><br><span class=\"line\">    isFlushing = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"comment\">// 重置当前微任务为 Null</span></span><br><span class=\"line\">    currentFlushPromise = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果主任务队列、后置任务队列还有没被清空，就继续递归执行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue.<span class=\"property\">length</span> || pendingPostFlushCbs.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">flushJobs</span>(seen)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在详细介绍 flushJobs 之前，我想先简单介绍一下 Vue 的更新任务执行机制中的一个重要概念：更新时机。 Vue 整个更新过程分成了三个部分：</p>\n<p>更新前，称之为 pre 阶段；<br>更新中，也就是 flushing 中，执行 update 更新；<br>更新后，称之为 flushPost 阶段。</p>\n<h6 id=\"更新前\"><a href=\"#更新前\" class=\"headerlink\" title=\"更新前\"></a>更新前</h6><p>什么是 pre 阶段呢？拿组件更新举例，就是在 Vue 组件更新之前被调用执行的阶段。默认情况下，Vue 的 watch 和 watchEffect 函数中的 callback 函数都是在这个阶段被执行的，我们简单看一下 watch 中的源码实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">watch</span>(<span class=\"params\">surce, cb, &#123;immediate, deep, flush, onTrack, onTrigger&#125; = &#123;&#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (flush === <span class=\"string\">&#x27;sync&#x27;</span>) &#123;</span><br><span class=\"line\">    scheduler = job</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (flush === <span class=\"string\">&#x27;post&#x27;</span>) &#123;</span><br><span class=\"line\">    scheduler = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">queuePostRenderEffect</span>(job, instance &amp;&amp; instance.<span class=\"property\">suspense</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 默认会给 job 打上 pre 的标记</span></span><br><span class=\"line\">    job.<span class=\"property\">pre</span> = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance) job.<span class=\"property\">id</span> = instance.<span class=\"property\">uid</span></span><br><span class=\"line\">    scheduler = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">queueJob</span>(job)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 watch 的 job 会被默认打上 pre 的标签。而带 pre 标签的 job 则会在渲染前被执行：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">updateComponent</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... 省略 n 行代码</span></span><br><span class=\"line\">  <span class=\"title function_\">updateComponentPreRender</span>(instance, n2, optimized)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateComponentPreRender</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... 省略 n 行代码</span></span><br><span class=\"line\">  <span class=\"title function_\">flushPreFlushCbs</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">flushPreFlushCbs</span>(<span class=\"params\">seen, i = isFlushing ? flushIndex + <span class=\"number\">1</span> : <span class=\"number\">0</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (; i &lt; queue.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cb = queue[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cb &amp;&amp; cb.<span class=\"property\">pre</span>) &#123;</span><br><span class=\"line\">      queue.<span class=\"title function_\">splice</span>(i, <span class=\"number\">1</span>)</span><br><span class=\"line\">      i--</span><br><span class=\"line\">      <span class=\"title function_\">cb</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，在执行 updateComponent 更新组件之前，会调用 flushPreFlushCbs 函数，执行所有带上 pre 标签的 job。</p>\n<h6 id=\"更新中\"><a href=\"#更新中\" class=\"headerlink\" title=\"更新中\"></a>更新中</h6><p>更新中的过程就是 flushJobs 函数体前面的部分，首先会通过一个 comparator 函数对 queue 队列进行排序，这里排序的目的主要是保证父组件优先于子组件执行，另外在执行后续循环执行 job 任务的时候，通过判断 job.active !&#x3D;&#x3D; false 来剔除被 unmount 卸载的组件，卸载的组件会有 active &#x3D; false 的标记。</p>\n<p>最后即通过 callWithErrorHandling 函数执行 queue 队列中的每一个 job:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">callWithErrorHandling</span>(<span class=\"params\">fn, instance, <span class=\"keyword\">type</span>, args</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    res = args ? <span class=\"title function_\">fn</span>(...args) : <span class=\"title function_\">fn</span>()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">handleError</span>(err, instance, <span class=\"keyword\">type</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"更新后\"><a href=\"#更新后\" class=\"headerlink\" title=\"更新后\"></a>更新后</h6><p>当页面更新后，需要执行的一些回调函数都存储在 pendingPostFlushCbs 中，通过 flushPostFlushCbs 函数来进行回调执行：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">flushPostFlushCbs</span>(<span class=\"params\">seen</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 存在 job 才执行</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pendingPostFlushCbs.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 去重</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> deduped = [...<span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>(pendingPostFlushCbs)]</span><br><span class=\"line\">    pendingPostFlushCbs.<span class=\"property\">length</span> = <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// #1947 already has active queue, nested flushPostFlushCbs call</span></span><br><span class=\"line\">    <span class=\"comment\">// 已经存在activePostFlushCbs，嵌套flushPostFlushCbs调用，直接return</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activePostFlushCbs) &#123;</span><br><span class=\"line\">      activePostFlushCbs.<span class=\"title function_\">push</span>(...deduped)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    activePostFlushCbs = deduped</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 按job.id升序</span></span><br><span class=\"line\">    activePostFlushCbs.<span class=\"title function_\">sort</span>(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> <span class=\"title function_\">getId</span>(a) - <span class=\"title function_\">getId</span>(b))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 循环执行job</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (</span><br><span class=\"line\">      postFlushIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">      postFlushIndex &lt; activePostFlushCbs.<span class=\"property\">length</span>;</span><br><span class=\"line\">      postFlushIndex++</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      activePostFlushCbs[postFlushIndex]()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    activePostFlushCbs = <span class=\"literal\">null</span></span><br><span class=\"line\">    postFlushIndex = <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一些需要渲染完成后再执行的钩子函数都会在这个阶段执行，比如 mounted hook 等等。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>通过上面的一些介绍，我们可以了解到本小节开头的示例中，number 的更新函数只会被同步地添加一次到更新队列 queue 中，但更新是异步的，会在 nextTick 也就是 Promise.then 的微任务中执行 update，所以更新会直接从 0 -&gt; 1000。</p>\n<p>另外，需要注意的是一个组件内的相同 update 只会有一个被推入 queue 中。比如下面的例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;number&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;handleClick&quot;</span>&gt;</span>click<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; ref &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title function_\">setup</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">const</span> number = <span class=\"title function_\">ref</span>(<span class=\"number\">0</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">const</span> msg = <span class=\"title function_\">ref</span>(<span class=\"string\">&#x27;init&#x27;</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">function</span> <span class=\"title function_\">handleClick</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        number.<span class=\"property\">value</span> ++;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      msg.<span class=\"property\">value</span> = <span class=\"string\">&#x27;hello world&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      number,</span></span><br><span class=\"line\"><span class=\"language-javascript\">      msg,</span></span><br><span class=\"line\"><span class=\"language-javascript\">      handleClick</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>当点击按钮时，因为 update 内部执行的是当前组件的同一个 componentUpdateFn 函数，状态 msg 和 number 的 update 的 id 是一致的，所以 queue 中，只有一个 update 函数，只会进行一次统一的更新。</p>\n"},{"title":"渲染器：数组子节点的 Diff 算法","_content":"\n#### 前言\n上一节，我们介绍了关于新旧子节点不同为数组的情况下的更新过程，下面将接着上节的内容继续介绍如果子节点都是数组的情况，那么更新过程会变成什么样呢？\n\n#### 1. 从头比对\nVue 3 的 diff 算法第一步就是进行新老节点从头比对的方式来判断是否是同类型的节点：\n\n```typescript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  let i = 0\n  const l2 = c2.length\n  // 旧节点的尾部标记位\n  let e1 = c1.length - 1\n  // 新节点的尾部标记位\n  let e2 = l2 - 1\n  // 从头部开始比对\n  // (a b) c\n  // (a b) d e\n  while (i <= e1 && i <= e2) {\n    const n1 = c1[i]\n    const n2 = (c2[i] = optimized\n      ? cloneIfMounted(c2[i] as VNode)\n      : normalizeVNode(c2[i]))\n    // 如果是 sameVnode 则递归执行 patch  \n    if (isSameVNodeType(n1, n2)) {\n      patch(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized)\n    } else {\n      break\n    }\n    i++\n  }\n}\n```\n\n这里有几个变量需要说明一下：\n\ni 代表的是头部的标记位；\ne1 代表的是旧的子节点的尾部标记位；\ne2 代表的是新的子节点的尾部标记位。\n从头比对就是通过不断移动 i 这个头部标记位来判断对应的节点是否是 sameVnode。如果是，则进行递归 patch 操作，递归 patch 就是继续进入到我们上一小节的内容。如果不满足条件，则退出头部比对，进入从尾比对流程。\n\n#### 2. 从尾比对\n\n```typescript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  let i = 0\n  const l2 = c2.length\n  // 旧节点的尾部标记位\n  let e1 = c1.length - 1\n  // 新节点的尾部标记位\n  let e2 = l2 - 1\n  // 从头部开始比对\n  // ...\n  // 从尾部开始比对\n  // a (b c)\n  // d e (b c)\n  while (i <= e1 && i <= e2) {\n    const n1 = c1[e1]\n    const n2 = (c2[e2] = optimized\n      ? cloneIfMounted(c2[e2] as VNode)\n      : normalizeVNode(c2[e2]))\n    // 如果是 sameVnode 则递归执行 patch  \n    if (isSameVNodeType(n1, n2)) {\n      patch(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized)\n    } else {\n      break\n    }\n    e1--\n    e2--\n  }\n}\n```\n从尾比对就是通过不断移动新旧节点 e1 和 e2 的尾部指针来判断对应的节点是否是 sameVnode。如果是则进行递归 patch 操作，递归 patch 也是继续进入到我们上一小节的内容。如果不满足条件，则退出头部比对，进入后续流程。\n\n####　3. 新增节点\n假设我们有这样一个旧列表：\n\n```html\n<ul>\n  <li key=\"a\">a</li>\n  <li key=\"b\">b</li>\n  <li key=\"c\">c</li>\n  <li key=\"d\">d</li>\n</ul>\n```\n\n新列表的变更是在中间插入了一个新节点：\n\n```html\n<ul>\n  <li key=\"a\">a</li>\n  <li key=\"b\">b</li>\n  <li key=\"b\">e</li>\n  <li key=\"c\">c</li>\n  <li key=\"d\">d</li>\n</ul>\n```\n\n那么先进入第一步头部比对流程：\n\nimage.png\n\n第一步执行时，会完成对 a 和 b 头部这 2 个节点进行 patch。当 i = 2 时，由于此时的 c 和 e 节点的 key 不一样，所以退出了头部比对流程，进入尾部比对：\n\nimage.png\n\n第二步执行时，会完成对 c 和 d 尾部这 2 个节点进行 patch。当 e1 = 1 时，由于i > e1，所以退出了尾部比对流程。肉眼可见，此时的情况是新节点多了个 e 节点的情况，所以我们需要添加多余的剩余节点：\n\n\n```typescript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  let i = 0\n  const l2 = c2.length\n  // 旧节点的尾部标记位\n  let e1 = c1.length - 1\n  // 新节点的尾部标记位\n  let e2 = l2 - 1\n  // 从头部开始必须\n  // ...\n  // 从尾部开始比对\n  // ...\n  // 如果有多余的新节点，则执行新增逻辑\n  if (i > e1) {\n    if (i <= e2) {\n      const nextPos = e2 + 1\n      const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor\n      while (i <= e2) {\n        // 新增新节点\n        patch(null, c2[i], container, anchor, parentComponent, parentSuspense, isSVG)\n        i++\n      }\n    }\n  }\n}\n```\n\n#### 4. 删除节点\n类比新增节点的情况，假设我们有这样一个旧列表：\n\n```html\n<ul>\n  <li key=\"a\">a</li>\n  <li key=\"b\">b</li>\n  <li key=\"b\">e</li>\n  <li key=\"c\">c</li>\n  <li key=\"d\">d</li>\n</ul>\n```\n\n新列表的变更是在中间删除了一个旧节点：\n\n```html\n<ul>\n  <li key=\"a\">a</li>\n  <li key=\"b\">b</li>\n  <li key=\"c\">c</li>\n  <li key=\"d\">d</li>\n</ul>\n```\n那么先进入第一步头部比对流程：\n\nimage.png\n\n第一步执行时，会完成对 a 和 b 头部这 2 个节点进行 patch。当 i = 2 时，由于此时的 e 和 c 节点的 key 不一样，所以退出了头部比对流程，进入尾部比对：\n\nimage.png\n\n第二步执行时，会完成对 c 和 d 尾部这 2 个节点进行 patch。当 e2 = 1 时，由于i > e2，所以退出了尾部比对流程。肉眼可见，此时的情况是新节点少了个 e 节点的情况，所以我们需要删除节点 e：\n\n```typescript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  let i = 0\n  const l2 = c2.length\n  // 旧节点的尾部标记位\n  let e1 = c1.length - 1\n  // 新节点的尾部标记位\n  let e2 = l2 - 1\n  // 从头部开始比对\n  // ...\n  // 从尾部开始比对\n  // ...\n  // 如果有多余的新节点，则执行新增逻辑\n  // ...\n  // 如果有多余的旧节点，则执行卸载逻辑\n  else if (i > e2) {\n    while (i <= e1) {\n      // 卸载节点\n      unmount(c1[i], parentComponent, parentSuspense, true)\n      i++\n    }\n  }\n}\n```\n\n#### 5. 未知子序列\n经过步骤 1、2 的操作后如果可以直接进入步骤 3、4 那是非常方便的操作了，直接进行多余删除缺少新增的操作。如果步骤 3、4 的条件都不满足的情况，那么 Vue 是如何处理的呢？再来看这样一个例子。\n\n旧子节点：\n\n```html\n<ul>\n  <li key=\"a\">a</li>\n  <li key=\"b\">b</li>\n  <li key=\"c\">c</li>\n  <li key=\"d\">d</li>\n  <li key=\"e\">e</li>\n  <li key=\"f\">f</li>\n  <li key=\"g\">g</li>\n  <li key=\"h\">h</li>\n</ul>\n```\n\n新子节点：\n\n```html\n<ul>\n  <li key=\"a\">a</li>\n  <li key=\"b\">b</li>\n  <li key=\"e\">e</li>\n  <li key=\"c\">c</li>\n  <li key=\"d\">d</li>\n  <li key=\"i\">i</li>\n  <li key=\"g\">g</li>\n  <li key=\"h\">h</li>\n</ul>\n```\n\n此时经过步骤 1、2 后的结果可以表示为如下图：\n\nimage.png\n\n这种情况，既不满足 i > e1 也不满足 i > e2 的条件，所以对于这种情况应该如何处理呢？我们知道 DOM 更新的性能优劣关系大致为：属性更新 > 位置移动 > 增删节点。所以，我们需要尽可能地复用老节点，做属性更新，减少移动次数和增删节点的次数。\n\n那么上述更新策略假设有这样 2 种方式。\n\nc 和 d 节点不动，只做 patch，e 节点 patch 后移动到 c 节点前面，删除 f 节点，然后在 d 节点后面添加 i 节点。\ne 节点不动，只做 patch，c 和 d 节点 patch 后移动到 e 节点后面，删除 f 节点，然后在 d 节点后面添加 i 节点。\n根据上面的性能优劣关系，我们需要尽可能多地保障最多的公共子节点位置不变，只做 patch 更新。然后找出多余的节点删除，找出新的节点添加，找出有需要移动的节点移动。\n\n当需要进行移动操作时，那么这个问题就变成了求取新旧子树上的最长公共子序列。当知道了最长公共子序列，所有的操作就可以简化为：\n\n如果节点在新节点中，不在旧节点中，那么新增节点。\n如果节点在旧节点中，不在新节点中，那么删除节点。\n如果节点既在旧节点中，也在新节点中，那么更新。\n如果节点需要移动，那么求取最长公共子序列后，进行最小位置移动。\n接下来看看 Vue 是如何实现上述能力的。\n\n#### 构造新老节点位置映射 keyToNewIndexMap\n\n```typescript\n// 旧子序列开始位置\nconst s1 = i\n// 新子序列开始位置\nconst s2 = i\n\n// 5.1 构建 key:index 关系索引 map\nconst keyToNewIndexMap = new Map()\nfor (i = s2; i <= e2; i++) {\n  const nextChild = (c2[i] = optimized\n    ? cloneIfMounted(c2[i] as VNode)\n    : normalizeVNode(c2[i]))\n  if (nextChild.key != null) {\n    keyToNewIndexMap.set(nextChild.key, i)\n  }\n}\n```\n\n这里的新旧子节点开始位置通过 s1 和 s2 作为标记，然后开始进行构造新老节点位置映射，这里新节点 key -> index 关系的索引图是保存在了 keyToNewIndexMap 这样一个 Map 结构中，其中的 key 就是新节点的 key 值，而 value 则是旧节点对应的位置关系 index。这一步完成后，生成的 keyToNewIndexMap 结果可以表示为：\n\n```typescript\nkeyToNewIndexMap = {e: 2, c: 3, d: 4, i: 5}\n```\n\nimage.png\n\n#### 继续处理旧节点\n有了上面的 keyToNewIndexMap 新节点的索引图，接下来我们就需要遍历旧的节点，寻找旧节点在新节点中对应的位置信息，如果找到则做更新，找不到则移除。\n\n```typescript\n// 记录新节点已更新的数目\nlet patched = 0\n// 记录新节点还有多少个没有更新\nconst toBePatched = e2 - s2 + 1\n// 标记是否有必要进行节点的位置移动\nlet moved = false\n// 标记是否有节点进行了位置移动\nlet maxNewIndexSoFar = 0\n// 记录新节点在旧节点中的位置数组\nconst newIndexToOldIndexMap = new Array(toBePatched)\n// newIndexToOldIndexMap 全部置为 0\nfor (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0\n// 开始遍历旧子节点\nfor (i = s1; i <= e1; i++) {\n  // prevChild 代表旧节点\n  const prevChild = c1[i]\n  // 还有多余的旧节点，则删除\n  if (patched >= toBePatched) {\n    unmount(prevChild, parentComponent, parentSuspense, true)\n    continue\n  }\n  // 记录旧节点在新节点中的位置数组\n  let newIndex = keyToNewIndexMap.get(prevChild.key)\n  \n  // 如果旧节点不存在于新节点中，则删除该节点\n  if (newIndex === undefined) {\n    unmount(prevChild, parentComponent, parentSuspense, true)\n  } else {\n    // newIndexToOldIndexMap 中元素为 0 表示着新节点不存在于旧节点中\n    newIndexToOldIndexMap[newIndex - s2] = i + 1\n    // 默认不移动的话，所有相同节点都是增序排列的\n    // 如果有移动，必然出现节点降序的情况\n    if (newIndex >= maxNewIndexSoFar) {\n      maxNewIndexSoFar = newIndex\n    } else {\n      moved = true\n    }\n    // 更新节点\n    patch(\n      prevChild,\n      c2[newIndex] as VNode,\n      container,\n      null,\n      parentComponent,\n      parentSuspense,\n      isSVG,\n      slotScopeIds,\n      optimized\n    )\n    // 记录更新的数量\n    patched++\n  }\n}\n```\n\n我们简单来总结一下这一步的一些核心操作。\n\nStep 1： 定义一个初始长度为新节点数组长度且默认值全为 0 的变量 newIndexToOldIndexMap，记录新节点中的元素在旧节点中的位置关系。\n\nStep 2： 遍历旧的节点数组，如果旧节点不存在于新节点中，则表示旧的节点其实是多余的节点，需要被移除。\n\nStep 3： 如果旧节点存在于新节点数组中，则将它在旧子序列中的位置信息记录到 newIndexToOldIndexMap 中，同时根据 newIndex 是否大于 maxNewIndexSoFar 来判断是否有节点移动。\n\n这里我们结合个例子来说明。假如旧节点信息为 abc、新节点为 cab，当旧节点遍历到 c 节点时，此时的newIndex 的值为 0 而 maxNewIndexSoFar 的值为 2。这就意味着此时的 c 节点并不是升序位于 ab 节点之后的，因此需要标记为有需要移动的节点。\n\nStep 4： 更新相同节点。\n\n经过上面的一系列操作，我们最终得到了一个 newIndexToOldIndexMap 和一个 moved 两个变量 ，这两个变量将在下文的移动和新增节点中被使用。\n\n我们来看一下示例处理后的结果，如下图所示：\n\nimage.png\n\n此时 c、d、e 因为是相同节点，所以进行 patch 更新，f 节点因为不存在于新的索引中，所以被删除。最后得到的 newIndexToOldIndexMap 数据结构大致如下：\n\n```\nnewIndexToOldIndexMap = [5, 3, 4, 0]\n```\n\n而且此时的 moved 也被标记为 true。\n\n#### 移动和增加新节点\n通过前面的操作，我们完成了对旧节点的移除和更新，那么接下来就是需要进行对节点的移动和新节点的增加了：\n\n```typescript\n// 根据 newIndexToOldIndexMap 求取最长公共子序列\nconst increasingNewIndexSequence = moved\n  ? getSequence(newIndexToOldIndexMap)\n  : EMPTY_ARR\n// 最长公共子序列尾部索引  \nj = increasingNewIndexSequence.length - 1\n// 从尾部开始遍历\nfor (i = toBePatched - 1; i >= 0; i--) {\n  const nextIndex = s2 + i\n  const nextChild = c2[nextIndex]\n  const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor\n  // 如果新子序列中的节点在旧子序列中不存在，则新增节点\n  if (newIndexToOldIndexMap[i] === 0) {\n    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG)\n  } else if (moved) {\n    // 如果需要移动且\n    // 没有最长递增子序列\n    // 当前的节点不在最长递增子序列中\n    if (j < 0 || i !== increasingNewIndexSequence[j]) {\n      move(nextChild, container, anchor, MoveType.REORDER)\n    } else {\n      j--\n    }\n  }\n}\n```\n\nStep 1： 这里针对 moved 是 true 的情况，则会进行求取最长递增子序列的索引操作。\n\n什么是最长递增子序列？简单来说指的是找到一个特定的最长的子序列，并且子序列中的所有元素单调递增。本例中，newIndexToOldIndexMap = [5, 3, 4, 0] 最长递增子序列的值为 [3, 4], 对应到 newIndexToOldIndexMap 中的索引即 increasingNewIndexSequence = [1, 2]。关于具体的算法细节，我们后面再详细探讨。\n\nStep 2： 从尾部开始遍历新的子序列，在遍历的过程中，如果新子序列中的节点在旧子序列中不存在，也就是 newIndexToOldIndexMap[i] === 0，则新增节点。\n\nStep 3： 判断是否存在节点移动的情况，如果存在的话则看节点的索引是不是在最长递增子序列中，如果不在，则将它移动到锚点的前面，否则仅移动最长子序列的尾部指针。\n\n针对上述例子中，新的子序列为 e,c,d,i。最长递增子序列的索引为 [1, 2]。开始遍历到 i 节点时，因为 newIndexToOldIndexMap[i] = 0 所以新增，然后遍历到 c,d 节点，因为存在于最长子序列中，所以最后 j = -1。当遍历到 e 节点时，此时 j = -1 并且 e 节点不存在于最长递增子序列索引中，索引最后一步就是把节点 e 进行一次移动：\n\n```\nmove(nextChild, container, anchor, MoveType.REORDER)\n```\n\n其中 anchor 是参照物，记录着上一次更新的节点信息，也就是节点 c 的信息，所以这里的意思就是将节点 e 移动到节点 c 前面。\n\n至此，完成了所有节点的增、删、更新、移动的操作，此次操作结果如下：\n\nimage.png\n\n#### 最长递增子序列\n求最长递增子序列是 LeetCode 上的一道经典算法题，原题：300. 最长递增子序列。\n\n什么是上升子序列？简单来说指的是找到一个特定的最长的子序列，并且子序列中的所有元素单调递增。\n\n假设我们的序列为 [5, 3, 4, 9] ，那么最长的递增子序列是 [3, 4]。\n\n那么如何找到最长的递增子序列呢？Vue 内部使用的是一套 贪心 + 二分查找 的算法，关于贪心和二分查找的解释如下。\n\n贪心算法：贪心算法在每一步都做出了当时看起来最佳的选择，也就是说，它总是做出局部最优的选择，寄希望这样的选择能导致全局最优解。leetCode 455. 分发饼干。\n二分查找：每次的查找都是和区间的中间元素对比，将待查找的区间缩小为一半，直到找到目标元素，或者区间被缩小为 0（没找到）。leetCode 704. 二分查找。\n那么这里我们再结合一下贪心算法的思想，在求取最长上升子序列时，对于同样长度是二的序列 [2, 3] 一定比 [2, 5] 好，因为要想让子序列尽可能地长，那么上升得尽可能慢，这样潜力更大。\n\n所以我们可以创建一个临时数组，用来保存最长的递增子序列，如果当前遍历的元素大于临时数组中的最后一个元素（也就是临时数组的最大值）时，那么将其追加到临时数组的尾部，否则，查找临时数组，找到第一个大于该元素的数并替换它，这样就保证了临时数组上升时最慢的。因为是单调递增的序列，我们也可以在临时数组中用二分查找，降低时间复杂度。\n\n以输入序列 [1, 4, 5, 2, 8, 7, 6, 0] 为例，根据上面算法的描述，我们大致可以得到如下的计算步骤：\n\n[1]\n[1, 4]\n[1, 4, 5]\n[1, 2, 5]\n[1, 2, 5, 8]\n[1, 2, 5, 7]\n[0, 2, 5, 6]\n可以看到，如果单纯地按照上述算法的模式，得到的结果的长度虽然一致，但位置顺序和值并不符合预期，预期结果是 [1, 4, 5, 6]。那么在 Vue 中是如何解决这个顺序和值错乱的问题呢？\n\n我们一起来看看源码的实现：\n\n```typescript\nfunction getSequence (arr) {\n  const p = arr.slice()\n  const result = [0]\n  let i, j, u, v, c\n  const len = arr.length\n  for (i = 0; i < len; i++) {\n    const arrI = arr[i]\n    // 排除等于 0 的情况\n    if (arrI !== 0) {\n      j = result[result.length - 1]\n      // 与最后一项进行比较\n      if (arr[j] < arrI) {\n        // 存储在 result 更新前的最后一个索引的值\n        p[i] = j\n        result.push(i)\n        continue\n      }\n      u = 0\n      v = result.length - 1\n      // 二分搜索，查找比 arrI 小的节点，更新 result 的值\n      while (u < v) {\n        // 取整得到当前位置\n        c = ((u + v) / 2) | 0\n        if (arr[result[c]] < arrI) {\n          u = c + 1\n        }\n        else {\n          v = c\n        }\n      }\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          // 正确的结果\n          p[i] = result[u - 1]\n        }\n        // 有可能替换会导致结果不正确，需要一个新数组 p 记录正确的结果\n        result[u] = i\n      }\n    }\n  }\n  u = result.length\n  v = result[u - 1]\n\n  // 回溯数组 p，找到最终的索引\n  while (u-- > 0) {\n    result[u] = v\n    v = p[v]\n  }\n  return result\n}\n```\n\n其中 result 中存储的是长度为 i 的递增子序列最小末尾值的索引。p 是来存储在每次更新 result 前最后一个索引的值，并且它的 key 是这次要更新的 result 值：\n\n\n```\n // 插入\n p[i] = j\n result.push(i)\n // 替换\n p[i] = result[u - 1]\n result[u] = i\n```\n\n对于上述的实例，我们在进行最后一步回溯数组 p 之前，得到的数据机构如下：\n\n```\nresult = [ 0, 3, 2, 6 ] // => [0, 2, 5, 6]\n\np = [1, 0, 1, 0, 2, 2, 2]\n```\n\n从 result 最后一个元素 6 对应的索引 6 开始回溯，可以看到 p[6] = 2，p[2] = 1，p[1] = 0，所以通过对 p 的回溯，得到最终的 result 值是 [0, 1, 2, 6]，也就找到最长递增子序列的最终索引了。\n\n#### 总结\n至此我们介绍完了关于 Vue3 的 diff 算法。接下来小伙伴们可以思考两个问题：\n\n为什么 Vue 3 不再沿用之前 Vue 2 的双端 diff 算法而改成现在的这种模式呢？\n我们使用 v-for 编写列表时为什么不建议使用 index 作为 key?","source":"_drafts/technical-disclosure-of-vue3/patch-keyed-children.md","raw":"---\ntitle: 渲染器：数组子节点的 diff 算法\ncategories:\n  - Vue3 技术揭秘\n---\n\n#### 前言\n上一节，我们介绍了关于新旧子节点不同为数组的情况下的更新过程，下面将接着上节的内容继续介绍如果子节点都是数组的情况，那么更新过程会变成什么样呢？\n\n#### 1. 从头比对\nVue 3 的 diff 算法第一步就是进行新老节点从头比对的方式来判断是否是同类型的节点：\n\n```typescript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  let i = 0\n  const l2 = c2.length\n  // 旧节点的尾部标记位\n  let e1 = c1.length - 1\n  // 新节点的尾部标记位\n  let e2 = l2 - 1\n  // 从头部开始比对\n  // (a b) c\n  // (a b) d e\n  while (i <= e1 && i <= e2) {\n    const n1 = c1[i]\n    const n2 = (c2[i] = optimized\n      ? cloneIfMounted(c2[i] as VNode)\n      : normalizeVNode(c2[i]))\n    // 如果是 sameVnode 则递归执行 patch  \n    if (isSameVNodeType(n1, n2)) {\n      patch(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized)\n    } else {\n      break\n    }\n    i++\n  }\n}\n```\n\n这里有几个变量需要说明一下：\n\ni 代表的是头部的标记位；\ne1 代表的是旧的子节点的尾部标记位；\ne2 代表的是新的子节点的尾部标记位。\n从头比对就是通过不断移动 i 这个头部标记位来判断对应的节点是否是 sameVnode。如果是，则进行递归 patch 操作，递归 patch 就是继续进入到我们上一小节的内容。如果不满足条件，则退出头部比对，进入从尾比对流程。\n\n#### 2. 从尾比对\n\n```typescript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  let i = 0\n  const l2 = c2.length\n  // 旧节点的尾部标记位\n  let e1 = c1.length - 1\n  // 新节点的尾部标记位\n  let e2 = l2 - 1\n  // 从头部开始比对\n  // ...\n  // 从尾部开始比对\n  // a (b c)\n  // d e (b c)\n  while (i <= e1 && i <= e2) {\n    const n1 = c1[e1]\n    const n2 = (c2[e2] = optimized\n      ? cloneIfMounted(c2[e2] as VNode)\n      : normalizeVNode(c2[e2]))\n    // 如果是 sameVnode 则递归执行 patch  \n    if (isSameVNodeType(n1, n2)) {\n      patch(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized)\n    } else {\n      break\n    }\n    e1--\n    e2--\n  }\n}\n```\n从尾比对就是通过不断移动新旧节点 e1 和 e2 的尾部指针来判断对应的节点是否是 sameVnode。如果是则进行递归 patch 操作，递归 patch 也是继续进入到我们上一小节的内容。如果不满足条件，则退出头部比对，进入后续流程。\n\n####　3. 新增节点\n假设我们有这样一个旧列表：\n\n```html\n<ul>\n  <li key=\"a\">a</li>\n  <li key=\"b\">b</li>\n  <li key=\"c\">c</li>\n  <li key=\"d\">d</li>\n</ul>\n```\n\n新列表的变更是在中间插入了一个新节点：\n\n```html\n<ul>\n  <li key=\"a\">a</li>\n  <li key=\"b\">b</li>\n  <li key=\"b\">e</li>\n  <li key=\"c\">c</li>\n  <li key=\"d\">d</li>\n</ul>\n```\n\n那么先进入第一步头部比对流程：\n\nimage.png\n\n第一步执行时，会完成对 a 和 b 头部这 2 个节点进行 patch。当 i = 2 时，由于此时的 c 和 e 节点的 key 不一样，所以退出了头部比对流程，进入尾部比对：\n\nimage.png\n\n第二步执行时，会完成对 c 和 d 尾部这 2 个节点进行 patch。当 e1 = 1 时，由于i > e1，所以退出了尾部比对流程。肉眼可见，此时的情况是新节点多了个 e 节点的情况，所以我们需要添加多余的剩余节点：\n\n\n```typescript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  let i = 0\n  const l2 = c2.length\n  // 旧节点的尾部标记位\n  let e1 = c1.length - 1\n  // 新节点的尾部标记位\n  let e2 = l2 - 1\n  // 从头部开始必须\n  // ...\n  // 从尾部开始比对\n  // ...\n  // 如果有多余的新节点，则执行新增逻辑\n  if (i > e1) {\n    if (i <= e2) {\n      const nextPos = e2 + 1\n      const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor\n      while (i <= e2) {\n        // 新增新节点\n        patch(null, c2[i], container, anchor, parentComponent, parentSuspense, isSVG)\n        i++\n      }\n    }\n  }\n}\n```\n\n#### 4. 删除节点\n类比新增节点的情况，假设我们有这样一个旧列表：\n\n```html\n<ul>\n  <li key=\"a\">a</li>\n  <li key=\"b\">b</li>\n  <li key=\"b\">e</li>\n  <li key=\"c\">c</li>\n  <li key=\"d\">d</li>\n</ul>\n```\n\n新列表的变更是在中间删除了一个旧节点：\n\n```html\n<ul>\n  <li key=\"a\">a</li>\n  <li key=\"b\">b</li>\n  <li key=\"c\">c</li>\n  <li key=\"d\">d</li>\n</ul>\n```\n那么先进入第一步头部比对流程：\n\nimage.png\n\n第一步执行时，会完成对 a 和 b 头部这 2 个节点进行 patch。当 i = 2 时，由于此时的 e 和 c 节点的 key 不一样，所以退出了头部比对流程，进入尾部比对：\n\nimage.png\n\n第二步执行时，会完成对 c 和 d 尾部这 2 个节点进行 patch。当 e2 = 1 时，由于i > e2，所以退出了尾部比对流程。肉眼可见，此时的情况是新节点少了个 e 节点的情况，所以我们需要删除节点 e：\n\n```typescript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  let i = 0\n  const l2 = c2.length\n  // 旧节点的尾部标记位\n  let e1 = c1.length - 1\n  // 新节点的尾部标记位\n  let e2 = l2 - 1\n  // 从头部开始比对\n  // ...\n  // 从尾部开始比对\n  // ...\n  // 如果有多余的新节点，则执行新增逻辑\n  // ...\n  // 如果有多余的旧节点，则执行卸载逻辑\n  else if (i > e2) {\n    while (i <= e1) {\n      // 卸载节点\n      unmount(c1[i], parentComponent, parentSuspense, true)\n      i++\n    }\n  }\n}\n```\n\n#### 5. 未知子序列\n经过步骤 1、2 的操作后如果可以直接进入步骤 3、4 那是非常方便的操作了，直接进行多余删除缺少新增的操作。如果步骤 3、4 的条件都不满足的情况，那么 Vue 是如何处理的呢？再来看这样一个例子。\n\n旧子节点：\n\n```html\n<ul>\n  <li key=\"a\">a</li>\n  <li key=\"b\">b</li>\n  <li key=\"c\">c</li>\n  <li key=\"d\">d</li>\n  <li key=\"e\">e</li>\n  <li key=\"f\">f</li>\n  <li key=\"g\">g</li>\n  <li key=\"h\">h</li>\n</ul>\n```\n\n新子节点：\n\n```html\n<ul>\n  <li key=\"a\">a</li>\n  <li key=\"b\">b</li>\n  <li key=\"e\">e</li>\n  <li key=\"c\">c</li>\n  <li key=\"d\">d</li>\n  <li key=\"i\">i</li>\n  <li key=\"g\">g</li>\n  <li key=\"h\">h</li>\n</ul>\n```\n\n此时经过步骤 1、2 后的结果可以表示为如下图：\n\nimage.png\n\n这种情况，既不满足 i > e1 也不满足 i > e2 的条件，所以对于这种情况应该如何处理呢？我们知道 DOM 更新的性能优劣关系大致为：属性更新 > 位置移动 > 增删节点。所以，我们需要尽可能地复用老节点，做属性更新，减少移动次数和增删节点的次数。\n\n那么上述更新策略假设有这样 2 种方式。\n\nc 和 d 节点不动，只做 patch，e 节点 patch 后移动到 c 节点前面，删除 f 节点，然后在 d 节点后面添加 i 节点。\ne 节点不动，只做 patch，c 和 d 节点 patch 后移动到 e 节点后面，删除 f 节点，然后在 d 节点后面添加 i 节点。\n根据上面的性能优劣关系，我们需要尽可能多地保障最多的公共子节点位置不变，只做 patch 更新。然后找出多余的节点删除，找出新的节点添加，找出有需要移动的节点移动。\n\n当需要进行移动操作时，那么这个问题就变成了求取新旧子树上的最长公共子序列。当知道了最长公共子序列，所有的操作就可以简化为：\n\n如果节点在新节点中，不在旧节点中，那么新增节点。\n如果节点在旧节点中，不在新节点中，那么删除节点。\n如果节点既在旧节点中，也在新节点中，那么更新。\n如果节点需要移动，那么求取最长公共子序列后，进行最小位置移动。\n接下来看看 Vue 是如何实现上述能力的。\n\n#### 构造新老节点位置映射 keyToNewIndexMap\n\n```typescript\n// 旧子序列开始位置\nconst s1 = i\n// 新子序列开始位置\nconst s2 = i\n\n// 5.1 构建 key:index 关系索引 map\nconst keyToNewIndexMap = new Map()\nfor (i = s2; i <= e2; i++) {\n  const nextChild = (c2[i] = optimized\n    ? cloneIfMounted(c2[i] as VNode)\n    : normalizeVNode(c2[i]))\n  if (nextChild.key != null) {\n    keyToNewIndexMap.set(nextChild.key, i)\n  }\n}\n```\n\n这里的新旧子节点开始位置通过 s1 和 s2 作为标记，然后开始进行构造新老节点位置映射，这里新节点 key -> index 关系的索引图是保存在了 keyToNewIndexMap 这样一个 Map 结构中，其中的 key 就是新节点的 key 值，而 value 则是旧节点对应的位置关系 index。这一步完成后，生成的 keyToNewIndexMap 结果可以表示为：\n\n```typescript\nkeyToNewIndexMap = {e: 2, c: 3, d: 4, i: 5}\n```\n\nimage.png\n\n#### 继续处理旧节点\n有了上面的 keyToNewIndexMap 新节点的索引图，接下来我们就需要遍历旧的节点，寻找旧节点在新节点中对应的位置信息，如果找到则做更新，找不到则移除。\n\n```typescript\n// 记录新节点已更新的数目\nlet patched = 0\n// 记录新节点还有多少个没有更新\nconst toBePatched = e2 - s2 + 1\n// 标记是否有必要进行节点的位置移动\nlet moved = false\n// 标记是否有节点进行了位置移动\nlet maxNewIndexSoFar = 0\n// 记录新节点在旧节点中的位置数组\nconst newIndexToOldIndexMap = new Array(toBePatched)\n// newIndexToOldIndexMap 全部置为 0\nfor (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0\n// 开始遍历旧子节点\nfor (i = s1; i <= e1; i++) {\n  // prevChild 代表旧节点\n  const prevChild = c1[i]\n  // 还有多余的旧节点，则删除\n  if (patched >= toBePatched) {\n    unmount(prevChild, parentComponent, parentSuspense, true)\n    continue\n  }\n  // 记录旧节点在新节点中的位置数组\n  let newIndex = keyToNewIndexMap.get(prevChild.key)\n  \n  // 如果旧节点不存在于新节点中，则删除该节点\n  if (newIndex === undefined) {\n    unmount(prevChild, parentComponent, parentSuspense, true)\n  } else {\n    // newIndexToOldIndexMap 中元素为 0 表示着新节点不存在于旧节点中\n    newIndexToOldIndexMap[newIndex - s2] = i + 1\n    // 默认不移动的话，所有相同节点都是增序排列的\n    // 如果有移动，必然出现节点降序的情况\n    if (newIndex >= maxNewIndexSoFar) {\n      maxNewIndexSoFar = newIndex\n    } else {\n      moved = true\n    }\n    // 更新节点\n    patch(\n      prevChild,\n      c2[newIndex] as VNode,\n      container,\n      null,\n      parentComponent,\n      parentSuspense,\n      isSVG,\n      slotScopeIds,\n      optimized\n    )\n    // 记录更新的数量\n    patched++\n  }\n}\n```\n\n我们简单来总结一下这一步的一些核心操作。\n\nStep 1： 定义一个初始长度为新节点数组长度且默认值全为 0 的变量 newIndexToOldIndexMap，记录新节点中的元素在旧节点中的位置关系。\n\nStep 2： 遍历旧的节点数组，如果旧节点不存在于新节点中，则表示旧的节点其实是多余的节点，需要被移除。\n\nStep 3： 如果旧节点存在于新节点数组中，则将它在旧子序列中的位置信息记录到 newIndexToOldIndexMap 中，同时根据 newIndex 是否大于 maxNewIndexSoFar 来判断是否有节点移动。\n\n这里我们结合个例子来说明。假如旧节点信息为 abc、新节点为 cab，当旧节点遍历到 c 节点时，此时的newIndex 的值为 0 而 maxNewIndexSoFar 的值为 2。这就意味着此时的 c 节点并不是升序位于 ab 节点之后的，因此需要标记为有需要移动的节点。\n\nStep 4： 更新相同节点。\n\n经过上面的一系列操作，我们最终得到了一个 newIndexToOldIndexMap 和一个 moved 两个变量 ，这两个变量将在下文的移动和新增节点中被使用。\n\n我们来看一下示例处理后的结果，如下图所示：\n\nimage.png\n\n此时 c、d、e 因为是相同节点，所以进行 patch 更新，f 节点因为不存在于新的索引中，所以被删除。最后得到的 newIndexToOldIndexMap 数据结构大致如下：\n\n```\nnewIndexToOldIndexMap = [5, 3, 4, 0]\n```\n\n而且此时的 moved 也被标记为 true。\n\n#### 移动和增加新节点\n通过前面的操作，我们完成了对旧节点的移除和更新，那么接下来就是需要进行对节点的移动和新节点的增加了：\n\n```typescript\n// 根据 newIndexToOldIndexMap 求取最长公共子序列\nconst increasingNewIndexSequence = moved\n  ? getSequence(newIndexToOldIndexMap)\n  : EMPTY_ARR\n// 最长公共子序列尾部索引  \nj = increasingNewIndexSequence.length - 1\n// 从尾部开始遍历\nfor (i = toBePatched - 1; i >= 0; i--) {\n  const nextIndex = s2 + i\n  const nextChild = c2[nextIndex]\n  const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor\n  // 如果新子序列中的节点在旧子序列中不存在，则新增节点\n  if (newIndexToOldIndexMap[i] === 0) {\n    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG)\n  } else if (moved) {\n    // 如果需要移动且\n    // 没有最长递增子序列\n    // 当前的节点不在最长递增子序列中\n    if (j < 0 || i !== increasingNewIndexSequence[j]) {\n      move(nextChild, container, anchor, MoveType.REORDER)\n    } else {\n      j--\n    }\n  }\n}\n```\n\nStep 1： 这里针对 moved 是 true 的情况，则会进行求取最长递增子序列的索引操作。\n\n什么是最长递增子序列？简单来说指的是找到一个特定的最长的子序列，并且子序列中的所有元素单调递增。本例中，newIndexToOldIndexMap = [5, 3, 4, 0] 最长递增子序列的值为 [3, 4], 对应到 newIndexToOldIndexMap 中的索引即 increasingNewIndexSequence = [1, 2]。关于具体的算法细节，我们后面再详细探讨。\n\nStep 2： 从尾部开始遍历新的子序列，在遍历的过程中，如果新子序列中的节点在旧子序列中不存在，也就是 newIndexToOldIndexMap[i] === 0，则新增节点。\n\nStep 3： 判断是否存在节点移动的情况，如果存在的话则看节点的索引是不是在最长递增子序列中，如果不在，则将它移动到锚点的前面，否则仅移动最长子序列的尾部指针。\n\n针对上述例子中，新的子序列为 e,c,d,i。最长递增子序列的索引为 [1, 2]。开始遍历到 i 节点时，因为 newIndexToOldIndexMap[i] = 0 所以新增，然后遍历到 c,d 节点，因为存在于最长子序列中，所以最后 j = -1。当遍历到 e 节点时，此时 j = -1 并且 e 节点不存在于最长递增子序列索引中，索引最后一步就是把节点 e 进行一次移动：\n\n```\nmove(nextChild, container, anchor, MoveType.REORDER)\n```\n\n其中 anchor 是参照物，记录着上一次更新的节点信息，也就是节点 c 的信息，所以这里的意思就是将节点 e 移动到节点 c 前面。\n\n至此，完成了所有节点的增、删、更新、移动的操作，此次操作结果如下：\n\nimage.png\n\n#### 最长递增子序列\n求最长递增子序列是 LeetCode 上的一道经典算法题，原题：300. 最长递增子序列。\n\n什么是上升子序列？简单来说指的是找到一个特定的最长的子序列，并且子序列中的所有元素单调递增。\n\n假设我们的序列为 [5, 3, 4, 9] ，那么最长的递增子序列是 [3, 4]。\n\n那么如何找到最长的递增子序列呢？Vue 内部使用的是一套 贪心 + 二分查找 的算法，关于贪心和二分查找的解释如下。\n\n贪心算法：贪心算法在每一步都做出了当时看起来最佳的选择，也就是说，它总是做出局部最优的选择，寄希望这样的选择能导致全局最优解。leetCode 455. 分发饼干。\n二分查找：每次的查找都是和区间的中间元素对比，将待查找的区间缩小为一半，直到找到目标元素，或者区间被缩小为 0（没找到）。leetCode 704. 二分查找。\n那么这里我们再结合一下贪心算法的思想，在求取最长上升子序列时，对于同样长度是二的序列 [2, 3] 一定比 [2, 5] 好，因为要想让子序列尽可能地长，那么上升得尽可能慢，这样潜力更大。\n\n所以我们可以创建一个临时数组，用来保存最长的递增子序列，如果当前遍历的元素大于临时数组中的最后一个元素（也就是临时数组的最大值）时，那么将其追加到临时数组的尾部，否则，查找临时数组，找到第一个大于该元素的数并替换它，这样就保证了临时数组上升时最慢的。因为是单调递增的序列，我们也可以在临时数组中用二分查找，降低时间复杂度。\n\n以输入序列 [1, 4, 5, 2, 8, 7, 6, 0] 为例，根据上面算法的描述，我们大致可以得到如下的计算步骤：\n\n[1]\n[1, 4]\n[1, 4, 5]\n[1, 2, 5]\n[1, 2, 5, 8]\n[1, 2, 5, 7]\n[0, 2, 5, 6]\n可以看到，如果单纯地按照上述算法的模式，得到的结果的长度虽然一致，但位置顺序和值并不符合预期，预期结果是 [1, 4, 5, 6]。那么在 Vue 中是如何解决这个顺序和值错乱的问题呢？\n\n我们一起来看看源码的实现：\n\n```typescript\nfunction getSequence (arr) {\n  const p = arr.slice()\n  const result = [0]\n  let i, j, u, v, c\n  const len = arr.length\n  for (i = 0; i < len; i++) {\n    const arrI = arr[i]\n    // 排除等于 0 的情况\n    if (arrI !== 0) {\n      j = result[result.length - 1]\n      // 与最后一项进行比较\n      if (arr[j] < arrI) {\n        // 存储在 result 更新前的最后一个索引的值\n        p[i] = j\n        result.push(i)\n        continue\n      }\n      u = 0\n      v = result.length - 1\n      // 二分搜索，查找比 arrI 小的节点，更新 result 的值\n      while (u < v) {\n        // 取整得到当前位置\n        c = ((u + v) / 2) | 0\n        if (arr[result[c]] < arrI) {\n          u = c + 1\n        }\n        else {\n          v = c\n        }\n      }\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          // 正确的结果\n          p[i] = result[u - 1]\n        }\n        // 有可能替换会导致结果不正确，需要一个新数组 p 记录正确的结果\n        result[u] = i\n      }\n    }\n  }\n  u = result.length\n  v = result[u - 1]\n\n  // 回溯数组 p，找到最终的索引\n  while (u-- > 0) {\n    result[u] = v\n    v = p[v]\n  }\n  return result\n}\n```\n\n其中 result 中存储的是长度为 i 的递增子序列最小末尾值的索引。p 是来存储在每次更新 result 前最后一个索引的值，并且它的 key 是这次要更新的 result 值：\n\n\n```\n // 插入\n p[i] = j\n result.push(i)\n // 替换\n p[i] = result[u - 1]\n result[u] = i\n```\n\n对于上述的实例，我们在进行最后一步回溯数组 p 之前，得到的数据机构如下：\n\n```\nresult = [ 0, 3, 2, 6 ] // => [0, 2, 5, 6]\n\np = [1, 0, 1, 0, 2, 2, 2]\n```\n\n从 result 最后一个元素 6 对应的索引 6 开始回溯，可以看到 p[6] = 2，p[2] = 1，p[1] = 0，所以通过对 p 的回溯，得到最终的 result 值是 [0, 1, 2, 6]，也就找到最长递增子序列的最终索引了。\n\n#### 总结\n至此我们介绍完了关于 Vue3 的 diff 算法。接下来小伙伴们可以思考两个问题：\n\n为什么 Vue 3 不再沿用之前 Vue 2 的双端 diff 算法而改成现在的这种模式呢？\n我们使用 v-for 编写列表时为什么不建议使用 index 作为 key?","slug":"technical-disclosure-of-vue3/patch-keyed-children","published":0,"date":"2023-08-12T07:53:19.989Z","updated":"2023-08-12T07:53:19.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokp0011sovc21hphbfw","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>上一节，我们介绍了关于新旧子节点不同为数组的情况下的更新过程，下面将接着上节的内容继续介绍如果子节点都是数组的情况，那么更新过程会变成什么样呢？</p>\n<h4 id=\"1-从头比对\"><a href=\"#1-从头比对\" class=\"headerlink\" title=\"1. 从头比对\"></a>1. 从头比对</h4><p>Vue 3 的 diff 算法第一步就是进行新老节点从头比对的方式来判断是否是同类型的节点：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchKeyedChildren</span> = (<span class=\"params\">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> l2 = c2.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"comment\">// 旧节点的尾部标记位</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> e1 = c1.<span class=\"property\">length</span> - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\">// 新节点的尾部标记位</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> e2 = l2 - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\">// 从头部开始比对</span></span><br><span class=\"line\">  <span class=\"comment\">// (a b) c</span></span><br><span class=\"line\">  <span class=\"comment\">// (a b) d e</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> n1 = c1[i]</span><br><span class=\"line\">    <span class=\"keyword\">const</span> n2 = (c2[i] = optimized</span><br><span class=\"line\">      ? <span class=\"title function_\">cloneIfMounted</span>(c2[i] <span class=\"keyword\">as</span> <span class=\"title class_\">VNode</span>)</span><br><span class=\"line\">      : <span class=\"title function_\">normalizeVNode</span>(c2[i]))</span><br><span class=\"line\">    <span class=\"comment\">// 如果是 sameVnode 则递归执行 patch  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title function_\">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">patch</span>(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里有几个变量需要说明一下：</p>\n<p>i 代表的是头部的标记位；<br>e1 代表的是旧的子节点的尾部标记位；<br>e2 代表的是新的子节点的尾部标记位。<br>从头比对就是通过不断移动 i 这个头部标记位来判断对应的节点是否是 sameVnode。如果是，则进行递归 patch 操作，递归 patch 就是继续进入到我们上一小节的内容。如果不满足条件，则退出头部比对，进入从尾比对流程。</p>\n<h4 id=\"2-从尾比对\"><a href=\"#2-从尾比对\" class=\"headerlink\" title=\"2. 从尾比对\"></a>2. 从尾比对</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchKeyedChildren</span> = (<span class=\"params\">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> l2 = c2.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"comment\">// 旧节点的尾部标记位</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> e1 = c1.<span class=\"property\">length</span> - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\">// 新节点的尾部标记位</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> e2 = l2 - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\">// 从头部开始比对</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 从尾部开始比对</span></span><br><span class=\"line\">  <span class=\"comment\">// a (b c)</span></span><br><span class=\"line\">  <span class=\"comment\">// d e (b c)</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> n1 = c1[e1]</span><br><span class=\"line\">    <span class=\"keyword\">const</span> n2 = (c2[e2] = optimized</span><br><span class=\"line\">      ? <span class=\"title function_\">cloneIfMounted</span>(c2[e2] <span class=\"keyword\">as</span> <span class=\"title class_\">VNode</span>)</span><br><span class=\"line\">      : <span class=\"title function_\">normalizeVNode</span>(c2[e2]))</span><br><span class=\"line\">    <span class=\"comment\">// 如果是 sameVnode 则递归执行 patch  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title function_\">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">patch</span>(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    e1--</span><br><span class=\"line\">    e2--</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从尾比对就是通过不断移动新旧节点 e1 和 e2 的尾部指针来判断对应的节点是否是 sameVnode。如果是则进行递归 patch 操作，递归 patch 也是继续进入到我们上一小节的内容。如果不满足条件，则退出头部比对，进入后续流程。</p>\n<h4 id=\"3-新增节点\"><a href=\"#3-新增节点\" class=\"headerlink\" title=\"3. 新增节点\"></a>3. 新增节点</h4><p>假设我们有这样一个旧列表：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;a&quot;</span>&gt;</span>a<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;b&quot;</span>&gt;</span>b<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;c&quot;</span>&gt;</span>c<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;d&quot;</span>&gt;</span>d<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>新列表的变更是在中间插入了一个新节点：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;a&quot;</span>&gt;</span>a<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;b&quot;</span>&gt;</span>b<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;b&quot;</span>&gt;</span>e<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;c&quot;</span>&gt;</span>c<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;d&quot;</span>&gt;</span>d<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>那么先进入第一步头部比对流程：</p>\n<p>image.png</p>\n<p>第一步执行时，会完成对 a 和 b 头部这 2 个节点进行 patch。当 i &#x3D; 2 时，由于此时的 c 和 e 节点的 key 不一样，所以退出了头部比对流程，进入尾部比对：</p>\n<p>image.png</p>\n<p>第二步执行时，会完成对 c 和 d 尾部这 2 个节点进行 patch。当 e1 &#x3D; 1 时，由于i &gt; e1，所以退出了尾部比对流程。肉眼可见，此时的情况是新节点多了个 e 节点的情况，所以我们需要添加多余的剩余节点：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchKeyedChildren</span> = (<span class=\"params\">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> l2 = c2.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"comment\">// 旧节点的尾部标记位</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> e1 = c1.<span class=\"property\">length</span> - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\">// 新节点的尾部标记位</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> e2 = l2 - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\">// 从头部开始必须</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 从尾部开始比对</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果有多余的新节点，则执行新增逻辑</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt; e1) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt;= e2) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nextPos = e2 + <span class=\"number\">1</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> anchor = nextPos &lt; l2 ? c2[nextPos].<span class=\"property\">el</span> : parentAnchor</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (i &lt;= e2) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 新增新节点</span></span><br><span class=\"line\">        <span class=\"title function_\">patch</span>(<span class=\"literal\">null</span>, c2[i], container, anchor, parentComponent, parentSuspense, isSVG)</span><br><span class=\"line\">        i++</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-删除节点\"><a href=\"#4-删除节点\" class=\"headerlink\" title=\"4. 删除节点\"></a>4. 删除节点</h4><p>类比新增节点的情况，假设我们有这样一个旧列表：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;a&quot;</span>&gt;</span>a<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;b&quot;</span>&gt;</span>b<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;b&quot;</span>&gt;</span>e<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;c&quot;</span>&gt;</span>c<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;d&quot;</span>&gt;</span>d<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>新列表的变更是在中间删除了一个旧节点：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;a&quot;</span>&gt;</span>a<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;b&quot;</span>&gt;</span>b<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;c&quot;</span>&gt;</span>c<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;d&quot;</span>&gt;</span>d<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>那么先进入第一步头部比对流程：</p>\n<p>image.png</p>\n<p>第一步执行时，会完成对 a 和 b 头部这 2 个节点进行 patch。当 i &#x3D; 2 时，由于此时的 e 和 c 节点的 key 不一样，所以退出了头部比对流程，进入尾部比对：</p>\n<p>image.png</p>\n<p>第二步执行时，会完成对 c 和 d 尾部这 2 个节点进行 patch。当 e2 &#x3D; 1 时，由于i &gt; e2，所以退出了尾部比对流程。肉眼可见，此时的情况是新节点少了个 e 节点的情况，所以我们需要删除节点 e：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchKeyedChildren</span> = (<span class=\"params\">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> l2 = c2.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"comment\">// 旧节点的尾部标记位</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> e1 = c1.<span class=\"property\">length</span> - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\">// 新节点的尾部标记位</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> e2 = l2 - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\">// 从头部开始比对</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 从尾部开始比对</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果有多余的新节点，则执行新增逻辑</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果有多余的旧节点，则执行卸载逻辑</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &gt; e2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= e1) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 卸载节点</span></span><br><span class=\"line\">      <span class=\"title function_\">unmount</span>(c1[i], parentComponent, parentSuspense, <span class=\"literal\">true</span>)</span><br><span class=\"line\">      i++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-未知子序列\"><a href=\"#5-未知子序列\" class=\"headerlink\" title=\"5. 未知子序列\"></a>5. 未知子序列</h4><p>经过步骤 1、2 的操作后如果可以直接进入步骤 3、4 那是非常方便的操作了，直接进行多余删除缺少新增的操作。如果步骤 3、4 的条件都不满足的情况，那么 Vue 是如何处理的呢？再来看这样一个例子。</p>\n<p>旧子节点：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;a&quot;</span>&gt;</span>a<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;b&quot;</span>&gt;</span>b<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;c&quot;</span>&gt;</span>c<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;d&quot;</span>&gt;</span>d<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;e&quot;</span>&gt;</span>e<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;f&quot;</span>&gt;</span>f<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;g&quot;</span>&gt;</span>g<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;h&quot;</span>&gt;</span>h<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>新子节点：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;a&quot;</span>&gt;</span>a<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;b&quot;</span>&gt;</span>b<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;e&quot;</span>&gt;</span>e<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;c&quot;</span>&gt;</span>c<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;d&quot;</span>&gt;</span>d<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;i&quot;</span>&gt;</span>i<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;g&quot;</span>&gt;</span>g<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;h&quot;</span>&gt;</span>h<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>此时经过步骤 1、2 后的结果可以表示为如下图：</p>\n<p>image.png</p>\n<p>这种情况，既不满足 i &gt; e1 也不满足 i &gt; e2 的条件，所以对于这种情况应该如何处理呢？我们知道 DOM 更新的性能优劣关系大致为：属性更新 &gt; 位置移动 &gt; 增删节点。所以，我们需要尽可能地复用老节点，做属性更新，减少移动次数和增删节点的次数。</p>\n<p>那么上述更新策略假设有这样 2 种方式。</p>\n<p>c 和 d 节点不动，只做 patch，e 节点 patch 后移动到 c 节点前面，删除 f 节点，然后在 d 节点后面添加 i 节点。<br>e 节点不动，只做 patch，c 和 d 节点 patch 后移动到 e 节点后面，删除 f 节点，然后在 d 节点后面添加 i 节点。<br>根据上面的性能优劣关系，我们需要尽可能多地保障最多的公共子节点位置不变，只做 patch 更新。然后找出多余的节点删除，找出新的节点添加，找出有需要移动的节点移动。</p>\n<p>当需要进行移动操作时，那么这个问题就变成了求取新旧子树上的最长公共子序列。当知道了最长公共子序列，所有的操作就可以简化为：</p>\n<p>如果节点在新节点中，不在旧节点中，那么新增节点。<br>如果节点在旧节点中，不在新节点中，那么删除节点。<br>如果节点既在旧节点中，也在新节点中，那么更新。<br>如果节点需要移动，那么求取最长公共子序列后，进行最小位置移动。<br>接下来看看 Vue 是如何实现上述能力的。</p>\n<h4 id=\"构造新老节点位置映射-keyToNewIndexMap\"><a href=\"#构造新老节点位置映射-keyToNewIndexMap\" class=\"headerlink\" title=\"构造新老节点位置映射 keyToNewIndexMap\"></a>构造新老节点位置映射 keyToNewIndexMap</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 旧子序列开始位置</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> s1 = i</span><br><span class=\"line\"><span class=\"comment\">// 新子序列开始位置</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> s2 = i</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5.1 构建 key:index 关系索引 map</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> keyToNewIndexMap = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>()</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = s2; i &lt;= e2; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nextChild = (c2[i] = optimized</span><br><span class=\"line\">    ? <span class=\"title function_\">cloneIfMounted</span>(c2[i] <span class=\"keyword\">as</span> <span class=\"title class_\">VNode</span>)</span><br><span class=\"line\">    : <span class=\"title function_\">normalizeVNode</span>(c2[i]))</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nextChild.<span class=\"property\">key</span> != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    keyToNewIndexMap.<span class=\"title function_\">set</span>(nextChild.<span class=\"property\">key</span>, i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的新旧子节点开始位置通过 s1 和 s2 作为标记，然后开始进行构造新老节点位置映射，这里新节点 key -&gt; index 关系的索引图是保存在了 keyToNewIndexMap 这样一个 Map 结构中，其中的 key 就是新节点的 key 值，而 value 则是旧节点对应的位置关系 index。这一步完成后，生成的 keyToNewIndexMap 结果可以表示为：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">keyToNewIndexMap = &#123;<span class=\"attr\">e</span>: <span class=\"number\">2</span>, <span class=\"attr\">c</span>: <span class=\"number\">3</span>, <span class=\"attr\">d</span>: <span class=\"number\">4</span>, <span class=\"attr\">i</span>: <span class=\"number\">5</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>image.png</p>\n<h4 id=\"继续处理旧节点\"><a href=\"#继续处理旧节点\" class=\"headerlink\" title=\"继续处理旧节点\"></a>继续处理旧节点</h4><p>有了上面的 keyToNewIndexMap 新节点的索引图，接下来我们就需要遍历旧的节点，寻找旧节点在新节点中对应的位置信息，如果找到则做更新，找不到则移除。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 记录新节点已更新的数目</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> patched = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">// 记录新节点还有多少个没有更新</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> toBePatched = e2 - s2 + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">// 标记是否有必要进行节点的位置移动</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> moved = <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\">// 标记是否有节点进行了位置移动</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> maxNewIndexSoFar = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">// 记录新节点在旧节点中的位置数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> newIndexToOldIndexMap = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(toBePatched)</span><br><span class=\"line\"><span class=\"comment\">// newIndexToOldIndexMap 全部置为 0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">// 开始遍历旧子节点</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = s1; i &lt;= e1; i++) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// prevChild 代表旧节点</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> prevChild = c1[i]</span><br><span class=\"line\">  <span class=\"comment\">// 还有多余的旧节点，则删除</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (patched &gt;= toBePatched) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">unmount</span>(prevChild, parentComponent, parentSuspense, <span class=\"literal\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">continue</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 记录旧节点在新节点中的位置数组</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> newIndex = keyToNewIndexMap.<span class=\"title function_\">get</span>(prevChild.<span class=\"property\">key</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 如果旧节点不存在于新节点中，则删除该节点</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newIndex === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">unmount</span>(prevChild, parentComponent, parentSuspense, <span class=\"literal\">true</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// newIndexToOldIndexMap 中元素为 0 表示着新节点不存在于旧节点中</span></span><br><span class=\"line\">    newIndexToOldIndexMap[newIndex - s2] = i + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\">// 默认不移动的话，所有相同节点都是增序排列的</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果有移动，必然出现节点降序的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class=\"line\">      maxNewIndexSoFar = newIndex</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      moved = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 更新节点</span></span><br><span class=\"line\">    <span class=\"title function_\">patch</span>(</span><br><span class=\"line\">      prevChild,</span><br><span class=\"line\">      c2[newIndex] <span class=\"keyword\">as</span> <span class=\"title class_\">VNode</span>,</span><br><span class=\"line\">      container,</span><br><span class=\"line\">      <span class=\"literal\">null</span>,</span><br><span class=\"line\">      parentComponent,</span><br><span class=\"line\">      parentSuspense,</span><br><span class=\"line\">      isSVG,</span><br><span class=\"line\">      slotScopeIds,</span><br><span class=\"line\">      optimized</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"comment\">// 记录更新的数量</span></span><br><span class=\"line\">    patched++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们简单来总结一下这一步的一些核心操作。</p>\n<p>Step 1： 定义一个初始长度为新节点数组长度且默认值全为 0 的变量 newIndexToOldIndexMap，记录新节点中的元素在旧节点中的位置关系。</p>\n<p>Step 2： 遍历旧的节点数组，如果旧节点不存在于新节点中，则表示旧的节点其实是多余的节点，需要被移除。</p>\n<p>Step 3： 如果旧节点存在于新节点数组中，则将它在旧子序列中的位置信息记录到 newIndexToOldIndexMap 中，同时根据 newIndex 是否大于 maxNewIndexSoFar 来判断是否有节点移动。</p>\n<p>这里我们结合个例子来说明。假如旧节点信息为 abc、新节点为 cab，当旧节点遍历到 c 节点时，此时的newIndex 的值为 0 而 maxNewIndexSoFar 的值为 2。这就意味着此时的 c 节点并不是升序位于 ab 节点之后的，因此需要标记为有需要移动的节点。</p>\n<p>Step 4： 更新相同节点。</p>\n<p>经过上面的一系列操作，我们最终得到了一个 newIndexToOldIndexMap 和一个 moved 两个变量 ，这两个变量将在下文的移动和新增节点中被使用。</p>\n<p>我们来看一下示例处理后的结果，如下图所示：</p>\n<p>image.png</p>\n<p>此时 c、d、e 因为是相同节点，所以进行 patch 更新，f 节点因为不存在于新的索引中，所以被删除。最后得到的 newIndexToOldIndexMap 数据结构大致如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">newIndexToOldIndexMap = [5, 3, 4, 0]</span><br></pre></td></tr></table></figure>\n\n<p>而且此时的 moved 也被标记为 true。</p>\n<h4 id=\"移动和增加新节点\"><a href=\"#移动和增加新节点\" class=\"headerlink\" title=\"移动和增加新节点\"></a>移动和增加新节点</h4><p>通过前面的操作，我们完成了对旧节点的移除和更新，那么接下来就是需要进行对节点的移动和新节点的增加了：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根据 newIndexToOldIndexMap 求取最长公共子序列</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> increasingNewIndexSequence = moved</span><br><span class=\"line\">  ? <span class=\"title function_\">getSequence</span>(newIndexToOldIndexMap)</span><br><span class=\"line\">  : <span class=\"variable constant_\">EMPTY_ARR</span></span><br><span class=\"line\"><span class=\"comment\">// 最长公共子序列尾部索引  </span></span><br><span class=\"line\">j = increasingNewIndexSequence.<span class=\"property\">length</span> - <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">// 从尾部开始遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = toBePatched - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nextIndex = s2 + i</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nextChild = c2[nextIndex]</span><br><span class=\"line\">  <span class=\"keyword\">const</span> anchor = nextIndex + <span class=\"number\">1</span> &lt; l2 ? c2[nextIndex + <span class=\"number\">1</span>].<span class=\"property\">el</span> : parentAnchor</span><br><span class=\"line\">  <span class=\"comment\">// 如果新子序列中的节点在旧子序列中不存在，则新增节点</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newIndexToOldIndexMap[i] === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">patch</span>(<span class=\"literal\">null</span>, nextChild, container, anchor, parentComponent, parentSuspense, isSVG)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (moved) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果需要移动且</span></span><br><span class=\"line\">    <span class=\"comment\">// 没有最长递增子序列</span></span><br><span class=\"line\">    <span class=\"comment\">// 当前的节点不在最长递增子序列中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j &lt; <span class=\"number\">0</span> || i !== increasingNewIndexSequence[j]) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">move</span>(nextChild, container, anchor, <span class=\"title class_\">MoveType</span>.<span class=\"property\">REORDER</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      j--</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Step 1： 这里针对 moved 是 true 的情况，则会进行求取最长递增子序列的索引操作。</p>\n<p>什么是最长递增子序列？简单来说指的是找到一个特定的最长的子序列，并且子序列中的所有元素单调递增。本例中，newIndexToOldIndexMap &#x3D; [5, 3, 4, 0] 最长递增子序列的值为 [3, 4], 对应到 newIndexToOldIndexMap 中的索引即 increasingNewIndexSequence &#x3D; [1, 2]。关于具体的算法细节，我们后面再详细探讨。</p>\n<p>Step 2： 从尾部开始遍历新的子序列，在遍历的过程中，如果新子序列中的节点在旧子序列中不存在，也就是 newIndexToOldIndexMap[i] &#x3D;&#x3D;&#x3D; 0，则新增节点。</p>\n<p>Step 3： 判断是否存在节点移动的情况，如果存在的话则看节点的索引是不是在最长递增子序列中，如果不在，则将它移动到锚点的前面，否则仅移动最长子序列的尾部指针。</p>\n<p>针对上述例子中，新的子序列为 e,c,d,i。最长递增子序列的索引为 [1, 2]。开始遍历到 i 节点时，因为 newIndexToOldIndexMap[i] &#x3D; 0 所以新增，然后遍历到 c,d 节点，因为存在于最长子序列中，所以最后 j &#x3D; -1。当遍历到 e 节点时，此时 j &#x3D; -1 并且 e 节点不存在于最长递增子序列索引中，索引最后一步就是把节点 e 进行一次移动：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">move(nextChild, container, anchor, MoveType.REORDER)</span><br></pre></td></tr></table></figure>\n\n<p>其中 anchor 是参照物，记录着上一次更新的节点信息，也就是节点 c 的信息，所以这里的意思就是将节点 e 移动到节点 c 前面。</p>\n<p>至此，完成了所有节点的增、删、更新、移动的操作，此次操作结果如下：</p>\n<p>image.png</p>\n<h4 id=\"最长递增子序列\"><a href=\"#最长递增子序列\" class=\"headerlink\" title=\"最长递增子序列\"></a>最长递增子序列</h4><p>求最长递增子序列是 LeetCode 上的一道经典算法题，原题：300. 最长递增子序列。</p>\n<p>什么是上升子序列？简单来说指的是找到一个特定的最长的子序列，并且子序列中的所有元素单调递增。</p>\n<p>假设我们的序列为 [5, 3, 4, 9] ，那么最长的递增子序列是 [3, 4]。</p>\n<p>那么如何找到最长的递增子序列呢？Vue 内部使用的是一套 贪心 + 二分查找 的算法，关于贪心和二分查找的解释如下。</p>\n<p>贪心算法：贪心算法在每一步都做出了当时看起来最佳的选择，也就是说，它总是做出局部最优的选择，寄希望这样的选择能导致全局最优解。leetCode 455. 分发饼干。<br>二分查找：每次的查找都是和区间的中间元素对比，将待查找的区间缩小为一半，直到找到目标元素，或者区间被缩小为 0（没找到）。leetCode 704. 二分查找。<br>那么这里我们再结合一下贪心算法的思想，在求取最长上升子序列时，对于同样长度是二的序列 [2, 3] 一定比 [2, 5] 好，因为要想让子序列尽可能地长，那么上升得尽可能慢，这样潜力更大。</p>\n<p>所以我们可以创建一个临时数组，用来保存最长的递增子序列，如果当前遍历的元素大于临时数组中的最后一个元素（也就是临时数组的最大值）时，那么将其追加到临时数组的尾部，否则，查找临时数组，找到第一个大于该元素的数并替换它，这样就保证了临时数组上升时最慢的。因为是单调递增的序列，我们也可以在临时数组中用二分查找，降低时间复杂度。</p>\n<p>以输入序列 [1, 4, 5, 2, 8, 7, 6, 0] 为例，根据上面算法的描述，我们大致可以得到如下的计算步骤：</p>\n<p>[1]<br>[1, 4]<br>[1, 4, 5]<br>[1, 2, 5]<br>[1, 2, 5, 8]<br>[1, 2, 5, 7]<br>[0, 2, 5, 6]<br>可以看到，如果单纯地按照上述算法的模式，得到的结果的长度虽然一致，但位置顺序和值并不符合预期，预期结果是 [1, 4, 5, 6]。那么在 Vue 中是如何解决这个顺序和值错乱的问题呢？</p>\n<p>我们一起来看看源码的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getSequence</span> (arr) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> p = arr.<span class=\"title function_\">slice</span>()</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = [<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i, j, u, v, c</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = arr.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> arrI = arr[i]</span><br><span class=\"line\">    <span class=\"comment\">// 排除等于 0 的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arrI !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      j = result[result.<span class=\"property\">length</span> - <span class=\"number\">1</span>]</span><br><span class=\"line\">      <span class=\"comment\">// 与最后一项进行比较</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &lt; arrI) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 存储在 result 更新前的最后一个索引的值</span></span><br><span class=\"line\">        p[i] = j</span><br><span class=\"line\">        result.<span class=\"title function_\">push</span>(i)</span><br><span class=\"line\">        <span class=\"keyword\">continue</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      u = <span class=\"number\">0</span></span><br><span class=\"line\">      v = result.<span class=\"property\">length</span> - <span class=\"number\">1</span></span><br><span class=\"line\">      <span class=\"comment\">// 二分搜索，查找比 arrI 小的节点，更新 result 的值</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (u &lt; v) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 取整得到当前位置</span></span><br><span class=\"line\">        c = ((u + v) / <span class=\"number\">2</span>) | <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[result[c]] &lt; arrI) &#123;</span><br><span class=\"line\">          u = c + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          v = c</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arrI &lt; arr[result[u]]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (u &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 正确的结果</span></span><br><span class=\"line\">          p[i] = result[u - <span class=\"number\">1</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 有可能替换会导致结果不正确，需要一个新数组 p 记录正确的结果</span></span><br><span class=\"line\">        result[u] = i</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  u = result.<span class=\"property\">length</span></span><br><span class=\"line\">  v = result[u - <span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 回溯数组 p，找到最终的索引</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (u-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    result[u] = v</span><br><span class=\"line\">    v = p[v]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 result 中存储的是长度为 i 的递增子序列最小末尾值的索引。p 是来存储在每次更新 result 前最后一个索引的值，并且它的 key 是这次要更新的 result 值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 插入</span><br><span class=\"line\">p[i] = j</span><br><span class=\"line\">result.push(i)</span><br><span class=\"line\">// 替换</span><br><span class=\"line\">p[i] = result[u - 1]</span><br><span class=\"line\">result[u] = i</span><br></pre></td></tr></table></figure>\n\n<p>对于上述的实例，我们在进行最后一步回溯数组 p 之前，得到的数据机构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">result = [ 0, 3, 2, 6 ] // =&gt; [0, 2, 5, 6]</span><br><span class=\"line\"></span><br><span class=\"line\">p = [1, 0, 1, 0, 2, 2, 2]</span><br></pre></td></tr></table></figure>\n\n<p>从 result 最后一个元素 6 对应的索引 6 开始回溯，可以看到 p[6] &#x3D; 2，p[2] &#x3D; 1，p[1] &#x3D; 0，所以通过对 p 的回溯，得到最终的 result 值是 [0, 1, 2, 6]，也就找到最长递增子序列的最终索引了。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>至此我们介绍完了关于 Vue3 的 diff 算法。接下来小伙伴们可以思考两个问题：</p>\n<p>为什么 Vue 3 不再沿用之前 Vue 2 的双端 diff 算法而改成现在的这种模式呢？<br>我们使用 v-for 编写列表时为什么不建议使用 index 作为 key?</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>上一节，我们介绍了关于新旧子节点不同为数组的情况下的更新过程，下面将接着上节的内容继续介绍如果子节点都是数组的情况，那么更新过程会变成什么样呢？</p>\n<h4 id=\"1-从头比对\"><a href=\"#1-从头比对\" class=\"headerlink\" title=\"1. 从头比对\"></a>1. 从头比对</h4><p>Vue 3 的 diff 算法第一步就是进行新老节点从头比对的方式来判断是否是同类型的节点：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchKeyedChildren</span> = (<span class=\"params\">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> l2 = c2.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"comment\">// 旧节点的尾部标记位</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> e1 = c1.<span class=\"property\">length</span> - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\">// 新节点的尾部标记位</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> e2 = l2 - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\">// 从头部开始比对</span></span><br><span class=\"line\">  <span class=\"comment\">// (a b) c</span></span><br><span class=\"line\">  <span class=\"comment\">// (a b) d e</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> n1 = c1[i]</span><br><span class=\"line\">    <span class=\"keyword\">const</span> n2 = (c2[i] = optimized</span><br><span class=\"line\">      ? <span class=\"title function_\">cloneIfMounted</span>(c2[i] <span class=\"keyword\">as</span> <span class=\"title class_\">VNode</span>)</span><br><span class=\"line\">      : <span class=\"title function_\">normalizeVNode</span>(c2[i]))</span><br><span class=\"line\">    <span class=\"comment\">// 如果是 sameVnode 则递归执行 patch  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title function_\">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">patch</span>(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里有几个变量需要说明一下：</p>\n<p>i 代表的是头部的标记位；<br>e1 代表的是旧的子节点的尾部标记位；<br>e2 代表的是新的子节点的尾部标记位。<br>从头比对就是通过不断移动 i 这个头部标记位来判断对应的节点是否是 sameVnode。如果是，则进行递归 patch 操作，递归 patch 就是继续进入到我们上一小节的内容。如果不满足条件，则退出头部比对，进入从尾比对流程。</p>\n<h4 id=\"2-从尾比对\"><a href=\"#2-从尾比对\" class=\"headerlink\" title=\"2. 从尾比对\"></a>2. 从尾比对</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchKeyedChildren</span> = (<span class=\"params\">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> l2 = c2.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"comment\">// 旧节点的尾部标记位</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> e1 = c1.<span class=\"property\">length</span> - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\">// 新节点的尾部标记位</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> e2 = l2 - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\">// 从头部开始比对</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 从尾部开始比对</span></span><br><span class=\"line\">  <span class=\"comment\">// a (b c)</span></span><br><span class=\"line\">  <span class=\"comment\">// d e (b c)</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> n1 = c1[e1]</span><br><span class=\"line\">    <span class=\"keyword\">const</span> n2 = (c2[e2] = optimized</span><br><span class=\"line\">      ? <span class=\"title function_\">cloneIfMounted</span>(c2[e2] <span class=\"keyword\">as</span> <span class=\"title class_\">VNode</span>)</span><br><span class=\"line\">      : <span class=\"title function_\">normalizeVNode</span>(c2[e2]))</span><br><span class=\"line\">    <span class=\"comment\">// 如果是 sameVnode 则递归执行 patch  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title function_\">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">patch</span>(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    e1--</span><br><span class=\"line\">    e2--</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从尾比对就是通过不断移动新旧节点 e1 和 e2 的尾部指针来判断对应的节点是否是 sameVnode。如果是则进行递归 patch 操作，递归 patch 也是继续进入到我们上一小节的内容。如果不满足条件，则退出头部比对，进入后续流程。</p>\n<h4 id=\"3-新增节点\"><a href=\"#3-新增节点\" class=\"headerlink\" title=\"3. 新增节点\"></a>3. 新增节点</h4><p>假设我们有这样一个旧列表：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;a&quot;</span>&gt;</span>a<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;b&quot;</span>&gt;</span>b<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;c&quot;</span>&gt;</span>c<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;d&quot;</span>&gt;</span>d<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>新列表的变更是在中间插入了一个新节点：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;a&quot;</span>&gt;</span>a<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;b&quot;</span>&gt;</span>b<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;b&quot;</span>&gt;</span>e<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;c&quot;</span>&gt;</span>c<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;d&quot;</span>&gt;</span>d<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>那么先进入第一步头部比对流程：</p>\n<p>image.png</p>\n<p>第一步执行时，会完成对 a 和 b 头部这 2 个节点进行 patch。当 i &#x3D; 2 时，由于此时的 c 和 e 节点的 key 不一样，所以退出了头部比对流程，进入尾部比对：</p>\n<p>image.png</p>\n<p>第二步执行时，会完成对 c 和 d 尾部这 2 个节点进行 patch。当 e1 &#x3D; 1 时，由于i &gt; e1，所以退出了尾部比对流程。肉眼可见，此时的情况是新节点多了个 e 节点的情况，所以我们需要添加多余的剩余节点：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchKeyedChildren</span> = (<span class=\"params\">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> l2 = c2.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"comment\">// 旧节点的尾部标记位</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> e1 = c1.<span class=\"property\">length</span> - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\">// 新节点的尾部标记位</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> e2 = l2 - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\">// 从头部开始必须</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 从尾部开始比对</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果有多余的新节点，则执行新增逻辑</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt; e1) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt;= e2) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nextPos = e2 + <span class=\"number\">1</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> anchor = nextPos &lt; l2 ? c2[nextPos].<span class=\"property\">el</span> : parentAnchor</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (i &lt;= e2) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 新增新节点</span></span><br><span class=\"line\">        <span class=\"title function_\">patch</span>(<span class=\"literal\">null</span>, c2[i], container, anchor, parentComponent, parentSuspense, isSVG)</span><br><span class=\"line\">        i++</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-删除节点\"><a href=\"#4-删除节点\" class=\"headerlink\" title=\"4. 删除节点\"></a>4. 删除节点</h4><p>类比新增节点的情况，假设我们有这样一个旧列表：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;a&quot;</span>&gt;</span>a<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;b&quot;</span>&gt;</span>b<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;b&quot;</span>&gt;</span>e<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;c&quot;</span>&gt;</span>c<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;d&quot;</span>&gt;</span>d<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>新列表的变更是在中间删除了一个旧节点：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;a&quot;</span>&gt;</span>a<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;b&quot;</span>&gt;</span>b<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;c&quot;</span>&gt;</span>c<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;d&quot;</span>&gt;</span>d<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>那么先进入第一步头部比对流程：</p>\n<p>image.png</p>\n<p>第一步执行时，会完成对 a 和 b 头部这 2 个节点进行 patch。当 i &#x3D; 2 时，由于此时的 e 和 c 节点的 key 不一样，所以退出了头部比对流程，进入尾部比对：</p>\n<p>image.png</p>\n<p>第二步执行时，会完成对 c 和 d 尾部这 2 个节点进行 patch。当 e2 &#x3D; 1 时，由于i &gt; e2，所以退出了尾部比对流程。肉眼可见，此时的情况是新节点少了个 e 节点的情况，所以我们需要删除节点 e：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchKeyedChildren</span> = (<span class=\"params\">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> l2 = c2.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"comment\">// 旧节点的尾部标记位</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> e1 = c1.<span class=\"property\">length</span> - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\">// 新节点的尾部标记位</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> e2 = l2 - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\">// 从头部开始比对</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 从尾部开始比对</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果有多余的新节点，则执行新增逻辑</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果有多余的旧节点，则执行卸载逻辑</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &gt; e2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= e1) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 卸载节点</span></span><br><span class=\"line\">      <span class=\"title function_\">unmount</span>(c1[i], parentComponent, parentSuspense, <span class=\"literal\">true</span>)</span><br><span class=\"line\">      i++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-未知子序列\"><a href=\"#5-未知子序列\" class=\"headerlink\" title=\"5. 未知子序列\"></a>5. 未知子序列</h4><p>经过步骤 1、2 的操作后如果可以直接进入步骤 3、4 那是非常方便的操作了，直接进行多余删除缺少新增的操作。如果步骤 3、4 的条件都不满足的情况，那么 Vue 是如何处理的呢？再来看这样一个例子。</p>\n<p>旧子节点：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;a&quot;</span>&gt;</span>a<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;b&quot;</span>&gt;</span>b<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;c&quot;</span>&gt;</span>c<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;d&quot;</span>&gt;</span>d<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;e&quot;</span>&gt;</span>e<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;f&quot;</span>&gt;</span>f<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;g&quot;</span>&gt;</span>g<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;h&quot;</span>&gt;</span>h<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>新子节点：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;a&quot;</span>&gt;</span>a<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;b&quot;</span>&gt;</span>b<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;e&quot;</span>&gt;</span>e<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;c&quot;</span>&gt;</span>c<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;d&quot;</span>&gt;</span>d<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;i&quot;</span>&gt;</span>i<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;g&quot;</span>&gt;</span>g<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;h&quot;</span>&gt;</span>h<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>此时经过步骤 1、2 后的结果可以表示为如下图：</p>\n<p>image.png</p>\n<p>这种情况，既不满足 i &gt; e1 也不满足 i &gt; e2 的条件，所以对于这种情况应该如何处理呢？我们知道 DOM 更新的性能优劣关系大致为：属性更新 &gt; 位置移动 &gt; 增删节点。所以，我们需要尽可能地复用老节点，做属性更新，减少移动次数和增删节点的次数。</p>\n<p>那么上述更新策略假设有这样 2 种方式。</p>\n<p>c 和 d 节点不动，只做 patch，e 节点 patch 后移动到 c 节点前面，删除 f 节点，然后在 d 节点后面添加 i 节点。<br>e 节点不动，只做 patch，c 和 d 节点 patch 后移动到 e 节点后面，删除 f 节点，然后在 d 节点后面添加 i 节点。<br>根据上面的性能优劣关系，我们需要尽可能多地保障最多的公共子节点位置不变，只做 patch 更新。然后找出多余的节点删除，找出新的节点添加，找出有需要移动的节点移动。</p>\n<p>当需要进行移动操作时，那么这个问题就变成了求取新旧子树上的最长公共子序列。当知道了最长公共子序列，所有的操作就可以简化为：</p>\n<p>如果节点在新节点中，不在旧节点中，那么新增节点。<br>如果节点在旧节点中，不在新节点中，那么删除节点。<br>如果节点既在旧节点中，也在新节点中，那么更新。<br>如果节点需要移动，那么求取最长公共子序列后，进行最小位置移动。<br>接下来看看 Vue 是如何实现上述能力的。</p>\n<h4 id=\"构造新老节点位置映射-keyToNewIndexMap\"><a href=\"#构造新老节点位置映射-keyToNewIndexMap\" class=\"headerlink\" title=\"构造新老节点位置映射 keyToNewIndexMap\"></a>构造新老节点位置映射 keyToNewIndexMap</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 旧子序列开始位置</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> s1 = i</span><br><span class=\"line\"><span class=\"comment\">// 新子序列开始位置</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> s2 = i</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5.1 构建 key:index 关系索引 map</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> keyToNewIndexMap = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>()</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = s2; i &lt;= e2; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nextChild = (c2[i] = optimized</span><br><span class=\"line\">    ? <span class=\"title function_\">cloneIfMounted</span>(c2[i] <span class=\"keyword\">as</span> <span class=\"title class_\">VNode</span>)</span><br><span class=\"line\">    : <span class=\"title function_\">normalizeVNode</span>(c2[i]))</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nextChild.<span class=\"property\">key</span> != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    keyToNewIndexMap.<span class=\"title function_\">set</span>(nextChild.<span class=\"property\">key</span>, i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的新旧子节点开始位置通过 s1 和 s2 作为标记，然后开始进行构造新老节点位置映射，这里新节点 key -&gt; index 关系的索引图是保存在了 keyToNewIndexMap 这样一个 Map 结构中，其中的 key 就是新节点的 key 值，而 value 则是旧节点对应的位置关系 index。这一步完成后，生成的 keyToNewIndexMap 结果可以表示为：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">keyToNewIndexMap = &#123;<span class=\"attr\">e</span>: <span class=\"number\">2</span>, <span class=\"attr\">c</span>: <span class=\"number\">3</span>, <span class=\"attr\">d</span>: <span class=\"number\">4</span>, <span class=\"attr\">i</span>: <span class=\"number\">5</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>image.png</p>\n<h4 id=\"继续处理旧节点\"><a href=\"#继续处理旧节点\" class=\"headerlink\" title=\"继续处理旧节点\"></a>继续处理旧节点</h4><p>有了上面的 keyToNewIndexMap 新节点的索引图，接下来我们就需要遍历旧的节点，寻找旧节点在新节点中对应的位置信息，如果找到则做更新，找不到则移除。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 记录新节点已更新的数目</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> patched = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">// 记录新节点还有多少个没有更新</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> toBePatched = e2 - s2 + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">// 标记是否有必要进行节点的位置移动</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> moved = <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\">// 标记是否有节点进行了位置移动</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> maxNewIndexSoFar = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">// 记录新节点在旧节点中的位置数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> newIndexToOldIndexMap = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(toBePatched)</span><br><span class=\"line\"><span class=\"comment\">// newIndexToOldIndexMap 全部置为 0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">// 开始遍历旧子节点</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = s1; i &lt;= e1; i++) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// prevChild 代表旧节点</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> prevChild = c1[i]</span><br><span class=\"line\">  <span class=\"comment\">// 还有多余的旧节点，则删除</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (patched &gt;= toBePatched) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">unmount</span>(prevChild, parentComponent, parentSuspense, <span class=\"literal\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">continue</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 记录旧节点在新节点中的位置数组</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> newIndex = keyToNewIndexMap.<span class=\"title function_\">get</span>(prevChild.<span class=\"property\">key</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 如果旧节点不存在于新节点中，则删除该节点</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newIndex === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">unmount</span>(prevChild, parentComponent, parentSuspense, <span class=\"literal\">true</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// newIndexToOldIndexMap 中元素为 0 表示着新节点不存在于旧节点中</span></span><br><span class=\"line\">    newIndexToOldIndexMap[newIndex - s2] = i + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\">// 默认不移动的话，所有相同节点都是增序排列的</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果有移动，必然出现节点降序的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class=\"line\">      maxNewIndexSoFar = newIndex</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      moved = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 更新节点</span></span><br><span class=\"line\">    <span class=\"title function_\">patch</span>(</span><br><span class=\"line\">      prevChild,</span><br><span class=\"line\">      c2[newIndex] <span class=\"keyword\">as</span> <span class=\"title class_\">VNode</span>,</span><br><span class=\"line\">      container,</span><br><span class=\"line\">      <span class=\"literal\">null</span>,</span><br><span class=\"line\">      parentComponent,</span><br><span class=\"line\">      parentSuspense,</span><br><span class=\"line\">      isSVG,</span><br><span class=\"line\">      slotScopeIds,</span><br><span class=\"line\">      optimized</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"comment\">// 记录更新的数量</span></span><br><span class=\"line\">    patched++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们简单来总结一下这一步的一些核心操作。</p>\n<p>Step 1： 定义一个初始长度为新节点数组长度且默认值全为 0 的变量 newIndexToOldIndexMap，记录新节点中的元素在旧节点中的位置关系。</p>\n<p>Step 2： 遍历旧的节点数组，如果旧节点不存在于新节点中，则表示旧的节点其实是多余的节点，需要被移除。</p>\n<p>Step 3： 如果旧节点存在于新节点数组中，则将它在旧子序列中的位置信息记录到 newIndexToOldIndexMap 中，同时根据 newIndex 是否大于 maxNewIndexSoFar 来判断是否有节点移动。</p>\n<p>这里我们结合个例子来说明。假如旧节点信息为 abc、新节点为 cab，当旧节点遍历到 c 节点时，此时的newIndex 的值为 0 而 maxNewIndexSoFar 的值为 2。这就意味着此时的 c 节点并不是升序位于 ab 节点之后的，因此需要标记为有需要移动的节点。</p>\n<p>Step 4： 更新相同节点。</p>\n<p>经过上面的一系列操作，我们最终得到了一个 newIndexToOldIndexMap 和一个 moved 两个变量 ，这两个变量将在下文的移动和新增节点中被使用。</p>\n<p>我们来看一下示例处理后的结果，如下图所示：</p>\n<p>image.png</p>\n<p>此时 c、d、e 因为是相同节点，所以进行 patch 更新，f 节点因为不存在于新的索引中，所以被删除。最后得到的 newIndexToOldIndexMap 数据结构大致如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">newIndexToOldIndexMap = [5, 3, 4, 0]</span><br></pre></td></tr></table></figure>\n\n<p>而且此时的 moved 也被标记为 true。</p>\n<h4 id=\"移动和增加新节点\"><a href=\"#移动和增加新节点\" class=\"headerlink\" title=\"移动和增加新节点\"></a>移动和增加新节点</h4><p>通过前面的操作，我们完成了对旧节点的移除和更新，那么接下来就是需要进行对节点的移动和新节点的增加了：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根据 newIndexToOldIndexMap 求取最长公共子序列</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> increasingNewIndexSequence = moved</span><br><span class=\"line\">  ? <span class=\"title function_\">getSequence</span>(newIndexToOldIndexMap)</span><br><span class=\"line\">  : <span class=\"variable constant_\">EMPTY_ARR</span></span><br><span class=\"line\"><span class=\"comment\">// 最长公共子序列尾部索引  </span></span><br><span class=\"line\">j = increasingNewIndexSequence.<span class=\"property\">length</span> - <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">// 从尾部开始遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = toBePatched - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nextIndex = s2 + i</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nextChild = c2[nextIndex]</span><br><span class=\"line\">  <span class=\"keyword\">const</span> anchor = nextIndex + <span class=\"number\">1</span> &lt; l2 ? c2[nextIndex + <span class=\"number\">1</span>].<span class=\"property\">el</span> : parentAnchor</span><br><span class=\"line\">  <span class=\"comment\">// 如果新子序列中的节点在旧子序列中不存在，则新增节点</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newIndexToOldIndexMap[i] === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">patch</span>(<span class=\"literal\">null</span>, nextChild, container, anchor, parentComponent, parentSuspense, isSVG)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (moved) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果需要移动且</span></span><br><span class=\"line\">    <span class=\"comment\">// 没有最长递增子序列</span></span><br><span class=\"line\">    <span class=\"comment\">// 当前的节点不在最长递增子序列中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j &lt; <span class=\"number\">0</span> || i !== increasingNewIndexSequence[j]) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">move</span>(nextChild, container, anchor, <span class=\"title class_\">MoveType</span>.<span class=\"property\">REORDER</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      j--</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Step 1： 这里针对 moved 是 true 的情况，则会进行求取最长递增子序列的索引操作。</p>\n<p>什么是最长递增子序列？简单来说指的是找到一个特定的最长的子序列，并且子序列中的所有元素单调递增。本例中，newIndexToOldIndexMap &#x3D; [5, 3, 4, 0] 最长递增子序列的值为 [3, 4], 对应到 newIndexToOldIndexMap 中的索引即 increasingNewIndexSequence &#x3D; [1, 2]。关于具体的算法细节，我们后面再详细探讨。</p>\n<p>Step 2： 从尾部开始遍历新的子序列，在遍历的过程中，如果新子序列中的节点在旧子序列中不存在，也就是 newIndexToOldIndexMap[i] &#x3D;&#x3D;&#x3D; 0，则新增节点。</p>\n<p>Step 3： 判断是否存在节点移动的情况，如果存在的话则看节点的索引是不是在最长递增子序列中，如果不在，则将它移动到锚点的前面，否则仅移动最长子序列的尾部指针。</p>\n<p>针对上述例子中，新的子序列为 e,c,d,i。最长递增子序列的索引为 [1, 2]。开始遍历到 i 节点时，因为 newIndexToOldIndexMap[i] &#x3D; 0 所以新增，然后遍历到 c,d 节点，因为存在于最长子序列中，所以最后 j &#x3D; -1。当遍历到 e 节点时，此时 j &#x3D; -1 并且 e 节点不存在于最长递增子序列索引中，索引最后一步就是把节点 e 进行一次移动：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">move(nextChild, container, anchor, MoveType.REORDER)</span><br></pre></td></tr></table></figure>\n\n<p>其中 anchor 是参照物，记录着上一次更新的节点信息，也就是节点 c 的信息，所以这里的意思就是将节点 e 移动到节点 c 前面。</p>\n<p>至此，完成了所有节点的增、删、更新、移动的操作，此次操作结果如下：</p>\n<p>image.png</p>\n<h4 id=\"最长递增子序列\"><a href=\"#最长递增子序列\" class=\"headerlink\" title=\"最长递增子序列\"></a>最长递增子序列</h4><p>求最长递增子序列是 LeetCode 上的一道经典算法题，原题：300. 最长递增子序列。</p>\n<p>什么是上升子序列？简单来说指的是找到一个特定的最长的子序列，并且子序列中的所有元素单调递增。</p>\n<p>假设我们的序列为 [5, 3, 4, 9] ，那么最长的递增子序列是 [3, 4]。</p>\n<p>那么如何找到最长的递增子序列呢？Vue 内部使用的是一套 贪心 + 二分查找 的算法，关于贪心和二分查找的解释如下。</p>\n<p>贪心算法：贪心算法在每一步都做出了当时看起来最佳的选择，也就是说，它总是做出局部最优的选择，寄希望这样的选择能导致全局最优解。leetCode 455. 分发饼干。<br>二分查找：每次的查找都是和区间的中间元素对比，将待查找的区间缩小为一半，直到找到目标元素，或者区间被缩小为 0（没找到）。leetCode 704. 二分查找。<br>那么这里我们再结合一下贪心算法的思想，在求取最长上升子序列时，对于同样长度是二的序列 [2, 3] 一定比 [2, 5] 好，因为要想让子序列尽可能地长，那么上升得尽可能慢，这样潜力更大。</p>\n<p>所以我们可以创建一个临时数组，用来保存最长的递增子序列，如果当前遍历的元素大于临时数组中的最后一个元素（也就是临时数组的最大值）时，那么将其追加到临时数组的尾部，否则，查找临时数组，找到第一个大于该元素的数并替换它，这样就保证了临时数组上升时最慢的。因为是单调递增的序列，我们也可以在临时数组中用二分查找，降低时间复杂度。</p>\n<p>以输入序列 [1, 4, 5, 2, 8, 7, 6, 0] 为例，根据上面算法的描述，我们大致可以得到如下的计算步骤：</p>\n<p>[1]<br>[1, 4]<br>[1, 4, 5]<br>[1, 2, 5]<br>[1, 2, 5, 8]<br>[1, 2, 5, 7]<br>[0, 2, 5, 6]<br>可以看到，如果单纯地按照上述算法的模式，得到的结果的长度虽然一致，但位置顺序和值并不符合预期，预期结果是 [1, 4, 5, 6]。那么在 Vue 中是如何解决这个顺序和值错乱的问题呢？</p>\n<p>我们一起来看看源码的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getSequence</span> (arr) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> p = arr.<span class=\"title function_\">slice</span>()</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = [<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i, j, u, v, c</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = arr.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> arrI = arr[i]</span><br><span class=\"line\">    <span class=\"comment\">// 排除等于 0 的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arrI !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      j = result[result.<span class=\"property\">length</span> - <span class=\"number\">1</span>]</span><br><span class=\"line\">      <span class=\"comment\">// 与最后一项进行比较</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &lt; arrI) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 存储在 result 更新前的最后一个索引的值</span></span><br><span class=\"line\">        p[i] = j</span><br><span class=\"line\">        result.<span class=\"title function_\">push</span>(i)</span><br><span class=\"line\">        <span class=\"keyword\">continue</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      u = <span class=\"number\">0</span></span><br><span class=\"line\">      v = result.<span class=\"property\">length</span> - <span class=\"number\">1</span></span><br><span class=\"line\">      <span class=\"comment\">// 二分搜索，查找比 arrI 小的节点，更新 result 的值</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (u &lt; v) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 取整得到当前位置</span></span><br><span class=\"line\">        c = ((u + v) / <span class=\"number\">2</span>) | <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[result[c]] &lt; arrI) &#123;</span><br><span class=\"line\">          u = c + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          v = c</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arrI &lt; arr[result[u]]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (u &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 正确的结果</span></span><br><span class=\"line\">          p[i] = result[u - <span class=\"number\">1</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 有可能替换会导致结果不正确，需要一个新数组 p 记录正确的结果</span></span><br><span class=\"line\">        result[u] = i</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  u = result.<span class=\"property\">length</span></span><br><span class=\"line\">  v = result[u - <span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 回溯数组 p，找到最终的索引</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (u-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    result[u] = v</span><br><span class=\"line\">    v = p[v]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 result 中存储的是长度为 i 的递增子序列最小末尾值的索引。p 是来存储在每次更新 result 前最后一个索引的值，并且它的 key 是这次要更新的 result 值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 插入</span><br><span class=\"line\">p[i] = j</span><br><span class=\"line\">result.push(i)</span><br><span class=\"line\">// 替换</span><br><span class=\"line\">p[i] = result[u - 1]</span><br><span class=\"line\">result[u] = i</span><br></pre></td></tr></table></figure>\n\n<p>对于上述的实例，我们在进行最后一步回溯数组 p 之前，得到的数据机构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">result = [ 0, 3, 2, 6 ] // =&gt; [0, 2, 5, 6]</span><br><span class=\"line\"></span><br><span class=\"line\">p = [1, 0, 1, 0, 2, 2, 2]</span><br></pre></td></tr></table></figure>\n\n<p>从 result 最后一个元素 6 对应的索引 6 开始回溯，可以看到 p[6] &#x3D; 2，p[2] &#x3D; 1，p[1] &#x3D; 0，所以通过对 p 的回溯，得到最终的 result 值是 [0, 1, 2, 6]，也就找到最长递增子序列的最终索引了。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>至此我们介绍完了关于 Vue3 的 diff 算法。接下来小伙伴们可以思考两个问题：</p>\n<p>为什么 Vue 3 不再沿用之前 Vue 2 的双端 diff 算法而改成现在的这种模式呢？<br>我们使用 v-for 编写列表时为什么不建议使用 index 作为 key?</p>\n"},{"title":"响应式原理：依赖注入实现跨级组件数据共享","_content":"\n#### 前言\n通常情况下，当我们需要从父组件向子组件传递数据时，会使用 props。对于层级不深的父子组件可以通过 props 透传数据，但是当父子层级过深时，数据透传将会变得非常麻烦和难以维护，引用 Vue.js 官网的一张图：\n\nimage.png\n\n而依赖注入则是为了解决 prop 逐级透传 的问题而诞生的，父组件 provide 需要共享给子组件的数据，子组件 inject 使用需要的父组件状态数据，而且可以保持响应式。\n\nimage.png\n\n再来看一个依赖注入的使用示例：\n\n```typescript\n// 父组件\nimport { provide, ref } from 'vue'\nconst msg = ref('hello')\nprovide(/* 注入名 */ 'message', /* 值 */ msg)\n\n//子组件使用\nimport { inject } from 'vue' \nconst message = inject('message')\n```\n\n那么，依赖注入的核心实现原理是怎样的呢？接下来我们就一起分析吧。\n\n#### Provide\nProvide 顾名思义，就是一个数据提供方，看看源码里面是如何提供的：\n\n```typescript\nexport function provide(key, value) {\n  if (!currentInstance) {\n    // ...\n  } else {\n    // 获取当前组件实例上的 provides 对象\n    let provides = currentInstance.provides\n    // 获取父组件实例上的 provides 对象\n    const parentProvides =\n      currentInstance.parent && currentInstance.parent.provides\n    // 当前组件的 providers 指向父组件的情况  \n    if (parentProvides === provides) {\n      // 继承父组件再创建一个 provides\n      provides = currentInstance.provides = Object.create(parentProvides)\n    }\n    // 生成 provides 对象\n    provides[key] = value\n  }\n}\n```\n\n这里稍微回忆一下 Object.create 这个函数：这个方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）。\n\n所以 provide 就是通过获取当前组件实例对象上的 provides，然后通过 Object.create 把父组件的 provides 属性设置到当前的组件实例对象的provides 属性的原型对象上。最后再将需要 provid 的数据存储在当前的组件实例对象上的 provides上。\n\n这里你可能会有个疑问，当前组件上实例的 provides 为什么会等于父组件上的 provides 呢？这是因为在组件实例 currentInstance 创建的时候进行了初始化的：\n\n```typescript\nappContext = {\n  // ...\n  provides: Object.create(null),\n}\n\nconst instance = { \n  // 依赖注入相关 \n  provides: parent ? parent.provides : Object.create(appContext.provides), \n  // 其它属性 \n  // ... \n}\n```\n\n可以看到，如果父组件定义了 provide 那么子组件初始的过程中都会将自己的 porvide 指向父组件的 provide。而根组件因为没有父组件，则被赋值为一个空对象。大致可以表示为：\n\nimage.png\n\n#### Inject\nInject 顾名思义，就是一个数据注入方，看看源码里面是如何实现注入的：\n\n```typescript\nexport function inject(key, defaultValue, treatDefaultAsFactory = false) {\n  // 获取当前组件实例\n  const instance = currentInstance || currentRenderingInstance\n  if (instance) {\n    // 获取父组件上的 provides 对象\n    const provides =\n      instance.parent == null\n        ? instance.vnode.appContext && instance.vnode.appContext.provides\n        : instance.parent.provides\n    // 如果能取到，则返回值\n    if (provides && key in provides) {\n      return provides[key]\n    } else if (arguments.length > 1) {\n      // 返回默认值\n      return treatDefaultAsFactory && isFunction(defaultValue)\n      // 如果默认内容是个函数的，就执行并且通过call方法把组件实例的代理对象绑定到该函数的this上\n        ? defaultValue.call(instance.proxy)\n        : defaultValue\n    \n  }\n}\n```\n\n这里的实现就显得通俗易懂了，核心也就是从当前组件实例的父组件上取 provides 对象，然后再查找父组件 provides 上有没有对应的属性。因为父组件的 provides 是通过原型链的方式和父组件的父组件进行了关联，如果父组件上没有，那么会通过原型链的方式再向上取，这也实现了不管组件层级多深，总是可以找到对应的 provide 的提供方数据。\n\n总结\n通过上面的分析，我们知道了依赖注入的实现原理相对还是比较简单的，比较有意思的事他巧妙地利用了原型和原型链的方式进行数据的继承和获取。\n\n在执行 provide 的时候，会将父组件的的 provides 关联成当前组件实例 provides 对象原型上的属性，当在 inject 获取数据的时候，则会根据原型链的规则进行查找，找不到的话则会返回用户自定义的默认值。\n\n最后，我们知道 Vue 通过了依赖注入的方式实现了跨层级组件的状态共享问题。跨层级的状态共享问题是不是听起来有点耳熟？没错，那就是 vuex / pinia 所做的事情。\n\n那思考一下 Vue 3 是否可以依托于 Composition API + 依赖注入 实现一个轻量级的状态管理工具呢？","source":"_drafts/technical-disclosure-of-vue3/provide-and-inject.md","raw":"---\ntitle: 响应式原理：依赖注入实现跨级组件数据共享\ncategories:\n  - Vue3 技术揭秘\n---\n\n#### 前言\n通常情况下，当我们需要从父组件向子组件传递数据时，会使用 props。对于层级不深的父子组件可以通过 props 透传数据，但是当父子层级过深时，数据透传将会变得非常麻烦和难以维护，引用 Vue.js 官网的一张图：\n\nimage.png\n\n而依赖注入则是为了解决 prop 逐级透传 的问题而诞生的，父组件 provide 需要共享给子组件的数据，子组件 inject 使用需要的父组件状态数据，而且可以保持响应式。\n\nimage.png\n\n再来看一个依赖注入的使用示例：\n\n```typescript\n// 父组件\nimport { provide, ref } from 'vue'\nconst msg = ref('hello')\nprovide(/* 注入名 */ 'message', /* 值 */ msg)\n\n//子组件使用\nimport { inject } from 'vue' \nconst message = inject('message')\n```\n\n那么，依赖注入的核心实现原理是怎样的呢？接下来我们就一起分析吧。\n\n#### Provide\nProvide 顾名思义，就是一个数据提供方，看看源码里面是如何提供的：\n\n```typescript\nexport function provide(key, value) {\n  if (!currentInstance) {\n    // ...\n  } else {\n    // 获取当前组件实例上的 provides 对象\n    let provides = currentInstance.provides\n    // 获取父组件实例上的 provides 对象\n    const parentProvides =\n      currentInstance.parent && currentInstance.parent.provides\n    // 当前组件的 providers 指向父组件的情况  \n    if (parentProvides === provides) {\n      // 继承父组件再创建一个 provides\n      provides = currentInstance.provides = Object.create(parentProvides)\n    }\n    // 生成 provides 对象\n    provides[key] = value\n  }\n}\n```\n\n这里稍微回忆一下 Object.create 这个函数：这个方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）。\n\n所以 provide 就是通过获取当前组件实例对象上的 provides，然后通过 Object.create 把父组件的 provides 属性设置到当前的组件实例对象的provides 属性的原型对象上。最后再将需要 provid 的数据存储在当前的组件实例对象上的 provides上。\n\n这里你可能会有个疑问，当前组件上实例的 provides 为什么会等于父组件上的 provides 呢？这是因为在组件实例 currentInstance 创建的时候进行了初始化的：\n\n```typescript\nappContext = {\n  // ...\n  provides: Object.create(null),\n}\n\nconst instance = { \n  // 依赖注入相关 \n  provides: parent ? parent.provides : Object.create(appContext.provides), \n  // 其它属性 \n  // ... \n}\n```\n\n可以看到，如果父组件定义了 provide 那么子组件初始的过程中都会将自己的 porvide 指向父组件的 provide。而根组件因为没有父组件，则被赋值为一个空对象。大致可以表示为：\n\nimage.png\n\n#### Inject\nInject 顾名思义，就是一个数据注入方，看看源码里面是如何实现注入的：\n\n```typescript\nexport function inject(key, defaultValue, treatDefaultAsFactory = false) {\n  // 获取当前组件实例\n  const instance = currentInstance || currentRenderingInstance\n  if (instance) {\n    // 获取父组件上的 provides 对象\n    const provides =\n      instance.parent == null\n        ? instance.vnode.appContext && instance.vnode.appContext.provides\n        : instance.parent.provides\n    // 如果能取到，则返回值\n    if (provides && key in provides) {\n      return provides[key]\n    } else if (arguments.length > 1) {\n      // 返回默认值\n      return treatDefaultAsFactory && isFunction(defaultValue)\n      // 如果默认内容是个函数的，就执行并且通过call方法把组件实例的代理对象绑定到该函数的this上\n        ? defaultValue.call(instance.proxy)\n        : defaultValue\n    \n  }\n}\n```\n\n这里的实现就显得通俗易懂了，核心也就是从当前组件实例的父组件上取 provides 对象，然后再查找父组件 provides 上有没有对应的属性。因为父组件的 provides 是通过原型链的方式和父组件的父组件进行了关联，如果父组件上没有，那么会通过原型链的方式再向上取，这也实现了不管组件层级多深，总是可以找到对应的 provide 的提供方数据。\n\n总结\n通过上面的分析，我们知道了依赖注入的实现原理相对还是比较简单的，比较有意思的事他巧妙地利用了原型和原型链的方式进行数据的继承和获取。\n\n在执行 provide 的时候，会将父组件的的 provides 关联成当前组件实例 provides 对象原型上的属性，当在 inject 获取数据的时候，则会根据原型链的规则进行查找，找不到的话则会返回用户自定义的默认值。\n\n最后，我们知道 Vue 通过了依赖注入的方式实现了跨层级组件的状态共享问题。跨层级的状态共享问题是不是听起来有点耳熟？没错，那就是 vuex / pinia 所做的事情。\n\n那思考一下 Vue 3 是否可以依托于 Composition API + 依赖注入 实现一个轻量级的状态管理工具呢？","slug":"technical-disclosure-of-vue3/provide-and-inject","published":0,"date":"2023-08-12T07:53:19.989Z","updated":"2023-08-12T07:53:19.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokq0013sovchko75wik","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>通常情况下，当我们需要从父组件向子组件传递数据时，会使用 props。对于层级不深的父子组件可以通过 props 透传数据，但是当父子层级过深时，数据透传将会变得非常麻烦和难以维护，引用 Vue.js 官网的一张图：</p>\n<p>image.png</p>\n<p>而依赖注入则是为了解决 prop 逐级透传 的问题而诞生的，父组件 provide 需要共享给子组件的数据，子组件 inject 使用需要的父组件状态数据，而且可以保持响应式。</p>\n<p>image.png</p>\n<p>再来看一个依赖注入的使用示例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; provide, ref &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> msg = <span class=\"title function_\">ref</span>(<span class=\"string\">&#x27;hello&#x27;</span>)</span><br><span class=\"line\"><span class=\"title function_\">provide</span>(<span class=\"comment\">/* 注入名 */</span> <span class=\"string\">&#x27;message&#x27;</span>, <span class=\"comment\">/* 值 */</span> msg)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//子组件使用</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; inject &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">const</span> message = <span class=\"title function_\">inject</span>(<span class=\"string\">&#x27;message&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>那么，依赖注入的核心实现原理是怎样的呢？接下来我们就一起分析吧。</p>\n<h4 id=\"Provide\"><a href=\"#Provide\" class=\"headerlink\" title=\"Provide\"></a>Provide</h4><p>Provide 顾名思义，就是一个数据提供方，看看源码里面是如何提供的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">provide</span>(<span class=\"params\">key, value</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!currentInstance) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前组件实例上的 provides 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> provides = currentInstance.<span class=\"property\">provides</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取父组件实例上的 provides 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> parentProvides =</span><br><span class=\"line\">      currentInstance.<span class=\"property\">parent</span> &amp;&amp; currentInstance.<span class=\"property\">parent</span>.<span class=\"property\">provides</span></span><br><span class=\"line\">    <span class=\"comment\">// 当前组件的 providers 指向父组件的情况  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parentProvides === provides) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 继承父组件再创建一个 provides</span></span><br><span class=\"line\">      provides = currentInstance.<span class=\"property\">provides</span> = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(parentProvides)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 生成 provides 对象</span></span><br><span class=\"line\">    provides[key] = value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里稍微回忆一下 Object.create 这个函数：这个方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）。</p>\n<p>所以 provide 就是通过获取当前组件实例对象上的 provides，然后通过 Object.create 把父组件的 provides 属性设置到当前的组件实例对象的provides 属性的原型对象上。最后再将需要 provid 的数据存储在当前的组件实例对象上的 provides上。</p>\n<p>这里你可能会有个疑问，当前组件上实例的 provides 为什么会等于父组件上的 provides 呢？这是因为在组件实例 currentInstance 创建的时候进行了初始化的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">appContext = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">provides</span>: <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"literal\">null</span>),</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> instance = &#123; </span><br><span class=\"line\">  <span class=\"comment\">// 依赖注入相关 </span></span><br><span class=\"line\">  <span class=\"attr\">provides</span>: parent ? parent.<span class=\"property\">provides</span> : <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(appContext.<span class=\"property\">provides</span>), </span><br><span class=\"line\">  <span class=\"comment\">// 其它属性 </span></span><br><span class=\"line\">  <span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，如果父组件定义了 provide 那么子组件初始的过程中都会将自己的 porvide 指向父组件的 provide。而根组件因为没有父组件，则被赋值为一个空对象。大致可以表示为：</p>\n<p>image.png</p>\n<h4 id=\"Inject\"><a href=\"#Inject\" class=\"headerlink\" title=\"Inject\"></a>Inject</h4><p>Inject 顾名思义，就是一个数据注入方，看看源码里面是如何实现注入的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">inject</span>(<span class=\"params\">key, defaultValue, treatDefaultAsFactory = <span class=\"literal\">false</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 获取当前组件实例</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> instance = currentInstance || currentRenderingInstance</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (instance) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取父组件上的 provides 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> provides =</span><br><span class=\"line\">      instance.<span class=\"property\">parent</span> == <span class=\"literal\">null</span></span><br><span class=\"line\">        ? instance.<span class=\"property\">vnode</span>.<span class=\"property\">appContext</span> &amp;&amp; instance.<span class=\"property\">vnode</span>.<span class=\"property\">appContext</span>.<span class=\"property\">provides</span></span><br><span class=\"line\">        : instance.<span class=\"property\">parent</span>.<span class=\"property\">provides</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果能取到，则返回值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (provides &amp;&amp; key <span class=\"keyword\">in</span> provides) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> provides[key]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"variable language_\">arguments</span>.<span class=\"property\">length</span> &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 返回默认值</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> treatDefaultAsFactory &amp;&amp; <span class=\"title function_\">isFunction</span>(defaultValue)</span><br><span class=\"line\">      <span class=\"comment\">// 如果默认内容是个函数的，就执行并且通过call方法把组件实例的代理对象绑定到该函数的this上</span></span><br><span class=\"line\">        ? defaultValue.<span class=\"title function_\">call</span>(instance.<span class=\"property\">proxy</span>)</span><br><span class=\"line\">        : defaultValue</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的实现就显得通俗易懂了，核心也就是从当前组件实例的父组件上取 provides 对象，然后再查找父组件 provides 上有没有对应的属性。因为父组件的 provides 是通过原型链的方式和父组件的父组件进行了关联，如果父组件上没有，那么会通过原型链的方式再向上取，这也实现了不管组件层级多深，总是可以找到对应的 provide 的提供方数据。</p>\n<p>总结<br>通过上面的分析，我们知道了依赖注入的实现原理相对还是比较简单的，比较有意思的事他巧妙地利用了原型和原型链的方式进行数据的继承和获取。</p>\n<p>在执行 provide 的时候，会将父组件的的 provides 关联成当前组件实例 provides 对象原型上的属性，当在 inject 获取数据的时候，则会根据原型链的规则进行查找，找不到的话则会返回用户自定义的默认值。</p>\n<p>最后，我们知道 Vue 通过了依赖注入的方式实现了跨层级组件的状态共享问题。跨层级的状态共享问题是不是听起来有点耳熟？没错，那就是 vuex &#x2F; pinia 所做的事情。</p>\n<p>那思考一下 Vue 3 是否可以依托于 Composition API + 依赖注入 实现一个轻量级的状态管理工具呢？</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>通常情况下，当我们需要从父组件向子组件传递数据时，会使用 props。对于层级不深的父子组件可以通过 props 透传数据，但是当父子层级过深时，数据透传将会变得非常麻烦和难以维护，引用 Vue.js 官网的一张图：</p>\n<p>image.png</p>\n<p>而依赖注入则是为了解决 prop 逐级透传 的问题而诞生的，父组件 provide 需要共享给子组件的数据，子组件 inject 使用需要的父组件状态数据，而且可以保持响应式。</p>\n<p>image.png</p>\n<p>再来看一个依赖注入的使用示例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; provide, ref &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> msg = <span class=\"title function_\">ref</span>(<span class=\"string\">&#x27;hello&#x27;</span>)</span><br><span class=\"line\"><span class=\"title function_\">provide</span>(<span class=\"comment\">/* 注入名 */</span> <span class=\"string\">&#x27;message&#x27;</span>, <span class=\"comment\">/* 值 */</span> msg)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//子组件使用</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; inject &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">const</span> message = <span class=\"title function_\">inject</span>(<span class=\"string\">&#x27;message&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>那么，依赖注入的核心实现原理是怎样的呢？接下来我们就一起分析吧。</p>\n<h4 id=\"Provide\"><a href=\"#Provide\" class=\"headerlink\" title=\"Provide\"></a>Provide</h4><p>Provide 顾名思义，就是一个数据提供方，看看源码里面是如何提供的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">provide</span>(<span class=\"params\">key, value</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!currentInstance) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前组件实例上的 provides 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> provides = currentInstance.<span class=\"property\">provides</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取父组件实例上的 provides 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> parentProvides =</span><br><span class=\"line\">      currentInstance.<span class=\"property\">parent</span> &amp;&amp; currentInstance.<span class=\"property\">parent</span>.<span class=\"property\">provides</span></span><br><span class=\"line\">    <span class=\"comment\">// 当前组件的 providers 指向父组件的情况  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parentProvides === provides) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 继承父组件再创建一个 provides</span></span><br><span class=\"line\">      provides = currentInstance.<span class=\"property\">provides</span> = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(parentProvides)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 生成 provides 对象</span></span><br><span class=\"line\">    provides[key] = value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里稍微回忆一下 Object.create 这个函数：这个方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）。</p>\n<p>所以 provide 就是通过获取当前组件实例对象上的 provides，然后通过 Object.create 把父组件的 provides 属性设置到当前的组件实例对象的provides 属性的原型对象上。最后再将需要 provid 的数据存储在当前的组件实例对象上的 provides上。</p>\n<p>这里你可能会有个疑问，当前组件上实例的 provides 为什么会等于父组件上的 provides 呢？这是因为在组件实例 currentInstance 创建的时候进行了初始化的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">appContext = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">provides</span>: <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"literal\">null</span>),</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> instance = &#123; </span><br><span class=\"line\">  <span class=\"comment\">// 依赖注入相关 </span></span><br><span class=\"line\">  <span class=\"attr\">provides</span>: parent ? parent.<span class=\"property\">provides</span> : <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(appContext.<span class=\"property\">provides</span>), </span><br><span class=\"line\">  <span class=\"comment\">// 其它属性 </span></span><br><span class=\"line\">  <span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，如果父组件定义了 provide 那么子组件初始的过程中都会将自己的 porvide 指向父组件的 provide。而根组件因为没有父组件，则被赋值为一个空对象。大致可以表示为：</p>\n<p>image.png</p>\n<h4 id=\"Inject\"><a href=\"#Inject\" class=\"headerlink\" title=\"Inject\"></a>Inject</h4><p>Inject 顾名思义，就是一个数据注入方，看看源码里面是如何实现注入的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">inject</span>(<span class=\"params\">key, defaultValue, treatDefaultAsFactory = <span class=\"literal\">false</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 获取当前组件实例</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> instance = currentInstance || currentRenderingInstance</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (instance) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取父组件上的 provides 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> provides =</span><br><span class=\"line\">      instance.<span class=\"property\">parent</span> == <span class=\"literal\">null</span></span><br><span class=\"line\">        ? instance.<span class=\"property\">vnode</span>.<span class=\"property\">appContext</span> &amp;&amp; instance.<span class=\"property\">vnode</span>.<span class=\"property\">appContext</span>.<span class=\"property\">provides</span></span><br><span class=\"line\">        : instance.<span class=\"property\">parent</span>.<span class=\"property\">provides</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果能取到，则返回值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (provides &amp;&amp; key <span class=\"keyword\">in</span> provides) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> provides[key]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"variable language_\">arguments</span>.<span class=\"property\">length</span> &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 返回默认值</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> treatDefaultAsFactory &amp;&amp; <span class=\"title function_\">isFunction</span>(defaultValue)</span><br><span class=\"line\">      <span class=\"comment\">// 如果默认内容是个函数的，就执行并且通过call方法把组件实例的代理对象绑定到该函数的this上</span></span><br><span class=\"line\">        ? defaultValue.<span class=\"title function_\">call</span>(instance.<span class=\"property\">proxy</span>)</span><br><span class=\"line\">        : defaultValue</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的实现就显得通俗易懂了，核心也就是从当前组件实例的父组件上取 provides 对象，然后再查找父组件 provides 上有没有对应的属性。因为父组件的 provides 是通过原型链的方式和父组件的父组件进行了关联，如果父组件上没有，那么会通过原型链的方式再向上取，这也实现了不管组件层级多深，总是可以找到对应的 provide 的提供方数据。</p>\n<p>总结<br>通过上面的分析，我们知道了依赖注入的实现原理相对还是比较简单的，比较有意思的事他巧妙地利用了原型和原型链的方式进行数据的继承和获取。</p>\n<p>在执行 provide 的时候，会将父组件的的 provides 关联成当前组件实例 provides 对象原型上的属性，当在 inject 获取数据的时候，则会根据原型链的规则进行查找，找不到的话则会返回用户自定义的默认值。</p>\n<p>最后，我们知道 Vue 通过了依赖注入的方式实现了跨层级组件的状态共享问题。跨层级的状态共享问题是不是听起来有点耳熟？没错，那就是 vuex &#x2F; pinia 所做的事情。</p>\n<p>那思考一下 Vue 3 是否可以依托于 Composition API + 依赖注入 实现一个轻量级的状态管理工具呢？</p>\n"},{"title":"响应式原理：基于 Proxy 的响应式是什么样的？","_content":"\n\n#### 前言\n本小节我们开启响应式原理的篇章，在开启这个篇章之前，我们先来了解一下 Vue3 中一个基于 Composition API 响应式应用的例子是如何编写的：\n\n```html\n<template>\n  <div>\n    {{ state.msg }} {{ count }}\n  </div>\n</template>\n<script>\n  import { reactive, ref } from 'vue'\n  export default {\n    setup() {\n      const state = reactive({\n        msg: 'hello world'\n      })\n      \n      const count = ref(0)\n      \n      const changeMsg = () => {\n        state.msg = 'world hello'\n      }\n\n      return {\n        state,\n        count,\n        changeMsg,\n      }\n    }\n  }\n</script>\n```\n\n此时我们通过 reactive API 或者 ref API 来定义响应式对象。\n\n对于 reactive API 而言，核心是用来定义集合类型的数据，比如：普通对象、数组和 Map、Set。\n\n对于 ref API 而言，可以用来对 string、number、boolean 这些原始类型数据进行响应式定义。\n\n关于二者使用上的更多区别和差异，小伙伴们可以直接参见 Vue 3 官网上《响应式基础》这个章节中的介绍。对于二者的核心实现原理，其实都是依托于 Vue 3 的响应式基础，本小节将以 reactive API 作为切入点，核心分析 Vue 3 的响应式原理。\n\n#### Reactive\n找到源码中关于 reactive 部分的定义：\n\n```typescript\nexport function reactive(target: object) {\n  // 不需要对 readonly 的对象进行响应式\n  if (isReadonly(target)) {\n    return target\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  )\n}\n```\n\n这个函数核心也就是通过 createReactiveObject 把我们传入的 target 变成响应式的：\n\n```typescript\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n  // 如果目标不是对象，则直接返回\n  if (!isObject(target)) {\n    return target\n  }\n  // 已经是一个响应式对象了，也直接返回\n  if (\n    target[ReactiveFlags.RAW] &&\n    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])\n  ) {\n    return target\n  }\n  // proxyMap 中已经存入过 target，直接返回\n  const existingProxy = proxyMap.get(target)\n  if (existingProxy) {\n    return existingProxy\n  }\n  // 只有特定类型的值才能被 observe.\n  const targetType = getTargetType(target)\n  if (targetType === TargetType.INVALID) {\n    return target\n  }\n  // 通过 proxy 来构造一个响应式对象\n  const proxy = new Proxy(\n    target,\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers\n  )\n  // 缓存 target proxy\n  proxyMap.set(target, proxy)\n  return proxy\n}\n```\n\n上述整个核心流程就是首先经过一系列判断，判断符合要求的 target 才能被响应式，整理的判断包括了target 的类型、是否是响应式的、是否已经被定义过了，以及是否是符合要求的类型这些步骤，最后执行的是 new Proxy() 这样的一个响应式代理 API。一起来看看这个 API 的实现：\n\n```typescript\n  const proxy = new Proxy(\n    target,\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers\n  )\n```\n\nProxy 根据 targetType 来确定执行的是 collectionHandlers 还是 baseHandlers。那 targetType 是什么时候确定的呢？可以看一下：\n\n```typescript\nconst targetType = getTargetType(target)\n\nfunction getTargetType(value) {\n  return value[ReactiveFlags.SKIP] || !Object.isExtensible(value)\n    ? TargetType.INVALID\n    : targetTypeMap(toRawType(value))\n}\n\nexport const toRawType = (value) => {\n  // toTypeString 转换成字符串的方式，比如 \"[object RawType]\"\n  return toTypeString(value).slice(8, -1)\n}\n\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case 'Object':\n    case 'Array':\n      return TargetType.COMMON\n    case 'Map':\n    case 'Set':\n    case 'WeakMap':\n    case 'WeakSet':\n      return TargetType.COLLECTION\n    default:\n      return TargetType.INVALID\n  }\n}\n```\n\n因为 target 传入进来的是一个 Object，所以 toRawType(value) 得到的值是 Object。所以这里的 targetType 的值等于 TargetType.COMMON 也就是执行了 baseHandlers 。而当我们的 reactive(target) 中的 target 是个 WeakMap 或者 WeakSet 时，那么执行的就是 collectionHandlers 了。\n\n接下来看一下 baseHandlers 的实现：\n\n```typescript\nexport const mutableHandlers = {\n  get,\n  set,\n  deleteProperty,\n  has,\n  ownKeys\n}\n```\n\n这里就是 Proxy 中的定义 handler 的一些属性。\n\nget：属性读取操作的捕捉器。\nset：属性设置操作的捕捉器。\ndeleteProperty：delete 操作符的捕捉器。\nhas：in 操作符的捕捉器。\nownKeys：Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。\n而关于响应式核心的部分就在 set 和 get 中，我们一起来看一下二者的定义实现。\n\n##### 1. get\n其中 get 的实现：\n\n```typescript\nconst get = /*#__PURE__*/ createGetter()\n```\n\n可以看到核心其实通过 createGetter 来实现的：\n\n```typescript\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target: Target, key: string | symbol, receiver: object) {\n    // 对 ReactiveFlags 的处理部分\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return !isReadonly\n    } else if (key === ReactiveFlags.IS_READONLY) {\n      return isReadonly\n    } else if (key === ReactiveFlags.IS_SHALLOW) {\n      return shallow\n    } else if (\n      key === ReactiveFlags.RAW &&\n      receiver ===\n        (isReadonly\n          ? shallow\n            ? shallowReadonlyMap\n            : readonlyMap\n          : shallow\n          ? shallowReactiveMap\n          : reactiveMap\n        ).get(target)\n    ) {\n      return target\n    }\n    \n    const targetIsArray = isArray(target)\n    if (!isReadonly) {\n      // 数组的特殊方法处理\n      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\n        return Reflect.get(arrayInstrumentations, key, receiver)\n      }\n      // 对象 hasOwnProperty 方法处理\n      if (key === 'hasOwnProperty') {\n        return hasOwnProperty\n      }\n    }\n    // 取值\n    const res = Reflect.get(target, key, receiver)\n    \n    // Symbol Key 不做依赖收集\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res\n    }\n    \n    // 进行依赖收集\n    if (!isReadonly) {\n      track(target, TrackOpTypes.GET, key)\n    }\n    \n    // 如果是浅层响应，那么直接返回，不需要递归了\n    if (shallow) {\n      return res\n    }\n    \n    \n    if (isRef(res)) {\n      // 跳过数组、整数 key 的展开\n      return targetIsArray && isIntegerKey(key) ? res : res.value\n    }\n\n    if (isObject(res)) {\n      // 如果 isReadonly 是 true，那么直接返回 readonly(res)\n      // 如果 res 是个对象或者数组类型，则递归执行 reactive 函数把 res 变成响应式\n      return isReadonly ? readonly(res) : reactive(res)\n    }\n\n    return res\n  }\n}\n```\n\n因为调用 createGetter 时，默认参数 isReadonly = false，所以这里可以先忽略 isReadonly 的部分。整体而言，该函数还是比较通俗易懂的，首先对 key 属于 ReactiveFlags 的部分做了特殊处理，这也是为什么在 createReactiveObject 函数中判断响应式对象是否存在 ReactiveFlags.RAW 属性，如果存在就返回这个响应式对象本身。\n\n然后当我们的 target 是数组，且 key 值存在 arrayInstrumentations 中时，返回 arrayInstrumentations 中对应的 key 值。再来看看 arrayInstrumentations 是个什么：\n\n```typescript\nconst arrayInstrumentations = createArrayInstrumentations()\n\nfunction createArrayInstrumentations() {\n  const instrumentations = {};\n  (['includes', 'indexOf', 'lastIndexOf']).forEach(key => {\n    instrumentations[key] = function (this, ...args) {\n      // toRaw 可以把响应式对象转成原始数据\n      const arr = toRaw(this)\n      \n      for (let i = 0, l = this.length; i < l; i++) {\n        // 对数组的每一项进行依赖收集\n        track(arr, TrackOpTypes.GET, i + '')\n      }\n      // 先尝试用参数本身，可能是响应式数据\n      const res = arr[key](...args)\n      if (res === -1 || res === false) {\n        // 如果失败，再尝试把参数转成原始数据\n        return arr[key](...args.map(toRaw))\n      } else {\n        return res\n      }\n    }\n  })\n  // instrument length-altering mutation methods to avoid length being tracked\n  // which leads to infinite loops in some cases (#2137)\n  ;(['push', 'pop', 'shift', 'unshift', 'splice'] as const).forEach(key => {\n    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {\n      pauseTracking()\n      const res = (toRaw(this) as any)[key].apply(this, args)\n      resetTracking()\n      return res\n    }\n  })\n  return instrumentations\n}\n```\n\n当reactive函数传入数组时，get捕获器会先在arrayInstrumentations对象上查找，如果找不到，再在代理对象target上查找。arrayInstrumentations对象会重写两类函数，一类是查询类函数: includes、 indexOf、 lastIndexOf，代表对数组的读取操作。在这些函数中会执行track函数，对数组上的索引和length属性进行追踪。\n\n一类是修改类函数push、 pop、 shift、 unshift、 splice，代表对数组的修改操作，在这些函数中暂停了全局的追踪功能，防止某些情况下导致死循环。关于这里的一些说明也可以参见 Vue issue。\n\n再回过头看 createGetter 中，接下来的操作就是通过 track(target, TrackOpTypes.GET, key) 进行依赖收集，我们再来一起看一下 track 的实现：\n\n```typescript\n// 是否应该收集依赖\nlet shouldTrack = true\n// 当前激活的 effect\nlet activeEffect\n// 存放所有 reactive 传入的 receiver 容器\nconst targetMap = new WeakMap()\n\nexport function track(target, type, key) {\n  if (shouldTrack && activeEffect) {\n    let depsMap = targetMap.get(target)\n    if (!depsMap) {\n      targetMap.set(target, (depsMap = new Map()))\n    }\n    let dep = depsMap.get(key)\n    if (!dep) {\n      depsMap.set(key, (dep = createDep()))\n    }\n\n    trackEffects(dep)\n  }\n}\n\n\nexport function trackEffects(\n  dep,\n  debuggerEventExtraInfo\n) {\n  // ...\n  if (shouldTrack) {\n    // 把 activeEffect 添加到 dep 中\n    dep.add(activeEffect!)\n    activeEffect!.deps.push(dep)\n  }\n}\n```\n\n上面函数有点绕，其实核心就是在生成一个数据结构，什么样的数据结构呢？我们来画个图看看：\n\nimage.png\n\n我们创建了全局的 targetMap ，它的键是 target，值是 depsMap；这个 depsMap 的键是 target 的 key，值是 dep 集合，dep 集合中存储的是依赖的副作用函数 effect。\n\n另外，关于 trackEffects 的实现细节，我们后面的小节再详细介绍。\n\n注意到 Proxy 在访问对象属性时才递归执行劫持对象属性，相比 Object.defineProperty 在定义时就遍历把所有层级的对象设置成响应式而言，在性能上有所提升。\n\n##### 2. set\n上面说完了 get 的流程，我们了解了依赖收集后的数据结构存储在了 targetMap 中，接下来我们接着看 set 的过程：\n\n```typescript\nconst set = /*#__PURE__*/ createSetter()\n```\n\n可以看到核心其实通过 createSetter 来实现的：\n\n```typescript\nfunction createSetter(shallow = false) {\n  return function set(target, key, value, receiver) {\n    let oldValue = target[key]\n    // 不是浅层响应式，这里默认是 false\n    if (!shallow) {\n      // 不是浅层响应式对象\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue)\n        value = toRaw(value)\n      }\n      // ...\n    } else {\n      // 在浅模式中，对象被设置为原始值，而不管是否是响应式\n    }\n\n    const hadKey =\n      isArray(target) && isIntegerKey(key)\n        ? Number(key) < target.length\n        : hasOwn(target, key)\n    const result = Reflect.set(target, key, value, receiver)\n     // 如果目标的原型链也是一个 proxy，通过 Reflect.set 修改原型链上的属性会再次触发 setter，这种情况下就没必要触发两次 trigger 了\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, TriggerOpTypes.ADD, key, value)\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, TriggerOpTypes.SET, key, value, oldValue)\n      }\n    }\n    return result\n  }\n}\n```\n\n可以看到 set 的核心逻辑是先根据是否是浅层响应式来确定原始值和新值，这里默认不是浅层的响应式，所以会先把原始值和新值进行 toRaw 转换，然后通过 Reflect.set 设置值，最后通过 trigger 函数派发通知 ，并依据 key 是否存在于 target 上来确定通知类型是 add（新增） 还是 set（修改）。\n\n接下来核心就是 trigger 的逻辑，是如何实现触发响应的:\n\n```typescript\nexport function trigger(target,type,key,newValue,oldValue,oldTarget) {\n  const depsMap = targetMap.get(target)\n  if (!depsMap) {\n    return\n  }\n  let deps: (Dep | undefined)[] = []\n  if (type === TriggerOpTypes.CLEAR) {\n    deps = [...depsMap.values()]\n  } else if (key === 'length' && isArray(target)) {\n    depsMap.forEach((dep, key) => {\n      if (key === 'length' || key >= toNumber(newValue)) {\n        deps.push(dep)\n      }\n    })\n  } else {\n    if (key !== void 0) {\n      deps.push(depsMap.get(key))\n    }\n\n    switch (type) {\n      case TriggerOpTypes.ADD:\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY))\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\n          }\n        } else if (isIntegerKey(key)) {\n          deps.push(depsMap.get('length'))\n        }\n        break\n      case TriggerOpTypes.DELETE:\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY))\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\n          }\n        }\n        break\n      case TriggerOpTypes.SET:\n        if (isMap(target)) {\n          deps.push(depsMap.get(ITERATE_KEY))\n        }\n        break\n    }\n  }\n\n  if (deps.length === 1) {\n    if (deps[0]) {\n      triggerEffects(deps[0])\n    }\n  } else {\n    const effects: ReactiveEffect[] = []\n    for (const dep of deps) {\n      if (dep) {\n        effects.push(...dep)\n      }\n    }\n    triggerEffects(createDep(effects))\n  }\n}\n```\n\n内容有点多，看起来有点头大，我们来简化一下：\n\n```typescript\nexport function trigger(target, type, key) {\n  const dep = targetMap.get(target)\n  dep.get(key).forEach(effect => effect.run())\n}\n```\n\n核心其实就是通过 target 找到 targetMap 中的 dep，再根据 key 来找到所有的副作用函数 effect 遍历执行。副作用函数就是上面 get 收集起来的。\n\n这里有个有意思的地方是对数组的操作监听，我们来看一段代码：\n\n```typescript\nconst state = reactive([]);\n\neffect(() => {\n  console.log(`state: ${state[1]}`)\n});\n\n// 不会触发 effect\nstate.push(0);\n\n// 触发 effect\nstate.push(1);\n```\n\n上面的 demo 中，我们第一次访问了 state[1]， 所以，对 state[1] 进行了依赖收集，而第一次的 state.push(0) 设置的是 state 的第 0 个元素，所以不会触发响应式更新。而第二次的 push 触发了对 state[1] 的更新。这看起来很合理，没啥问题。那么我们再来看另外一个示例：\n\n```typescript\n// 响应式数据\nconst state = reactive([])\n\n// 观测变化\neffect(() => console.log('state map: ', state.map(item => item))\n\nstate.push(1)\n```\n\n按照常理来说，state.map 由于 state 是个空数组，所以理论上不会对数组的每一项进行访问，所以 state.push(1) 理论上也不会触发 effect。但实际上是会的，为什么呢？我们再来看一下一个 proxy 的 demo：\n\n```typescript\nconst raw = []\nconst arr = new Proxy(raw, {\n  get(target, key) {\n    console.log('get', key)\n    return Reflect.get(target, key)\n  },\n  set(target, key, value) {\n    console.log('set', key)\n    return Reflect.set(target, key, value)\n  }\n})\n\narr.map(v => v)\n```\n\n可以看到打印的内容如下：\n\n```\nget map\nget length\nget constructor\n```\n\n可以看到 map 函数的操作，会触发对数组的 length 访问！这就有意思了，当访问数组 length 的时候，我们进行了对 state 的依赖收集，而数组的 push 操作也会改变 length 的长度，如果我们对 length 做监听，那么此时便会触发 effect！而 Vue 也是这么做的，也就是这段代码：\n\n```typescript\ndeps.push(depsMap.get('length'))\n```\n\n同理，对于 for in, forEach, map ... 都会触发 length 的依赖收集，从而 pop, push, shift... 等等操作都会触发响应式更新！\n\n另外，除了数组，对象的 Object.keys , for ... of ... 等等对象遍历操作都会触发响应式的依赖收集，这是因为 Vue 在定义 Proxy 的时候，定义了 ownKeys 这个函数：\n\n```typescript\nfunction ownKeys(target) {\n  track(target, TrackOpTypes.ITERATE, isArray(target) ? 'length' : ITERATE_KEY)\n  return Reflect.ownKeys(target)\n}\n```\n\nownKeys 函数内部执行了 track 进行了对 Object 的 ITERATE_KEY 的依赖收集。而在 setter 的时候，则对 ITERATE_KEY 进行了响应式触发：\n\n```typescript\ndeps.push(depsMap.get(ITERATE_KEY))\n```\n\n总结\n至此，我们讲完了对响应式的依赖收集和触发过程，但有个概览我们没有说清楚，那就是 effect 到底是什么，以及是如何产生的被收集到 dep 当中的。下一节我们将具体介绍。\n\n课外知识\n这里细心的小伙伴，可能会注意到在上面的源码中出现了一个有意思的标识符 /*#__PURE__*/。要说这个东西，那就需要说到和这玩意相关的 Tree-Shaking 副作用了。我们知道 Tree-Shaking 可以删除一些 DC（dead code） 代码。但是对于一些有副作用的函数代码，却是无法进行很好的识别和删除，举个例子：\n\n```typescript\nfoo()\n\nfunction foo(obj) {\n  obj?.a\n}\n```\n\n上述代码中，foo 函数本身是没有任何意义的，仅仅是对对象 obj 进行了属性 a 的读取操作，但是 Tree-Shaking 是无法删除该函数的，因为上述的属性读取操作可能会产生副作用，因为 obj 可能是一个响应式对象，我们可能对 obj 定了一个 getter 在 getter 中触发了很多不可预期的操作。\n\n如果我们确认 foo 函数是一个不会有副作用的纯净的函数，那么这个时候 /*#__PURE__*/ 就派上用场了，其作用就是告诉打包器，对于 foo 函数的调用不会产生副作用，你可以放心地对其进行 Tree-Shaking。\n\n另外，值得一提的是，在 Vue 3 源码中，包含了大量的 /*#__PURE__*/ 标识符，可见 Vue 3 对源码体积的控制是多么的用心！","source":"_drafts/technical-disclosure-of-vue3/proxy-response.md","raw":"---\ntitle: 响应式原理：基于 Proxy 的响应式是什么样的？\ncategories:\n  - Vue3 技术揭秘\n---\n\n\n#### 前言\n本小节我们开启响应式原理的篇章，在开启这个篇章之前，我们先来了解一下 Vue3 中一个基于 Composition API 响应式应用的例子是如何编写的：\n\n```html\n<template>\n  <div>\n    {{ state.msg }} {{ count }}\n  </div>\n</template>\n<script>\n  import { reactive, ref } from 'vue'\n  export default {\n    setup() {\n      const state = reactive({\n        msg: 'hello world'\n      })\n      \n      const count = ref(0)\n      \n      const changeMsg = () => {\n        state.msg = 'world hello'\n      }\n\n      return {\n        state,\n        count,\n        changeMsg,\n      }\n    }\n  }\n</script>\n```\n\n此时我们通过 reactive API 或者 ref API 来定义响应式对象。\n\n对于 reactive API 而言，核心是用来定义集合类型的数据，比如：普通对象、数组和 Map、Set。\n\n对于 ref API 而言，可以用来对 string、number、boolean 这些原始类型数据进行响应式定义。\n\n关于二者使用上的更多区别和差异，小伙伴们可以直接参见 Vue 3 官网上《响应式基础》这个章节中的介绍。对于二者的核心实现原理，其实都是依托于 Vue 3 的响应式基础，本小节将以 reactive API 作为切入点，核心分析 Vue 3 的响应式原理。\n\n#### Reactive\n找到源码中关于 reactive 部分的定义：\n\n```typescript\nexport function reactive(target: object) {\n  // 不需要对 readonly 的对象进行响应式\n  if (isReadonly(target)) {\n    return target\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  )\n}\n```\n\n这个函数核心也就是通过 createReactiveObject 把我们传入的 target 变成响应式的：\n\n```typescript\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n  // 如果目标不是对象，则直接返回\n  if (!isObject(target)) {\n    return target\n  }\n  // 已经是一个响应式对象了，也直接返回\n  if (\n    target[ReactiveFlags.RAW] &&\n    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])\n  ) {\n    return target\n  }\n  // proxyMap 中已经存入过 target，直接返回\n  const existingProxy = proxyMap.get(target)\n  if (existingProxy) {\n    return existingProxy\n  }\n  // 只有特定类型的值才能被 observe.\n  const targetType = getTargetType(target)\n  if (targetType === TargetType.INVALID) {\n    return target\n  }\n  // 通过 proxy 来构造一个响应式对象\n  const proxy = new Proxy(\n    target,\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers\n  )\n  // 缓存 target proxy\n  proxyMap.set(target, proxy)\n  return proxy\n}\n```\n\n上述整个核心流程就是首先经过一系列判断，判断符合要求的 target 才能被响应式，整理的判断包括了target 的类型、是否是响应式的、是否已经被定义过了，以及是否是符合要求的类型这些步骤，最后执行的是 new Proxy() 这样的一个响应式代理 API。一起来看看这个 API 的实现：\n\n```typescript\n  const proxy = new Proxy(\n    target,\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers\n  )\n```\n\nProxy 根据 targetType 来确定执行的是 collectionHandlers 还是 baseHandlers。那 targetType 是什么时候确定的呢？可以看一下：\n\n```typescript\nconst targetType = getTargetType(target)\n\nfunction getTargetType(value) {\n  return value[ReactiveFlags.SKIP] || !Object.isExtensible(value)\n    ? TargetType.INVALID\n    : targetTypeMap(toRawType(value))\n}\n\nexport const toRawType = (value) => {\n  // toTypeString 转换成字符串的方式，比如 \"[object RawType]\"\n  return toTypeString(value).slice(8, -1)\n}\n\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case 'Object':\n    case 'Array':\n      return TargetType.COMMON\n    case 'Map':\n    case 'Set':\n    case 'WeakMap':\n    case 'WeakSet':\n      return TargetType.COLLECTION\n    default:\n      return TargetType.INVALID\n  }\n}\n```\n\n因为 target 传入进来的是一个 Object，所以 toRawType(value) 得到的值是 Object。所以这里的 targetType 的值等于 TargetType.COMMON 也就是执行了 baseHandlers 。而当我们的 reactive(target) 中的 target 是个 WeakMap 或者 WeakSet 时，那么执行的就是 collectionHandlers 了。\n\n接下来看一下 baseHandlers 的实现：\n\n```typescript\nexport const mutableHandlers = {\n  get,\n  set,\n  deleteProperty,\n  has,\n  ownKeys\n}\n```\n\n这里就是 Proxy 中的定义 handler 的一些属性。\n\nget：属性读取操作的捕捉器。\nset：属性设置操作的捕捉器。\ndeleteProperty：delete 操作符的捕捉器。\nhas：in 操作符的捕捉器。\nownKeys：Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。\n而关于响应式核心的部分就在 set 和 get 中，我们一起来看一下二者的定义实现。\n\n##### 1. get\n其中 get 的实现：\n\n```typescript\nconst get = /*#__PURE__*/ createGetter()\n```\n\n可以看到核心其实通过 createGetter 来实现的：\n\n```typescript\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target: Target, key: string | symbol, receiver: object) {\n    // 对 ReactiveFlags 的处理部分\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return !isReadonly\n    } else if (key === ReactiveFlags.IS_READONLY) {\n      return isReadonly\n    } else if (key === ReactiveFlags.IS_SHALLOW) {\n      return shallow\n    } else if (\n      key === ReactiveFlags.RAW &&\n      receiver ===\n        (isReadonly\n          ? shallow\n            ? shallowReadonlyMap\n            : readonlyMap\n          : shallow\n          ? shallowReactiveMap\n          : reactiveMap\n        ).get(target)\n    ) {\n      return target\n    }\n    \n    const targetIsArray = isArray(target)\n    if (!isReadonly) {\n      // 数组的特殊方法处理\n      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\n        return Reflect.get(arrayInstrumentations, key, receiver)\n      }\n      // 对象 hasOwnProperty 方法处理\n      if (key === 'hasOwnProperty') {\n        return hasOwnProperty\n      }\n    }\n    // 取值\n    const res = Reflect.get(target, key, receiver)\n    \n    // Symbol Key 不做依赖收集\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res\n    }\n    \n    // 进行依赖收集\n    if (!isReadonly) {\n      track(target, TrackOpTypes.GET, key)\n    }\n    \n    // 如果是浅层响应，那么直接返回，不需要递归了\n    if (shallow) {\n      return res\n    }\n    \n    \n    if (isRef(res)) {\n      // 跳过数组、整数 key 的展开\n      return targetIsArray && isIntegerKey(key) ? res : res.value\n    }\n\n    if (isObject(res)) {\n      // 如果 isReadonly 是 true，那么直接返回 readonly(res)\n      // 如果 res 是个对象或者数组类型，则递归执行 reactive 函数把 res 变成响应式\n      return isReadonly ? readonly(res) : reactive(res)\n    }\n\n    return res\n  }\n}\n```\n\n因为调用 createGetter 时，默认参数 isReadonly = false，所以这里可以先忽略 isReadonly 的部分。整体而言，该函数还是比较通俗易懂的，首先对 key 属于 ReactiveFlags 的部分做了特殊处理，这也是为什么在 createReactiveObject 函数中判断响应式对象是否存在 ReactiveFlags.RAW 属性，如果存在就返回这个响应式对象本身。\n\n然后当我们的 target 是数组，且 key 值存在 arrayInstrumentations 中时，返回 arrayInstrumentations 中对应的 key 值。再来看看 arrayInstrumentations 是个什么：\n\n```typescript\nconst arrayInstrumentations = createArrayInstrumentations()\n\nfunction createArrayInstrumentations() {\n  const instrumentations = {};\n  (['includes', 'indexOf', 'lastIndexOf']).forEach(key => {\n    instrumentations[key] = function (this, ...args) {\n      // toRaw 可以把响应式对象转成原始数据\n      const arr = toRaw(this)\n      \n      for (let i = 0, l = this.length; i < l; i++) {\n        // 对数组的每一项进行依赖收集\n        track(arr, TrackOpTypes.GET, i + '')\n      }\n      // 先尝试用参数本身，可能是响应式数据\n      const res = arr[key](...args)\n      if (res === -1 || res === false) {\n        // 如果失败，再尝试把参数转成原始数据\n        return arr[key](...args.map(toRaw))\n      } else {\n        return res\n      }\n    }\n  })\n  // instrument length-altering mutation methods to avoid length being tracked\n  // which leads to infinite loops in some cases (#2137)\n  ;(['push', 'pop', 'shift', 'unshift', 'splice'] as const).forEach(key => {\n    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {\n      pauseTracking()\n      const res = (toRaw(this) as any)[key].apply(this, args)\n      resetTracking()\n      return res\n    }\n  })\n  return instrumentations\n}\n```\n\n当reactive函数传入数组时，get捕获器会先在arrayInstrumentations对象上查找，如果找不到，再在代理对象target上查找。arrayInstrumentations对象会重写两类函数，一类是查询类函数: includes、 indexOf、 lastIndexOf，代表对数组的读取操作。在这些函数中会执行track函数，对数组上的索引和length属性进行追踪。\n\n一类是修改类函数push、 pop、 shift、 unshift、 splice，代表对数组的修改操作，在这些函数中暂停了全局的追踪功能，防止某些情况下导致死循环。关于这里的一些说明也可以参见 Vue issue。\n\n再回过头看 createGetter 中，接下来的操作就是通过 track(target, TrackOpTypes.GET, key) 进行依赖收集，我们再来一起看一下 track 的实现：\n\n```typescript\n// 是否应该收集依赖\nlet shouldTrack = true\n// 当前激活的 effect\nlet activeEffect\n// 存放所有 reactive 传入的 receiver 容器\nconst targetMap = new WeakMap()\n\nexport function track(target, type, key) {\n  if (shouldTrack && activeEffect) {\n    let depsMap = targetMap.get(target)\n    if (!depsMap) {\n      targetMap.set(target, (depsMap = new Map()))\n    }\n    let dep = depsMap.get(key)\n    if (!dep) {\n      depsMap.set(key, (dep = createDep()))\n    }\n\n    trackEffects(dep)\n  }\n}\n\n\nexport function trackEffects(\n  dep,\n  debuggerEventExtraInfo\n) {\n  // ...\n  if (shouldTrack) {\n    // 把 activeEffect 添加到 dep 中\n    dep.add(activeEffect!)\n    activeEffect!.deps.push(dep)\n  }\n}\n```\n\n上面函数有点绕，其实核心就是在生成一个数据结构，什么样的数据结构呢？我们来画个图看看：\n\nimage.png\n\n我们创建了全局的 targetMap ，它的键是 target，值是 depsMap；这个 depsMap 的键是 target 的 key，值是 dep 集合，dep 集合中存储的是依赖的副作用函数 effect。\n\n另外，关于 trackEffects 的实现细节，我们后面的小节再详细介绍。\n\n注意到 Proxy 在访问对象属性时才递归执行劫持对象属性，相比 Object.defineProperty 在定义时就遍历把所有层级的对象设置成响应式而言，在性能上有所提升。\n\n##### 2. set\n上面说完了 get 的流程，我们了解了依赖收集后的数据结构存储在了 targetMap 中，接下来我们接着看 set 的过程：\n\n```typescript\nconst set = /*#__PURE__*/ createSetter()\n```\n\n可以看到核心其实通过 createSetter 来实现的：\n\n```typescript\nfunction createSetter(shallow = false) {\n  return function set(target, key, value, receiver) {\n    let oldValue = target[key]\n    // 不是浅层响应式，这里默认是 false\n    if (!shallow) {\n      // 不是浅层响应式对象\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue)\n        value = toRaw(value)\n      }\n      // ...\n    } else {\n      // 在浅模式中，对象被设置为原始值，而不管是否是响应式\n    }\n\n    const hadKey =\n      isArray(target) && isIntegerKey(key)\n        ? Number(key) < target.length\n        : hasOwn(target, key)\n    const result = Reflect.set(target, key, value, receiver)\n     // 如果目标的原型链也是一个 proxy，通过 Reflect.set 修改原型链上的属性会再次触发 setter，这种情况下就没必要触发两次 trigger 了\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, TriggerOpTypes.ADD, key, value)\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, TriggerOpTypes.SET, key, value, oldValue)\n      }\n    }\n    return result\n  }\n}\n```\n\n可以看到 set 的核心逻辑是先根据是否是浅层响应式来确定原始值和新值，这里默认不是浅层的响应式，所以会先把原始值和新值进行 toRaw 转换，然后通过 Reflect.set 设置值，最后通过 trigger 函数派发通知 ，并依据 key 是否存在于 target 上来确定通知类型是 add（新增） 还是 set（修改）。\n\n接下来核心就是 trigger 的逻辑，是如何实现触发响应的:\n\n```typescript\nexport function trigger(target,type,key,newValue,oldValue,oldTarget) {\n  const depsMap = targetMap.get(target)\n  if (!depsMap) {\n    return\n  }\n  let deps: (Dep | undefined)[] = []\n  if (type === TriggerOpTypes.CLEAR) {\n    deps = [...depsMap.values()]\n  } else if (key === 'length' && isArray(target)) {\n    depsMap.forEach((dep, key) => {\n      if (key === 'length' || key >= toNumber(newValue)) {\n        deps.push(dep)\n      }\n    })\n  } else {\n    if (key !== void 0) {\n      deps.push(depsMap.get(key))\n    }\n\n    switch (type) {\n      case TriggerOpTypes.ADD:\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY))\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\n          }\n        } else if (isIntegerKey(key)) {\n          deps.push(depsMap.get('length'))\n        }\n        break\n      case TriggerOpTypes.DELETE:\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY))\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\n          }\n        }\n        break\n      case TriggerOpTypes.SET:\n        if (isMap(target)) {\n          deps.push(depsMap.get(ITERATE_KEY))\n        }\n        break\n    }\n  }\n\n  if (deps.length === 1) {\n    if (deps[0]) {\n      triggerEffects(deps[0])\n    }\n  } else {\n    const effects: ReactiveEffect[] = []\n    for (const dep of deps) {\n      if (dep) {\n        effects.push(...dep)\n      }\n    }\n    triggerEffects(createDep(effects))\n  }\n}\n```\n\n内容有点多，看起来有点头大，我们来简化一下：\n\n```typescript\nexport function trigger(target, type, key) {\n  const dep = targetMap.get(target)\n  dep.get(key).forEach(effect => effect.run())\n}\n```\n\n核心其实就是通过 target 找到 targetMap 中的 dep，再根据 key 来找到所有的副作用函数 effect 遍历执行。副作用函数就是上面 get 收集起来的。\n\n这里有个有意思的地方是对数组的操作监听，我们来看一段代码：\n\n```typescript\nconst state = reactive([]);\n\neffect(() => {\n  console.log(`state: ${state[1]}`)\n});\n\n// 不会触发 effect\nstate.push(0);\n\n// 触发 effect\nstate.push(1);\n```\n\n上面的 demo 中，我们第一次访问了 state[1]， 所以，对 state[1] 进行了依赖收集，而第一次的 state.push(0) 设置的是 state 的第 0 个元素，所以不会触发响应式更新。而第二次的 push 触发了对 state[1] 的更新。这看起来很合理，没啥问题。那么我们再来看另外一个示例：\n\n```typescript\n// 响应式数据\nconst state = reactive([])\n\n// 观测变化\neffect(() => console.log('state map: ', state.map(item => item))\n\nstate.push(1)\n```\n\n按照常理来说，state.map 由于 state 是个空数组，所以理论上不会对数组的每一项进行访问，所以 state.push(1) 理论上也不会触发 effect。但实际上是会的，为什么呢？我们再来看一下一个 proxy 的 demo：\n\n```typescript\nconst raw = []\nconst arr = new Proxy(raw, {\n  get(target, key) {\n    console.log('get', key)\n    return Reflect.get(target, key)\n  },\n  set(target, key, value) {\n    console.log('set', key)\n    return Reflect.set(target, key, value)\n  }\n})\n\narr.map(v => v)\n```\n\n可以看到打印的内容如下：\n\n```\nget map\nget length\nget constructor\n```\n\n可以看到 map 函数的操作，会触发对数组的 length 访问！这就有意思了，当访问数组 length 的时候，我们进行了对 state 的依赖收集，而数组的 push 操作也会改变 length 的长度，如果我们对 length 做监听，那么此时便会触发 effect！而 Vue 也是这么做的，也就是这段代码：\n\n```typescript\ndeps.push(depsMap.get('length'))\n```\n\n同理，对于 for in, forEach, map ... 都会触发 length 的依赖收集，从而 pop, push, shift... 等等操作都会触发响应式更新！\n\n另外，除了数组，对象的 Object.keys , for ... of ... 等等对象遍历操作都会触发响应式的依赖收集，这是因为 Vue 在定义 Proxy 的时候，定义了 ownKeys 这个函数：\n\n```typescript\nfunction ownKeys(target) {\n  track(target, TrackOpTypes.ITERATE, isArray(target) ? 'length' : ITERATE_KEY)\n  return Reflect.ownKeys(target)\n}\n```\n\nownKeys 函数内部执行了 track 进行了对 Object 的 ITERATE_KEY 的依赖收集。而在 setter 的时候，则对 ITERATE_KEY 进行了响应式触发：\n\n```typescript\ndeps.push(depsMap.get(ITERATE_KEY))\n```\n\n总结\n至此，我们讲完了对响应式的依赖收集和触发过程，但有个概览我们没有说清楚，那就是 effect 到底是什么，以及是如何产生的被收集到 dep 当中的。下一节我们将具体介绍。\n\n课外知识\n这里细心的小伙伴，可能会注意到在上面的源码中出现了一个有意思的标识符 /*#__PURE__*/。要说这个东西，那就需要说到和这玩意相关的 Tree-Shaking 副作用了。我们知道 Tree-Shaking 可以删除一些 DC（dead code） 代码。但是对于一些有副作用的函数代码，却是无法进行很好的识别和删除，举个例子：\n\n```typescript\nfoo()\n\nfunction foo(obj) {\n  obj?.a\n}\n```\n\n上述代码中，foo 函数本身是没有任何意义的，仅仅是对对象 obj 进行了属性 a 的读取操作，但是 Tree-Shaking 是无法删除该函数的，因为上述的属性读取操作可能会产生副作用，因为 obj 可能是一个响应式对象，我们可能对 obj 定了一个 getter 在 getter 中触发了很多不可预期的操作。\n\n如果我们确认 foo 函数是一个不会有副作用的纯净的函数，那么这个时候 /*#__PURE__*/ 就派上用场了，其作用就是告诉打包器，对于 foo 函数的调用不会产生副作用，你可以放心地对其进行 Tree-Shaking。\n\n另外，值得一提的是，在 Vue 3 源码中，包含了大量的 /*#__PURE__*/ 标识符，可见 Vue 3 对源码体积的控制是多么的用心！","slug":"technical-disclosure-of-vue3/proxy-response","published":0,"date":"2023-08-12T07:53:19.989Z","updated":"2023-08-12T07:53:19.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokr0015sovcdaa3hy2v","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>本小节我们开启响应式原理的篇章，在开启这个篇章之前，我们先来了解一下 Vue3 中一个基于 Composition API 响应式应用的例子是如何编写的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    &#123;&#123; state.msg &#125;&#125; &#123;&#123; count &#125;&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">import</span> &#123; reactive, ref &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"title function_\">setup</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">const</span> state = <span class=\"title function_\">reactive</span>(&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"attr\">msg</span>: <span class=\"string\">&#x27;hello world&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">      &#125;)</span></span><br><span class=\"line\"><span class=\"language-javascript\">      </span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">const</span> count = <span class=\"title function_\">ref</span>(<span class=\"number\">0</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">      </span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">const</span> <span class=\"title function_\">changeMsg</span> = (<span class=\"params\"></span>) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        state.<span class=\"property\">msg</span> = <span class=\"string\">&#x27;world hello&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">      &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        state,</span></span><br><span class=\"line\"><span class=\"language-javascript\">        count,</span></span><br><span class=\"line\"><span class=\"language-javascript\">        changeMsg,</span></span><br><span class=\"line\"><span class=\"language-javascript\">      &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>此时我们通过 reactive API 或者 ref API 来定义响应式对象。</p>\n<p>对于 reactive API 而言，核心是用来定义集合类型的数据，比如：普通对象、数组和 Map、Set。</p>\n<p>对于 ref API 而言，可以用来对 string、number、boolean 这些原始类型数据进行响应式定义。</p>\n<p>关于二者使用上的更多区别和差异，小伙伴们可以直接参见 Vue 3 官网上《响应式基础》这个章节中的介绍。对于二者的核心实现原理，其实都是依托于 Vue 3 的响应式基础，本小节将以 reactive API 作为切入点，核心分析 Vue 3 的响应式原理。</p>\n<h4 id=\"Reactive\"><a href=\"#Reactive\" class=\"headerlink\" title=\"Reactive\"></a>Reactive</h4><p>找到源码中关于 reactive 部分的定义：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">reactive</span>(<span class=\"params\">target: <span class=\"built_in\">object</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 不需要对 readonly 的对象进行响应式</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title function_\">isReadonly</span>(target)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">createReactiveObject</span>(</span><br><span class=\"line\">    target,</span><br><span class=\"line\">    <span class=\"literal\">false</span>,</span><br><span class=\"line\">    mutableHandlers,</span><br><span class=\"line\">    mutableCollectionHandlers,</span><br><span class=\"line\">    reactiveMap</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数核心也就是通过 createReactiveObject 把我们传入的 target 变成响应式的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createReactiveObject</span>(<span class=\"params\">target, isReadonly, baseHandlers, collectionHandlers, proxyMap</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果目标不是对象，则直接返回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"title function_\">isObject</span>(target)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 已经是一个响应式对象了，也直接返回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    target[<span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">RAW</span>] &amp;&amp;</span><br><span class=\"line\">    !(isReadonly &amp;&amp; target[<span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">IS_REACTIVE</span>])</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// proxyMap 中已经存入过 target，直接返回</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> existingProxy = proxyMap.<span class=\"title function_\">get</span>(target)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (existingProxy) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> existingProxy</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 只有特定类型的值才能被 observe.</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> targetType = <span class=\"title function_\">getTargetType</span>(target)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (targetType === <span class=\"title class_\">TargetType</span>.<span class=\"property\">INVALID</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 通过 proxy 来构造一个响应式对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(</span><br><span class=\"line\">    target,</span><br><span class=\"line\">    targetType === <span class=\"title class_\">TargetType</span>.<span class=\"property\">COLLECTION</span> ? collectionHandlers : baseHandlers</span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"comment\">// 缓存 target proxy</span></span><br><span class=\"line\">  proxyMap.<span class=\"title function_\">set</span>(target, proxy)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> proxy</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述整个核心流程就是首先经过一系列判断，判断符合要求的 target 才能被响应式，整理的判断包括了target 的类型、是否是响应式的、是否已经被定义过了，以及是否是符合要求的类型这些步骤，最后执行的是 new Proxy() 这样的一个响应式代理 API。一起来看看这个 API 的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(</span><br><span class=\"line\">  target,</span><br><span class=\"line\">  targetType === <span class=\"title class_\">TargetType</span>.<span class=\"property\">COLLECTION</span> ? collectionHandlers : baseHandlers</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>Proxy 根据 targetType 来确定执行的是 collectionHandlers 还是 baseHandlers。那 targetType 是什么时候确定的呢？可以看一下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> targetType = <span class=\"title function_\">getTargetType</span>(target)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getTargetType</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value[<span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">SKIP</span>] || !<span class=\"title class_\">Object</span>.<span class=\"title function_\">isExtensible</span>(value)</span><br><span class=\"line\">    ? <span class=\"title class_\">TargetType</span>.<span class=\"property\">INVALID</span></span><br><span class=\"line\">    : <span class=\"title function_\">targetTypeMap</span>(<span class=\"title function_\">toRawType</span>(value))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">toRawType</span> = (<span class=\"params\">value</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// toTypeString 转换成字符串的方式，比如 &quot;[object RawType]&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">toTypeString</span>(value).<span class=\"title function_\">slice</span>(<span class=\"number\">8</span>, -<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">targetTypeMap</span>(<span class=\"params\">rawType</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (rawType) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;Object&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;Array&#x27;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">TargetType</span>.<span class=\"property\">COMMON</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;Map&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;Set&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;WeakMap&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;WeakSet&#x27;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">TargetType</span>.<span class=\"property\">COLLECTION</span></span><br><span class=\"line\">    <span class=\"attr\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">TargetType</span>.<span class=\"property\">INVALID</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为 target 传入进来的是一个 Object，所以 toRawType(value) 得到的值是 Object。所以这里的 targetType 的值等于 TargetType.COMMON 也就是执行了 baseHandlers 。而当我们的 reactive(target) 中的 target 是个 WeakMap 或者 WeakSet 时，那么执行的就是 collectionHandlers 了。</p>\n<p>接下来看一下 baseHandlers 的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> mutableHandlers = &#123;</span><br><span class=\"line\">  get,</span><br><span class=\"line\">  set,</span><br><span class=\"line\">  deleteProperty,</span><br><span class=\"line\">  has,</span><br><span class=\"line\">  ownKeys</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就是 Proxy 中的定义 handler 的一些属性。</p>\n<p>get：属性读取操作的捕捉器。<br>set：属性设置操作的捕捉器。<br>deleteProperty：delete 操作符的捕捉器。<br>has：in 操作符的捕捉器。<br>ownKeys：Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。<br>而关于响应式核心的部分就在 set 和 get 中，我们一起来看一下二者的定义实现。</p>\n<h5 id=\"1-get\"><a href=\"#1-get\" class=\"headerlink\" title=\"1. get\"></a>1. get</h5><p>其中 get 的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> get = <span class=\"comment\">/*#__PURE__*/</span> <span class=\"title function_\">createGetter</span>()</span><br></pre></td></tr></table></figure>\n\n<p>可以看到核心其实通过 createGetter 来实现的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createGetter</span>(<span class=\"params\">isReadonly = <span class=\"literal\">false</span>, shallow = <span class=\"literal\">false</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> <span class=\"title function_\">get</span>(<span class=\"params\">target: Target, key: <span class=\"built_in\">string</span> | <span class=\"built_in\">symbol</span>, receiver: <span class=\"built_in\">object</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 对 ReactiveFlags 的处理部分</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key === <span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">IS_REACTIVE</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> !isReadonly</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key === <span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">IS_READONLY</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> isReadonly</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key === <span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">IS_SHALLOW</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> shallow</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      key === <span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">RAW</span> &amp;&amp;</span><br><span class=\"line\">      receiver ===</span><br><span class=\"line\">        (isReadonly</span><br><span class=\"line\">          ? shallow</span><br><span class=\"line\">            ? shallowReadonlyMap</span><br><span class=\"line\">            : readonlyMap</span><br><span class=\"line\">          : shallow</span><br><span class=\"line\">          ? shallowReactiveMap</span><br><span class=\"line\">          : reactiveMap</span><br><span class=\"line\">        ).<span class=\"title function_\">get</span>(target)</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> target</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">const</span> targetIsArray = <span class=\"title function_\">isArray</span>(target)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isReadonly) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 数组的特殊方法处理</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (targetIsArray &amp;&amp; <span class=\"title function_\">hasOwn</span>(arrayInstrumentations, key)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(arrayInstrumentations, key, receiver)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 对象 hasOwnProperty 方法处理</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (key === <span class=\"string\">&#x27;hasOwnProperty&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hasOwnProperty</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 取值</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, key, receiver)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Symbol Key 不做依赖收集</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title function_\">isSymbol</span>(key) ? builtInSymbols.<span class=\"title function_\">has</span>(key) : <span class=\"title function_\">isNonTrackableKeys</span>(key)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 进行依赖收集</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isReadonly) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">track</span>(target, <span class=\"title class_\">TrackOpTypes</span>.<span class=\"property\">GET</span>, key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果是浅层响应，那么直接返回，不需要递归了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shallow) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title function_\">isRef</span>(res)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 跳过数组、整数 key 的展开</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> targetIsArray &amp;&amp; <span class=\"title function_\">isIntegerKey</span>(key) ? res : res.<span class=\"property\">value</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title function_\">isObject</span>(res)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果 isReadonly 是 true，那么直接返回 readonly(res)</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果 res 是个对象或者数组类型，则递归执行 reactive 函数把 res 变成响应式</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> isReadonly ? <span class=\"title function_\">readonly</span>(res) : <span class=\"title function_\">reactive</span>(res)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为调用 createGetter 时，默认参数 isReadonly &#x3D; false，所以这里可以先忽略 isReadonly 的部分。整体而言，该函数还是比较通俗易懂的，首先对 key 属于 ReactiveFlags 的部分做了特殊处理，这也是为什么在 createReactiveObject 函数中判断响应式对象是否存在 ReactiveFlags.RAW 属性，如果存在就返回这个响应式对象本身。</p>\n<p>然后当我们的 target 是数组，且 key 值存在 arrayInstrumentations 中时，返回 arrayInstrumentations 中对应的 key 值。再来看看 arrayInstrumentations 是个什么：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arrayInstrumentations = <span class=\"title function_\">createArrayInstrumentations</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createArrayInstrumentations</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> instrumentations = &#123;&#125;;</span><br><span class=\"line\">  ([<span class=\"string\">&#x27;includes&#x27;</span>, <span class=\"string\">&#x27;indexOf&#x27;</span>, <span class=\"string\">&#x27;lastIndexOf&#x27;</span>]).<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">    instrumentations[key] = <span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"variable language_\">this</span>, ...args</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// toRaw 可以把响应式对象转成原始数据</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> arr = <span class=\"title function_\">toRaw</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = <span class=\"variable language_\">this</span>.<span class=\"property\">length</span>; i &lt; l; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 对数组的每一项进行依赖收集</span></span><br><span class=\"line\">        <span class=\"title function_\">track</span>(arr, <span class=\"title class_\">TrackOpTypes</span>.<span class=\"property\">GET</span>, i + <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 先尝试用参数本身，可能是响应式数据</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> res = arr[key](...args)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (res === -<span class=\"number\">1</span> || res === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果失败，再尝试把参数转成原始数据</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr[key](...args.<span class=\"title function_\">map</span>(toRaw))</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"comment\">// instrument length-altering mutation methods to avoid length being tracked</span></span><br><span class=\"line\">  <span class=\"comment\">// which leads to infinite loops in some cases (#2137)</span></span><br><span class=\"line\">  ;([<span class=\"string\">&#x27;push&#x27;</span>, <span class=\"string\">&#x27;pop&#x27;</span>, <span class=\"string\">&#x27;shift&#x27;</span>, <span class=\"string\">&#x27;unshift&#x27;</span>, <span class=\"string\">&#x27;splice&#x27;</span>] <span class=\"keyword\">as</span> <span class=\"keyword\">const</span>).<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">    instrumentations[key] = <span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"variable language_\">this</span>: <span class=\"built_in\">unknown</span>[], ...args: <span class=\"built_in\">unknown</span>[]</span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">pauseTracking</span>()</span><br><span class=\"line\">      <span class=\"keyword\">const</span> res = (<span class=\"title function_\">toRaw</span>(<span class=\"variable language_\">this</span>) <span class=\"keyword\">as</span> <span class=\"built_in\">any</span>)[key].<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, args)</span><br><span class=\"line\">      <span class=\"title function_\">resetTracking</span>()</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> instrumentations</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当reactive函数传入数组时，get捕获器会先在arrayInstrumentations对象上查找，如果找不到，再在代理对象target上查找。arrayInstrumentations对象会重写两类函数，一类是查询类函数: includes、 indexOf、 lastIndexOf，代表对数组的读取操作。在这些函数中会执行track函数，对数组上的索引和length属性进行追踪。</p>\n<p>一类是修改类函数push、 pop、 shift、 unshift、 splice，代表对数组的修改操作，在这些函数中暂停了全局的追踪功能，防止某些情况下导致死循环。关于这里的一些说明也可以参见 Vue issue。</p>\n<p>再回过头看 createGetter 中，接下来的操作就是通过 track(target, TrackOpTypes.GET, key) 进行依赖收集，我们再来一起看一下 track 的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 是否应该收集依赖</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> shouldTrack = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\">// 当前激活的 effect</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> activeEffect</span><br><span class=\"line\"><span class=\"comment\">// 存放所有 reactive 传入的 receiver 容器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> targetMap = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakMap</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">track</span>(<span class=\"params\">target, <span class=\"keyword\">type</span>, key</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> depsMap = targetMap.<span class=\"title function_\">get</span>(target)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!depsMap) &#123;</span><br><span class=\"line\">      targetMap.<span class=\"title function_\">set</span>(target, (depsMap = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>()))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dep = depsMap.<span class=\"title function_\">get</span>(key)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!dep) &#123;</span><br><span class=\"line\">      depsMap.<span class=\"title function_\">set</span>(key, (dep = <span class=\"title function_\">createDep</span>()))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">trackEffects</span>(dep)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">trackEffects</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  dep,</span></span><br><span class=\"line\"><span class=\"params\">  debuggerEventExtraInfo</span></span><br><span class=\"line\"><span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldTrack) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 把 activeEffect 添加到 dep 中</span></span><br><span class=\"line\">    dep.<span class=\"title function_\">add</span>(activeEffect!)</span><br><span class=\"line\">    activeEffect!.<span class=\"property\">deps</span>.<span class=\"title function_\">push</span>(dep)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面函数有点绕，其实核心就是在生成一个数据结构，什么样的数据结构呢？我们来画个图看看：</p>\n<p>image.png</p>\n<p>我们创建了全局的 targetMap ，它的键是 target，值是 depsMap；这个 depsMap 的键是 target 的 key，值是 dep 集合，dep 集合中存储的是依赖的副作用函数 effect。</p>\n<p>另外，关于 trackEffects 的实现细节，我们后面的小节再详细介绍。</p>\n<p>注意到 Proxy 在访问对象属性时才递归执行劫持对象属性，相比 Object.defineProperty 在定义时就遍历把所有层级的对象设置成响应式而言，在性能上有所提升。</p>\n<h5 id=\"2-set\"><a href=\"#2-set\" class=\"headerlink\" title=\"2. set\"></a>2. set</h5><p>上面说完了 get 的流程，我们了解了依赖收集后的数据结构存储在了 targetMap 中，接下来我们接着看 set 的过程：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"comment\">/*#__PURE__*/</span> <span class=\"title function_\">createSetter</span>()</span><br></pre></td></tr></table></figure>\n\n<p>可以看到核心其实通过 createSetter 来实现的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createSetter</span>(<span class=\"params\">shallow = <span class=\"literal\">false</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> <span class=\"title function_\">set</span>(<span class=\"params\">target, key, value, receiver</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> oldValue = target[key]</span><br><span class=\"line\">    <span class=\"comment\">// 不是浅层响应式，这里默认是 false</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!shallow) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 不是浅层响应式对象</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"title function_\">isShallow</span>(value) &amp;&amp; !<span class=\"title function_\">isReadonly</span>(value)) &#123;</span><br><span class=\"line\">        oldValue = <span class=\"title function_\">toRaw</span>(oldValue)</span><br><span class=\"line\">        value = <span class=\"title function_\">toRaw</span>(value)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在浅模式中，对象被设置为原始值，而不管是否是响应式</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> hadKey =</span><br><span class=\"line\">      <span class=\"title function_\">isArray</span>(target) &amp;&amp; <span class=\"title function_\">isIntegerKey</span>(key)</span><br><span class=\"line\">        ? <span class=\"title class_\">Number</span>(key) &lt; target.<span class=\"property\">length</span></span><br><span class=\"line\">        : <span class=\"title function_\">hasOwn</span>(target, key)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, key, value, receiver)</span><br><span class=\"line\">     <span class=\"comment\">// 如果目标的原型链也是一个 proxy，通过 Reflect.set 修改原型链上的属性会再次触发 setter，这种情况下就没必要触发两次 trigger 了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target === <span class=\"title function_\">toRaw</span>(receiver)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!hadKey) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">trigger</span>(target, <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">ADD</span>, key, value)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">hasChanged</span>(value, oldValue)) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">trigger</span>(target, <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">SET</span>, key, value, oldValue)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 set 的核心逻辑是先根据是否是浅层响应式来确定原始值和新值，这里默认不是浅层的响应式，所以会先把原始值和新值进行 toRaw 转换，然后通过 Reflect.set 设置值，最后通过 trigger 函数派发通知 ，并依据 key 是否存在于 target 上来确定通知类型是 add（新增） 还是 set（修改）。</p>\n<p>接下来核心就是 trigger 的逻辑，是如何实现触发响应的:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">trigger</span>(<span class=\"params\">target,<span class=\"keyword\">type</span>,key,newValue,oldValue,oldTarget</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> depsMap = targetMap.<span class=\"title function_\">get</span>(target)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!depsMap) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">deps</span>: (<span class=\"title class_\">Dep</span> | <span class=\"literal\">undefined</span>)[] = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">type</span> === <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">CLEAR</span>) &#123;</span><br><span class=\"line\">    deps = [...depsMap.<span class=\"title function_\">values</span>()]</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key === <span class=\"string\">&#x27;length&#x27;</span> &amp;&amp; <span class=\"title function_\">isArray</span>(target)) &#123;</span><br><span class=\"line\">    depsMap.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">dep, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (key === <span class=\"string\">&#x27;length&#x27;</span> || key &gt;= <span class=\"title function_\">toNumber</span>(newValue)) &#123;</span><br><span class=\"line\">        deps.<span class=\"title function_\">push</span>(dep)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key !== <span class=\"built_in\">void</span> <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(key))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">ADD</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"title function_\">isArray</span>(target)) &#123;</span><br><span class=\"line\">          deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">ITERATE_KEY</span>))</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"title function_\">isMap</span>(target)) &#123;</span><br><span class=\"line\">            deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">MAP_KEY_ITERATE_KEY</span>))</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isIntegerKey</span>(key)) &#123;</span><br><span class=\"line\">          deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;length&#x27;</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">DELETE</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"title function_\">isArray</span>(target)) &#123;</span><br><span class=\"line\">          deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">ITERATE_KEY</span>))</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"title function_\">isMap</span>(target)) &#123;</span><br><span class=\"line\">            deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">MAP_KEY_ITERATE_KEY</span>))</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">SET</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title function_\">isMap</span>(target)) &#123;</span><br><span class=\"line\">          deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">ITERATE_KEY</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (deps.<span class=\"property\">length</span> === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (deps[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">triggerEffects</span>(deps[<span class=\"number\">0</span>])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">effects</span>: <span class=\"title class_\">ReactiveEffect</span>[] = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> dep <span class=\"keyword\">of</span> deps) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (dep) &#123;</span><br><span class=\"line\">        effects.<span class=\"title function_\">push</span>(...dep)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">triggerEffects</span>(<span class=\"title function_\">createDep</span>(effects))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>内容有点多，看起来有点头大，我们来简化一下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">trigger</span>(<span class=\"params\">target, <span class=\"keyword\">type</span>, key</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dep = targetMap.<span class=\"title function_\">get</span>(target)</span><br><span class=\"line\">  dep.<span class=\"title function_\">get</span>(key).<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">effect</span> =&gt;</span> effect.<span class=\"title function_\">run</span>())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>核心其实就是通过 target 找到 targetMap 中的 dep，再根据 key 来找到所有的副作用函数 effect 遍历执行。副作用函数就是上面 get 收集起来的。</p>\n<p>这里有个有意思的地方是对数组的操作监听，我们来看一段代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> state = <span class=\"title function_\">reactive</span>([]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`state: <span class=\"subst\">$&#123;state[<span class=\"number\">1</span>]&#125;</span>`</span>)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不会触发 effect</span></span><br><span class=\"line\">state.<span class=\"title function_\">push</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 触发 effect</span></span><br><span class=\"line\">state.<span class=\"title function_\">push</span>(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面的 demo 中，我们第一次访问了 state[1]， 所以，对 state[1] 进行了依赖收集，而第一次的 state.push(0) 设置的是 state 的第 0 个元素，所以不会触发响应式更新。而第二次的 push 触发了对 state[1] 的更新。这看起来很合理，没啥问题。那么我们再来看另外一个示例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 响应式数据</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> state = <span class=\"title function_\">reactive</span>([])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 观测变化</span></span><br><span class=\"line\"><span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;state map: &#x27;</span>, state.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item))</span><br><span class=\"line\"></span><br><span class=\"line\">state.<span class=\"title function_\">push</span>(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>按照常理来说，state.map 由于 state 是个空数组，所以理论上不会对数组的每一项进行访问，所以 state.push(1) 理论上也不会触发 effect。但实际上是会的，为什么呢？我们再来看一下一个 proxy 的 demo：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> raw = []</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(raw, &#123;</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\">target, key</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;get&#x27;</span>, key)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, key)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"title function_\">set</span>(<span class=\"params\">target, key, value</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;set&#x27;</span>, key)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, key, value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">arr.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v)</span><br></pre></td></tr></table></figure>\n\n<p>可以看到打印的内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">get map</span><br><span class=\"line\">get length</span><br><span class=\"line\">get constructor</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 map 函数的操作，会触发对数组的 length 访问！这就有意思了，当访问数组 length 的时候，我们进行了对 state 的依赖收集，而数组的 push 操作也会改变 length 的长度，如果我们对 length 做监听，那么此时便会触发 effect！而 Vue 也是这么做的，也就是这段代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;length&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>同理，对于 for in, forEach, map … 都会触发 length 的依赖收集，从而 pop, push, shift… 等等操作都会触发响应式更新！</p>\n<p>另外，除了数组，对象的 Object.keys , for … of … 等等对象遍历操作都会触发响应式的依赖收集，这是因为 Vue 在定义 Proxy 的时候，定义了 ownKeys 这个函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ownKeys</span>(<span class=\"params\">target</span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">track</span>(target, <span class=\"title class_\">TrackOpTypes</span>.<span class=\"property\">ITERATE</span>, <span class=\"title function_\">isArray</span>(target) ? <span class=\"string\">&#x27;length&#x27;</span> : <span class=\"variable constant_\">ITERATE_KEY</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">ownKeys</span>(target)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ownKeys 函数内部执行了 track 进行了对 Object 的 ITERATE_KEY 的依赖收集。而在 setter 的时候，则对 ITERATE_KEY 进行了响应式触发：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">ITERATE_KEY</span>))</span><br></pre></td></tr></table></figure>\n\n<p>总结<br>至此，我们讲完了对响应式的依赖收集和触发过程，但有个概览我们没有说清楚，那就是 effect 到底是什么，以及是如何产生的被收集到 dep 当中的。下一节我们将具体介绍。</p>\n<p>课外知识<br>这里细心的小伙伴，可能会注意到在上面的源码中出现了一个有意思的标识符 &#x2F;<em>#<strong>PURE</strong></em>&#x2F;。要说这个东西，那就需要说到和这玩意相关的 Tree-Shaking 副作用了。我们知道 Tree-Shaking 可以删除一些 DC（dead code） 代码。但是对于一些有副作用的函数代码，却是无法进行很好的识别和删除，举个例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">foo</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">obj</span>) &#123;</span><br><span class=\"line\">  obj?.<span class=\"property\">a</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码中，foo 函数本身是没有任何意义的，仅仅是对对象 obj 进行了属性 a 的读取操作，但是 Tree-Shaking 是无法删除该函数的，因为上述的属性读取操作可能会产生副作用，因为 obj 可能是一个响应式对象，我们可能对 obj 定了一个 getter 在 getter 中触发了很多不可预期的操作。</p>\n<p>如果我们确认 foo 函数是一个不会有副作用的纯净的函数，那么这个时候 &#x2F;<em>#<strong>PURE</strong></em>&#x2F; 就派上用场了，其作用就是告诉打包器，对于 foo 函数的调用不会产生副作用，你可以放心地对其进行 Tree-Shaking。</p>\n<p>另外，值得一提的是，在 Vue 3 源码中，包含了大量的 &#x2F;<em>#<strong>PURE</strong></em>&#x2F; 标识符，可见 Vue 3 对源码体积的控制是多么的用心！</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>本小节我们开启响应式原理的篇章，在开启这个篇章之前，我们先来了解一下 Vue3 中一个基于 Composition API 响应式应用的例子是如何编写的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    &#123;&#123; state.msg &#125;&#125; &#123;&#123; count &#125;&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">import</span> &#123; reactive, ref &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"title function_\">setup</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">const</span> state = <span class=\"title function_\">reactive</span>(&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"attr\">msg</span>: <span class=\"string\">&#x27;hello world&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">      &#125;)</span></span><br><span class=\"line\"><span class=\"language-javascript\">      </span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">const</span> count = <span class=\"title function_\">ref</span>(<span class=\"number\">0</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">      </span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">const</span> <span class=\"title function_\">changeMsg</span> = (<span class=\"params\"></span>) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        state.<span class=\"property\">msg</span> = <span class=\"string\">&#x27;world hello&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">      &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        state,</span></span><br><span class=\"line\"><span class=\"language-javascript\">        count,</span></span><br><span class=\"line\"><span class=\"language-javascript\">        changeMsg,</span></span><br><span class=\"line\"><span class=\"language-javascript\">      &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>此时我们通过 reactive API 或者 ref API 来定义响应式对象。</p>\n<p>对于 reactive API 而言，核心是用来定义集合类型的数据，比如：普通对象、数组和 Map、Set。</p>\n<p>对于 ref API 而言，可以用来对 string、number、boolean 这些原始类型数据进行响应式定义。</p>\n<p>关于二者使用上的更多区别和差异，小伙伴们可以直接参见 Vue 3 官网上《响应式基础》这个章节中的介绍。对于二者的核心实现原理，其实都是依托于 Vue 3 的响应式基础，本小节将以 reactive API 作为切入点，核心分析 Vue 3 的响应式原理。</p>\n<h4 id=\"Reactive\"><a href=\"#Reactive\" class=\"headerlink\" title=\"Reactive\"></a>Reactive</h4><p>找到源码中关于 reactive 部分的定义：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">reactive</span>(<span class=\"params\">target: <span class=\"built_in\">object</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 不需要对 readonly 的对象进行响应式</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title function_\">isReadonly</span>(target)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">createReactiveObject</span>(</span><br><span class=\"line\">    target,</span><br><span class=\"line\">    <span class=\"literal\">false</span>,</span><br><span class=\"line\">    mutableHandlers,</span><br><span class=\"line\">    mutableCollectionHandlers,</span><br><span class=\"line\">    reactiveMap</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数核心也就是通过 createReactiveObject 把我们传入的 target 变成响应式的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createReactiveObject</span>(<span class=\"params\">target, isReadonly, baseHandlers, collectionHandlers, proxyMap</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果目标不是对象，则直接返回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"title function_\">isObject</span>(target)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 已经是一个响应式对象了，也直接返回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    target[<span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">RAW</span>] &amp;&amp;</span><br><span class=\"line\">    !(isReadonly &amp;&amp; target[<span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">IS_REACTIVE</span>])</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// proxyMap 中已经存入过 target，直接返回</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> existingProxy = proxyMap.<span class=\"title function_\">get</span>(target)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (existingProxy) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> existingProxy</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 只有特定类型的值才能被 observe.</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> targetType = <span class=\"title function_\">getTargetType</span>(target)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (targetType === <span class=\"title class_\">TargetType</span>.<span class=\"property\">INVALID</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 通过 proxy 来构造一个响应式对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(</span><br><span class=\"line\">    target,</span><br><span class=\"line\">    targetType === <span class=\"title class_\">TargetType</span>.<span class=\"property\">COLLECTION</span> ? collectionHandlers : baseHandlers</span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"comment\">// 缓存 target proxy</span></span><br><span class=\"line\">  proxyMap.<span class=\"title function_\">set</span>(target, proxy)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> proxy</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述整个核心流程就是首先经过一系列判断，判断符合要求的 target 才能被响应式，整理的判断包括了target 的类型、是否是响应式的、是否已经被定义过了，以及是否是符合要求的类型这些步骤，最后执行的是 new Proxy() 这样的一个响应式代理 API。一起来看看这个 API 的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(</span><br><span class=\"line\">  target,</span><br><span class=\"line\">  targetType === <span class=\"title class_\">TargetType</span>.<span class=\"property\">COLLECTION</span> ? collectionHandlers : baseHandlers</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>Proxy 根据 targetType 来确定执行的是 collectionHandlers 还是 baseHandlers。那 targetType 是什么时候确定的呢？可以看一下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> targetType = <span class=\"title function_\">getTargetType</span>(target)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getTargetType</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value[<span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">SKIP</span>] || !<span class=\"title class_\">Object</span>.<span class=\"title function_\">isExtensible</span>(value)</span><br><span class=\"line\">    ? <span class=\"title class_\">TargetType</span>.<span class=\"property\">INVALID</span></span><br><span class=\"line\">    : <span class=\"title function_\">targetTypeMap</span>(<span class=\"title function_\">toRawType</span>(value))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">toRawType</span> = (<span class=\"params\">value</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// toTypeString 转换成字符串的方式，比如 &quot;[object RawType]&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">toTypeString</span>(value).<span class=\"title function_\">slice</span>(<span class=\"number\">8</span>, -<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">targetTypeMap</span>(<span class=\"params\">rawType</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (rawType) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;Object&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;Array&#x27;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">TargetType</span>.<span class=\"property\">COMMON</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;Map&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;Set&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;WeakMap&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;WeakSet&#x27;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">TargetType</span>.<span class=\"property\">COLLECTION</span></span><br><span class=\"line\">    <span class=\"attr\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">TargetType</span>.<span class=\"property\">INVALID</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为 target 传入进来的是一个 Object，所以 toRawType(value) 得到的值是 Object。所以这里的 targetType 的值等于 TargetType.COMMON 也就是执行了 baseHandlers 。而当我们的 reactive(target) 中的 target 是个 WeakMap 或者 WeakSet 时，那么执行的就是 collectionHandlers 了。</p>\n<p>接下来看一下 baseHandlers 的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> mutableHandlers = &#123;</span><br><span class=\"line\">  get,</span><br><span class=\"line\">  set,</span><br><span class=\"line\">  deleteProperty,</span><br><span class=\"line\">  has,</span><br><span class=\"line\">  ownKeys</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就是 Proxy 中的定义 handler 的一些属性。</p>\n<p>get：属性读取操作的捕捉器。<br>set：属性设置操作的捕捉器。<br>deleteProperty：delete 操作符的捕捉器。<br>has：in 操作符的捕捉器。<br>ownKeys：Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。<br>而关于响应式核心的部分就在 set 和 get 中，我们一起来看一下二者的定义实现。</p>\n<h5 id=\"1-get\"><a href=\"#1-get\" class=\"headerlink\" title=\"1. get\"></a>1. get</h5><p>其中 get 的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> get = <span class=\"comment\">/*#__PURE__*/</span> <span class=\"title function_\">createGetter</span>()</span><br></pre></td></tr></table></figure>\n\n<p>可以看到核心其实通过 createGetter 来实现的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createGetter</span>(<span class=\"params\">isReadonly = <span class=\"literal\">false</span>, shallow = <span class=\"literal\">false</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> <span class=\"title function_\">get</span>(<span class=\"params\">target: Target, key: <span class=\"built_in\">string</span> | <span class=\"built_in\">symbol</span>, receiver: <span class=\"built_in\">object</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 对 ReactiveFlags 的处理部分</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key === <span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">IS_REACTIVE</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> !isReadonly</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key === <span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">IS_READONLY</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> isReadonly</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key === <span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">IS_SHALLOW</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> shallow</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      key === <span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">RAW</span> &amp;&amp;</span><br><span class=\"line\">      receiver ===</span><br><span class=\"line\">        (isReadonly</span><br><span class=\"line\">          ? shallow</span><br><span class=\"line\">            ? shallowReadonlyMap</span><br><span class=\"line\">            : readonlyMap</span><br><span class=\"line\">          : shallow</span><br><span class=\"line\">          ? shallowReactiveMap</span><br><span class=\"line\">          : reactiveMap</span><br><span class=\"line\">        ).<span class=\"title function_\">get</span>(target)</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> target</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">const</span> targetIsArray = <span class=\"title function_\">isArray</span>(target)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isReadonly) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 数组的特殊方法处理</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (targetIsArray &amp;&amp; <span class=\"title function_\">hasOwn</span>(arrayInstrumentations, key)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(arrayInstrumentations, key, receiver)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 对象 hasOwnProperty 方法处理</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (key === <span class=\"string\">&#x27;hasOwnProperty&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hasOwnProperty</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 取值</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, key, receiver)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Symbol Key 不做依赖收集</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title function_\">isSymbol</span>(key) ? builtInSymbols.<span class=\"title function_\">has</span>(key) : <span class=\"title function_\">isNonTrackableKeys</span>(key)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 进行依赖收集</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isReadonly) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">track</span>(target, <span class=\"title class_\">TrackOpTypes</span>.<span class=\"property\">GET</span>, key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果是浅层响应，那么直接返回，不需要递归了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shallow) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title function_\">isRef</span>(res)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 跳过数组、整数 key 的展开</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> targetIsArray &amp;&amp; <span class=\"title function_\">isIntegerKey</span>(key) ? res : res.<span class=\"property\">value</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title function_\">isObject</span>(res)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果 isReadonly 是 true，那么直接返回 readonly(res)</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果 res 是个对象或者数组类型，则递归执行 reactive 函数把 res 变成响应式</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> isReadonly ? <span class=\"title function_\">readonly</span>(res) : <span class=\"title function_\">reactive</span>(res)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为调用 createGetter 时，默认参数 isReadonly &#x3D; false，所以这里可以先忽略 isReadonly 的部分。整体而言，该函数还是比较通俗易懂的，首先对 key 属于 ReactiveFlags 的部分做了特殊处理，这也是为什么在 createReactiveObject 函数中判断响应式对象是否存在 ReactiveFlags.RAW 属性，如果存在就返回这个响应式对象本身。</p>\n<p>然后当我们的 target 是数组，且 key 值存在 arrayInstrumentations 中时，返回 arrayInstrumentations 中对应的 key 值。再来看看 arrayInstrumentations 是个什么：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arrayInstrumentations = <span class=\"title function_\">createArrayInstrumentations</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createArrayInstrumentations</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> instrumentations = &#123;&#125;;</span><br><span class=\"line\">  ([<span class=\"string\">&#x27;includes&#x27;</span>, <span class=\"string\">&#x27;indexOf&#x27;</span>, <span class=\"string\">&#x27;lastIndexOf&#x27;</span>]).<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">    instrumentations[key] = <span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"variable language_\">this</span>, ...args</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// toRaw 可以把响应式对象转成原始数据</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> arr = <span class=\"title function_\">toRaw</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = <span class=\"variable language_\">this</span>.<span class=\"property\">length</span>; i &lt; l; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 对数组的每一项进行依赖收集</span></span><br><span class=\"line\">        <span class=\"title function_\">track</span>(arr, <span class=\"title class_\">TrackOpTypes</span>.<span class=\"property\">GET</span>, i + <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 先尝试用参数本身，可能是响应式数据</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> res = arr[key](...args)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (res === -<span class=\"number\">1</span> || res === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果失败，再尝试把参数转成原始数据</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr[key](...args.<span class=\"title function_\">map</span>(toRaw))</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"comment\">// instrument length-altering mutation methods to avoid length being tracked</span></span><br><span class=\"line\">  <span class=\"comment\">// which leads to infinite loops in some cases (#2137)</span></span><br><span class=\"line\">  ;([<span class=\"string\">&#x27;push&#x27;</span>, <span class=\"string\">&#x27;pop&#x27;</span>, <span class=\"string\">&#x27;shift&#x27;</span>, <span class=\"string\">&#x27;unshift&#x27;</span>, <span class=\"string\">&#x27;splice&#x27;</span>] <span class=\"keyword\">as</span> <span class=\"keyword\">const</span>).<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">    instrumentations[key] = <span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"variable language_\">this</span>: <span class=\"built_in\">unknown</span>[], ...args: <span class=\"built_in\">unknown</span>[]</span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">pauseTracking</span>()</span><br><span class=\"line\">      <span class=\"keyword\">const</span> res = (<span class=\"title function_\">toRaw</span>(<span class=\"variable language_\">this</span>) <span class=\"keyword\">as</span> <span class=\"built_in\">any</span>)[key].<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, args)</span><br><span class=\"line\">      <span class=\"title function_\">resetTracking</span>()</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> instrumentations</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当reactive函数传入数组时，get捕获器会先在arrayInstrumentations对象上查找，如果找不到，再在代理对象target上查找。arrayInstrumentations对象会重写两类函数，一类是查询类函数: includes、 indexOf、 lastIndexOf，代表对数组的读取操作。在这些函数中会执行track函数，对数组上的索引和length属性进行追踪。</p>\n<p>一类是修改类函数push、 pop、 shift、 unshift、 splice，代表对数组的修改操作，在这些函数中暂停了全局的追踪功能，防止某些情况下导致死循环。关于这里的一些说明也可以参见 Vue issue。</p>\n<p>再回过头看 createGetter 中，接下来的操作就是通过 track(target, TrackOpTypes.GET, key) 进行依赖收集，我们再来一起看一下 track 的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 是否应该收集依赖</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> shouldTrack = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\">// 当前激活的 effect</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> activeEffect</span><br><span class=\"line\"><span class=\"comment\">// 存放所有 reactive 传入的 receiver 容器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> targetMap = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakMap</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">track</span>(<span class=\"params\">target, <span class=\"keyword\">type</span>, key</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> depsMap = targetMap.<span class=\"title function_\">get</span>(target)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!depsMap) &#123;</span><br><span class=\"line\">      targetMap.<span class=\"title function_\">set</span>(target, (depsMap = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>()))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dep = depsMap.<span class=\"title function_\">get</span>(key)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!dep) &#123;</span><br><span class=\"line\">      depsMap.<span class=\"title function_\">set</span>(key, (dep = <span class=\"title function_\">createDep</span>()))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">trackEffects</span>(dep)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">trackEffects</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  dep,</span></span><br><span class=\"line\"><span class=\"params\">  debuggerEventExtraInfo</span></span><br><span class=\"line\"><span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldTrack) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 把 activeEffect 添加到 dep 中</span></span><br><span class=\"line\">    dep.<span class=\"title function_\">add</span>(activeEffect!)</span><br><span class=\"line\">    activeEffect!.<span class=\"property\">deps</span>.<span class=\"title function_\">push</span>(dep)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面函数有点绕，其实核心就是在生成一个数据结构，什么样的数据结构呢？我们来画个图看看：</p>\n<p>image.png</p>\n<p>我们创建了全局的 targetMap ，它的键是 target，值是 depsMap；这个 depsMap 的键是 target 的 key，值是 dep 集合，dep 集合中存储的是依赖的副作用函数 effect。</p>\n<p>另外，关于 trackEffects 的实现细节，我们后面的小节再详细介绍。</p>\n<p>注意到 Proxy 在访问对象属性时才递归执行劫持对象属性，相比 Object.defineProperty 在定义时就遍历把所有层级的对象设置成响应式而言，在性能上有所提升。</p>\n<h5 id=\"2-set\"><a href=\"#2-set\" class=\"headerlink\" title=\"2. set\"></a>2. set</h5><p>上面说完了 get 的流程，我们了解了依赖收集后的数据结构存储在了 targetMap 中，接下来我们接着看 set 的过程：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"comment\">/*#__PURE__*/</span> <span class=\"title function_\">createSetter</span>()</span><br></pre></td></tr></table></figure>\n\n<p>可以看到核心其实通过 createSetter 来实现的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createSetter</span>(<span class=\"params\">shallow = <span class=\"literal\">false</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> <span class=\"title function_\">set</span>(<span class=\"params\">target, key, value, receiver</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> oldValue = target[key]</span><br><span class=\"line\">    <span class=\"comment\">// 不是浅层响应式，这里默认是 false</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!shallow) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 不是浅层响应式对象</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"title function_\">isShallow</span>(value) &amp;&amp; !<span class=\"title function_\">isReadonly</span>(value)) &#123;</span><br><span class=\"line\">        oldValue = <span class=\"title function_\">toRaw</span>(oldValue)</span><br><span class=\"line\">        value = <span class=\"title function_\">toRaw</span>(value)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在浅模式中，对象被设置为原始值，而不管是否是响应式</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> hadKey =</span><br><span class=\"line\">      <span class=\"title function_\">isArray</span>(target) &amp;&amp; <span class=\"title function_\">isIntegerKey</span>(key)</span><br><span class=\"line\">        ? <span class=\"title class_\">Number</span>(key) &lt; target.<span class=\"property\">length</span></span><br><span class=\"line\">        : <span class=\"title function_\">hasOwn</span>(target, key)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, key, value, receiver)</span><br><span class=\"line\">     <span class=\"comment\">// 如果目标的原型链也是一个 proxy，通过 Reflect.set 修改原型链上的属性会再次触发 setter，这种情况下就没必要触发两次 trigger 了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target === <span class=\"title function_\">toRaw</span>(receiver)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!hadKey) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">trigger</span>(target, <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">ADD</span>, key, value)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">hasChanged</span>(value, oldValue)) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">trigger</span>(target, <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">SET</span>, key, value, oldValue)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 set 的核心逻辑是先根据是否是浅层响应式来确定原始值和新值，这里默认不是浅层的响应式，所以会先把原始值和新值进行 toRaw 转换，然后通过 Reflect.set 设置值，最后通过 trigger 函数派发通知 ，并依据 key 是否存在于 target 上来确定通知类型是 add（新增） 还是 set（修改）。</p>\n<p>接下来核心就是 trigger 的逻辑，是如何实现触发响应的:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">trigger</span>(<span class=\"params\">target,<span class=\"keyword\">type</span>,key,newValue,oldValue,oldTarget</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> depsMap = targetMap.<span class=\"title function_\">get</span>(target)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!depsMap) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">deps</span>: (<span class=\"title class_\">Dep</span> | <span class=\"literal\">undefined</span>)[] = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">type</span> === <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">CLEAR</span>) &#123;</span><br><span class=\"line\">    deps = [...depsMap.<span class=\"title function_\">values</span>()]</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key === <span class=\"string\">&#x27;length&#x27;</span> &amp;&amp; <span class=\"title function_\">isArray</span>(target)) &#123;</span><br><span class=\"line\">    depsMap.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">dep, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (key === <span class=\"string\">&#x27;length&#x27;</span> || key &gt;= <span class=\"title function_\">toNumber</span>(newValue)) &#123;</span><br><span class=\"line\">        deps.<span class=\"title function_\">push</span>(dep)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key !== <span class=\"built_in\">void</span> <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(key))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">ADD</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"title function_\">isArray</span>(target)) &#123;</span><br><span class=\"line\">          deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">ITERATE_KEY</span>))</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"title function_\">isMap</span>(target)) &#123;</span><br><span class=\"line\">            deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">MAP_KEY_ITERATE_KEY</span>))</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isIntegerKey</span>(key)) &#123;</span><br><span class=\"line\">          deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;length&#x27;</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">DELETE</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"title function_\">isArray</span>(target)) &#123;</span><br><span class=\"line\">          deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">ITERATE_KEY</span>))</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"title function_\">isMap</span>(target)) &#123;</span><br><span class=\"line\">            deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">MAP_KEY_ITERATE_KEY</span>))</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">SET</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title function_\">isMap</span>(target)) &#123;</span><br><span class=\"line\">          deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">ITERATE_KEY</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (deps.<span class=\"property\">length</span> === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (deps[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">triggerEffects</span>(deps[<span class=\"number\">0</span>])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">effects</span>: <span class=\"title class_\">ReactiveEffect</span>[] = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> dep <span class=\"keyword\">of</span> deps) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (dep) &#123;</span><br><span class=\"line\">        effects.<span class=\"title function_\">push</span>(...dep)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">triggerEffects</span>(<span class=\"title function_\">createDep</span>(effects))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>内容有点多，看起来有点头大，我们来简化一下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">trigger</span>(<span class=\"params\">target, <span class=\"keyword\">type</span>, key</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dep = targetMap.<span class=\"title function_\">get</span>(target)</span><br><span class=\"line\">  dep.<span class=\"title function_\">get</span>(key).<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">effect</span> =&gt;</span> effect.<span class=\"title function_\">run</span>())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>核心其实就是通过 target 找到 targetMap 中的 dep，再根据 key 来找到所有的副作用函数 effect 遍历执行。副作用函数就是上面 get 收集起来的。</p>\n<p>这里有个有意思的地方是对数组的操作监听，我们来看一段代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> state = <span class=\"title function_\">reactive</span>([]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`state: <span class=\"subst\">$&#123;state[<span class=\"number\">1</span>]&#125;</span>`</span>)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不会触发 effect</span></span><br><span class=\"line\">state.<span class=\"title function_\">push</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 触发 effect</span></span><br><span class=\"line\">state.<span class=\"title function_\">push</span>(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面的 demo 中，我们第一次访问了 state[1]， 所以，对 state[1] 进行了依赖收集，而第一次的 state.push(0) 设置的是 state 的第 0 个元素，所以不会触发响应式更新。而第二次的 push 触发了对 state[1] 的更新。这看起来很合理，没啥问题。那么我们再来看另外一个示例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 响应式数据</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> state = <span class=\"title function_\">reactive</span>([])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 观测变化</span></span><br><span class=\"line\"><span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;state map: &#x27;</span>, state.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item))</span><br><span class=\"line\"></span><br><span class=\"line\">state.<span class=\"title function_\">push</span>(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>按照常理来说，state.map 由于 state 是个空数组，所以理论上不会对数组的每一项进行访问，所以 state.push(1) 理论上也不会触发 effect。但实际上是会的，为什么呢？我们再来看一下一个 proxy 的 demo：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> raw = []</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(raw, &#123;</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\">target, key</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;get&#x27;</span>, key)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, key)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"title function_\">set</span>(<span class=\"params\">target, key, value</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;set&#x27;</span>, key)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, key, value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">arr.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v)</span><br></pre></td></tr></table></figure>\n\n<p>可以看到打印的内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">get map</span><br><span class=\"line\">get length</span><br><span class=\"line\">get constructor</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 map 函数的操作，会触发对数组的 length 访问！这就有意思了，当访问数组 length 的时候，我们进行了对 state 的依赖收集，而数组的 push 操作也会改变 length 的长度，如果我们对 length 做监听，那么此时便会触发 effect！而 Vue 也是这么做的，也就是这段代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;length&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>同理，对于 for in, forEach, map … 都会触发 length 的依赖收集，从而 pop, push, shift… 等等操作都会触发响应式更新！</p>\n<p>另外，除了数组，对象的 Object.keys , for … of … 等等对象遍历操作都会触发响应式的依赖收集，这是因为 Vue 在定义 Proxy 的时候，定义了 ownKeys 这个函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ownKeys</span>(<span class=\"params\">target</span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">track</span>(target, <span class=\"title class_\">TrackOpTypes</span>.<span class=\"property\">ITERATE</span>, <span class=\"title function_\">isArray</span>(target) ? <span class=\"string\">&#x27;length&#x27;</span> : <span class=\"variable constant_\">ITERATE_KEY</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">ownKeys</span>(target)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ownKeys 函数内部执行了 track 进行了对 Object 的 ITERATE_KEY 的依赖收集。而在 setter 的时候，则对 ITERATE_KEY 进行了响应式触发：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">ITERATE_KEY</span>))</span><br></pre></td></tr></table></figure>\n\n<p>总结<br>至此，我们讲完了对响应式的依赖收集和触发过程，但有个概览我们没有说清楚，那就是 effect 到底是什么，以及是如何产生的被收集到 dep 当中的。下一节我们将具体介绍。</p>\n<p>课外知识<br>这里细心的小伙伴，可能会注意到在上面的源码中出现了一个有意思的标识符 &#x2F;<em>#<strong>PURE</strong></em>&#x2F;。要说这个东西，那就需要说到和这玩意相关的 Tree-Shaking 副作用了。我们知道 Tree-Shaking 可以删除一些 DC（dead code） 代码。但是对于一些有副作用的函数代码，却是无法进行很好的识别和删除，举个例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">foo</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">obj</span>) &#123;</span><br><span class=\"line\">  obj?.<span class=\"property\">a</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码中，foo 函数本身是没有任何意义的，仅仅是对对象 obj 进行了属性 a 的读取操作，但是 Tree-Shaking 是无法删除该函数的，因为上述的属性读取操作可能会产生副作用，因为 obj 可能是一个响应式对象，我们可能对 obj 定了一个 getter 在 getter 中触发了很多不可预期的操作。</p>\n<p>如果我们确认 foo 函数是一个不会有副作用的纯净的函数，那么这个时候 &#x2F;<em>#<strong>PURE</strong></em>&#x2F; 就派上用场了，其作用就是告诉打包器，对于 foo 函数的调用不会产生副作用，你可以放心地对其进行 Tree-Shaking。</p>\n<p>另外，值得一提的是，在 Vue 3 源码中，包含了大量的 &#x2F;<em>#<strong>PURE</strong></em>&#x2F; 标识符，可见 Vue 3 对源码体积的控制是多么的用心！</p>\n"},{"title":"响应式原理：Watch 函数的实现原理","_content":"\n#### 前言\n在组合式 API 中，我们可以使用 watch 函数在每次响应式状态发生变化时触发回调函数，watch 的第一个参数可以是不同形式的数据类型：它可以是一个 ref（包括计算属性）、一个响应式对象、一个 getter 函数、或多个数据源组成的数组。\n\n```typescript\nconst x = ref(0)\nconst y = ref(0)\nconst state = reactive({ num: 0 })\n\n// 单个 ref\nwatch(x, (newX) => {\n  console.log(`x is ${newX}`)\n})\n\n// getter 函数\nwatch(\n  () => x.value + y.value,\n  (sum) => {\n    console.log(`sum of x + y is: ${sum}`)\n  }\n)\n\n// 响应式对象\nwatch(\n  state,\n  (newState) => {\n    console.log(`new state num is: ${newState.num}`)\n  }\n)\n\n// 多个来源组成的数组\nwatch([x, () => y.value], ([newX, newY]) => {\n  console.log(`x is ${newX} and y is ${newY}`)\n})\n```\n\n了解了一些基础的 watch 使用示例后，我们开始分析一下 watch 函数是如何实现的呢。\n\n#### 标准化 source\n先来看一下 watch 函数实现的代码：\n\n```typescript\nfunction watch(source, cb, options) { \n  // ...\n  return doWatch(source, cb, options) \n} \n\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) { \n  // ...\n} \n```\n\nwatch 函数内部是通过 doWatch 来执行的，在分析 doWatch 函数实现前，我们先看看前面的示例中，watch 监听的 source 可以是多种类型，一个函数可以支持多种类型的参数入参，那么实现该函数最好的设计模式就是 adapter 代理模式。就是将底层模型设计成一致的，抹平调用差异，这也是 doWatch 函数实现的第一步：标准化 source 参数。\n\n一起来看看其中的实现：\n\n```typescript\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {\n  // ...\n  // source 不合法的时候警告函数\n  const warnInvalidSource = (s: unknown) => {\n    warn(\n      `Invalid watch source: `,\n      s,\n      `A watch source can only be a getter/effect function, a ref, ` +\n      `a reactive object, or an array of these types.`\n    )\n  }\n  \n  const instance = currentInstance\n  let getter\n  let forceTrigger = false\n  let isMultiSource = false\n\n  // 判断是不是 ref 类型\n  if (isRef(source)) {\n    getter = () => source.value\n    forceTrigger = isShallow(source)\n  }\n  // 判断是不是响应式对象\n  else if (isReactive(source)) {\n    getter = () => source\n    deep = true\n  }\n  // 判断是不是数组类型\n  else if (isArray(source)) {\n    isMultiSource = true\n    forceTrigger = source.some(s => isReactive(s) || isShallow(s))\n    getter = () =>\n      source.map(s => {\n        if (isRef(s)) {\n          return s.value\n        } else if (isReactive(s)) {\n          return traverse(s)\n        } else if (isFunction(s)) {\n          return callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER)\n        } else {\n          __DEV__ && warnInvalidSource(s)\n        }\n      })\n  }\n  // 判断是不是函数类型\n  else if (isFunction(source)) {\n    if (cb) {\n      // getter with cb\n      getter = () =>\n        callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER)\n    } else {\n      // 如果只有一个函数作为source 入参，则执行 watchEffect 的逻辑\n      // ...\n    }\n  }\n  // 都不符合，则告警\n  else {\n    getter = NOOP\n    __DEV__ && warnInvalidSource(source)\n  }\n\n  // 深度监听\n  if (cb && deep) {\n    const baseGetter = getter\n    getter = () => traverse(baseGetter())\n  }\n  \n  // ...\n}\n```\n\n由于 doWatch 函数代码量比较多，我们先一部分一部分地来解读，这里我们只关注于标准化 source 的逻辑。可以看到 doWatch 函数会对入参的 source 做不同类型的判断逻辑，然后生成一个统一的 getter 函数：\n\nimage.png\n\ngetter 函数就是简单地对不同数据类型设置一个访问 source 的操作，比如对于 ref 就是一个创建了一个访问 source.value 的函数。\n\n那么为什么需要访问呢？由之前的响应式原理我们知道，只有在触发 proxy getter 的时候，才会进行依赖收集，所以，这里标准化的 source 函数中，不管是什么类型的 source 都会设计一个访问器函数。\n\n另外，需要注意的是当 source 是个响应式对象时，源码中会同时设置 deep = true。这是因为对于响应式对象，需要进行深度监听，因为响应式对象中的属性变化时，都需要进行反馈。那是怎么做到深度监听的呢？在回答这个问题之前，我们前面说了监听一个对象的属性就是需要先访问对象的属性，触发 proxy getter，把副作用 cb 收集起来。源码中则是通过 traverse 函数来实现对响应式对象属性的遍历访问：\n\n```typescript\nexport function traverse(value, seen) {\n  // ...\n  if (isRef(value)) {\n    // 如果是 ref 类型，继续递归执行 .value值\n    traverse(value.value, seen)\n  } else if (Array.isArray(value)) {\n    // 如果是数组类型\n    for (let i = 0; i < value.length; i++) {\n      // 递归调用 traverse 进行处理\n      traverse(value[i], seen)\n    }\n  } else if (isPlainObject(value)) {\n    // 如果是对象，使用 for in 读取对象的每一个值，并递归调用 traverse 进行处理\n    for (const key in value) {\n      traverse((value as any)[key], seen)\n    }\n  }\n  return value\n}\n```\n\n#### 构造副作用 effect\n前面说到，我们通过一系列操作，标准化了用户传入的 source 成了一个 getter 函数，此时的 getter 函数一方面还没有真正执行，也就没有触发对属性的访问操作。\n\nwatch 的本质是对数据源进行依赖收集，当依赖变化时，回调执行 cb 函数并传入新旧值。所以我们需要构造一个副作用函数，完成对数据源的变化追踪：\n\n```typescript\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) { \n  // ...\n  const effect = new ReactiveEffect(getter, scheduler)\n} \n```\n\n这里的 getter 就是前面构造的属性访问函数，我们在介绍响应式原理的章节中，介绍过 ReactiveEffect 函数，这里再来回顾一下 ReactiveEffect 的实现：\n\n```typescript\nclass ReactiveEffect {\n  constructor(\n    public fn: () => T,\n    public scheduler: EffectScheduler | null = null,\n    scope?: EffectScope\n  ) {\n    recordEffectScope(this, scope)\n  }\n  \n  run() {\n    // ...  \n    this.fn()\n  }\n}\n```\n\n这里细节部分可以详细阅读响应式原理的部分，我们只需要知道这里的 ReactiveEffect run 函数内部执行了 this.fn() 也就是上面传入的 getter 函数，所以，本质上是在此时完成了对 watch source 的访问。\n\n然后再看一下 ReactiveEffect 的第二个参数 scheduler，是如何构造的呢？\n\n#### 构造 scheduler 调度\n\n```typescript\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {\n  // ...\n  let oldValue = isMultiSource \n    ? new Array(source.length).fill(INITIAL_WATCHER_VALUE)\n    : INITIAL_WATCHER_VALUE\n  const job = () => {\n    // 被卸载\n    if (!effect.active) {\n      return\n    }\n    if (cb) {\n      // 获取新值\n      const newValue = effect.run()\n      // ...\n      // 执行 cb 函数\n      callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [\n        newValue,\n        // 第一次更改时传递旧值为 undefined\n        oldValue === INITIAL_WATCHER_VALUE\n          ? undefined\n          : (isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE)\n            ? []\n            : oldValue,\n        onCleanup\n        ])\n      oldValue = newValue\n    } else {\n      // watchEffect\n      effect.run()\n    }\n  }\n\n  let scheduler\n  // 直接赋值为 job 函数\n  if (flush === 'sync') {\n    scheduler = job\n  } else if (flush === 'post') {\n    // 渲染后执行，放入 postRenderEffect 队列\n    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense)\n  } else {\n    // 默认是渲染更新之前执行，设置 job.pre = true\n    job.pre = true\n    if (instance) job.id = instance.uid\n    scheduler = () => queueJob(job)\n  }\n}\n```\n\nscheduler 我们在批量调度更新章节有简单介绍过，本质这里是根据不同的 watch options 中的 flush 参数来设置不同的调度节点，这里默认是渲染更新前执行，也就是在异步更新队列 queue 执行前执行。\n\nscheduler 核心就是将 job 放入异步执行队列中，但有个特殊，也就是 flush = 'sync' 时，是放入同步执行的。那么 job 是个什么啥玩意呢？\n\n上述代码的注释已经很详尽了，job 其实就是一个用来执行回调函数 cb 的函数而已，在执行 cb 的同时，传入了 source 的新旧值。\n\n##### effect run 函数执行\n前面我们说到了，ReactiveEffect 内部的 run 函数，执行了依赖访问的 getter 函数，所以 run 函数是如何被执行的呢？\n\n```typescript\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {\n  //...\n  // 如果存在 cb\n  if (cb) {\n    // 立即执行\n    if (immediate) {\n      // 首次直接执行 job\n      job()\n    } else {\n      // 执行run 函数，获取旧值\n      oldValue = effect.run()\n    }\n  }\n}\n```\n\n可以看到在执行 effect.run 的前面判断了是否是立即执行的模式，如果是立即执行，则直接执行上面的 job 函数，而此时的 job 函数是没有旧值的，所以此时执行的 oldValue = undefined。\n\n#### 返回销毁函数\n最后，会返回侦听器销毁函数，也就是 watch API 执行后返回的函数。我们可以通过调用它来停止 watcher 对数据的侦听。\n\n```typescript\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {\n  //...\n  return () => {\n    effect.stop()\n    if (instance && instance.scope) {\n      remove(instance.scope.effects!, effect)\n    }\n  }\n}\n```\n\n销毁函数内部会执行 effect.stop 方法，用来停止对数据的 effect 响应。并且，如果是在组件中注册的 watcher，也会移除组件 effects 对这个 runner 的引用。\n\n#### 总结\n所谓 watch，就是观测一个响应式数据或者监测一个副作用函数里面的响应式数据，当数据发生变化的时候通知并执行相应的回调函数。而内部实现，就是通过构造一个 effect 副作用对象，通过对 watch 监听属性的访问触发副作用收集，当修改监听属性时，根据 flush 的状态触发 job 的不同阶段更新。","source":"_drafts/technical-disclosure-of-vue3/watch.md","raw":"---\ntitle: 响应式原理：watch 函数的实现原理\ncategories:\n  - Vue3 技术揭秘\n---\n\n#### 前言\n在组合式 API 中，我们可以使用 watch 函数在每次响应式状态发生变化时触发回调函数，watch 的第一个参数可以是不同形式的数据类型：它可以是一个 ref（包括计算属性）、一个响应式对象、一个 getter 函数、或多个数据源组成的数组。\n\n```typescript\nconst x = ref(0)\nconst y = ref(0)\nconst state = reactive({ num: 0 })\n\n// 单个 ref\nwatch(x, (newX) => {\n  console.log(`x is ${newX}`)\n})\n\n// getter 函数\nwatch(\n  () => x.value + y.value,\n  (sum) => {\n    console.log(`sum of x + y is: ${sum}`)\n  }\n)\n\n// 响应式对象\nwatch(\n  state,\n  (newState) => {\n    console.log(`new state num is: ${newState.num}`)\n  }\n)\n\n// 多个来源组成的数组\nwatch([x, () => y.value], ([newX, newY]) => {\n  console.log(`x is ${newX} and y is ${newY}`)\n})\n```\n\n了解了一些基础的 watch 使用示例后，我们开始分析一下 watch 函数是如何实现的呢。\n\n#### 标准化 source\n先来看一下 watch 函数实现的代码：\n\n```typescript\nfunction watch(source, cb, options) { \n  // ...\n  return doWatch(source, cb, options) \n} \n\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) { \n  // ...\n} \n```\n\nwatch 函数内部是通过 doWatch 来执行的，在分析 doWatch 函数实现前，我们先看看前面的示例中，watch 监听的 source 可以是多种类型，一个函数可以支持多种类型的参数入参，那么实现该函数最好的设计模式就是 adapter 代理模式。就是将底层模型设计成一致的，抹平调用差异，这也是 doWatch 函数实现的第一步：标准化 source 参数。\n\n一起来看看其中的实现：\n\n```typescript\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {\n  // ...\n  // source 不合法的时候警告函数\n  const warnInvalidSource = (s: unknown) => {\n    warn(\n      `Invalid watch source: `,\n      s,\n      `A watch source can only be a getter/effect function, a ref, ` +\n      `a reactive object, or an array of these types.`\n    )\n  }\n  \n  const instance = currentInstance\n  let getter\n  let forceTrigger = false\n  let isMultiSource = false\n\n  // 判断是不是 ref 类型\n  if (isRef(source)) {\n    getter = () => source.value\n    forceTrigger = isShallow(source)\n  }\n  // 判断是不是响应式对象\n  else if (isReactive(source)) {\n    getter = () => source\n    deep = true\n  }\n  // 判断是不是数组类型\n  else if (isArray(source)) {\n    isMultiSource = true\n    forceTrigger = source.some(s => isReactive(s) || isShallow(s))\n    getter = () =>\n      source.map(s => {\n        if (isRef(s)) {\n          return s.value\n        } else if (isReactive(s)) {\n          return traverse(s)\n        } else if (isFunction(s)) {\n          return callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER)\n        } else {\n          __DEV__ && warnInvalidSource(s)\n        }\n      })\n  }\n  // 判断是不是函数类型\n  else if (isFunction(source)) {\n    if (cb) {\n      // getter with cb\n      getter = () =>\n        callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER)\n    } else {\n      // 如果只有一个函数作为source 入参，则执行 watchEffect 的逻辑\n      // ...\n    }\n  }\n  // 都不符合，则告警\n  else {\n    getter = NOOP\n    __DEV__ && warnInvalidSource(source)\n  }\n\n  // 深度监听\n  if (cb && deep) {\n    const baseGetter = getter\n    getter = () => traverse(baseGetter())\n  }\n  \n  // ...\n}\n```\n\n由于 doWatch 函数代码量比较多，我们先一部分一部分地来解读，这里我们只关注于标准化 source 的逻辑。可以看到 doWatch 函数会对入参的 source 做不同类型的判断逻辑，然后生成一个统一的 getter 函数：\n\nimage.png\n\ngetter 函数就是简单地对不同数据类型设置一个访问 source 的操作，比如对于 ref 就是一个创建了一个访问 source.value 的函数。\n\n那么为什么需要访问呢？由之前的响应式原理我们知道，只有在触发 proxy getter 的时候，才会进行依赖收集，所以，这里标准化的 source 函数中，不管是什么类型的 source 都会设计一个访问器函数。\n\n另外，需要注意的是当 source 是个响应式对象时，源码中会同时设置 deep = true。这是因为对于响应式对象，需要进行深度监听，因为响应式对象中的属性变化时，都需要进行反馈。那是怎么做到深度监听的呢？在回答这个问题之前，我们前面说了监听一个对象的属性就是需要先访问对象的属性，触发 proxy getter，把副作用 cb 收集起来。源码中则是通过 traverse 函数来实现对响应式对象属性的遍历访问：\n\n```typescript\nexport function traverse(value, seen) {\n  // ...\n  if (isRef(value)) {\n    // 如果是 ref 类型，继续递归执行 .value值\n    traverse(value.value, seen)\n  } else if (Array.isArray(value)) {\n    // 如果是数组类型\n    for (let i = 0; i < value.length; i++) {\n      // 递归调用 traverse 进行处理\n      traverse(value[i], seen)\n    }\n  } else if (isPlainObject(value)) {\n    // 如果是对象，使用 for in 读取对象的每一个值，并递归调用 traverse 进行处理\n    for (const key in value) {\n      traverse((value as any)[key], seen)\n    }\n  }\n  return value\n}\n```\n\n#### 构造副作用 effect\n前面说到，我们通过一系列操作，标准化了用户传入的 source 成了一个 getter 函数，此时的 getter 函数一方面还没有真正执行，也就没有触发对属性的访问操作。\n\nwatch 的本质是对数据源进行依赖收集，当依赖变化时，回调执行 cb 函数并传入新旧值。所以我们需要构造一个副作用函数，完成对数据源的变化追踪：\n\n```typescript\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) { \n  // ...\n  const effect = new ReactiveEffect(getter, scheduler)\n} \n```\n\n这里的 getter 就是前面构造的属性访问函数，我们在介绍响应式原理的章节中，介绍过 ReactiveEffect 函数，这里再来回顾一下 ReactiveEffect 的实现：\n\n```typescript\nclass ReactiveEffect {\n  constructor(\n    public fn: () => T,\n    public scheduler: EffectScheduler | null = null,\n    scope?: EffectScope\n  ) {\n    recordEffectScope(this, scope)\n  }\n  \n  run() {\n    // ...  \n    this.fn()\n  }\n}\n```\n\n这里细节部分可以详细阅读响应式原理的部分，我们只需要知道这里的 ReactiveEffect run 函数内部执行了 this.fn() 也就是上面传入的 getter 函数，所以，本质上是在此时完成了对 watch source 的访问。\n\n然后再看一下 ReactiveEffect 的第二个参数 scheduler，是如何构造的呢？\n\n#### 构造 scheduler 调度\n\n```typescript\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {\n  // ...\n  let oldValue = isMultiSource \n    ? new Array(source.length).fill(INITIAL_WATCHER_VALUE)\n    : INITIAL_WATCHER_VALUE\n  const job = () => {\n    // 被卸载\n    if (!effect.active) {\n      return\n    }\n    if (cb) {\n      // 获取新值\n      const newValue = effect.run()\n      // ...\n      // 执行 cb 函数\n      callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [\n        newValue,\n        // 第一次更改时传递旧值为 undefined\n        oldValue === INITIAL_WATCHER_VALUE\n          ? undefined\n          : (isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE)\n            ? []\n            : oldValue,\n        onCleanup\n        ])\n      oldValue = newValue\n    } else {\n      // watchEffect\n      effect.run()\n    }\n  }\n\n  let scheduler\n  // 直接赋值为 job 函数\n  if (flush === 'sync') {\n    scheduler = job\n  } else if (flush === 'post') {\n    // 渲染后执行，放入 postRenderEffect 队列\n    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense)\n  } else {\n    // 默认是渲染更新之前执行，设置 job.pre = true\n    job.pre = true\n    if (instance) job.id = instance.uid\n    scheduler = () => queueJob(job)\n  }\n}\n```\n\nscheduler 我们在批量调度更新章节有简单介绍过，本质这里是根据不同的 watch options 中的 flush 参数来设置不同的调度节点，这里默认是渲染更新前执行，也就是在异步更新队列 queue 执行前执行。\n\nscheduler 核心就是将 job 放入异步执行队列中，但有个特殊，也就是 flush = 'sync' 时，是放入同步执行的。那么 job 是个什么啥玩意呢？\n\n上述代码的注释已经很详尽了，job 其实就是一个用来执行回调函数 cb 的函数而已，在执行 cb 的同时，传入了 source 的新旧值。\n\n##### effect run 函数执行\n前面我们说到了，ReactiveEffect 内部的 run 函数，执行了依赖访问的 getter 函数，所以 run 函数是如何被执行的呢？\n\n```typescript\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {\n  //...\n  // 如果存在 cb\n  if (cb) {\n    // 立即执行\n    if (immediate) {\n      // 首次直接执行 job\n      job()\n    } else {\n      // 执行run 函数，获取旧值\n      oldValue = effect.run()\n    }\n  }\n}\n```\n\n可以看到在执行 effect.run 的前面判断了是否是立即执行的模式，如果是立即执行，则直接执行上面的 job 函数，而此时的 job 函数是没有旧值的，所以此时执行的 oldValue = undefined。\n\n#### 返回销毁函数\n最后，会返回侦听器销毁函数，也就是 watch API 执行后返回的函数。我们可以通过调用它来停止 watcher 对数据的侦听。\n\n```typescript\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {\n  //...\n  return () => {\n    effect.stop()\n    if (instance && instance.scope) {\n      remove(instance.scope.effects!, effect)\n    }\n  }\n}\n```\n\n销毁函数内部会执行 effect.stop 方法，用来停止对数据的 effect 响应。并且，如果是在组件中注册的 watcher，也会移除组件 effects 对这个 runner 的引用。\n\n#### 总结\n所谓 watch，就是观测一个响应式数据或者监测一个副作用函数里面的响应式数据，当数据发生变化的时候通知并执行相应的回调函数。而内部实现，就是通过构造一个 effect 副作用对象，通过对 watch 监听属性的访问触发副作用收集，当修改监听属性时，根据 flush 的状态触发 job 的不同阶段更新。","slug":"technical-disclosure-of-vue3/watch","published":0,"date":"2023-08-12T07:53:19.989Z","updated":"2023-08-12T07:53:19.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokr0017sovcehbi4hj4","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>在组合式 API 中，我们可以使用 watch 函数在每次响应式状态发生变化时触发回调函数，watch 的第一个参数可以是不同形式的数据类型：它可以是一个 ref（包括计算属性）、一个响应式对象、一个 getter 函数、或多个数据源组成的数组。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> x = <span class=\"title function_\">ref</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> y = <span class=\"title function_\">ref</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> state = <span class=\"title function_\">reactive</span>(&#123; <span class=\"attr\">num</span>: <span class=\"number\">0</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 单个 ref</span></span><br><span class=\"line\"><span class=\"title function_\">watch</span>(x, <span class=\"function\">(<span class=\"params\">newX</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`x is <span class=\"subst\">$&#123;newX&#125;</span>`</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// getter 函数</span></span><br><span class=\"line\"><span class=\"title function_\">watch</span>(</span><br><span class=\"line\">  <span class=\"function\">() =&gt;</span> x.<span class=\"property\">value</span> + y.<span class=\"property\">value</span>,</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">sum</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`sum of x + y is: <span class=\"subst\">$&#123;sum&#125;</span>`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 响应式对象</span></span><br><span class=\"line\"><span class=\"title function_\">watch</span>(</span><br><span class=\"line\">  state,</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">newState</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`new state num is: <span class=\"subst\">$&#123;newState.num&#125;</span>`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 多个来源组成的数组</span></span><br><span class=\"line\"><span class=\"title function_\">watch</span>([x, <span class=\"function\">() =&gt;</span> y.<span class=\"property\">value</span>], <span class=\"function\">(<span class=\"params\">[newX, newY]</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`x is <span class=\"subst\">$&#123;newX&#125;</span> and y is <span class=\"subst\">$&#123;newY&#125;</span>`</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>了解了一些基础的 watch 使用示例后，我们开始分析一下 watch 函数是如何实现的呢。</p>\n<h4 id=\"标准化-source\"><a href=\"#标准化-source\" class=\"headerlink\" title=\"标准化 source\"></a>标准化 source</h4><p>先来看一下 watch 函数实现的代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">watch</span>(<span class=\"params\">source, cb, options</span>) &#123; </span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">doWatch</span>(source, cb, options) </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123; </span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>watch 函数内部是通过 doWatch 来执行的，在分析 doWatch 函数实现前，我们先看看前面的示例中，watch 监听的 source 可以是多种类型，一个函数可以支持多种类型的参数入参，那么实现该函数最好的设计模式就是 adapter 代理模式。就是将底层模型设计成一致的，抹平调用差异，这也是 doWatch 函数实现的第一步：标准化 source 参数。</p>\n<p>一起来看看其中的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// source 不合法的时候警告函数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">warnInvalidSource</span> = (<span class=\"params\">s: <span class=\"built_in\">unknown</span></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">warn</span>(</span><br><span class=\"line\">      <span class=\"string\">`Invalid watch source: `</span>,</span><br><span class=\"line\">      s,</span><br><span class=\"line\">      <span class=\"string\">`A watch source can only be a getter/effect function, a ref, `</span> +</span><br><span class=\"line\">      <span class=\"string\">`a reactive object, or an array of these types.`</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> instance = currentInstance</span><br><span class=\"line\">  <span class=\"keyword\">let</span> getter</span><br><span class=\"line\">  <span class=\"keyword\">let</span> forceTrigger = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> isMultiSource = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 判断是不是 ref 类型</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title function_\">isRef</span>(source)) &#123;</span><br><span class=\"line\">    getter = <span class=\"function\">() =&gt;</span> source.<span class=\"property\">value</span></span><br><span class=\"line\">    forceTrigger = <span class=\"title function_\">isShallow</span>(source)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 判断是不是响应式对象</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isReactive</span>(source)) &#123;</span><br><span class=\"line\">    getter = <span class=\"function\">() =&gt;</span> source</span><br><span class=\"line\">    deep = <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 判断是不是数组类型</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isArray</span>(source)) &#123;</span><br><span class=\"line\">    isMultiSource = <span class=\"literal\">true</span></span><br><span class=\"line\">    forceTrigger = source.<span class=\"title function_\">some</span>(<span class=\"function\"><span class=\"params\">s</span> =&gt;</span> <span class=\"title function_\">isReactive</span>(s) || <span class=\"title function_\">isShallow</span>(s))</span><br><span class=\"line\">    getter = <span class=\"function\">() =&gt;</span></span><br><span class=\"line\">      source.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">s</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title function_\">isRef</span>(s)) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> s.<span class=\"property\">value</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isReactive</span>(s)) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(s)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isFunction</span>(s)) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"title function_\">callWithErrorHandling</span>(s, instance, <span class=\"title class_\">ErrorCodes</span>.<span class=\"property\">WATCH_GETTER</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          __DEV__ &amp;&amp; <span class=\"title function_\">warnInvalidSource</span>(s)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 判断是不是函数类型</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isFunction</span>(source)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cb) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// getter with cb</span></span><br><span class=\"line\">      getter = <span class=\"function\">() =&gt;</span></span><br><span class=\"line\">        <span class=\"title function_\">callWithErrorHandling</span>(source, instance, <span class=\"title class_\">ErrorCodes</span>.<span class=\"property\">WATCH_GETTER</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果只有一个函数作为source 入参，则执行 watchEffect 的逻辑</span></span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 都不符合，则告警</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    getter = <span class=\"variable constant_\">NOOP</span></span><br><span class=\"line\">    __DEV__ &amp;&amp; <span class=\"title function_\">warnInvalidSource</span>(source)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 深度监听</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cb &amp;&amp; deep) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> baseGetter = getter</span><br><span class=\"line\">    getter = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">traverse</span>(<span class=\"title function_\">baseGetter</span>())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于 doWatch 函数代码量比较多，我们先一部分一部分地来解读，这里我们只关注于标准化 source 的逻辑。可以看到 doWatch 函数会对入参的 source 做不同类型的判断逻辑，然后生成一个统一的 getter 函数：</p>\n<p>image.png</p>\n<p>getter 函数就是简单地对不同数据类型设置一个访问 source 的操作，比如对于 ref 就是一个创建了一个访问 source.value 的函数。</p>\n<p>那么为什么需要访问呢？由之前的响应式原理我们知道，只有在触发 proxy getter 的时候，才会进行依赖收集，所以，这里标准化的 source 函数中，不管是什么类型的 source 都会设计一个访问器函数。</p>\n<p>另外，需要注意的是当 source 是个响应式对象时，源码中会同时设置 deep &#x3D; true。这是因为对于响应式对象，需要进行深度监听，因为响应式对象中的属性变化时，都需要进行反馈。那是怎么做到深度监听的呢？在回答这个问题之前，我们前面说了监听一个对象的属性就是需要先访问对象的属性，触发 proxy getter，把副作用 cb 收集起来。源码中则是通过 traverse 函数来实现对响应式对象属性的遍历访问：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">value, seen</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title function_\">isRef</span>(value)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是 ref 类型，继续递归执行 .value值</span></span><br><span class=\"line\">    <span class=\"title function_\">traverse</span>(value.<span class=\"property\">value</span>, seen)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(value)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是数组类型</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; value.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 递归调用 traverse 进行处理</span></span><br><span class=\"line\">      <span class=\"title function_\">traverse</span>(value[i], seen)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isPlainObject</span>(value)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是对象，使用 for in 读取对象的每一个值，并递归调用 traverse 进行处理</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> value) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">traverse</span>((value <span class=\"keyword\">as</span> <span class=\"built_in\">any</span>)[key], seen)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"构造副作用-effect\"><a href=\"#构造副作用-effect\" class=\"headerlink\" title=\"构造副作用 effect\"></a>构造副作用 effect</h4><p>前面说到，我们通过一系列操作，标准化了用户传入的 source 成了一个 getter 函数，此时的 getter 函数一方面还没有真正执行，也就没有触发对属性的访问操作。</p>\n<p>watch 的本质是对数据源进行依赖收集，当依赖变化时，回调执行 cb 函数并传入新旧值。所以我们需要构造一个副作用函数，完成对数据源的变化追踪：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123; </span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> effect = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(getter, scheduler)</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>这里的 getter 就是前面构造的属性访问函数，我们在介绍响应式原理的章节中，介绍过 ReactiveEffect 函数，这里再来回顾一下 ReactiveEffect 的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ReactiveEffect</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">public</span> fn: () =&gt; T,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">public</span> scheduler: EffectScheduler | <span class=\"literal\">null</span> = <span class=\"literal\">null</span>,</span></span><br><span class=\"line\"><span class=\"params\">    scope?: EffectScope</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">recordEffectScope</span>(<span class=\"variable language_\">this</span>, scope)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"title function_\">run</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...  </span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">fn</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里细节部分可以详细阅读响应式原理的部分，我们只需要知道这里的 ReactiveEffect run 函数内部执行了 this.fn() 也就是上面传入的 getter 函数，所以，本质上是在此时完成了对 watch source 的访问。</p>\n<p>然后再看一下 ReactiveEffect 的第二个参数 scheduler，是如何构造的呢？</p>\n<h4 id=\"构造-scheduler-调度\"><a href=\"#构造-scheduler-调度\" class=\"headerlink\" title=\"构造 scheduler 调度\"></a>构造 scheduler 调度</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> oldValue = isMultiSource </span><br><span class=\"line\">    ? <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(source.<span class=\"property\">length</span>).<span class=\"title function_\">fill</span>(<span class=\"variable constant_\">INITIAL_WATCHER_VALUE</span>)</span><br><span class=\"line\">    : <span class=\"variable constant_\">INITIAL_WATCHER_VALUE</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">job</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 被卸载</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!effect.<span class=\"property\">active</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cb) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 获取新值</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> newValue = effect.<span class=\"title function_\">run</span>()</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">      <span class=\"comment\">// 执行 cb 函数</span></span><br><span class=\"line\">      <span class=\"title function_\">callWithAsyncErrorHandling</span>(cb, instance, <span class=\"title class_\">ErrorCodes</span>.<span class=\"property\">WATCH_CALLBACK</span>, [</span><br><span class=\"line\">        newValue,</span><br><span class=\"line\">        <span class=\"comment\">// 第一次更改时传递旧值为 undefined</span></span><br><span class=\"line\">        oldValue === <span class=\"variable constant_\">INITIAL_WATCHER_VALUE</span></span><br><span class=\"line\">          ? <span class=\"literal\">undefined</span></span><br><span class=\"line\">          : (isMultiSource &amp;&amp; oldValue[<span class=\"number\">0</span>] === <span class=\"variable constant_\">INITIAL_WATCHER_VALUE</span>)</span><br><span class=\"line\">            ? []</span><br><span class=\"line\">            : oldValue,</span><br><span class=\"line\">        onCleanup</span><br><span class=\"line\">        ])</span><br><span class=\"line\">      oldValue = newValue</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// watchEffect</span></span><br><span class=\"line\">      effect.<span class=\"title function_\">run</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> scheduler</span><br><span class=\"line\">  <span class=\"comment\">// 直接赋值为 job 函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (flush === <span class=\"string\">&#x27;sync&#x27;</span>) &#123;</span><br><span class=\"line\">    scheduler = job</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (flush === <span class=\"string\">&#x27;post&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 渲染后执行，放入 postRenderEffect 队列</span></span><br><span class=\"line\">    scheduler = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">queuePostRenderEffect</span>(job, instance &amp;&amp; instance.<span class=\"property\">suspense</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 默认是渲染更新之前执行，设置 job.pre = true</span></span><br><span class=\"line\">    job.<span class=\"property\">pre</span> = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance) job.<span class=\"property\">id</span> = instance.<span class=\"property\">uid</span></span><br><span class=\"line\">    scheduler = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">queueJob</span>(job)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>scheduler 我们在批量调度更新章节有简单介绍过，本质这里是根据不同的 watch options 中的 flush 参数来设置不同的调度节点，这里默认是渲染更新前执行，也就是在异步更新队列 queue 执行前执行。</p>\n<p>scheduler 核心就是将 job 放入异步执行队列中，但有个特殊，也就是 flush &#x3D; ‘sync’ 时，是放入同步执行的。那么 job 是个什么啥玩意呢？</p>\n<p>上述代码的注释已经很详尽了，job 其实就是一个用来执行回调函数 cb 的函数而已，在执行 cb 的同时，传入了 source 的新旧值。</p>\n<h5 id=\"effect-run-函数执行\"><a href=\"#effect-run-函数执行\" class=\"headerlink\" title=\"effect run 函数执行\"></a>effect run 函数执行</h5><p>前面我们说到了，ReactiveEffect 内部的 run 函数，执行了依赖访问的 getter 函数，所以 run 函数是如何被执行的呢？</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果存在 cb</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cb) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 立即执行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (immediate) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 首次直接执行 job</span></span><br><span class=\"line\">      <span class=\"title function_\">job</span>()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 执行run 函数，获取旧值</span></span><br><span class=\"line\">      oldValue = effect.<span class=\"title function_\">run</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到在执行 effect.run 的前面判断了是否是立即执行的模式，如果是立即执行，则直接执行上面的 job 函数，而此时的 job 函数是没有旧值的，所以此时执行的 oldValue &#x3D; undefined。</p>\n<h4 id=\"返回销毁函数\"><a href=\"#返回销毁函数\" class=\"headerlink\" title=\"返回销毁函数\"></a>返回销毁函数</h4><p>最后，会返回侦听器销毁函数，也就是 watch API 执行后返回的函数。我们可以通过调用它来停止 watcher 对数据的侦听。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    effect.<span class=\"title function_\">stop</span>()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance &amp;&amp; instance.<span class=\"property\">scope</span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">remove</span>(instance.<span class=\"property\">scope</span>.<span class=\"property\">effects</span>!, effect)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>销毁函数内部会执行 effect.stop 方法，用来停止对数据的 effect 响应。并且，如果是在组件中注册的 watcher，也会移除组件 effects 对这个 runner 的引用。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>所谓 watch，就是观测一个响应式数据或者监测一个副作用函数里面的响应式数据，当数据发生变化的时候通知并执行相应的回调函数。而内部实现，就是通过构造一个 effect 副作用对象，通过对 watch 监听属性的访问触发副作用收集，当修改监听属性时，根据 flush 的状态触发 job 的不同阶段更新。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>在组合式 API 中，我们可以使用 watch 函数在每次响应式状态发生变化时触发回调函数，watch 的第一个参数可以是不同形式的数据类型：它可以是一个 ref（包括计算属性）、一个响应式对象、一个 getter 函数、或多个数据源组成的数组。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> x = <span class=\"title function_\">ref</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> y = <span class=\"title function_\">ref</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> state = <span class=\"title function_\">reactive</span>(&#123; <span class=\"attr\">num</span>: <span class=\"number\">0</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 单个 ref</span></span><br><span class=\"line\"><span class=\"title function_\">watch</span>(x, <span class=\"function\">(<span class=\"params\">newX</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`x is <span class=\"subst\">$&#123;newX&#125;</span>`</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// getter 函数</span></span><br><span class=\"line\"><span class=\"title function_\">watch</span>(</span><br><span class=\"line\">  <span class=\"function\">() =&gt;</span> x.<span class=\"property\">value</span> + y.<span class=\"property\">value</span>,</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">sum</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`sum of x + y is: <span class=\"subst\">$&#123;sum&#125;</span>`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 响应式对象</span></span><br><span class=\"line\"><span class=\"title function_\">watch</span>(</span><br><span class=\"line\">  state,</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">newState</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`new state num is: <span class=\"subst\">$&#123;newState.num&#125;</span>`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 多个来源组成的数组</span></span><br><span class=\"line\"><span class=\"title function_\">watch</span>([x, <span class=\"function\">() =&gt;</span> y.<span class=\"property\">value</span>], <span class=\"function\">(<span class=\"params\">[newX, newY]</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`x is <span class=\"subst\">$&#123;newX&#125;</span> and y is <span class=\"subst\">$&#123;newY&#125;</span>`</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>了解了一些基础的 watch 使用示例后，我们开始分析一下 watch 函数是如何实现的呢。</p>\n<h4 id=\"标准化-source\"><a href=\"#标准化-source\" class=\"headerlink\" title=\"标准化 source\"></a>标准化 source</h4><p>先来看一下 watch 函数实现的代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">watch</span>(<span class=\"params\">source, cb, options</span>) &#123; </span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">doWatch</span>(source, cb, options) </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123; </span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>watch 函数内部是通过 doWatch 来执行的，在分析 doWatch 函数实现前，我们先看看前面的示例中，watch 监听的 source 可以是多种类型，一个函数可以支持多种类型的参数入参，那么实现该函数最好的设计模式就是 adapter 代理模式。就是将底层模型设计成一致的，抹平调用差异，这也是 doWatch 函数实现的第一步：标准化 source 参数。</p>\n<p>一起来看看其中的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// source 不合法的时候警告函数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">warnInvalidSource</span> = (<span class=\"params\">s: <span class=\"built_in\">unknown</span></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">warn</span>(</span><br><span class=\"line\">      <span class=\"string\">`Invalid watch source: `</span>,</span><br><span class=\"line\">      s,</span><br><span class=\"line\">      <span class=\"string\">`A watch source can only be a getter/effect function, a ref, `</span> +</span><br><span class=\"line\">      <span class=\"string\">`a reactive object, or an array of these types.`</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> instance = currentInstance</span><br><span class=\"line\">  <span class=\"keyword\">let</span> getter</span><br><span class=\"line\">  <span class=\"keyword\">let</span> forceTrigger = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> isMultiSource = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 判断是不是 ref 类型</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title function_\">isRef</span>(source)) &#123;</span><br><span class=\"line\">    getter = <span class=\"function\">() =&gt;</span> source.<span class=\"property\">value</span></span><br><span class=\"line\">    forceTrigger = <span class=\"title function_\">isShallow</span>(source)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 判断是不是响应式对象</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isReactive</span>(source)) &#123;</span><br><span class=\"line\">    getter = <span class=\"function\">() =&gt;</span> source</span><br><span class=\"line\">    deep = <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 判断是不是数组类型</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isArray</span>(source)) &#123;</span><br><span class=\"line\">    isMultiSource = <span class=\"literal\">true</span></span><br><span class=\"line\">    forceTrigger = source.<span class=\"title function_\">some</span>(<span class=\"function\"><span class=\"params\">s</span> =&gt;</span> <span class=\"title function_\">isReactive</span>(s) || <span class=\"title function_\">isShallow</span>(s))</span><br><span class=\"line\">    getter = <span class=\"function\">() =&gt;</span></span><br><span class=\"line\">      source.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">s</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title function_\">isRef</span>(s)) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> s.<span class=\"property\">value</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isReactive</span>(s)) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(s)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isFunction</span>(s)) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"title function_\">callWithErrorHandling</span>(s, instance, <span class=\"title class_\">ErrorCodes</span>.<span class=\"property\">WATCH_GETTER</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          __DEV__ &amp;&amp; <span class=\"title function_\">warnInvalidSource</span>(s)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 判断是不是函数类型</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isFunction</span>(source)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cb) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// getter with cb</span></span><br><span class=\"line\">      getter = <span class=\"function\">() =&gt;</span></span><br><span class=\"line\">        <span class=\"title function_\">callWithErrorHandling</span>(source, instance, <span class=\"title class_\">ErrorCodes</span>.<span class=\"property\">WATCH_GETTER</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果只有一个函数作为source 入参，则执行 watchEffect 的逻辑</span></span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 都不符合，则告警</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    getter = <span class=\"variable constant_\">NOOP</span></span><br><span class=\"line\">    __DEV__ &amp;&amp; <span class=\"title function_\">warnInvalidSource</span>(source)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 深度监听</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cb &amp;&amp; deep) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> baseGetter = getter</span><br><span class=\"line\">    getter = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">traverse</span>(<span class=\"title function_\">baseGetter</span>())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于 doWatch 函数代码量比较多，我们先一部分一部分地来解读，这里我们只关注于标准化 source 的逻辑。可以看到 doWatch 函数会对入参的 source 做不同类型的判断逻辑，然后生成一个统一的 getter 函数：</p>\n<p>image.png</p>\n<p>getter 函数就是简单地对不同数据类型设置一个访问 source 的操作，比如对于 ref 就是一个创建了一个访问 source.value 的函数。</p>\n<p>那么为什么需要访问呢？由之前的响应式原理我们知道，只有在触发 proxy getter 的时候，才会进行依赖收集，所以，这里标准化的 source 函数中，不管是什么类型的 source 都会设计一个访问器函数。</p>\n<p>另外，需要注意的是当 source 是个响应式对象时，源码中会同时设置 deep &#x3D; true。这是因为对于响应式对象，需要进行深度监听，因为响应式对象中的属性变化时，都需要进行反馈。那是怎么做到深度监听的呢？在回答这个问题之前，我们前面说了监听一个对象的属性就是需要先访问对象的属性，触发 proxy getter，把副作用 cb 收集起来。源码中则是通过 traverse 函数来实现对响应式对象属性的遍历访问：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">value, seen</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title function_\">isRef</span>(value)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是 ref 类型，继续递归执行 .value值</span></span><br><span class=\"line\">    <span class=\"title function_\">traverse</span>(value.<span class=\"property\">value</span>, seen)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(value)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是数组类型</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; value.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 递归调用 traverse 进行处理</span></span><br><span class=\"line\">      <span class=\"title function_\">traverse</span>(value[i], seen)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isPlainObject</span>(value)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是对象，使用 for in 读取对象的每一个值，并递归调用 traverse 进行处理</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> value) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">traverse</span>((value <span class=\"keyword\">as</span> <span class=\"built_in\">any</span>)[key], seen)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"构造副作用-effect\"><a href=\"#构造副作用-effect\" class=\"headerlink\" title=\"构造副作用 effect\"></a>构造副作用 effect</h4><p>前面说到，我们通过一系列操作，标准化了用户传入的 source 成了一个 getter 函数，此时的 getter 函数一方面还没有真正执行，也就没有触发对属性的访问操作。</p>\n<p>watch 的本质是对数据源进行依赖收集，当依赖变化时，回调执行 cb 函数并传入新旧值。所以我们需要构造一个副作用函数，完成对数据源的变化追踪：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123; </span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> effect = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(getter, scheduler)</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>这里的 getter 就是前面构造的属性访问函数，我们在介绍响应式原理的章节中，介绍过 ReactiveEffect 函数，这里再来回顾一下 ReactiveEffect 的实现：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ReactiveEffect</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">public</span> fn: () =&gt; T,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">public</span> scheduler: EffectScheduler | <span class=\"literal\">null</span> = <span class=\"literal\">null</span>,</span></span><br><span class=\"line\"><span class=\"params\">    scope?: EffectScope</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">recordEffectScope</span>(<span class=\"variable language_\">this</span>, scope)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"title function_\">run</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...  </span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">fn</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里细节部分可以详细阅读响应式原理的部分，我们只需要知道这里的 ReactiveEffect run 函数内部执行了 this.fn() 也就是上面传入的 getter 函数，所以，本质上是在此时完成了对 watch source 的访问。</p>\n<p>然后再看一下 ReactiveEffect 的第二个参数 scheduler，是如何构造的呢？</p>\n<h4 id=\"构造-scheduler-调度\"><a href=\"#构造-scheduler-调度\" class=\"headerlink\" title=\"构造 scheduler 调度\"></a>构造 scheduler 调度</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> oldValue = isMultiSource </span><br><span class=\"line\">    ? <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(source.<span class=\"property\">length</span>).<span class=\"title function_\">fill</span>(<span class=\"variable constant_\">INITIAL_WATCHER_VALUE</span>)</span><br><span class=\"line\">    : <span class=\"variable constant_\">INITIAL_WATCHER_VALUE</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">job</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 被卸载</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!effect.<span class=\"property\">active</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cb) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 获取新值</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> newValue = effect.<span class=\"title function_\">run</span>()</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">      <span class=\"comment\">// 执行 cb 函数</span></span><br><span class=\"line\">      <span class=\"title function_\">callWithAsyncErrorHandling</span>(cb, instance, <span class=\"title class_\">ErrorCodes</span>.<span class=\"property\">WATCH_CALLBACK</span>, [</span><br><span class=\"line\">        newValue,</span><br><span class=\"line\">        <span class=\"comment\">// 第一次更改时传递旧值为 undefined</span></span><br><span class=\"line\">        oldValue === <span class=\"variable constant_\">INITIAL_WATCHER_VALUE</span></span><br><span class=\"line\">          ? <span class=\"literal\">undefined</span></span><br><span class=\"line\">          : (isMultiSource &amp;&amp; oldValue[<span class=\"number\">0</span>] === <span class=\"variable constant_\">INITIAL_WATCHER_VALUE</span>)</span><br><span class=\"line\">            ? []</span><br><span class=\"line\">            : oldValue,</span><br><span class=\"line\">        onCleanup</span><br><span class=\"line\">        ])</span><br><span class=\"line\">      oldValue = newValue</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// watchEffect</span></span><br><span class=\"line\">      effect.<span class=\"title function_\">run</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> scheduler</span><br><span class=\"line\">  <span class=\"comment\">// 直接赋值为 job 函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (flush === <span class=\"string\">&#x27;sync&#x27;</span>) &#123;</span><br><span class=\"line\">    scheduler = job</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (flush === <span class=\"string\">&#x27;post&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 渲染后执行，放入 postRenderEffect 队列</span></span><br><span class=\"line\">    scheduler = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">queuePostRenderEffect</span>(job, instance &amp;&amp; instance.<span class=\"property\">suspense</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 默认是渲染更新之前执行，设置 job.pre = true</span></span><br><span class=\"line\">    job.<span class=\"property\">pre</span> = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance) job.<span class=\"property\">id</span> = instance.<span class=\"property\">uid</span></span><br><span class=\"line\">    scheduler = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">queueJob</span>(job)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>scheduler 我们在批量调度更新章节有简单介绍过，本质这里是根据不同的 watch options 中的 flush 参数来设置不同的调度节点，这里默认是渲染更新前执行，也就是在异步更新队列 queue 执行前执行。</p>\n<p>scheduler 核心就是将 job 放入异步执行队列中，但有个特殊，也就是 flush &#x3D; ‘sync’ 时，是放入同步执行的。那么 job 是个什么啥玩意呢？</p>\n<p>上述代码的注释已经很详尽了，job 其实就是一个用来执行回调函数 cb 的函数而已，在执行 cb 的同时，传入了 source 的新旧值。</p>\n<h5 id=\"effect-run-函数执行\"><a href=\"#effect-run-函数执行\" class=\"headerlink\" title=\"effect run 函数执行\"></a>effect run 函数执行</h5><p>前面我们说到了，ReactiveEffect 内部的 run 函数，执行了依赖访问的 getter 函数，所以 run 函数是如何被执行的呢？</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果存在 cb</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cb) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 立即执行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (immediate) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 首次直接执行 job</span></span><br><span class=\"line\">      <span class=\"title function_\">job</span>()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 执行run 函数，获取旧值</span></span><br><span class=\"line\">      oldValue = effect.<span class=\"title function_\">run</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到在执行 effect.run 的前面判断了是否是立即执行的模式，如果是立即执行，则直接执行上面的 job 函数，而此时的 job 函数是没有旧值的，所以此时执行的 oldValue &#x3D; undefined。</p>\n<h4 id=\"返回销毁函数\"><a href=\"#返回销毁函数\" class=\"headerlink\" title=\"返回销毁函数\"></a>返回销毁函数</h4><p>最后，会返回侦听器销毁函数，也就是 watch API 执行后返回的函数。我们可以通过调用它来停止 watcher 对数据的侦听。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    effect.<span class=\"title function_\">stop</span>()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance &amp;&amp; instance.<span class=\"property\">scope</span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">remove</span>(instance.<span class=\"property\">scope</span>.<span class=\"property\">effects</span>!, effect)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>销毁函数内部会执行 effect.stop 方法，用来停止对数据的 effect 响应。并且，如果是在组件中注册的 watcher，也会移除组件 effects 对这个 runner 的引用。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>所谓 watch，就是观测一个响应式数据或者监测一个副作用函数里面的响应式数据，当数据发生变化的时候通知并执行相应的回调函数。而内部实现，就是通过构造一个 effect 副作用对象，通过对 watch 监听属性的访问触发副作用收集，当修改监听属性时，根据 flush 的状态触发 job 的不同阶段更新。</p>\n"},{"_content":"```javascript\nfunction defineReacitve(obj, key, value, customSetter) {\n    let childOb = observe(val);\n\n    Object.defineProperty(obj, key, {\n        enumeralbe: true,\n        configurable: true,\n        get: function () {\n            // 收集\n        },\n        set: function () {\n            // 通知\n        },\n    })\n}\n```","source":"_drafts/源码/vu2响应式实现.md","raw":"```javascript\nfunction defineReacitve(obj, key, value, customSetter) {\n    let childOb = observe(val);\n\n    Object.defineProperty(obj, key, {\n        enumeralbe: true,\n        configurable: true,\n        get: function () {\n            // 收集\n        },\n        set: function () {\n            // 通知\n        },\n    })\n}\n```","slug":"源码/vu2响应式实现","published":0,"date":"2024-03-20T00:18:37.748Z","updated":"2024-03-20T00:20:40.805Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzsloks0019sovcezgq954w","content":"<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">defineReacitve</span>(<span class=\"params\">obj, key, value, customSetter</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> childOb = <span class=\"title function_\">observe</span>(val);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, key, &#123;</span><br><span class=\"line\">        <span class=\"attr\">enumeralbe</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 收集</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">set</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通知</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">defineReacitve</span>(<span class=\"params\">obj, key, value, customSetter</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> childOb = <span class=\"title function_\">observe</span>(val);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, key, &#123;</span><br><span class=\"line\">        <span class=\"attr\">enumeralbe</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 收集</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">set</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通知</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"_content":"","source":"_drafts/设计模式/MVC.md","raw":"","slug":"设计模式/MVC","published":0,"date":"2024-03-19T06:12:46.887Z","updated":"2024-03-19T06:12:46.887Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokt001bsovc3gmu1fvw","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":""},{"_content":"","source":"_drafts/设计模式/MVVM.md","raw":"","slug":"设计模式/MVVM","published":0,"date":"2024-03-19T06:12:52.584Z","updated":"2024-03-19T06:12:46.887Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokt001dsovc8ska0ag7","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#4ebde9","excerpt":"","more":""},{"_content":"","source":"_drafts/设计模式/享元模式.md","raw":"","slug":"设计模式/享元模式","published":0,"date":"2024-03-19T06:16:48.022Z","updated":"2024-03-19T06:16:48.022Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzsloku001gsovcdr6jct9m","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":""},{"_content":"","source":"_drafts/设计模式/代理模式.md","raw":"","slug":"设计模式/代理模式","published":0,"date":"2024-03-19T06:17:34.057Z","updated":"2024-03-19T06:17:34.057Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokv001hsovcg9g2ghuo","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":""},{"title":"原型模式：创建对象的灵活性与效率的完美结合","_content":"\n原型模式是一种创建型设计模式，其核心思想是通过复制现有对象来创建新的对象，而无需显式地使用构造函数。原型模式基于原型实例来生成对象的副本，从而避免了直接创建对象所带来的性能开销和复杂的初始化过程。\n\n\n### 示例场景(Vue3代理处理器)\n```javascript\n// 使用原型模式实现依赖收集\nclass BaseReactiveHandler {\n    get(target, key, receiver) {\n        // 预置属性过滤\n\n        // 数组类型, 变异方法过滤\n\n        // symbol类型, 自有属性过滤\n\n        // 依赖收集\n\n        // 返回值处理\n    }\n}\nclass MutableReactiveHandler extends BaseReactiveHandler {\n    set(target, key, value, receiver) {\n        // 对深层响应对象的旧值和新值处理\n\n        // 判断target类型并判断key是否为已有属性\n\n        // 触发更新\n    }\n    deleteProperty(target, key) {\n        // 判断是否为已有属性\n\n        // 若为已有属性, 触发更新\n    }\n    has(target, key) {\n        // 判断key是否为symbol类型或非Symbol自有属性\n\n        // 若key为symbol类型或非Symbol自有属性, 则触发更新\n    }\n\n    ownKeys(target) {\n        // 触发更新\n    }\n}\n\nclass ReaonlyReactiveHandler extends BaseReactiveHandler {\n    set(target, key) {\n        // 报警\n    }\n\n    deleteProperty(target, key) {\n        // 报警\n    }\n}\n\n```","source":"_drafts/设计模式/原型模式.md","raw":"---\ntitle: 原型模式：创建对象的灵活性与效率的完美结合\n---\n\n原型模式是一种创建型设计模式，其核心思想是通过复制现有对象来创建新的对象，而无需显式地使用构造函数。原型模式基于原型实例来生成对象的副本，从而避免了直接创建对象所带来的性能开销和复杂的初始化过程。\n\n\n### 示例场景(Vue3代理处理器)\n```javascript\n// 使用原型模式实现依赖收集\nclass BaseReactiveHandler {\n    get(target, key, receiver) {\n        // 预置属性过滤\n\n        // 数组类型, 变异方法过滤\n\n        // symbol类型, 自有属性过滤\n\n        // 依赖收集\n\n        // 返回值处理\n    }\n}\nclass MutableReactiveHandler extends BaseReactiveHandler {\n    set(target, key, value, receiver) {\n        // 对深层响应对象的旧值和新值处理\n\n        // 判断target类型并判断key是否为已有属性\n\n        // 触发更新\n    }\n    deleteProperty(target, key) {\n        // 判断是否为已有属性\n\n        // 若为已有属性, 触发更新\n    }\n    has(target, key) {\n        // 判断key是否为symbol类型或非Symbol自有属性\n\n        // 若key为symbol类型或非Symbol自有属性, 则触发更新\n    }\n\n    ownKeys(target) {\n        // 触发更新\n    }\n}\n\nclass ReaonlyReactiveHandler extends BaseReactiveHandler {\n    set(target, key) {\n        // 报警\n    }\n\n    deleteProperty(target, key) {\n        // 报警\n    }\n}\n\n```","slug":"设计模式/原型模式","published":0,"date":"2024-03-19T06:14:08.699Z","updated":"2024-03-30T13:03:25.861Z","_id":"cltzslokw001jsovc0w9acblb","comments":1,"layout":"post","photos":[],"link":"","content":"<p>原型模式是一种创建型设计模式，其核心思想是通过复制现有对象来创建新的对象，而无需显式地使用构造函数。原型模式基于原型实例来生成对象的副本，从而避免了直接创建对象所带来的性能开销和复杂的初始化过程。</p>\n<h3 id=\"示例场景-Vue3代理处理器\"><a href=\"#示例场景-Vue3代理处理器\" class=\"headerlink\" title=\"示例场景(Vue3代理处理器)\"></a>示例场景(Vue3代理处理器)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用原型模式实现依赖收集</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BaseReactiveHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">get</span>(<span class=\"params\">target, key, receiver</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 预置属性过滤</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 数组类型, 变异方法过滤</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// symbol类型, 自有属性过滤</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 依赖收集</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 返回值处理</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MutableReactiveHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">BaseReactiveHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">set</span>(<span class=\"params\">target, key, value, receiver</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 对深层响应对象的旧值和新值处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断target类型并判断key是否为已有属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 触发更新</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">deleteProperty</span>(<span class=\"params\">target, key</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断是否为已有属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 若为已有属性, 触发更新</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">has</span>(<span class=\"params\">target, key</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断key是否为symbol类型或非Symbol自有属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 若key为symbol类型或非Symbol自有属性, 则触发更新</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">ownKeys</span>(<span class=\"params\">target</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 触发更新</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ReaonlyReactiveHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">BaseReactiveHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">set</span>(<span class=\"params\">target, key</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 报警</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">deleteProperty</span>(<span class=\"params\">target, key</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 报警</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":"<p>原型模式是一种创建型设计模式，其核心思想是通过复制现有对象来创建新的对象，而无需显式地使用构造函数。原型模式基于原型实例来生成对象的副本，从而避免了直接创建对象所带来的性能开销和复杂的初始化过程。</p>\n<h3 id=\"示例场景-Vue3代理处理器\"><a href=\"#示例场景-Vue3代理处理器\" class=\"headerlink\" title=\"示例场景(Vue3代理处理器)\"></a>示例场景(Vue3代理处理器)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用原型模式实现依赖收集</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BaseReactiveHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">get</span>(<span class=\"params\">target, key, receiver</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 预置属性过滤</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 数组类型, 变异方法过滤</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// symbol类型, 自有属性过滤</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 依赖收集</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 返回值处理</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MutableReactiveHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">BaseReactiveHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">set</span>(<span class=\"params\">target, key, value, receiver</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 对深层响应对象的旧值和新值处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断target类型并判断key是否为已有属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 触发更新</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">deleteProperty</span>(<span class=\"params\">target, key</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断是否为已有属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 若为已有属性, 触发更新</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">has</span>(<span class=\"params\">target, key</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断key是否为symbol类型或非Symbol自有属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 若key为symbol类型或非Symbol自有属性, 则触发更新</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">ownKeys</span>(<span class=\"params\">target</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 触发更新</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ReaonlyReactiveHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">BaseReactiveHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">set</span>(<span class=\"params\">target, key</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 报警</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">deleteProperty</span>(<span class=\"params\">target, key</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 报警</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"_content":"","source":"_drafts/设计模式/命令模式.md","raw":"","slug":"设计模式/命令模式","published":0,"date":"2024-03-19T06:12:57.541Z","updated":"2024-03-19T06:12:46.887Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokw001ksovcfcu55e4v","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#e7817c","excerpt":"","more":""},{"_content":"","source":"_drafts/设计模式/备忘录模式.md","raw":"","slug":"设计模式/备忘录模式","published":0,"date":"2024-03-19T06:12:59.743Z","updated":"2024-03-19T06:12:46.887Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokx001lsovcfa2g1uu9","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":""},{"_content":"","source":"_drafts/设计模式/桥接模式.md","raw":"","slug":"设计模式/桥接模式","published":0,"date":"2024-03-19T06:17:07.486Z","updated":"2024-03-19T06:17:07.486Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzsloky001osovc3ad2cjsv","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":""},{"_content":"","source":"_drafts/设计模式/模板方法模式.md","raw":"","slug":"设计模式/模板方法模式","published":0,"date":"2024-03-19T06:12:59.416Z","updated":"2024-03-19T06:12:46.887Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzsloky001psovc0gfwbft2","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":""},{"_content":"","source":"_drafts/设计模式/状态模式.md","raw":"","slug":"设计模式/状态模式","published":0,"date":"2024-03-19T06:12:59.064Z","updated":"2024-03-19T06:12:46.887Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokz001qsovce7kt2otf","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":""},{"_content":"","source":"_drafts/设计模式/策略模式.md","raw":"","slug":"设计模式/策略模式","published":0,"date":"2024-03-19T06:12:57.301Z","updated":"2024-03-19T06:12:46.887Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslokz001rsovc05xrcjbc","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#4ebde9","excerpt":"","more":""},{"_content":"","source":"_drafts/设计模式/组合模式.md","raw":"","slug":"设计模式/组合模式","published":0,"date":"2024-03-19T06:17:14.367Z","updated":"2024-03-19T06:17:14.367Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslol0001ssovc2im2dzun","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#4ebde9","excerpt":"","more":""},{"_content":"","source":"_drafts/设计模式/装饰者模式.md","raw":"","slug":"设计模式/装饰者模式","published":0,"date":"2024-03-19T06:12:53.565Z","updated":"2024-03-19T06:12:46.887Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslol0001tsovc88xa188l","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":""},{"_content":"","source":"_drafts/设计模式/观察者模式.md","raw":"","slug":"设计模式/观察者模式","published":0,"date":"2024-03-19T06:12:53.761Z","updated":"2024-03-19T06:12:46.887Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslol0001usovcfb0y4qd4","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":""},{"_content":"","source":"_drafts/设计模式/解释器模式.md","raw":"","slug":"设计模式/解释器模式","published":0,"date":"2024-03-19T06:12:51.438Z","updated":"2024-03-19T06:12:46.887Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslol1001vsovc26xs8hge","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#4ebde9","excerpt":"","more":""},{"_content":"","source":"_drafts/设计模式/访问者模式.md","raw":"","slug":"设计模式/访问者模式","published":0,"date":"2024-03-19T06:12:59.245Z","updated":"2024-03-19T06:12:46.887Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslol1001wsovcdksk0obe","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":""},{"_content":"","source":"_drafts/设计模式/责任链模式.md","raw":"","slug":"设计模式/责任链模式","published":0,"date":"2024-03-19T06:16:59.127Z","updated":"2024-03-19T06:16:59.127Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslol2001xsovc64p6dl2r","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":""},{"_content":"","source":"_drafts/设计模式/迭代器模式.md","raw":"","slug":"设计模式/迭代器模式","published":0,"date":"2024-03-19T06:17:25.542Z","updated":"2024-03-19T06:17:25.542Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslol2001ysovc7snf5eq5","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":""},{"_content":"","source":"_drafts/设计模式/适配器模式.md","raw":"","slug":"设计模式/适配器模式","published":0,"date":"2024-03-19T06:12:53.361Z","updated":"2024-03-19T06:12:46.887Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cltzslol2001zsovc43jb8hcc","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":""},{"title":"中介者模式：简化对象间的通信","_content":"\n中介者模式（Mediator Pattern）是一种行为型设计模式，用于解耦多个对象之间的通信，并将其集中处理。通过引入一个中介者对象，各个对象不再直接相互通信，而是通过中介者进行交互。这种模式可以减少对象间的耦合度，提高系统的可维护性和灵活性。\n\n---\n\n### 示例场景(vue2中收集响应式依赖, 通过Dep类集中处理依赖更新)\n\n```javascript\n// 中介模式\nlet uid = 0; // 使用闭包实现唯一标识\nclass Dep {\n  constructor() {\n    this.id = uid++;\n    this.subs = [];\n  }\n  addSub(sub) {\n    this.subs.push(sub);\n  }\n  removeSub(sub) {\n    remove(this.subs, sub); // 一个工具函数\n  }\n  depend() {\n    if (Dep.target) {\n      Dep.target.addDep(this);\n    }\n  }\n  notify() {\n    const subs = this.subs.slice();\n    for (let i = 0, l = subs.length; i < l; i++) {\n      subs[i].update();  // 调用Watcher.prototype.addDep\n    }\n  }\n}\n\n// 视图模型对象\nclass Watcher {\n    addDep(dep) {\n        dep.addSub(this);\n    }\n    update() {\n        // 更新视图\n    }\n}\n\n// 模型对象\nfunction defineReacitve(obj, key, value, customSetter) {\n    const dep = new Dep()\n    \n    Object.defineProperty(obj, key, {\n        enumeralbe: true,\n        configurable: true,\n        get: function () {\n            if(Dep.target) {\n                dep.depend() // 收集\n            }\n        },\n        set: function () {\n            dep.notify(); // 通知\n        },\n    })\n}\n```\n\n该案例中使用了**Dep类**充当中介者角色, **模型对象**不直接与**视图模型对象**直接通信, 避免了响应式数据挟持后书写视图更新的负责逻辑代码;\n\n### 其他场景\n\n假设我们正在开发一个聊天室应用程序，其中包含多个用户（User）和一个聊天室（ChatRoom）。用户之间可以相互发送消息，同时聊天室也可以将消息广播给所有用户。\n\n在这个场景中，可以使用中介者模式来简化用户和聊天室之间的通信。聊天室充当中介者，用户充当同事类。用户之间的消息不再直接发送给其他用户，而是通过聊天室中介者进行转发。\n\n### 总结\n\n- 中介者模式的核心思想是将对象间的通信行为集中管理，通过引入一个中介者对象来协调各个对象之间的交互。\n- 中介者模式的核心组成部分: 中介者, 交互对象(可能是同事类);\n\n### 结语\n\n在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。\n\n通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。\n\n敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。","source":"_posts/设计模式/中介者模式.md","raw":"---\ntitle: 中介者模式：简化对象间的通信\n---\n\n中介者模式（Mediator Pattern）是一种行为型设计模式，用于解耦多个对象之间的通信，并将其集中处理。通过引入一个中介者对象，各个对象不再直接相互通信，而是通过中介者进行交互。这种模式可以减少对象间的耦合度，提高系统的可维护性和灵活性。\n\n---\n\n### 示例场景(vue2中收集响应式依赖, 通过Dep类集中处理依赖更新)\n\n```javascript\n// 中介模式\nlet uid = 0; // 使用闭包实现唯一标识\nclass Dep {\n  constructor() {\n    this.id = uid++;\n    this.subs = [];\n  }\n  addSub(sub) {\n    this.subs.push(sub);\n  }\n  removeSub(sub) {\n    remove(this.subs, sub); // 一个工具函数\n  }\n  depend() {\n    if (Dep.target) {\n      Dep.target.addDep(this);\n    }\n  }\n  notify() {\n    const subs = this.subs.slice();\n    for (let i = 0, l = subs.length; i < l; i++) {\n      subs[i].update();  // 调用Watcher.prototype.addDep\n    }\n  }\n}\n\n// 视图模型对象\nclass Watcher {\n    addDep(dep) {\n        dep.addSub(this);\n    }\n    update() {\n        // 更新视图\n    }\n}\n\n// 模型对象\nfunction defineReacitve(obj, key, value, customSetter) {\n    const dep = new Dep()\n    \n    Object.defineProperty(obj, key, {\n        enumeralbe: true,\n        configurable: true,\n        get: function () {\n            if(Dep.target) {\n                dep.depend() // 收集\n            }\n        },\n        set: function () {\n            dep.notify(); // 通知\n        },\n    })\n}\n```\n\n该案例中使用了**Dep类**充当中介者角色, **模型对象**不直接与**视图模型对象**直接通信, 避免了响应式数据挟持后书写视图更新的负责逻辑代码;\n\n### 其他场景\n\n假设我们正在开发一个聊天室应用程序，其中包含多个用户（User）和一个聊天室（ChatRoom）。用户之间可以相互发送消息，同时聊天室也可以将消息广播给所有用户。\n\n在这个场景中，可以使用中介者模式来简化用户和聊天室之间的通信。聊天室充当中介者，用户充当同事类。用户之间的消息不再直接发送给其他用户，而是通过聊天室中介者进行转发。\n\n### 总结\n\n- 中介者模式的核心思想是将对象间的通信行为集中管理，通过引入一个中介者对象来协调各个对象之间的交互。\n- 中介者模式的核心组成部分: 中介者, 交互对象(可能是同事类);\n\n### 结语\n\n在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。\n\n通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。\n\n敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。","slug":"设计模式/中介者模式","published":1,"date":"2024-03-19T06:12:59.572Z","updated":"2024-03-25T09:55:19.471Z","_id":"cltzt0oir00001kvc6jxf7rt7","comments":1,"layout":"post","photos":[],"link":"","content":"<p>中介者模式（Mediator Pattern）是一种行为型设计模式，用于解耦多个对象之间的通信，并将其集中处理。通过引入一个中介者对象，各个对象不再直接相互通信，而是通过中介者进行交互。这种模式可以减少对象间的耦合度，提高系统的可维护性和灵活性。</p>\n<hr>\n<h3 id=\"示例场景-vue2中收集响应式依赖-通过Dep类集中处理依赖更新\"><a href=\"#示例场景-vue2中收集响应式依赖-通过Dep类集中处理依赖更新\" class=\"headerlink\" title=\"示例场景(vue2中收集响应式依赖, 通过Dep类集中处理依赖更新)\"></a>示例场景(vue2中收集响应式依赖, 通过Dep类集中处理依赖更新)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 中介模式</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> uid = <span class=\"number\">0</span>; <span class=\"comment\">// 使用闭包实现唯一标识</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dep</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">id</span> = uid++;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">subs</span> = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">addSub</span>(<span class=\"params\">sub</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">subs</span>.<span class=\"title function_\">push</span>(sub);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">removeSub</span>(<span class=\"params\">sub</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">remove</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">subs</span>, sub); <span class=\"comment\">// 一个工具函数</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">depend</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title class_\">Dep</span>.<span class=\"property\">target</span>) &#123;</span><br><span class=\"line\">      <span class=\"title class_\">Dep</span>.<span class=\"property\">target</span>.<span class=\"title function_\">addDep</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">notify</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> subs = <span class=\"variable language_\">this</span>.<span class=\"property\">subs</span>.<span class=\"title function_\">slice</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = subs.<span class=\"property\">length</span>; i &lt; l; i++) &#123;</span><br><span class=\"line\">      subs[i].<span class=\"title function_\">update</span>();  <span class=\"comment\">// 调用Watcher.prototype.addDep</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 视图模型对象</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Watcher</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">addDep</span>(<span class=\"params\">dep</span>) &#123;</span><br><span class=\"line\">        dep.<span class=\"title function_\">addSub</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">update</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 更新视图</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模型对象</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">defineReacitve</span>(<span class=\"params\">obj, key, value, customSetter</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> dep = <span class=\"keyword\">new</span> <span class=\"title class_\">Dep</span>()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, key, &#123;</span><br><span class=\"line\">        <span class=\"attr\">enumeralbe</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"title class_\">Dep</span>.<span class=\"property\">target</span>) &#123;</span><br><span class=\"line\">                dep.<span class=\"title function_\">depend</span>() <span class=\"comment\">// 收集</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">set</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            dep.<span class=\"title function_\">notify</span>(); <span class=\"comment\">// 通知</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该案例中使用了<strong>Dep类</strong>充当中介者角色, <strong>模型对象</strong>不直接与<strong>视图模型对象</strong>直接通信, 避免了响应式数据挟持后书写视图更新的负责逻辑代码;</p>\n<h3 id=\"其他场景\"><a href=\"#其他场景\" class=\"headerlink\" title=\"其他场景\"></a>其他场景</h3><p>假设我们正在开发一个聊天室应用程序，其中包含多个用户（User）和一个聊天室（ChatRoom）。用户之间可以相互发送消息，同时聊天室也可以将消息广播给所有用户。</p>\n<p>在这个场景中，可以使用中介者模式来简化用户和聊天室之间的通信。聊天室充当中介者，用户充当同事类。用户之间的消息不再直接发送给其他用户，而是通过聊天室中介者进行转发。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>中介者模式的核心思想是将对象间的通信行为集中管理，通过引入一个中介者对象来协调各个对象之间的交互。</li>\n<li>中介者模式的核心组成部分: 中介者, 交互对象(可能是同事类);</li>\n</ul>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。</p>\n<p>通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。</p>\n<p>敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":"<p>中介者模式（Mediator Pattern）是一种行为型设计模式，用于解耦多个对象之间的通信，并将其集中处理。通过引入一个中介者对象，各个对象不再直接相互通信，而是通过中介者进行交互。这种模式可以减少对象间的耦合度，提高系统的可维护性和灵活性。</p>\n<hr>\n<h3 id=\"示例场景-vue2中收集响应式依赖-通过Dep类集中处理依赖更新\"><a href=\"#示例场景-vue2中收集响应式依赖-通过Dep类集中处理依赖更新\" class=\"headerlink\" title=\"示例场景(vue2中收集响应式依赖, 通过Dep类集中处理依赖更新)\"></a>示例场景(vue2中收集响应式依赖, 通过Dep类集中处理依赖更新)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 中介模式</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> uid = <span class=\"number\">0</span>; <span class=\"comment\">// 使用闭包实现唯一标识</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dep</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">id</span> = uid++;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">subs</span> = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">addSub</span>(<span class=\"params\">sub</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">subs</span>.<span class=\"title function_\">push</span>(sub);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">removeSub</span>(<span class=\"params\">sub</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">remove</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">subs</span>, sub); <span class=\"comment\">// 一个工具函数</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">depend</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title class_\">Dep</span>.<span class=\"property\">target</span>) &#123;</span><br><span class=\"line\">      <span class=\"title class_\">Dep</span>.<span class=\"property\">target</span>.<span class=\"title function_\">addDep</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">notify</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> subs = <span class=\"variable language_\">this</span>.<span class=\"property\">subs</span>.<span class=\"title function_\">slice</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = subs.<span class=\"property\">length</span>; i &lt; l; i++) &#123;</span><br><span class=\"line\">      subs[i].<span class=\"title function_\">update</span>();  <span class=\"comment\">// 调用Watcher.prototype.addDep</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 视图模型对象</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Watcher</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">addDep</span>(<span class=\"params\">dep</span>) &#123;</span><br><span class=\"line\">        dep.<span class=\"title function_\">addSub</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">update</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 更新视图</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模型对象</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">defineReacitve</span>(<span class=\"params\">obj, key, value, customSetter</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> dep = <span class=\"keyword\">new</span> <span class=\"title class_\">Dep</span>()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, key, &#123;</span><br><span class=\"line\">        <span class=\"attr\">enumeralbe</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"title class_\">Dep</span>.<span class=\"property\">target</span>) &#123;</span><br><span class=\"line\">                dep.<span class=\"title function_\">depend</span>() <span class=\"comment\">// 收集</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">set</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            dep.<span class=\"title function_\">notify</span>(); <span class=\"comment\">// 通知</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该案例中使用了<strong>Dep类</strong>充当中介者角色, <strong>模型对象</strong>不直接与<strong>视图模型对象</strong>直接通信, 避免了响应式数据挟持后书写视图更新的负责逻辑代码;</p>\n<h3 id=\"其他场景\"><a href=\"#其他场景\" class=\"headerlink\" title=\"其他场景\"></a>其他场景</h3><p>假设我们正在开发一个聊天室应用程序，其中包含多个用户（User）和一个聊天室（ChatRoom）。用户之间可以相互发送消息，同时聊天室也可以将消息广播给所有用户。</p>\n<p>在这个场景中，可以使用中介者模式来简化用户和聊天室之间的通信。聊天室充当中介者，用户充当同事类。用户之间的消息不再直接发送给其他用户，而是通过聊天室中介者进行转发。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>中介者模式的核心思想是将对象间的通信行为集中管理，通过引入一个中介者对象来协调各个对象之间的交互。</li>\n<li>中介者模式的核心组成部分: 中介者, 交互对象(可能是同事类);</li>\n</ul>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。</p>\n<p>通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。</p>\n<p>敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。</p>\n"},{"title":"单例模式：实现全局唯一实例的设计模式","_content":"\n单例模式是一种常见的设计模式，它通过限制类的实例化次数，确保只有一个实例存在。\n\n### 示例场景(vue3创建渲染器)\n\n```javascript\nlet renderer;\nfunction ensureRenderer() {\n    return renderer || createRender(rendererOptions);\n}\n```\n\n### 其他实现方式\n\n由于 JavaScript 的事件循环机制和单线程执行，实现单例模式考虑的没那那么复杂，实现起来比较简单。\n\n```javascript\n// 方式一\nconst Singleton = (function() {\n    let instance;\n    function createInstance() {\n        return new Object('I am the instance');\n    }\n\n    return {\n        getInstance: function() {\n            if(!instance) {\n                instance = createInstance();\n            }\n\n            return instance;\n        }\n    }\n})\nconst instance = Singleton.getInstance();\n\n// 方式二，直接使用对象字面量\nconst messageManager = {\n    success() {},\n    error() {},\n}\nObject.freeze(messageManager)\n```\n\n### 其他场景\n\n- 全局配置：单例模式可以用于管理全局的配置信息，确保在应用中只有一个配置实例被使用。\n- 日志记录器：单例模式可以用于创建全局唯一的日志记录器，方便在应用中统一管理和记录日志信息\n\n### 总结\n\n- 单例模式的核心思想是需要确保一个类只有一个实例。\n\n### 结语\n\n在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。\n\n通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。\n\n敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。\n","source":"_posts/设计模式/单例模式.md","raw":"---\ntitle: 单例模式：实现全局唯一实例的设计模式\n---\n\n单例模式是一种常见的设计模式，它通过限制类的实例化次数，确保只有一个实例存在。\n\n### 示例场景(vue3创建渲染器)\n\n```javascript\nlet renderer;\nfunction ensureRenderer() {\n    return renderer || createRender(rendererOptions);\n}\n```\n\n### 其他实现方式\n\n由于 JavaScript 的事件循环机制和单线程执行，实现单例模式考虑的没那那么复杂，实现起来比较简单。\n\n```javascript\n// 方式一\nconst Singleton = (function() {\n    let instance;\n    function createInstance() {\n        return new Object('I am the instance');\n    }\n\n    return {\n        getInstance: function() {\n            if(!instance) {\n                instance = createInstance();\n            }\n\n            return instance;\n        }\n    }\n})\nconst instance = Singleton.getInstance();\n\n// 方式二，直接使用对象字面量\nconst messageManager = {\n    success() {},\n    error() {},\n}\nObject.freeze(messageManager)\n```\n\n### 其他场景\n\n- 全局配置：单例模式可以用于管理全局的配置信息，确保在应用中只有一个配置实例被使用。\n- 日志记录器：单例模式可以用于创建全局唯一的日志记录器，方便在应用中统一管理和记录日志信息\n\n### 总结\n\n- 单例模式的核心思想是需要确保一个类只有一个实例。\n\n### 结语\n\n在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。\n\n通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。\n\n敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。\n","slug":"设计模式/单例模式","published":1,"date":"2024-03-19T06:12:52.789Z","updated":"2024-03-23T09:30:29.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu3w4d9v00019ogm7pj0411o","content":"<p>单例模式是一种常见的设计模式，它通过限制类的实例化次数，确保只有一个实例存在。</p>\n<h3 id=\"示例场景-vue3创建渲染器\"><a href=\"#示例场景-vue3创建渲染器\" class=\"headerlink\" title=\"示例场景(vue3创建渲染器)\"></a>示例场景(vue3创建渲染器)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> renderer;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ensureRenderer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> renderer || <span class=\"title function_\">createRender</span>(rendererOptions);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其他实现方式\"><a href=\"#其他实现方式\" class=\"headerlink\" title=\"其他实现方式\"></a>其他实现方式</h3><p>由于 JavaScript 的事件循环机制和单线程执行，实现单例模式考虑的没那那么复杂，实现起来比较简单。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方式一</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Singleton</span> = (<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> instance;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">createInstance</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>(<span class=\"string\">&#x27;I am the instance&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">getInstance</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!instance) &#123;</span><br><span class=\"line\">                instance = <span class=\"title function_\">createInstance</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">const</span> instance = <span class=\"title class_\">Singleton</span>.<span class=\"title function_\">getInstance</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式二，直接使用对象字面量</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> messageManager = &#123;</span><br><span class=\"line\">    <span class=\"title function_\">success</span>(<span class=\"params\"></span>) &#123;&#125;,</span><br><span class=\"line\">    <span class=\"title function_\">error</span>(<span class=\"params\"></span>) &#123;&#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">freeze</span>(messageManager)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其他场景\"><a href=\"#其他场景\" class=\"headerlink\" title=\"其他场景\"></a>其他场景</h3><ul>\n<li>全局配置：单例模式可以用于管理全局的配置信息，确保在应用中只有一个配置实例被使用。</li>\n<li>日志记录器：单例模式可以用于创建全局唯一的日志记录器，方便在应用中统一管理和记录日志信息</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>单例模式的核心思想是需要确保一个类只有一个实例。</li>\n</ul>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。</p>\n<p>通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。</p>\n<p>敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":"<p>单例模式是一种常见的设计模式，它通过限制类的实例化次数，确保只有一个实例存在。</p>\n<h3 id=\"示例场景-vue3创建渲染器\"><a href=\"#示例场景-vue3创建渲染器\" class=\"headerlink\" title=\"示例场景(vue3创建渲染器)\"></a>示例场景(vue3创建渲染器)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> renderer;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ensureRenderer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> renderer || <span class=\"title function_\">createRender</span>(rendererOptions);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其他实现方式\"><a href=\"#其他实现方式\" class=\"headerlink\" title=\"其他实现方式\"></a>其他实现方式</h3><p>由于 JavaScript 的事件循环机制和单线程执行，实现单例模式考虑的没那那么复杂，实现起来比较简单。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方式一</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Singleton</span> = (<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> instance;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">createInstance</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>(<span class=\"string\">&#x27;I am the instance&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">getInstance</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!instance) &#123;</span><br><span class=\"line\">                instance = <span class=\"title function_\">createInstance</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">const</span> instance = <span class=\"title class_\">Singleton</span>.<span class=\"title function_\">getInstance</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式二，直接使用对象字面量</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> messageManager = &#123;</span><br><span class=\"line\">    <span class=\"title function_\">success</span>(<span class=\"params\"></span>) &#123;&#125;,</span><br><span class=\"line\">    <span class=\"title function_\">error</span>(<span class=\"params\"></span>) &#123;&#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">freeze</span>(messageManager)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其他场景\"><a href=\"#其他场景\" class=\"headerlink\" title=\"其他场景\"></a>其他场景</h3><ul>\n<li>全局配置：单例模式可以用于管理全局的配置信息，确保在应用中只有一个配置实例被使用。</li>\n<li>日志记录器：单例模式可以用于创建全局唯一的日志记录器，方便在应用中统一管理和记录日志信息</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>单例模式的核心思想是需要确保一个类只有一个实例。</li>\n</ul>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。</p>\n<p>通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。</p>\n<p>敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。</p>\n"},{"title":"工厂模式：灵活创建对象的设计模式","_content":"\n工厂模式是一种创建型设计模式，它通过使用工厂方法或抽象工厂，将对象的实例化过程封装起来，使得客户端与具体的对象创建过程解耦。工厂模式可以根据不同的条件或参数来创建不同的对象，提供了一种灵活的对象创建方式。\n\n---\n\n### 实现工厂模式的方式\n\n#### 简单工厂模式\n\n```javascript\n// 工厂类\nclass ShapeFactory {\n    createShape(type) {\n        if(type === 'circle') {\n            return new Circle();\n        } else if(type === 'rectangle') {\n            return new Rectangle();\n        } else {\n            throw new Error('无效的形状');\n        }\n    }\n}\n\nclass Shape {\n    draw() {\n        throw new Error('绘制接口必须实现');\n    }\n}\n\n// 不同的具体产品\nclass Circle extends Shape {\n    draw() {\n        console.log('绘制圆');\n    }\n}\n\nclass Rectangle extends Shape {\n    draw() {\n        console.log('绘制矩形');\n    }\n}\n\nconst circle = new ShapeFactory('circle');\nconst rectangle = new ShapeFactory('rectangle');\n```\n\n#### 工厂方法模式\n\n```javascript\n// 工厂类\nclass ShapeFactory {\n    createShape(type) {\n        throw new Error('创建形状接口必须实现');\n    }\n}\n\nclass CircleFactory extends ShapeFactory {\n    createShape() {\n        return new Circle();\n    }\n}\n\nclass RectangleFactory extends ShapeFactory {\n    createShape() {\n        return new Rectangle();\n    }\n}\n\nclass Shape {\n    draw() {\n        throw new Error('绘制接口必须实现');\n    }\n}\n// 不同的具体产品\nclass Circle extends Shape {\n    draw() {\n        console.log('绘制圆');\n    }\n}\n\nclass Rectangle  extends Shape {\n    draw() {\n        console.log('绘制矩形');\n    }\n}\n\nconst circle = new CircleFactory();\nconst rectangle = new RectFactory();\n```\n\n#### 抽象工厂模式\n\n```javascript\n// 工厂类\nclass H5Factory {\n    createButton() {\n        return new H5Button();\n    }\n\n    createIcon() {\n        return new H5Icon();\n    }\n}\nclass WxFactory {\n     createButton() {\n        return new WxButton();\n    }\n\n    createIcon() {\n        return new WxIcon();\n    }\n}\n\n\n// 不同的具体产品\nclass H5Button {\n    description() {\n        console.log('这是个按钮');\n    }\n}\n\nclass H5Icon {\n    description() {\n        console.log('这是个图标');\n    }\n}\nclass WxButton {\n    description() {\n        console.log('这是个按钮');\n    }\n}\n\nclass WxIcon {\n    description() {\n        console.log('这是个图标');\n    }\n}\n\n\nconst h5Factory = new H5Factory();\nconst wxFactory = new wxFactory();\n\nconst h5Button = new h5Factory.createButton();\nconst h5Icon = new h5Factory.createIcon();\n```\n\n### 简单工厂、工厂方法、抽象工厂模式的区别\n- 关注点不同: \n    - 简单工厂使用一个接口创建所有产品； \n    - 工厂方法将产品实例化放到不同的工厂中，关注产品的从属性；\n    - 抽象工厂关注的是一个工厂包含多个产品对应的接口，关注的是产品族的创建；\n- 组成结构不同：\n    - 简单工厂主要含有工厂类、具体产品类，工厂类下仅含有一个创建产品的接口；\n    - 工厂方法主要含有抽象工厂类、具体工厂类、具体产品类；\n    - 抽象工厂主要含有工厂类，具体产品A类，具体产品B类，工厂类下含有创建产品族的方法；\n\n### 总结\n\n- 工厂模式的核心思想是将对象的实例化过程封装起来，通过一个接口进行实例化，使得客户端与具体的对象创建过程解耦。\n\n### 结语\n\n在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。\n\n通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。\n\n敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。\n","source":"_posts/设计模式/工厂模式.md","raw":"---\ntitle: 工厂模式：灵活创建对象的设计模式\n---\n\n工厂模式是一种创建型设计模式，它通过使用工厂方法或抽象工厂，将对象的实例化过程封装起来，使得客户端与具体的对象创建过程解耦。工厂模式可以根据不同的条件或参数来创建不同的对象，提供了一种灵活的对象创建方式。\n\n---\n\n### 实现工厂模式的方式\n\n#### 简单工厂模式\n\n```javascript\n// 工厂类\nclass ShapeFactory {\n    createShape(type) {\n        if(type === 'circle') {\n            return new Circle();\n        } else if(type === 'rectangle') {\n            return new Rectangle();\n        } else {\n            throw new Error('无效的形状');\n        }\n    }\n}\n\nclass Shape {\n    draw() {\n        throw new Error('绘制接口必须实现');\n    }\n}\n\n// 不同的具体产品\nclass Circle extends Shape {\n    draw() {\n        console.log('绘制圆');\n    }\n}\n\nclass Rectangle extends Shape {\n    draw() {\n        console.log('绘制矩形');\n    }\n}\n\nconst circle = new ShapeFactory('circle');\nconst rectangle = new ShapeFactory('rectangle');\n```\n\n#### 工厂方法模式\n\n```javascript\n// 工厂类\nclass ShapeFactory {\n    createShape(type) {\n        throw new Error('创建形状接口必须实现');\n    }\n}\n\nclass CircleFactory extends ShapeFactory {\n    createShape() {\n        return new Circle();\n    }\n}\n\nclass RectangleFactory extends ShapeFactory {\n    createShape() {\n        return new Rectangle();\n    }\n}\n\nclass Shape {\n    draw() {\n        throw new Error('绘制接口必须实现');\n    }\n}\n// 不同的具体产品\nclass Circle extends Shape {\n    draw() {\n        console.log('绘制圆');\n    }\n}\n\nclass Rectangle  extends Shape {\n    draw() {\n        console.log('绘制矩形');\n    }\n}\n\nconst circle = new CircleFactory();\nconst rectangle = new RectFactory();\n```\n\n#### 抽象工厂模式\n\n```javascript\n// 工厂类\nclass H5Factory {\n    createButton() {\n        return new H5Button();\n    }\n\n    createIcon() {\n        return new H5Icon();\n    }\n}\nclass WxFactory {\n     createButton() {\n        return new WxButton();\n    }\n\n    createIcon() {\n        return new WxIcon();\n    }\n}\n\n\n// 不同的具体产品\nclass H5Button {\n    description() {\n        console.log('这是个按钮');\n    }\n}\n\nclass H5Icon {\n    description() {\n        console.log('这是个图标');\n    }\n}\nclass WxButton {\n    description() {\n        console.log('这是个按钮');\n    }\n}\n\nclass WxIcon {\n    description() {\n        console.log('这是个图标');\n    }\n}\n\n\nconst h5Factory = new H5Factory();\nconst wxFactory = new wxFactory();\n\nconst h5Button = new h5Factory.createButton();\nconst h5Icon = new h5Factory.createIcon();\n```\n\n### 简单工厂、工厂方法、抽象工厂模式的区别\n- 关注点不同: \n    - 简单工厂使用一个接口创建所有产品； \n    - 工厂方法将产品实例化放到不同的工厂中，关注产品的从属性；\n    - 抽象工厂关注的是一个工厂包含多个产品对应的接口，关注的是产品族的创建；\n- 组成结构不同：\n    - 简单工厂主要含有工厂类、具体产品类，工厂类下仅含有一个创建产品的接口；\n    - 工厂方法主要含有抽象工厂类、具体工厂类、具体产品类；\n    - 抽象工厂主要含有工厂类，具体产品A类，具体产品B类，工厂类下含有创建产品族的方法；\n\n### 总结\n\n- 工厂模式的核心思想是将对象的实例化过程封装起来，通过一个接口进行实例化，使得客户端与具体的对象创建过程解耦。\n\n### 结语\n\n在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。\n\n通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。\n\n敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。\n","slug":"设计模式/工厂模式","published":1,"date":"2024-03-19T06:12:52.958Z","updated":"2024-03-24T10:50:30.808Z","_id":"clu5aoul10000u0gm0hki9fk7","comments":1,"layout":"post","photos":[],"link":"","content":"<p>工厂模式是一种创建型设计模式，它通过使用工厂方法或抽象工厂，将对象的实例化过程封装起来，使得客户端与具体的对象创建过程解耦。工厂模式可以根据不同的条件或参数来创建不同的对象，提供了一种灵活的对象创建方式。</p>\n<hr>\n<h3 id=\"实现工厂模式的方式\"><a href=\"#实现工厂模式的方式\" class=\"headerlink\" title=\"实现工厂模式的方式\"></a>实现工厂模式的方式</h3><h4 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 工厂类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ShapeFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">createShape</span>(<span class=\"params\">type</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(type === <span class=\"string\">&#x27;circle&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Circle</span>();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(type === <span class=\"string\">&#x27;rectangle&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Rectangle</span>();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;无效的形状&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">draw</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;绘制接口必须实现&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不同的具体产品</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Circle</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Shape</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">draw</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;绘制圆&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rectangle</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Shape</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">draw</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;绘制矩形&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> circle = <span class=\"keyword\">new</span> <span class=\"title class_\">ShapeFactory</span>(<span class=\"string\">&#x27;circle&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> rectangle = <span class=\"keyword\">new</span> <span class=\"title class_\">ShapeFactory</span>(<span class=\"string\">&#x27;rectangle&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 工厂类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ShapeFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">createShape</span>(<span class=\"params\">type</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;创建形状接口必须实现&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CircleFactory</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">ShapeFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">createShape</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Circle</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RectangleFactory</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">ShapeFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">createShape</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Rectangle</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">draw</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;绘制接口必须实现&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 不同的具体产品</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Circle</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Shape</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">draw</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;绘制圆&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rectangle</span>  <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Shape</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">draw</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;绘制矩形&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> circle = <span class=\"keyword\">new</span> <span class=\"title class_\">CircleFactory</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> rectangle = <span class=\"keyword\">new</span> <span class=\"title class_\">RectFactory</span>();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 工厂类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">H5Factory</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">createButton</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">H5Button</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">createIcon</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">H5Icon</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WxFactory</span> &#123;</span><br><span class=\"line\">     <span class=\"title function_\">createButton</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">WxButton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">createIcon</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">WxIcon</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不同的具体产品</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">H5Button</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">description</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;这是个按钮&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">H5Icon</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">description</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;这是个图标&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WxButton</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">description</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;这是个按钮&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WxIcon</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">description</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;这是个图标&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> h5Factory = <span class=\"keyword\">new</span> <span class=\"title function_\">H5Factory</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> wxFactory = <span class=\"keyword\">new</span> <span class=\"title function_\">wxFactory</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> h5Button = <span class=\"keyword\">new</span> h5Factory.<span class=\"title function_\">createButton</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> h5Icon = <span class=\"keyword\">new</span> h5Factory.<span class=\"title function_\">createIcon</span>();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"简单工厂、工厂方法、抽象工厂模式的区别\"><a href=\"#简单工厂、工厂方法、抽象工厂模式的区别\" class=\"headerlink\" title=\"简单工厂、工厂方法、抽象工厂模式的区别\"></a>简单工厂、工厂方法、抽象工厂模式的区别</h3><ul>\n<li>关注点不同: <ul>\n<li>简单工厂使用一个接口创建所有产品； </li>\n<li>工厂方法将产品实例化放到不同的工厂中，关注产品的从属性；</li>\n<li>抽象工厂关注的是一个工厂包含多个产品对应的接口，关注的是产品族的创建；</li>\n</ul>\n</li>\n<li>组成结构不同：<ul>\n<li>简单工厂主要含有工厂类、具体产品类，工厂类下仅含有一个创建产品的接口；</li>\n<li>工厂方法主要含有抽象工厂类、具体工厂类、具体产品类；</li>\n<li>抽象工厂主要含有工厂类，具体产品A类，具体产品B类，工厂类下含有创建产品族的方法；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>工厂模式的核心思想是将对象的实例化过程封装起来，通过一个接口进行实例化，使得客户端与具体的对象创建过程解耦。</li>\n</ul>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。</p>\n<p>通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。</p>\n<p>敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":"<p>工厂模式是一种创建型设计模式，它通过使用工厂方法或抽象工厂，将对象的实例化过程封装起来，使得客户端与具体的对象创建过程解耦。工厂模式可以根据不同的条件或参数来创建不同的对象，提供了一种灵活的对象创建方式。</p>\n<hr>\n<h3 id=\"实现工厂模式的方式\"><a href=\"#实现工厂模式的方式\" class=\"headerlink\" title=\"实现工厂模式的方式\"></a>实现工厂模式的方式</h3><h4 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 工厂类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ShapeFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">createShape</span>(<span class=\"params\">type</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(type === <span class=\"string\">&#x27;circle&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Circle</span>();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(type === <span class=\"string\">&#x27;rectangle&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Rectangle</span>();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;无效的形状&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">draw</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;绘制接口必须实现&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不同的具体产品</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Circle</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Shape</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">draw</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;绘制圆&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rectangle</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Shape</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">draw</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;绘制矩形&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> circle = <span class=\"keyword\">new</span> <span class=\"title class_\">ShapeFactory</span>(<span class=\"string\">&#x27;circle&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> rectangle = <span class=\"keyword\">new</span> <span class=\"title class_\">ShapeFactory</span>(<span class=\"string\">&#x27;rectangle&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 工厂类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ShapeFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">createShape</span>(<span class=\"params\">type</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;创建形状接口必须实现&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CircleFactory</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">ShapeFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">createShape</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Circle</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RectangleFactory</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">ShapeFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">createShape</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Rectangle</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">draw</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;绘制接口必须实现&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 不同的具体产品</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Circle</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Shape</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">draw</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;绘制圆&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rectangle</span>  <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Shape</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">draw</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;绘制矩形&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> circle = <span class=\"keyword\">new</span> <span class=\"title class_\">CircleFactory</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> rectangle = <span class=\"keyword\">new</span> <span class=\"title class_\">RectFactory</span>();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 工厂类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">H5Factory</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">createButton</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">H5Button</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">createIcon</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">H5Icon</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WxFactory</span> &#123;</span><br><span class=\"line\">     <span class=\"title function_\">createButton</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">WxButton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">createIcon</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">WxIcon</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不同的具体产品</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">H5Button</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">description</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;这是个按钮&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">H5Icon</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">description</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;这是个图标&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WxButton</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">description</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;这是个按钮&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WxIcon</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">description</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;这是个图标&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> h5Factory = <span class=\"keyword\">new</span> <span class=\"title function_\">H5Factory</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> wxFactory = <span class=\"keyword\">new</span> <span class=\"title function_\">wxFactory</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> h5Button = <span class=\"keyword\">new</span> h5Factory.<span class=\"title function_\">createButton</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> h5Icon = <span class=\"keyword\">new</span> h5Factory.<span class=\"title function_\">createIcon</span>();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"简单工厂、工厂方法、抽象工厂模式的区别\"><a href=\"#简单工厂、工厂方法、抽象工厂模式的区别\" class=\"headerlink\" title=\"简单工厂、工厂方法、抽象工厂模式的区别\"></a>简单工厂、工厂方法、抽象工厂模式的区别</h3><ul>\n<li>关注点不同: <ul>\n<li>简单工厂使用一个接口创建所有产品； </li>\n<li>工厂方法将产品实例化放到不同的工厂中，关注产品的从属性；</li>\n<li>抽象工厂关注的是一个工厂包含多个产品对应的接口，关注的是产品族的创建；</li>\n</ul>\n</li>\n<li>组成结构不同：<ul>\n<li>简单工厂主要含有工厂类、具体产品类，工厂类下仅含有一个创建产品的接口；</li>\n<li>工厂方法主要含有抽象工厂类、具体工厂类、具体产品类；</li>\n<li>抽象工厂主要含有工厂类，具体产品A类，具体产品B类，工厂类下含有创建产品族的方法；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>工厂模式的核心思想是将对象的实例化过程封装起来，通过一个接口进行实例化，使得客户端与具体的对象创建过程解耦。</li>\n</ul>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。</p>\n<p>通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。</p>\n<p>敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。</p>\n"},{"title":"建造者模式：构建复杂对象的灵活设计模式","_content":"\n建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。\n---\n\n### 示例场景(创建一个计算机对象)\n```javascript\n// Product: 表示要构建的复杂对象​\nclass Computer {​\n  constructor() {​\n    this.cpu = \"\";​\n    this.gpu = \"\";​\n    this.ram = 0;​\n    this.storage = \"\";​\n  }​\n​\n  describe() {​\n    return `Computer with CPU: ${this.cpu}, GPU: ${this.gpu}, RAM: ${this.ram}GB, Storage: ${this.storage}`;​\n  }​\n}​\n​\n// Builder: 声明构建复杂对象的接口​\nclass ComputerBuilder {​\n  constructor() {​\n    this.computer = new Computer();​\n  }​\n​\n  setCPU() {​\n    this.computer.cpu = \"AMD 5600G\";​\n    return this;​\n  }​\n​\n  setGPU() {​\n    this.computer.gpu = \"核显\";​\n    return this;​\n  }​\n​\n  setRAM() {​\n    this.computer.ram = 16;​\n    return this;​\n  }​\n​\n  setStorage() {​\n    this.computer.storage = \"500G\";​\n    return this;​\n  }​\n​\n  build() {​\n    return this.computer;​\n  }​\n}​\n​\n// Director: 负责使用 Builder 构建对象​\nclass ComputerEngineer {​\n  constructComputer(builder) {​\n    return builder​\n      .setCPU()​\n      .setGPU()​\n      .setRAM()​\n      .setStorage()​\n      .build();​\n  }​\n}​\n​\n// 使用建造者模式创建复杂对象​\nconst engineer = new ComputerEngineer();​\nconst builder = new ComputerBuilder();​\n​\nconst computer = engineer.constructComputer(builder);​\n```\n\n### 总结\n- 建造者模式的核心思想是将对象的构建过程和表示分离;\n- 建造者模式的核心组成部分是: 构建对象类, 构建器类, 指挥者类;\n\n### 结语\n\n在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。\n\n通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。\n\n敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。","source":"_posts/设计模式/建造者模式.md","raw":"---\ntitle: 建造者模式：构建复杂对象的灵活设计模式\n---\n\n建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。\n---\n\n### 示例场景(创建一个计算机对象)\n```javascript\n// Product: 表示要构建的复杂对象​\nclass Computer {​\n  constructor() {​\n    this.cpu = \"\";​\n    this.gpu = \"\";​\n    this.ram = 0;​\n    this.storage = \"\";​\n  }​\n​\n  describe() {​\n    return `Computer with CPU: ${this.cpu}, GPU: ${this.gpu}, RAM: ${this.ram}GB, Storage: ${this.storage}`;​\n  }​\n}​\n​\n// Builder: 声明构建复杂对象的接口​\nclass ComputerBuilder {​\n  constructor() {​\n    this.computer = new Computer();​\n  }​\n​\n  setCPU() {​\n    this.computer.cpu = \"AMD 5600G\";​\n    return this;​\n  }​\n​\n  setGPU() {​\n    this.computer.gpu = \"核显\";​\n    return this;​\n  }​\n​\n  setRAM() {​\n    this.computer.ram = 16;​\n    return this;​\n  }​\n​\n  setStorage() {​\n    this.computer.storage = \"500G\";​\n    return this;​\n  }​\n​\n  build() {​\n    return this.computer;​\n  }​\n}​\n​\n// Director: 负责使用 Builder 构建对象​\nclass ComputerEngineer {​\n  constructComputer(builder) {​\n    return builder​\n      .setCPU()​\n      .setGPU()​\n      .setRAM()​\n      .setStorage()​\n      .build();​\n  }​\n}​\n​\n// 使用建造者模式创建复杂对象​\nconst engineer = new ComputerEngineer();​\nconst builder = new ComputerBuilder();​\n​\nconst computer = engineer.constructComputer(builder);​\n```\n\n### 总结\n- 建造者模式的核心思想是将对象的构建过程和表示分离;\n- 建造者模式的核心组成部分是: 构建对象类, 构建器类, 指挥者类;\n\n### 结语\n\n在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。\n\n通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。\n\n敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。","slug":"设计模式/建造者模式","published":1,"date":"2024-03-19T06:12:53.157Z","updated":"2024-03-25T10:01:31.331Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu6sc6yb0000uwgm80czboge","content":"<h2 id=\"建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。\"><a href=\"#建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。\" class=\"headerlink\" title=\"建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。\"></a>建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。</h2><h3 id=\"示例场景-创建一个计算机对象\"><a href=\"#示例场景-创建一个计算机对象\" class=\"headerlink\" title=\"示例场景(创建一个计算机对象)\"></a>示例场景(创建一个计算机对象)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Product: 表示要构建的复杂对象​</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Computer</span> &#123;​</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;​</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">cpu</span> = <span class=\"string\">&quot;&quot;</span>;​</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">gpu</span> = <span class=\"string\">&quot;&quot;</span>;​</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">ram</span> = <span class=\"number\">0</span>;​</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">storage</span> = <span class=\"string\">&quot;&quot;</span>;​</span><br><span class=\"line\">  &#125;​</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"title function_\">describe</span>(<span class=\"params\"></span>) &#123;​</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`Computer with CPU: <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.cpu&#125;</span>, GPU: <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.gpu&#125;</span>, RAM: <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.ram&#125;</span>GB, Storage: <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.storage&#125;</span>`</span>;​</span><br><span class=\"line\">  &#125;​</span><br><span class=\"line\">&#125;​</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"comment\">// Builder: 声明构建复杂对象的接口​</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ComputerBuilder</span> &#123;​</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;​</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">computer</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Computer</span>();​</span><br><span class=\"line\">  &#125;​</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"title function_\">setCPU</span>(<span class=\"params\"></span>) &#123;​</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">computer</span>.<span class=\"property\">cpu</span> = <span class=\"string\">&quot;AMD 5600G&quot;</span>;​</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>;​</span><br><span class=\"line\">  &#125;​</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"title function_\">setGPU</span>(<span class=\"params\"></span>) &#123;​</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">computer</span>.<span class=\"property\">gpu</span> = <span class=\"string\">&quot;核显&quot;</span>;​</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>;​</span><br><span class=\"line\">  &#125;​</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"title function_\">setRAM</span>(<span class=\"params\"></span>) &#123;​</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">computer</span>.<span class=\"property\">ram</span> = <span class=\"number\">16</span>;​</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>;​</span><br><span class=\"line\">  &#125;​</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"title function_\">setStorage</span>(<span class=\"params\"></span>) &#123;​</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">computer</span>.<span class=\"property\">storage</span> = <span class=\"string\">&quot;500G&quot;</span>;​</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>;​</span><br><span class=\"line\">  &#125;​</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;​</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">computer</span>;​</span><br><span class=\"line\">  &#125;​</span><br><span class=\"line\">&#125;​</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"comment\">// Director: 负责使用 Builder 构建对象​</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ComputerEngineer</span> &#123;​</span><br><span class=\"line\">  <span class=\"title function_\">constructComputer</span>(<span class=\"params\">builder</span>) &#123;​</span><br><span class=\"line\">    <span class=\"keyword\">return</span> builder​</span><br><span class=\"line\">      .<span class=\"title function_\">setCPU</span>()​</span><br><span class=\"line\">      .<span class=\"title function_\">setGPU</span>()​</span><br><span class=\"line\">      .<span class=\"title function_\">setRAM</span>()​</span><br><span class=\"line\">      .<span class=\"title function_\">setStorage</span>()​</span><br><span class=\"line\">      .<span class=\"title function_\">build</span>();​</span><br><span class=\"line\">  &#125;​</span><br><span class=\"line\">&#125;​</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"comment\">// 使用建造者模式创建复杂对象​</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> engineer = <span class=\"keyword\">new</span> <span class=\"title class_\">ComputerEngineer</span>();​</span><br><span class=\"line\"><span class=\"keyword\">const</span> builder = <span class=\"keyword\">new</span> <span class=\"title class_\">ComputerBuilder</span>();​</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"keyword\">const</span> computer = engineer.<span class=\"title function_\">constructComputer</span>(builder);​</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>建造者模式的核心思想是将对象的构建过程和表示分离;</li>\n<li>建造者模式的核心组成部分是: 构建对象类, 构建器类, 指挥者类;</li>\n</ul>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。</p>\n<p>通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。</p>\n<p>敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#4ebde9","excerpt":"","more":"<h2 id=\"建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。\"><a href=\"#建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。\" class=\"headerlink\" title=\"建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。\"></a>建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。</h2><h3 id=\"示例场景-创建一个计算机对象\"><a href=\"#示例场景-创建一个计算机对象\" class=\"headerlink\" title=\"示例场景(创建一个计算机对象)\"></a>示例场景(创建一个计算机对象)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Product: 表示要构建的复杂对象​</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Computer</span> &#123;​</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;​</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">cpu</span> = <span class=\"string\">&quot;&quot;</span>;​</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">gpu</span> = <span class=\"string\">&quot;&quot;</span>;​</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">ram</span> = <span class=\"number\">0</span>;​</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">storage</span> = <span class=\"string\">&quot;&quot;</span>;​</span><br><span class=\"line\">  &#125;​</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"title function_\">describe</span>(<span class=\"params\"></span>) &#123;​</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`Computer with CPU: <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.cpu&#125;</span>, GPU: <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.gpu&#125;</span>, RAM: <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.ram&#125;</span>GB, Storage: <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.storage&#125;</span>`</span>;​</span><br><span class=\"line\">  &#125;​</span><br><span class=\"line\">&#125;​</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"comment\">// Builder: 声明构建复杂对象的接口​</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ComputerBuilder</span> &#123;​</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;​</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">computer</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Computer</span>();​</span><br><span class=\"line\">  &#125;​</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"title function_\">setCPU</span>(<span class=\"params\"></span>) &#123;​</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">computer</span>.<span class=\"property\">cpu</span> = <span class=\"string\">&quot;AMD 5600G&quot;</span>;​</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>;​</span><br><span class=\"line\">  &#125;​</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"title function_\">setGPU</span>(<span class=\"params\"></span>) &#123;​</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">computer</span>.<span class=\"property\">gpu</span> = <span class=\"string\">&quot;核显&quot;</span>;​</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>;​</span><br><span class=\"line\">  &#125;​</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"title function_\">setRAM</span>(<span class=\"params\"></span>) &#123;​</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">computer</span>.<span class=\"property\">ram</span> = <span class=\"number\">16</span>;​</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>;​</span><br><span class=\"line\">  &#125;​</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"title function_\">setStorage</span>(<span class=\"params\"></span>) &#123;​</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">computer</span>.<span class=\"property\">storage</span> = <span class=\"string\">&quot;500G&quot;</span>;​</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>;​</span><br><span class=\"line\">  &#125;​</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"title function_\">build</span>(<span class=\"params\"></span>) &#123;​</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">computer</span>;​</span><br><span class=\"line\">  &#125;​</span><br><span class=\"line\">&#125;​</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"comment\">// Director: 负责使用 Builder 构建对象​</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ComputerEngineer</span> &#123;​</span><br><span class=\"line\">  <span class=\"title function_\">constructComputer</span>(<span class=\"params\">builder</span>) &#123;​</span><br><span class=\"line\">    <span class=\"keyword\">return</span> builder​</span><br><span class=\"line\">      .<span class=\"title function_\">setCPU</span>()​</span><br><span class=\"line\">      .<span class=\"title function_\">setGPU</span>()​</span><br><span class=\"line\">      .<span class=\"title function_\">setRAM</span>()​</span><br><span class=\"line\">      .<span class=\"title function_\">setStorage</span>()​</span><br><span class=\"line\">      .<span class=\"title function_\">build</span>();​</span><br><span class=\"line\">  &#125;​</span><br><span class=\"line\">&#125;​</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"comment\">// 使用建造者模式创建复杂对象​</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> engineer = <span class=\"keyword\">new</span> <span class=\"title class_\">ComputerEngineer</span>();​</span><br><span class=\"line\"><span class=\"keyword\">const</span> builder = <span class=\"keyword\">new</span> <span class=\"title class_\">ComputerBuilder</span>();​</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"keyword\">const</span> computer = engineer.<span class=\"title function_\">constructComputer</span>(builder);​</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>建造者模式的核心思想是将对象的构建过程和表示分离;</li>\n<li>建造者模式的核心组成部分是: 构建对象类, 构建器类, 指挥者类;</li>\n</ul>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。</p>\n<p>通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。</p>\n<p>敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。</p>\n"},{"_content":"### 用户定制绘图流程\n\n1. 确认需求\n - 确认绘制主体、参照区域\n2. 平面绘制（fabric.js可以解决）\n - 图片图层、文字图层、矩阵绘制。\n - 图层操作：选择、缩放、位移、层级管理。\n3. 效果绘制\n - 平面图的扭曲绘制\n\n### 遇到的问题\n- 遇到绘制主体的种类繁多, 需要快速确认绘制主体的问题。可以使用预置绘制主体库方案进行解决。可以达到快速确认主体、主题配件效果。\n- 遇到fabric.js在小程序中可能不兼容。因小程序无DOM概念, 尝试解决方案: 到微信开发社区寻找解决方案、修改fabric.js源码中获取Canvs的方式、自行实现。\n- 遇到平面图的扭曲绘制是技术盲区, 尝试方案: 到第三方canvas绘制库源码中寻找。","source":"_drafts/设计模式/x.md","raw":"### 用户定制绘图流程\n\n1. 确认需求\n - 确认绘制主体、参照区域\n2. 平面绘制（fabric.js可以解决）\n - 图片图层、文字图层、矩阵绘制。\n - 图层操作：选择、缩放、位移、层级管理。\n3. 效果绘制\n - 平面图的扭曲绘制\n\n### 遇到的问题\n- 遇到绘制主体的种类繁多, 需要快速确认绘制主体的问题。可以使用预置绘制主体库方案进行解决。可以达到快速确认主体、主题配件效果。\n- 遇到fabric.js在小程序中可能不兼容。因小程序无DOM概念, 尝试解决方案: 到微信开发社区寻找解决方案、修改fabric.js源码中获取Canvs的方式、自行实现。\n- 遇到平面图的扭曲绘制是技术盲区, 尝试方案: 到第三方canvas绘制库源码中寻找。","slug":"设计模式/x","published":0,"date":"2024-03-27T23:55:32.815Z","updated":"2024-03-28T00:54:34.767Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cluct10ta0000tsgmhn7l8azd","content":"<h3 id=\"用户定制绘图流程\"><a href=\"#用户定制绘图流程\" class=\"headerlink\" title=\"用户定制绘图流程\"></a>用户定制绘图流程</h3><ol>\n<li>确认需求</li>\n</ol>\n<ul>\n<li>确认绘制主体、参照区域</li>\n</ul>\n<ol start=\"2\">\n<li>平面绘制（fabric.js可以解决）</li>\n</ol>\n<ul>\n<li>图片图层、文字图层、矩阵绘制。</li>\n<li>图层操作：选择、缩放、位移、层级管理。</li>\n</ul>\n<ol start=\"3\">\n<li>效果绘制</li>\n</ol>\n<ul>\n<li>平面图的扭曲绘制</li>\n</ul>\n<h3 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h3><ul>\n<li>遇到绘制主体的种类繁多, 需要快速确认绘制主体的问题。可以使用预置绘制主体库方案进行解决。可以达到快速确认主体、主题配件效果。</li>\n<li>遇到fabric.js在小程序中可能不兼容。因小程序无DOM概念, 尝试解决方案: 到微信开发社区寻找解决方案、修改fabric.js源码中获取Canvs的方式、自行实现。</li>\n<li>遇到平面图的扭曲绘制是技术盲区, 尝试方案: 到第三方canvas绘制库源码中寻找。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":"<h3 id=\"用户定制绘图流程\"><a href=\"#用户定制绘图流程\" class=\"headerlink\" title=\"用户定制绘图流程\"></a>用户定制绘图流程</h3><ol>\n<li>确认需求</li>\n</ol>\n<ul>\n<li>确认绘制主体、参照区域</li>\n</ul>\n<ol start=\"2\">\n<li>平面绘制（fabric.js可以解决）</li>\n</ol>\n<ul>\n<li>图片图层、文字图层、矩阵绘制。</li>\n<li>图层操作：选择、缩放、位移、层级管理。</li>\n</ul>\n<ol start=\"3\">\n<li>效果绘制</li>\n</ol>\n<ul>\n<li>平面图的扭曲绘制</li>\n</ul>\n<h3 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h3><ul>\n<li>遇到绘制主体的种类繁多, 需要快速确认绘制主体的问题。可以使用预置绘制主体库方案进行解决。可以达到快速确认主体、主题配件效果。</li>\n<li>遇到fabric.js在小程序中可能不兼容。因小程序无DOM概念, 尝试解决方案: 到微信开发社区寻找解决方案、修改fabric.js源码中获取Canvs的方式、自行实现。</li>\n<li>遇到平面图的扭曲绘制是技术盲区, 尝试方案: 到第三方canvas绘制库源码中寻找。</li>\n</ul>\n"},{"_content":"学历: 大专\n年限: 4年\n目标: 8k\n空档期: 1年\n\n投递时间: 3/08 - 3/12\n投递总数: 30\n投递平台: boss\n\n\n| 流程          | 总数          |\n| -----------   | ----------- |\n| 未读          | 15           |\n| 已读不回      | 11            |\n| 回应沟通      | 5             |\n| 要简历数      | 1             |\n| 面试通过次数  | 0             |\n\n\n","source":"_drafts/设计模式/简历记录.md","raw":"学历: 大专\n年限: 4年\n目标: 8k\n空档期: 1年\n\n投递时间: 3/08 - 3/12\n投递总数: 30\n投递平台: boss\n\n\n| 流程          | 总数          |\n| -----------   | ----------- |\n| 未读          | 15           |\n| 已读不回      | 11            |\n| 回应沟通      | 5             |\n| 要简历数      | 1             |\n| 面试通过次数  | 0             |\n\n\n","slug":"设计模式/简历记录","published":0,"date":"2024-03-28T04:14:36.215Z","updated":"2024-03-28T09:27:22.396Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cluct10tb0001tsgm93aa0ddx","content":"<p>学历: 大专<br>年限: 4年<br>目标: 8k<br>空档期: 1年</p>\n<p>投递时间: 3&#x2F;08 - 3&#x2F;12<br>投递总数: 30<br>投递平台: boss</p>\n<table>\n<thead>\n<tr>\n<th>流程</th>\n<th>总数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>未读</td>\n<td>15</td>\n</tr>\n<tr>\n<td>已读不回</td>\n<td>11</td>\n</tr>\n<tr>\n<td>回应沟通</td>\n<td>5</td>\n</tr>\n<tr>\n<td>要简历数</td>\n<td>1</td>\n</tr>\n<tr>\n<td>面试通过次数</td>\n<td>0</td>\n</tr>\n</tbody></table>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#e7817c","excerpt":"","more":"<p>学历: 大专<br>年限: 4年<br>目标: 8k<br>空档期: 1年</p>\n<p>投递时间: 3&#x2F;08 - 3&#x2F;12<br>投递总数: 30<br>投递平台: boss</p>\n<table>\n<thead>\n<tr>\n<th>流程</th>\n<th>总数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>未读</td>\n<td>15</td>\n</tr>\n<tr>\n<td>已读不回</td>\n<td>11</td>\n</tr>\n<tr>\n<td>回应沟通</td>\n<td>5</td>\n</tr>\n<tr>\n<td>要简历数</td>\n<td>1</td>\n</tr>\n<tr>\n<td>面试通过次数</td>\n<td>0</td>\n</tr>\n</tbody></table>\n"},{"title":"渲染器：数据访问是如何被代理的？","_content":"\n\n## 渲染器：数据访问是如何被代理的？\n\n### 源码定义: 对组件实例上下文进行代理\n\n```javascript\nfunction setupStatefulComponent(instance, isSSR) {\n  instance.accessCache = Object.create(null)\n  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers))\n}\n```\n\n### PublicInstanceProxyHandlers.get\n\n```\nconst PublicInstanceProxyHandlers = {\n  get({ _: instance }, key) {\n    const { ctx, setupState, data, props, accessCache, type, appContext } = instance\n    if (__DEV__ && key === '__isVue') {\n      return true\n    }\n\n    let normalizedProps;  // 预定义模块所需变量\n    if (key[0] !== '$') { // 处理非预留属性\n      const n = accessCache[key] // 读取缓存内容\n      if (n !== undefined) {\n        switch (n) {\n          case AccessTypes.SETUP:\n            return setupState[key]\n          case AccessTypes.DATA:\n            return data[key]\n          case AccessTypes.CONTEXT:\n            return ctx[key]\n          case AccessTypes.PROPS:\n            return props[key]\n        }\n      } else if (hasSetupBinding(setupState, key)) {\n        accessCache![key] = AccessTypes.SETUP\n        return setupState[key]\n      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\n        accessCache![key] = AccessTypes.DATA\n        return data[key]\n      } else if (\n        (normalizedProps = instance.propsOptions[0]) &&\n        hasOwn(normalizedProps, key)\n      ) {\n        accessCache![key] = AccessTypes.PROPS\n        return props![key]\n      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\n        accessCache![key] = AccessTypes.CONTEXT\n        return ctx[key]\n      } else if (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) {\n        accessCache![key] = AccessTypes.OTHER\n      }\n    }\n\n    const publicGetter = publicPropertiesMap[key] // 开始处理预留属性\n    let cssModule, globalProperties\n    if (publicGetter) {\n      // $保留字开头的相关逻辑\n    } else if (\n      (cssModule = type.__cssModules) &&\n      (cssModule = cssModule[key])\n    ) {\n      return cssModule\n    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\n      accessCache![key] = AccessTypes.CONTEXT\n      return ctx[key]\n    } else if (\n      ((globalProperties = appContext.config.globalProperties),\n        hasOwn(globalProperties, key))\n    ) {\n      if (__COMPAT__) {\n        const desc = Object.getOwnPropertyDescriptor(globalProperties, key)!\n        if (desc.get) {\n          return desc.get.call(instance.proxy)\n        } else {\n          const val = globalProperties[key]\n          return isFunction(val)\n            ? Object.assign(val.bind(instance.proxy), val)\n            : val\n        }\n      } else {\n        return globalProperties[key]\n      }\n    } else if (\n      // 一些告警\n    }\n  }\n}\n```\n\n#### 笔记\n\n1. 访问顺序为`setupState`》`data`》`prop`》`ctx`\n2. 使用`空间换时间`进行了优化，使用`accessCache`标记`key`存在于哪个属性上，减少了频繁调用`hasOwn`耗费性能。\n\n### PublicInstanceProxyHandlers .get\n\n```\nconst PublicInstanceProxyHandlers = {\n  set({ _: instance }, key, value) {\n    const { data, setupState, ctx } = instance\n    if (hasSetupBinding(setupState, key)) {\n      setupState[key] = value\n      return true\n    } else if (\n      __DEV__ &&\n      setupState.__isScriptSetup &&\n      hasOwn(setupState, key)\n    ) {\n      warn(`Cannot mutate <script setup> binding \"${key}\" from Options API.`)\n      return false\n    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\n      data[key] = value\n      return true\n    } else if (hasOwn(instance.props, key)) {\n      __DEV__ && warn(`Attempting to mutate prop \"${key}\". Props are readonly.`)\n      return false\n    }\n    if (key[0] === '$' && key.slice(1) in instance) {\n      __DEV__ &&\n      warn(\n        `Attempting to mutate public property \"${key}\". ` +\n        `Properties starting with $ are reserved and readonly.`,\n      )\n      return false\n    } else {\n      if (__DEV__ && key in instance.appContext.config.globalProperties) {\n        Object.defineProperty(ctx, key, {\n          enumerable: true,\n          configurable: true,\n          value,\n        })\n      } else {\n        ctx[key] = value\n      }\n    }\n    return true\n  },\n}\n```\n\n**结论：** 更改顺序为：`setupState` 》`data` 》`props` 》`globalProperties`\n\n### PublicInstanceProxyHandlers .has\n\n```\nconst PublicInstanceProxyHandlers = {\n  has({_: { data, setupState, accessCache, ctx, appContext, propsOptions }}, key) {\n    let normalizedProps\n    return (\n      !!accessCache[key] ||\n      (data !== EMPTY_OBJ && hasOwn(data, key)) ||\n      hasSetupBinding(setupState, key) ||\n      ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||\n      hasOwn(ctx, key) ||\n      hasOwn(publicPropertiesMap, key) || // $保留字开头的函数\n      hasOwn(appContext.config.globalProperties, key)\n    )\n  },\n}\n```\n\n**结论：** 访问顺序为`data `》`setupState`》`props`》`ctx`》`publicPropertiesMap`》`globalProperties`\n","source":"_posts/源码/vue3/3-渲染器-数据访问是如何被代理的.md","raw":"---\ntitle: 渲染器：数据访问是如何被代理的？\n---\n\n\n## 渲染器：数据访问是如何被代理的？\n\n### 源码定义: 对组件实例上下文进行代理\n\n```javascript\nfunction setupStatefulComponent(instance, isSSR) {\n  instance.accessCache = Object.create(null)\n  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers))\n}\n```\n\n### PublicInstanceProxyHandlers.get\n\n```\nconst PublicInstanceProxyHandlers = {\n  get({ _: instance }, key) {\n    const { ctx, setupState, data, props, accessCache, type, appContext } = instance\n    if (__DEV__ && key === '__isVue') {\n      return true\n    }\n\n    let normalizedProps;  // 预定义模块所需变量\n    if (key[0] !== '$') { // 处理非预留属性\n      const n = accessCache[key] // 读取缓存内容\n      if (n !== undefined) {\n        switch (n) {\n          case AccessTypes.SETUP:\n            return setupState[key]\n          case AccessTypes.DATA:\n            return data[key]\n          case AccessTypes.CONTEXT:\n            return ctx[key]\n          case AccessTypes.PROPS:\n            return props[key]\n        }\n      } else if (hasSetupBinding(setupState, key)) {\n        accessCache![key] = AccessTypes.SETUP\n        return setupState[key]\n      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\n        accessCache![key] = AccessTypes.DATA\n        return data[key]\n      } else if (\n        (normalizedProps = instance.propsOptions[0]) &&\n        hasOwn(normalizedProps, key)\n      ) {\n        accessCache![key] = AccessTypes.PROPS\n        return props![key]\n      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\n        accessCache![key] = AccessTypes.CONTEXT\n        return ctx[key]\n      } else if (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) {\n        accessCache![key] = AccessTypes.OTHER\n      }\n    }\n\n    const publicGetter = publicPropertiesMap[key] // 开始处理预留属性\n    let cssModule, globalProperties\n    if (publicGetter) {\n      // $保留字开头的相关逻辑\n    } else if (\n      (cssModule = type.__cssModules) &&\n      (cssModule = cssModule[key])\n    ) {\n      return cssModule\n    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\n      accessCache![key] = AccessTypes.CONTEXT\n      return ctx[key]\n    } else if (\n      ((globalProperties = appContext.config.globalProperties),\n        hasOwn(globalProperties, key))\n    ) {\n      if (__COMPAT__) {\n        const desc = Object.getOwnPropertyDescriptor(globalProperties, key)!\n        if (desc.get) {\n          return desc.get.call(instance.proxy)\n        } else {\n          const val = globalProperties[key]\n          return isFunction(val)\n            ? Object.assign(val.bind(instance.proxy), val)\n            : val\n        }\n      } else {\n        return globalProperties[key]\n      }\n    } else if (\n      // 一些告警\n    }\n  }\n}\n```\n\n#### 笔记\n\n1. 访问顺序为`setupState`》`data`》`prop`》`ctx`\n2. 使用`空间换时间`进行了优化，使用`accessCache`标记`key`存在于哪个属性上，减少了频繁调用`hasOwn`耗费性能。\n\n### PublicInstanceProxyHandlers .get\n\n```\nconst PublicInstanceProxyHandlers = {\n  set({ _: instance }, key, value) {\n    const { data, setupState, ctx } = instance\n    if (hasSetupBinding(setupState, key)) {\n      setupState[key] = value\n      return true\n    } else if (\n      __DEV__ &&\n      setupState.__isScriptSetup &&\n      hasOwn(setupState, key)\n    ) {\n      warn(`Cannot mutate <script setup> binding \"${key}\" from Options API.`)\n      return false\n    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\n      data[key] = value\n      return true\n    } else if (hasOwn(instance.props, key)) {\n      __DEV__ && warn(`Attempting to mutate prop \"${key}\". Props are readonly.`)\n      return false\n    }\n    if (key[0] === '$' && key.slice(1) in instance) {\n      __DEV__ &&\n      warn(\n        `Attempting to mutate public property \"${key}\". ` +\n        `Properties starting with $ are reserved and readonly.`,\n      )\n      return false\n    } else {\n      if (__DEV__ && key in instance.appContext.config.globalProperties) {\n        Object.defineProperty(ctx, key, {\n          enumerable: true,\n          configurable: true,\n          value,\n        })\n      } else {\n        ctx[key] = value\n      }\n    }\n    return true\n  },\n}\n```\n\n**结论：** 更改顺序为：`setupState` 》`data` 》`props` 》`globalProperties`\n\n### PublicInstanceProxyHandlers .has\n\n```\nconst PublicInstanceProxyHandlers = {\n  has({_: { data, setupState, accessCache, ctx, appContext, propsOptions }}, key) {\n    let normalizedProps\n    return (\n      !!accessCache[key] ||\n      (data !== EMPTY_OBJ && hasOwn(data, key)) ||\n      hasSetupBinding(setupState, key) ||\n      ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||\n      hasOwn(ctx, key) ||\n      hasOwn(publicPropertiesMap, key) || // $保留字开头的函数\n      hasOwn(appContext.config.globalProperties, key)\n    )\n  },\n}\n```\n\n**结论：** 访问顺序为`data `》`setupState`》`props`》`ctx`》`publicPropertiesMap`》`globalProperties`\n","slug":"源码/vue3/3-渲染器-数据访问是如何被代理的","published":1,"date":"2024-03-13T13:19:55.092Z","updated":"2024-03-20T00:50:15.318Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cluct10tc0002tsgm9f27e112","content":"<h2 id=\"渲染器：数据访问是如何被代理的？\"><a href=\"#渲染器：数据访问是如何被代理的？\" class=\"headerlink\" title=\"渲染器：数据访问是如何被代理的？\"></a>渲染器：数据访问是如何被代理的？</h2><h3 id=\"源码定义-对组件实例上下文进行代理\"><a href=\"#源码定义-对组件实例上下文进行代理\" class=\"headerlink\" title=\"源码定义: 对组件实例上下文进行代理\"></a>源码定义: 对组件实例上下文进行代理</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setupStatefulComponent</span>(<span class=\"params\">instance, isSSR</span>) &#123;</span><br><span class=\"line\">  instance.<span class=\"property\">accessCache</span> = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"literal\">null</span>)</span><br><span class=\"line\">  instance.<span class=\"property\">proxy</span> = <span class=\"title function_\">markRaw</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(instance.<span class=\"property\">ctx</span>, <span class=\"title class_\">PublicInstanceProxyHandlers</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"PublicInstanceProxyHandlers-get\"><a href=\"#PublicInstanceProxyHandlers-get\" class=\"headerlink\" title=\"PublicInstanceProxyHandlers.get\"></a>PublicInstanceProxyHandlers.get</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const PublicInstanceProxyHandlers = &#123;</span><br><span class=\"line\">  get(&#123; _: instance &#125;, key) &#123;</span><br><span class=\"line\">    const &#123; ctx, setupState, data, props, accessCache, type, appContext &#125; = instance</span><br><span class=\"line\">    if (__DEV__ &amp;&amp; key === &#x27;__isVue&#x27;) &#123;</span><br><span class=\"line\">      return true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    let normalizedProps;  // 预定义模块所需变量</span><br><span class=\"line\">    if (key[0] !== &#x27;$&#x27;) &#123; // 处理非预留属性</span><br><span class=\"line\">      const n = accessCache[key] // 读取缓存内容</span><br><span class=\"line\">      if (n !== undefined) &#123;</span><br><span class=\"line\">        switch (n) &#123;</span><br><span class=\"line\">          case AccessTypes.SETUP:</span><br><span class=\"line\">            return setupState[key]</span><br><span class=\"line\">          case AccessTypes.DATA:</span><br><span class=\"line\">            return data[key]</span><br><span class=\"line\">          case AccessTypes.CONTEXT:</span><br><span class=\"line\">            return ctx[key]</span><br><span class=\"line\">          case AccessTypes.PROPS:</span><br><span class=\"line\">            return props[key]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; else if (hasSetupBinding(setupState, key)) &#123;</span><br><span class=\"line\">        accessCache![key] = AccessTypes.SETUP</span><br><span class=\"line\">        return setupState[key]</span><br><span class=\"line\">      &#125; else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123;</span><br><span class=\"line\">        accessCache![key] = AccessTypes.DATA</span><br><span class=\"line\">        return data[key]</span><br><span class=\"line\">      &#125; else if (</span><br><span class=\"line\">        (normalizedProps = instance.propsOptions[0]) &amp;&amp;</span><br><span class=\"line\">        hasOwn(normalizedProps, key)</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        accessCache![key] = AccessTypes.PROPS</span><br><span class=\"line\">        return props![key]</span><br><span class=\"line\">      &#125; else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123;</span><br><span class=\"line\">        accessCache![key] = AccessTypes.CONTEXT</span><br><span class=\"line\">        return ctx[key]</span><br><span class=\"line\">      &#125; else if (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) &#123;</span><br><span class=\"line\">        accessCache![key] = AccessTypes.OTHER</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const publicGetter = publicPropertiesMap[key] // 开始处理预留属性</span><br><span class=\"line\">    let cssModule, globalProperties</span><br><span class=\"line\">    if (publicGetter) &#123;</span><br><span class=\"line\">      // $保留字开头的相关逻辑</span><br><span class=\"line\">    &#125; else if (</span><br><span class=\"line\">      (cssModule = type.__cssModules) &amp;&amp;</span><br><span class=\"line\">      (cssModule = cssModule[key])</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      return cssModule</span><br><span class=\"line\">    &#125; else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123;</span><br><span class=\"line\">      accessCache![key] = AccessTypes.CONTEXT</span><br><span class=\"line\">      return ctx[key]</span><br><span class=\"line\">    &#125; else if (</span><br><span class=\"line\">      ((globalProperties = appContext.config.globalProperties),</span><br><span class=\"line\">        hasOwn(globalProperties, key))</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      if (__COMPAT__) &#123;</span><br><span class=\"line\">        const desc = Object.getOwnPropertyDescriptor(globalProperties, key)!</span><br><span class=\"line\">        if (desc.get) &#123;</span><br><span class=\"line\">          return desc.get.call(instance.proxy)</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          const val = globalProperties[key]</span><br><span class=\"line\">          return isFunction(val)</span><br><span class=\"line\">            ? Object.assign(val.bind(instance.proxy), val)</span><br><span class=\"line\">            : val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        return globalProperties[key]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; else if (</span><br><span class=\"line\">      // 一些告警</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h4><ol>\n<li>访问顺序为<code>setupState</code>》<code>data</code>》<code>prop</code>》<code>ctx</code></li>\n<li>使用<code>空间换时间</code>进行了优化，使用<code>accessCache</code>标记<code>key</code>存在于哪个属性上，减少了频繁调用<code>hasOwn</code>耗费性能。</li>\n</ol>\n<h3 id=\"PublicInstanceProxyHandlers-get-1\"><a href=\"#PublicInstanceProxyHandlers-get-1\" class=\"headerlink\" title=\"PublicInstanceProxyHandlers .get\"></a>PublicInstanceProxyHandlers .get</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const PublicInstanceProxyHandlers = &#123;</span><br><span class=\"line\">  set(&#123; _: instance &#125;, key, value) &#123;</span><br><span class=\"line\">    const &#123; data, setupState, ctx &#125; = instance</span><br><span class=\"line\">    if (hasSetupBinding(setupState, key)) &#123;</span><br><span class=\"line\">      setupState[key] = value</span><br><span class=\"line\">      return true</span><br><span class=\"line\">    &#125; else if (</span><br><span class=\"line\">      __DEV__ &amp;&amp;</span><br><span class=\"line\">      setupState.__isScriptSetup &amp;&amp;</span><br><span class=\"line\">      hasOwn(setupState, key)</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      warn(`Cannot mutate &lt;script setup&gt; binding &quot;$&#123;key&#125;&quot; from Options API.`)</span><br><span class=\"line\">      return false</span><br><span class=\"line\">    &#125; else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123;</span><br><span class=\"line\">      data[key] = value</span><br><span class=\"line\">      return true</span><br><span class=\"line\">    &#125; else if (hasOwn(instance.props, key)) &#123;</span><br><span class=\"line\">      __DEV__ &amp;&amp; warn(`Attempting to mutate prop &quot;$&#123;key&#125;&quot;. Props are readonly.`)</span><br><span class=\"line\">      return false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (key[0] === &#x27;$&#x27; &amp;&amp; key.slice(1) in instance) &#123;</span><br><span class=\"line\">      __DEV__ &amp;&amp;</span><br><span class=\"line\">      warn(</span><br><span class=\"line\">        `Attempting to mutate public property &quot;$&#123;key&#125;&quot;. ` +</span><br><span class=\"line\">        `Properties starting with $ are reserved and readonly.`,</span><br><span class=\"line\">      )</span><br><span class=\"line\">      return false</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      if (__DEV__ &amp;&amp; key in instance.appContext.config.globalProperties) &#123;</span><br><span class=\"line\">        Object.defineProperty(ctx, key, &#123;</span><br><span class=\"line\">          enumerable: true,</span><br><span class=\"line\">          configurable: true,</span><br><span class=\"line\">          value,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        ctx[key] = value</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结论：</strong> 更改顺序为：<code>setupState</code> 》<code>data</code> 》<code>props</code> 》<code>globalProperties</code></p>\n<h3 id=\"PublicInstanceProxyHandlers-has\"><a href=\"#PublicInstanceProxyHandlers-has\" class=\"headerlink\" title=\"PublicInstanceProxyHandlers .has\"></a>PublicInstanceProxyHandlers .has</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const PublicInstanceProxyHandlers = &#123;</span><br><span class=\"line\">  has(&#123;_: &#123; data, setupState, accessCache, ctx, appContext, propsOptions &#125;&#125;, key) &#123;</span><br><span class=\"line\">    let normalizedProps</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      !!accessCache[key] ||</span><br><span class=\"line\">      (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) ||</span><br><span class=\"line\">      hasSetupBinding(setupState, key) ||</span><br><span class=\"line\">      ((normalizedProps = propsOptions[0]) &amp;&amp; hasOwn(normalizedProps, key)) ||</span><br><span class=\"line\">      hasOwn(ctx, key) ||</span><br><span class=\"line\">      hasOwn(publicPropertiesMap, key) || // $保留字开头的函数</span><br><span class=\"line\">      hasOwn(appContext.config.globalProperties, key)</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结论：</strong> 访问顺序为<code>data </code>》<code>setupState</code>》<code>props</code>》<code>ctx</code>》<code>publicPropertiesMap</code>》<code>globalProperties</code></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":"<h2 id=\"渲染器：数据访问是如何被代理的？\"><a href=\"#渲染器：数据访问是如何被代理的？\" class=\"headerlink\" title=\"渲染器：数据访问是如何被代理的？\"></a>渲染器：数据访问是如何被代理的？</h2><h3 id=\"源码定义-对组件实例上下文进行代理\"><a href=\"#源码定义-对组件实例上下文进行代理\" class=\"headerlink\" title=\"源码定义: 对组件实例上下文进行代理\"></a>源码定义: 对组件实例上下文进行代理</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setupStatefulComponent</span>(<span class=\"params\">instance, isSSR</span>) &#123;</span><br><span class=\"line\">  instance.<span class=\"property\">accessCache</span> = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"literal\">null</span>)</span><br><span class=\"line\">  instance.<span class=\"property\">proxy</span> = <span class=\"title function_\">markRaw</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(instance.<span class=\"property\">ctx</span>, <span class=\"title class_\">PublicInstanceProxyHandlers</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"PublicInstanceProxyHandlers-get\"><a href=\"#PublicInstanceProxyHandlers-get\" class=\"headerlink\" title=\"PublicInstanceProxyHandlers.get\"></a>PublicInstanceProxyHandlers.get</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const PublicInstanceProxyHandlers = &#123;</span><br><span class=\"line\">  get(&#123; _: instance &#125;, key) &#123;</span><br><span class=\"line\">    const &#123; ctx, setupState, data, props, accessCache, type, appContext &#125; = instance</span><br><span class=\"line\">    if (__DEV__ &amp;&amp; key === &#x27;__isVue&#x27;) &#123;</span><br><span class=\"line\">      return true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    let normalizedProps;  // 预定义模块所需变量</span><br><span class=\"line\">    if (key[0] !== &#x27;$&#x27;) &#123; // 处理非预留属性</span><br><span class=\"line\">      const n = accessCache[key] // 读取缓存内容</span><br><span class=\"line\">      if (n !== undefined) &#123;</span><br><span class=\"line\">        switch (n) &#123;</span><br><span class=\"line\">          case AccessTypes.SETUP:</span><br><span class=\"line\">            return setupState[key]</span><br><span class=\"line\">          case AccessTypes.DATA:</span><br><span class=\"line\">            return data[key]</span><br><span class=\"line\">          case AccessTypes.CONTEXT:</span><br><span class=\"line\">            return ctx[key]</span><br><span class=\"line\">          case AccessTypes.PROPS:</span><br><span class=\"line\">            return props[key]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; else if (hasSetupBinding(setupState, key)) &#123;</span><br><span class=\"line\">        accessCache![key] = AccessTypes.SETUP</span><br><span class=\"line\">        return setupState[key]</span><br><span class=\"line\">      &#125; else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123;</span><br><span class=\"line\">        accessCache![key] = AccessTypes.DATA</span><br><span class=\"line\">        return data[key]</span><br><span class=\"line\">      &#125; else if (</span><br><span class=\"line\">        (normalizedProps = instance.propsOptions[0]) &amp;&amp;</span><br><span class=\"line\">        hasOwn(normalizedProps, key)</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        accessCache![key] = AccessTypes.PROPS</span><br><span class=\"line\">        return props![key]</span><br><span class=\"line\">      &#125; else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123;</span><br><span class=\"line\">        accessCache![key] = AccessTypes.CONTEXT</span><br><span class=\"line\">        return ctx[key]</span><br><span class=\"line\">      &#125; else if (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) &#123;</span><br><span class=\"line\">        accessCache![key] = AccessTypes.OTHER</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const publicGetter = publicPropertiesMap[key] // 开始处理预留属性</span><br><span class=\"line\">    let cssModule, globalProperties</span><br><span class=\"line\">    if (publicGetter) &#123;</span><br><span class=\"line\">      // $保留字开头的相关逻辑</span><br><span class=\"line\">    &#125; else if (</span><br><span class=\"line\">      (cssModule = type.__cssModules) &amp;&amp;</span><br><span class=\"line\">      (cssModule = cssModule[key])</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      return cssModule</span><br><span class=\"line\">    &#125; else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123;</span><br><span class=\"line\">      accessCache![key] = AccessTypes.CONTEXT</span><br><span class=\"line\">      return ctx[key]</span><br><span class=\"line\">    &#125; else if (</span><br><span class=\"line\">      ((globalProperties = appContext.config.globalProperties),</span><br><span class=\"line\">        hasOwn(globalProperties, key))</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      if (__COMPAT__) &#123;</span><br><span class=\"line\">        const desc = Object.getOwnPropertyDescriptor(globalProperties, key)!</span><br><span class=\"line\">        if (desc.get) &#123;</span><br><span class=\"line\">          return desc.get.call(instance.proxy)</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          const val = globalProperties[key]</span><br><span class=\"line\">          return isFunction(val)</span><br><span class=\"line\">            ? Object.assign(val.bind(instance.proxy), val)</span><br><span class=\"line\">            : val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        return globalProperties[key]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; else if (</span><br><span class=\"line\">      // 一些告警</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h4><ol>\n<li>访问顺序为<code>setupState</code>》<code>data</code>》<code>prop</code>》<code>ctx</code></li>\n<li>使用<code>空间换时间</code>进行了优化，使用<code>accessCache</code>标记<code>key</code>存在于哪个属性上，减少了频繁调用<code>hasOwn</code>耗费性能。</li>\n</ol>\n<h3 id=\"PublicInstanceProxyHandlers-get-1\"><a href=\"#PublicInstanceProxyHandlers-get-1\" class=\"headerlink\" title=\"PublicInstanceProxyHandlers .get\"></a>PublicInstanceProxyHandlers .get</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const PublicInstanceProxyHandlers = &#123;</span><br><span class=\"line\">  set(&#123; _: instance &#125;, key, value) &#123;</span><br><span class=\"line\">    const &#123; data, setupState, ctx &#125; = instance</span><br><span class=\"line\">    if (hasSetupBinding(setupState, key)) &#123;</span><br><span class=\"line\">      setupState[key] = value</span><br><span class=\"line\">      return true</span><br><span class=\"line\">    &#125; else if (</span><br><span class=\"line\">      __DEV__ &amp;&amp;</span><br><span class=\"line\">      setupState.__isScriptSetup &amp;&amp;</span><br><span class=\"line\">      hasOwn(setupState, key)</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      warn(`Cannot mutate &lt;script setup&gt; binding &quot;$&#123;key&#125;&quot; from Options API.`)</span><br><span class=\"line\">      return false</span><br><span class=\"line\">    &#125; else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123;</span><br><span class=\"line\">      data[key] = value</span><br><span class=\"line\">      return true</span><br><span class=\"line\">    &#125; else if (hasOwn(instance.props, key)) &#123;</span><br><span class=\"line\">      __DEV__ &amp;&amp; warn(`Attempting to mutate prop &quot;$&#123;key&#125;&quot;. Props are readonly.`)</span><br><span class=\"line\">      return false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (key[0] === &#x27;$&#x27; &amp;&amp; key.slice(1) in instance) &#123;</span><br><span class=\"line\">      __DEV__ &amp;&amp;</span><br><span class=\"line\">      warn(</span><br><span class=\"line\">        `Attempting to mutate public property &quot;$&#123;key&#125;&quot;. ` +</span><br><span class=\"line\">        `Properties starting with $ are reserved and readonly.`,</span><br><span class=\"line\">      )</span><br><span class=\"line\">      return false</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      if (__DEV__ &amp;&amp; key in instance.appContext.config.globalProperties) &#123;</span><br><span class=\"line\">        Object.defineProperty(ctx, key, &#123;</span><br><span class=\"line\">          enumerable: true,</span><br><span class=\"line\">          configurable: true,</span><br><span class=\"line\">          value,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        ctx[key] = value</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结论：</strong> 更改顺序为：<code>setupState</code> 》<code>data</code> 》<code>props</code> 》<code>globalProperties</code></p>\n<h3 id=\"PublicInstanceProxyHandlers-has\"><a href=\"#PublicInstanceProxyHandlers-has\" class=\"headerlink\" title=\"PublicInstanceProxyHandlers .has\"></a>PublicInstanceProxyHandlers .has</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const PublicInstanceProxyHandlers = &#123;</span><br><span class=\"line\">  has(&#123;_: &#123; data, setupState, accessCache, ctx, appContext, propsOptions &#125;&#125;, key) &#123;</span><br><span class=\"line\">    let normalizedProps</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      !!accessCache[key] ||</span><br><span class=\"line\">      (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) ||</span><br><span class=\"line\">      hasSetupBinding(setupState, key) ||</span><br><span class=\"line\">      ((normalizedProps = propsOptions[0]) &amp;&amp; hasOwn(normalizedProps, key)) ||</span><br><span class=\"line\">      hasOwn(ctx, key) ||</span><br><span class=\"line\">      hasOwn(publicPropertiesMap, key) || // $保留字开头的函数</span><br><span class=\"line\">      hasOwn(appContext.config.globalProperties, key)</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结论：</strong> 访问顺序为<code>data </code>》<code>setupState</code>》<code>props</code>》<code>ctx</code>》<code>publicPropertiesMap</code>》<code>globalProperties</code></p>\n"},{"title":"响应式原理：响应式队形解析","_content":"\n### Ref\n\n源码中关于**ref**部分的定义：\n\n```javascript\nexport function ref(value) {\n    return createRef(value, false);\n}\n```\n\n这个函数的核心也就是通过**createRef**把我们传入的**value**变成响应式的\n\n```javascript\nfunction createRef(rawValue, shallow) {\n    if (isRef(rawValue)) {\n        return rawValue;\n    }\n\n    return new RefImpl(rawValue, shallow);\n}\n```\n\n先经过判断，判断符合要求的**value**才能被响应式。一起来看看这个**API**的实现：\n\n```javascript\nclass RefImpl {\n    constructor(value, __v_isShallow) {\n        this.__v_isShallow = __v_isShallow;\n        this._rawValue = __v_isShallow ? value : toRaw(value);\n        this._value = __v_isShallow ? value : toReactive(value);\n    }\n\n    get value() {\n        trackRefValue(this); // 收集依赖\n        return this._value;\n    }\n\n    set value(newVal) {\n        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\n        newVal = useDirectValue ? newVal : toRaw(newVal);\n        if (hasChanged(newVal, this._rawValue)) {\n            this._rawValue = newVal;\n            this._value = useDirectValue ? newVal : toReactive(newVal);\n            triggerRefValue(this, DirtyLevels.Dirty, newVal); // 触发响应\n        }\n    }\n}\n```\n\n可以发现，**RefImpl**定义了**value gettter**用于依赖的收集，定义了**value setter**用于触发响应。如果你想了解**trackRefValue**、**triggerRefValue**做了些什么，可以查看我的文章[响应式原理：dep（响应式对象的依赖管理器）]\n\n","source":"_posts/源码/vue3/ref.md","raw":"---\ntitle: 响应式原理：响应式队形解析\n---\n\n### Ref\n\n源码中关于**ref**部分的定义：\n\n```javascript\nexport function ref(value) {\n    return createRef(value, false);\n}\n```\n\n这个函数的核心也就是通过**createRef**把我们传入的**value**变成响应式的\n\n```javascript\nfunction createRef(rawValue, shallow) {\n    if (isRef(rawValue)) {\n        return rawValue;\n    }\n\n    return new RefImpl(rawValue, shallow);\n}\n```\n\n先经过判断，判断符合要求的**value**才能被响应式。一起来看看这个**API**的实现：\n\n```javascript\nclass RefImpl {\n    constructor(value, __v_isShallow) {\n        this.__v_isShallow = __v_isShallow;\n        this._rawValue = __v_isShallow ? value : toRaw(value);\n        this._value = __v_isShallow ? value : toReactive(value);\n    }\n\n    get value() {\n        trackRefValue(this); // 收集依赖\n        return this._value;\n    }\n\n    set value(newVal) {\n        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\n        newVal = useDirectValue ? newVal : toRaw(newVal);\n        if (hasChanged(newVal, this._rawValue)) {\n            this._rawValue = newVal;\n            this._value = useDirectValue ? newVal : toReactive(newVal);\n            triggerRefValue(this, DirtyLevels.Dirty, newVal); // 触发响应\n        }\n    }\n}\n```\n\n可以发现，**RefImpl**定义了**value gettter**用于依赖的收集，定义了**value setter**用于触发响应。如果你想了解**trackRefValue**、**triggerRefValue**做了些什么，可以查看我的文章[响应式原理：dep（响应式对象的依赖管理器）]\n\n","slug":"源码/vue3/ref","published":1,"date":"2024-03-22T12:33:24.547Z","updated":"2024-04-03T09:45:03.405Z","_id":"cluct10td0003tsgmeasae3w9","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h3><p>源码中关于<strong>ref</strong>部分的定义：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">ref</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">createRef</span>(value, <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数的核心也就是通过<strong>createRef</strong>把我们传入的<strong>value</strong>变成响应式的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createRef</span>(<span class=\"params\">rawValue, shallow</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title function_\">isRef</span>(rawValue)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rawValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RefImpl</span>(rawValue, shallow);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先经过判断，判断符合要求的<strong>value</strong>才能被响应式。一起来看看这个<strong>API</strong>的实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RefImpl</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">value, __v_isShallow</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">__v_isShallow</span> = __v_isShallow;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_rawValue</span> = __v_isShallow ? value : <span class=\"title function_\">toRaw</span>(value);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_value</span> = __v_isShallow ? value : <span class=\"title function_\">toReactive</span>(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">        <span class=\"title function_\">trackRefValue</span>(<span class=\"variable language_\">this</span>); <span class=\"comment\">// 收集依赖</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_value</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title function_\">value</span>(<span class=\"params\">newVal</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> useDirectValue = <span class=\"variable language_\">this</span>.<span class=\"property\">__v_isShallow</span> || <span class=\"title function_\">isShallow</span>(newVal) || <span class=\"title function_\">isReadonly</span>(newVal);</span><br><span class=\"line\">        newVal = useDirectValue ? newVal : <span class=\"title function_\">toRaw</span>(newVal);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title function_\">hasChanged</span>(newVal, <span class=\"variable language_\">this</span>.<span class=\"property\">_rawValue</span>)) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">_rawValue</span> = newVal;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">_value</span> = useDirectValue ? newVal : <span class=\"title function_\">toReactive</span>(newVal);</span><br><span class=\"line\">            <span class=\"title function_\">triggerRefValue</span>(<span class=\"variable language_\">this</span>, <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">Dirty</span>, newVal); <span class=\"comment\">// 触发响应</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现，<strong>RefImpl</strong>定义了<strong>value gettter</strong>用于依赖的收集，定义了<strong>value setter</strong>用于触发响应。如果你想了解<strong>trackRefValue</strong>、<strong>triggerRefValue</strong>做了些什么，可以查看我的文章[响应式原理：dep（响应式对象的依赖管理器）]</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":"<h3 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h3><p>源码中关于<strong>ref</strong>部分的定义：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">ref</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">createRef</span>(value, <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数的核心也就是通过<strong>createRef</strong>把我们传入的<strong>value</strong>变成响应式的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createRef</span>(<span class=\"params\">rawValue, shallow</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title function_\">isRef</span>(rawValue)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rawValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RefImpl</span>(rawValue, shallow);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先经过判断，判断符合要求的<strong>value</strong>才能被响应式。一起来看看这个<strong>API</strong>的实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RefImpl</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">value, __v_isShallow</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">__v_isShallow</span> = __v_isShallow;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_rawValue</span> = __v_isShallow ? value : <span class=\"title function_\">toRaw</span>(value);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_value</span> = __v_isShallow ? value : <span class=\"title function_\">toReactive</span>(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">        <span class=\"title function_\">trackRefValue</span>(<span class=\"variable language_\">this</span>); <span class=\"comment\">// 收集依赖</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_value</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title function_\">value</span>(<span class=\"params\">newVal</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> useDirectValue = <span class=\"variable language_\">this</span>.<span class=\"property\">__v_isShallow</span> || <span class=\"title function_\">isShallow</span>(newVal) || <span class=\"title function_\">isReadonly</span>(newVal);</span><br><span class=\"line\">        newVal = useDirectValue ? newVal : <span class=\"title function_\">toRaw</span>(newVal);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title function_\">hasChanged</span>(newVal, <span class=\"variable language_\">this</span>.<span class=\"property\">_rawValue</span>)) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">_rawValue</span> = newVal;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">_value</span> = useDirectValue ? newVal : <span class=\"title function_\">toReactive</span>(newVal);</span><br><span class=\"line\">            <span class=\"title function_\">triggerRefValue</span>(<span class=\"variable language_\">this</span>, <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">Dirty</span>, newVal); <span class=\"comment\">// 触发响应</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现，<strong>RefImpl</strong>定义了<strong>value gettter</strong>用于依赖的收集，定义了<strong>value setter</strong>用于触发响应。如果你想了解<strong>trackRefValue</strong>、<strong>triggerRefValue</strong>做了些什么，可以查看我的文章[响应式原理：dep（响应式对象的依赖管理器）]</p>\n"},{"title":"vue2中nextTick的实现","_content":"\n```javascript\nconst inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';\nconst nextTick = (function () {\n    let callbacks = [];\n    let pendding = false;\n    let timeFunc;\n    function nextTickHandler() {\n        pendding = false;\n        const copies = callbacks.slice(0);\n        callbacks = [];\n        for (let i = 0; i < copies.length; i++) {\n            copies[i]();\n        }\n    }\n\n    if (typeof MutationObserver === 'undefined') { // cb同步执行\n        let counter = 1;\n        const observer = new MutationObserver(nextTickHandler)\n        const textNode = document.createTextNode(String(counter));\n        observer.observe(textNode, {\n            characterData: true,\n        });\n        timeFunc = function () {\n            counter = (counter + 1) % 2;\n            textNode.data = String(counter);\n        }\n    } else { // cb同步执行\n        const context = inBrowser ? window : typeof global !== 'undefined' ? global : {};\n        timeFunc = context.setImmediate || setTimeout;\n    }\n\n    return function(cb, ctx) {\n        const func = ctx ? function() {cb.call(ctx);} : cb;\n        callbacks.push(func);\n\n        if(pendding) return;\n        \n        pendding = true;\n        timeFunc(nextTickHandler, 0)\n    }\n})()\n```","source":"_posts/源码/vue2/vue2_nextTeck.md","raw":"---\ntitle: vue2中nextTick的实现\n---\n\n```javascript\nconst inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';\nconst nextTick = (function () {\n    let callbacks = [];\n    let pendding = false;\n    let timeFunc;\n    function nextTickHandler() {\n        pendding = false;\n        const copies = callbacks.slice(0);\n        callbacks = [];\n        for (let i = 0; i < copies.length; i++) {\n            copies[i]();\n        }\n    }\n\n    if (typeof MutationObserver === 'undefined') { // cb同步执行\n        let counter = 1;\n        const observer = new MutationObserver(nextTickHandler)\n        const textNode = document.createTextNode(String(counter));\n        observer.observe(textNode, {\n            characterData: true,\n        });\n        timeFunc = function () {\n            counter = (counter + 1) % 2;\n            textNode.data = String(counter);\n        }\n    } else { // cb同步执行\n        const context = inBrowser ? window : typeof global !== 'undefined' ? global : {};\n        timeFunc = context.setImmediate || setTimeout;\n    }\n\n    return function(cb, ctx) {\n        const func = ctx ? function() {cb.call(ctx);} : cb;\n        callbacks.push(func);\n\n        if(pendding) return;\n        \n        pendding = true;\n        timeFunc(nextTickHandler, 0)\n    }\n})()\n```","slug":"源码/vue2/vue2_nextTeck","published":1,"date":"2024-03-21T12:56:44.097Z","updated":"2024-03-29T15:13:35.007Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cluct10td0004tsgmdndq13k8","content":"<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> inBrowser = <span class=\"keyword\">typeof</span> <span class=\"variable language_\">window</span> !== <span class=\"string\">&#x27;undefined&#x27;</span> &amp;&amp; <span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">window</span>) !== <span class=\"string\">&#x27;[object Object]&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> nextTick = (<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> callbacks = [];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pendding = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timeFunc;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">nextTickHandler</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        pendding = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> copies = callbacks.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        callbacks = [];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; copies.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">            copies[i]();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"title class_\">MutationObserver</span> === <span class=\"string\">&#x27;undefined&#x27;</span>) &#123; <span class=\"comment\">// cb同步执行</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> counter = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> observer = <span class=\"keyword\">new</span> <span class=\"title class_\">MutationObserver</span>(nextTickHandler)</span><br><span class=\"line\">        <span class=\"keyword\">const</span> textNode = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createTextNode</span>(<span class=\"title class_\">String</span>(counter));</span><br><span class=\"line\">        observer.<span class=\"title function_\">observe</span>(textNode, &#123;</span><br><span class=\"line\">            <span class=\"attr\">characterData</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        timeFunc = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            counter = (counter + <span class=\"number\">1</span>) % <span class=\"number\">2</span>;</span><br><span class=\"line\">            textNode.<span class=\"property\">data</span> = <span class=\"title class_\">String</span>(counter);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// cb同步执行</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> context = inBrowser ? <span class=\"variable language_\">window</span> : <span class=\"keyword\">typeof</span> <span class=\"variable language_\">global</span> !== <span class=\"string\">&#x27;undefined&#x27;</span> ? <span class=\"variable language_\">global</span> : &#123;&#125;;</span><br><span class=\"line\">        timeFunc = context.<span class=\"property\">setImmediate</span> || <span class=\"built_in\">setTimeout</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\">cb, ctx</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> func = ctx ? <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;cb.<span class=\"title function_\">call</span>(ctx);&#125; : cb;</span><br><span class=\"line\">        callbacks.<span class=\"title function_\">push</span>(func);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pendding) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        pendding = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"title function_\">timeFunc</span>(nextTickHandler, <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#e7817c","excerpt":"","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> inBrowser = <span class=\"keyword\">typeof</span> <span class=\"variable language_\">window</span> !== <span class=\"string\">&#x27;undefined&#x27;</span> &amp;&amp; <span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">window</span>) !== <span class=\"string\">&#x27;[object Object]&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> nextTick = (<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> callbacks = [];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pendding = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timeFunc;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">nextTickHandler</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        pendding = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> copies = callbacks.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        callbacks = [];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; copies.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">            copies[i]();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"title class_\">MutationObserver</span> === <span class=\"string\">&#x27;undefined&#x27;</span>) &#123; <span class=\"comment\">// cb同步执行</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> counter = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> observer = <span class=\"keyword\">new</span> <span class=\"title class_\">MutationObserver</span>(nextTickHandler)</span><br><span class=\"line\">        <span class=\"keyword\">const</span> textNode = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createTextNode</span>(<span class=\"title class_\">String</span>(counter));</span><br><span class=\"line\">        observer.<span class=\"title function_\">observe</span>(textNode, &#123;</span><br><span class=\"line\">            <span class=\"attr\">characterData</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        timeFunc = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            counter = (counter + <span class=\"number\">1</span>) % <span class=\"number\">2</span>;</span><br><span class=\"line\">            textNode.<span class=\"property\">data</span> = <span class=\"title class_\">String</span>(counter);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// cb同步执行</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> context = inBrowser ? <span class=\"variable language_\">window</span> : <span class=\"keyword\">typeof</span> <span class=\"variable language_\">global</span> !== <span class=\"string\">&#x27;undefined&#x27;</span> ? <span class=\"variable language_\">global</span> : &#123;&#125;;</span><br><span class=\"line\">        timeFunc = context.<span class=\"property\">setImmediate</span> || <span class=\"built_in\">setTimeout</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\">cb, ctx</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> func = ctx ? <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;cb.<span class=\"title function_\">call</span>(ctx);&#125; : cb;</span><br><span class=\"line\">        callbacks.<span class=\"title function_\">push</span>(func);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pendding) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        pendding = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"title function_\">timeFunc</span>(nextTickHandler, <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>"},{"title":"渲染器：数组节点中的Dom Diff","_content":"\n在前端开发中，我们经常需要处理包含数组子节点的动态列表或复杂组件。本文将基于源码，梳理数组子节点的Diff更新流程，帮助读者更好地理解Vue3是如何通过Diff算法来高效地更新这些子节点，以提升应用性能。\n\n### 从头对比\n\n```javascript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    let i = 0; // 当前对比索引\n    const l2 = c2.length; // 新节点长度\n    let e1 = c1.length - 1; // 旧节点结束标识\n    let e2 = l2 - 1; // 新节点介绍标识\n\n    // 1. 头对比\n    // (a b) c\n    // (a b) d e\n    while (i < e1 && i < e2) {\n        const n1 = c1[i];\n        const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n        if (isSameVNodeType(n1, n2)) {\n            patch(n1, n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)\n        } else {\n            break;\n        }\n        i++;\n    }\n}\n```\n\n### 从尾部对比\n\n```javascript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    let i = 0; // 当前对比索引\n    const l2 = c2.length; // 新节点长度\n    let e1 = c1.length - 1; // 旧节点结束标识\n    let e2 = l2 - 1; // 新节点介绍标识\n\n    // 1. 头对比\n    // ...\n\n    // 2. 尾对比\n    // a (b c)\n    // d e (b c)\n    while (i < e1 && i < e2) {\n        const n1 = c1[e1];\n        const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);\n        if (isSameVNodeType(n1, n2)) {\n            patch(n1, n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)\n        } else {\n            break;\n        }\n        e1--;\n        e2--;\n    }\n}\n```\n\n### 仅处理新增\n\n```javascript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    let i = 0; // 当前对比索引\n    const l2 = c2.length; // 新节点长度\n    let e1 = c1.length - 1; // 旧节点结束标识\n    let e2 = l2 - 1; // 新节点介绍标识\n\n    // 1. 头对比\n    //  ...\n    // 2. 从尾部对比\n    // ...\n\n    // 3. 仅新增\n    // (a b)\n    // (a b) c\n    // i = 2, e1 = 1, e2 = 2\n    // (a b)\n    // c (a b)\n    // i = 0, e1 = -1, e2 = 0\n    if (i > e1) {\n        if (i <= e2) {\n            const nextPos = e2 + 1;\n            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\n\n            while (i <= e2) {\n                patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense)\n                i++;\n            }\n        }\n    } \n}\n```\n\n### 仅处理卸载\n\n```javascript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    let i = 0; // 当前对比索引\n    const l2 = c2.length; // 新节点长度\n    let e1 = c1.length - 1; // 旧节点结束标识\n    let e2 = l2 - 1; // 新节点介绍标识\n\n    // 1. 头对比\n    //  ...\n    // 2. 从尾部对比\n    // ...\n    // 3. 仅新增\n    if(i > e1) { // ...} \n\n    // 4. 仅卸载\n    // (a b) c\n    // (a b)\n    // i = 2, e1 = 2, e2 = 1\n    // a (b c)\n    // (b c)\n    // i = 0, e1 = 0, e2 = -1\n    else if (i > e2) {\n        while (i <= e1) {\n            unmount(c1[i], parentComponent, parentAnchor, true);\n            i++;\n        }\n    }\n}\n```\n\n### 处理未知序列\n\n#### 构建新节点key到index的映射\n\n```javascript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    let i = 0; // 当前对比索引\n    const l2 = c2.length; // 新节点长度\n    let e1 = c1.length - 1; // 旧节点结束标识\n    let e2 = l2 - 1; // 新节点介绍标识\n\n    // 1. 头对比\n    //  ...\n    // 2. 从尾部对比\n    // ...\n    // 3. 仅新增\n    if(i > e1) { // ...} \n    // 4. 仅卸载\n    else if (i > e2) { // ... }\n\n    else {\n        const s1 = i; // 旧节点开始处理索引\n        const s2 = i; // 新节点开始处理索引\n\n        // 5.1 构建新节点key到index的映射\n        const keyToNewIndexMap = new Map();\n        for (i = s2; i <= e2; i++) {\n            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n\n            if (nextChild.key != null) {\n                keyToNewIndexMap.set(nextChild.key, i);\n            }\n        }\n    }\n}\n```\n\n#### 5.2 处理旧节点（更新和卸载）\n\n```javascript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    let i = 0; // 当前对比索引\n    const l2 = c2.length; // 新节点长度\n    let e1 = c1.length - 1; // 旧节点结束标识\n    let e2 = l2 - 1; // 新节点介绍标识\n\n    // 1. 头对比\n    //  ...\n    // 2. 从尾部对比\n    // ...\n    // 3. 仅新增\n    if(i > e1) { // ...} \n    // 4. 仅卸载\n    else if (i > e2) { // ... }\n\n    else {\n        const s1 = i; // 旧节点开始处理索引\n        const s2 = i; // 新节点开始处理索引\n\n        // 5.1 构建新节点key到index的映射\n        // ...\n\n        // 5.2 处理旧节点（更新和卸载）\n        let patched = 0; // 已处理的数目\n        const toBePatched = e2 - s2 + 1; // 需要处理的数目\n        let moved = false; // 标记节点是否移动\n        let maxNewIndexSoFar = 0; // 辅助判断节点是否移动\n        const newIndexToOldIndexMap = new Array(toBePatched);\n        for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;\n\n        for (i = s1; i <= e1; i++) {\n            const prevChild = e1[i];\n\n            if (patched >= toBePatched) { // 卸载多余节点\n                unmount(prevChild, parentComponent, parentSuspense, true);\n                continue;\n            }\n\n            let nextIndex;\n            newIndex = keyToNewIndexMap.get(prevChild.key);\n            if (newIndex === undefined) { // 新节点找不到则卸载\n                unmount(prevChild, parentComponent, parentAnchor, true);\n            } else {\n                newIndexToOldIndexMap[newIndex - s2] = i + 1;\n                if (newIndex >= maxNewIndexSoFar) {\n                    maxNewIndexSoFar = newIndex;\n                } else {\n                    moved = true;\n                }\n                patch(prevChild, c2[newIndex], null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)\n                patched++;\n            }\n        } \n    }\n}\n```\n\n#### 5.3 移动和新增\n\n```javascript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    let i = 0; // 当前对比索引\n    const l2 = c2.length; // 新节点长度\n    let e1 = c1.length - 1; // 旧节点结束标识\n    let e2 = l2 - 1; // 新节点介绍标识\n\n    // 1. 头对比\n    //  ...\n    // 2. 从尾部对比\n    // ...\n    // 3. 仅新增\n    if(i > e1) { // ...} \n    // 4. 仅卸载\n    else if (i > e2) { // ... }\n\n    else {\n        const s1 = i; // 旧节点开始处理索引\n        const s2 = i; // 新节点开始处理索引\n\n        // 5.1 构建新节点key到index的映射\n        // ...\n        // 5.2 处理旧节点（更新和卸载）\n        // ...\n\n        // 5.3 移动和新增\n        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;\n        let j = increasingNewIndexSequence.length - 1;\n\n        for (i = toBePatched - 1; i >= 0; i--) {\n            const nextIndex = s2 + i;\n            const nextChild = c2[nextIndex];\n            const anchor = nextIndex + 1 < l2 ? c2[nextIndex].el : parentAnchor;\n\n            if (newIndexToOldIndexMap[i] === 0) {\n                patch(null, nextChild, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);\n            } else if (moved) {\n                if (j < 0 || i !== increasingNewIndexSequence[j]) {\n                    moved(nextChild, container, anchor, MoveType.REORDER);\n                } else {\n                    j--;\n                }\n            }\n        }\n}\n```\n\n#### 优化思考\n\n- 唯一标识: 我们使用 v-for 编写列表时为什么不建议使用 index 作为 key?\n\n\n\n### 总结\n\n希望本文能够帮助读者深入理解基于数组子节点的Diff更新流程，并在实际项目中应用这一知识，提升应用的性能和用户体验","source":"_posts/源码/vue3/vue3_dom_diff.md","raw":"---\ntitle: 渲染器：数组节点中的Dom diff\n---\n\n在前端开发中，我们经常需要处理包含数组子节点的动态列表或复杂组件。本文将基于源码，梳理数组子节点的Diff更新流程，帮助读者更好地理解Vue3是如何通过Diff算法来高效地更新这些子节点，以提升应用性能。\n\n### 从头对比\n\n```javascript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    let i = 0; // 当前对比索引\n    const l2 = c2.length; // 新节点长度\n    let e1 = c1.length - 1; // 旧节点结束标识\n    let e2 = l2 - 1; // 新节点介绍标识\n\n    // 1. 头对比\n    // (a b) c\n    // (a b) d e\n    while (i < e1 && i < e2) {\n        const n1 = c1[i];\n        const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n        if (isSameVNodeType(n1, n2)) {\n            patch(n1, n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)\n        } else {\n            break;\n        }\n        i++;\n    }\n}\n```\n\n### 从尾部对比\n\n```javascript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    let i = 0; // 当前对比索引\n    const l2 = c2.length; // 新节点长度\n    let e1 = c1.length - 1; // 旧节点结束标识\n    let e2 = l2 - 1; // 新节点介绍标识\n\n    // 1. 头对比\n    // ...\n\n    // 2. 尾对比\n    // a (b c)\n    // d e (b c)\n    while (i < e1 && i < e2) {\n        const n1 = c1[e1];\n        const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);\n        if (isSameVNodeType(n1, n2)) {\n            patch(n1, n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)\n        } else {\n            break;\n        }\n        e1--;\n        e2--;\n    }\n}\n```\n\n### 仅处理新增\n\n```javascript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    let i = 0; // 当前对比索引\n    const l2 = c2.length; // 新节点长度\n    let e1 = c1.length - 1; // 旧节点结束标识\n    let e2 = l2 - 1; // 新节点介绍标识\n\n    // 1. 头对比\n    //  ...\n    // 2. 从尾部对比\n    // ...\n\n    // 3. 仅新增\n    // (a b)\n    // (a b) c\n    // i = 2, e1 = 1, e2 = 2\n    // (a b)\n    // c (a b)\n    // i = 0, e1 = -1, e2 = 0\n    if (i > e1) {\n        if (i <= e2) {\n            const nextPos = e2 + 1;\n            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\n\n            while (i <= e2) {\n                patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense)\n                i++;\n            }\n        }\n    } \n}\n```\n\n### 仅处理卸载\n\n```javascript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    let i = 0; // 当前对比索引\n    const l2 = c2.length; // 新节点长度\n    let e1 = c1.length - 1; // 旧节点结束标识\n    let e2 = l2 - 1; // 新节点介绍标识\n\n    // 1. 头对比\n    //  ...\n    // 2. 从尾部对比\n    // ...\n    // 3. 仅新增\n    if(i > e1) { // ...} \n\n    // 4. 仅卸载\n    // (a b) c\n    // (a b)\n    // i = 2, e1 = 2, e2 = 1\n    // a (b c)\n    // (b c)\n    // i = 0, e1 = 0, e2 = -1\n    else if (i > e2) {\n        while (i <= e1) {\n            unmount(c1[i], parentComponent, parentAnchor, true);\n            i++;\n        }\n    }\n}\n```\n\n### 处理未知序列\n\n#### 构建新节点key到index的映射\n\n```javascript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    let i = 0; // 当前对比索引\n    const l2 = c2.length; // 新节点长度\n    let e1 = c1.length - 1; // 旧节点结束标识\n    let e2 = l2 - 1; // 新节点介绍标识\n\n    // 1. 头对比\n    //  ...\n    // 2. 从尾部对比\n    // ...\n    // 3. 仅新增\n    if(i > e1) { // ...} \n    // 4. 仅卸载\n    else if (i > e2) { // ... }\n\n    else {\n        const s1 = i; // 旧节点开始处理索引\n        const s2 = i; // 新节点开始处理索引\n\n        // 5.1 构建新节点key到index的映射\n        const keyToNewIndexMap = new Map();\n        for (i = s2; i <= e2; i++) {\n            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n\n            if (nextChild.key != null) {\n                keyToNewIndexMap.set(nextChild.key, i);\n            }\n        }\n    }\n}\n```\n\n#### 5.2 处理旧节点（更新和卸载）\n\n```javascript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    let i = 0; // 当前对比索引\n    const l2 = c2.length; // 新节点长度\n    let e1 = c1.length - 1; // 旧节点结束标识\n    let e2 = l2 - 1; // 新节点介绍标识\n\n    // 1. 头对比\n    //  ...\n    // 2. 从尾部对比\n    // ...\n    // 3. 仅新增\n    if(i > e1) { // ...} \n    // 4. 仅卸载\n    else if (i > e2) { // ... }\n\n    else {\n        const s1 = i; // 旧节点开始处理索引\n        const s2 = i; // 新节点开始处理索引\n\n        // 5.1 构建新节点key到index的映射\n        // ...\n\n        // 5.2 处理旧节点（更新和卸载）\n        let patched = 0; // 已处理的数目\n        const toBePatched = e2 - s2 + 1; // 需要处理的数目\n        let moved = false; // 标记节点是否移动\n        let maxNewIndexSoFar = 0; // 辅助判断节点是否移动\n        const newIndexToOldIndexMap = new Array(toBePatched);\n        for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;\n\n        for (i = s1; i <= e1; i++) {\n            const prevChild = e1[i];\n\n            if (patched >= toBePatched) { // 卸载多余节点\n                unmount(prevChild, parentComponent, parentSuspense, true);\n                continue;\n            }\n\n            let nextIndex;\n            newIndex = keyToNewIndexMap.get(prevChild.key);\n            if (newIndex === undefined) { // 新节点找不到则卸载\n                unmount(prevChild, parentComponent, parentAnchor, true);\n            } else {\n                newIndexToOldIndexMap[newIndex - s2] = i + 1;\n                if (newIndex >= maxNewIndexSoFar) {\n                    maxNewIndexSoFar = newIndex;\n                } else {\n                    moved = true;\n                }\n                patch(prevChild, c2[newIndex], null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)\n                patched++;\n            }\n        } \n    }\n}\n```\n\n#### 5.3 移动和新增\n\n```javascript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    let i = 0; // 当前对比索引\n    const l2 = c2.length; // 新节点长度\n    let e1 = c1.length - 1; // 旧节点结束标识\n    let e2 = l2 - 1; // 新节点介绍标识\n\n    // 1. 头对比\n    //  ...\n    // 2. 从尾部对比\n    // ...\n    // 3. 仅新增\n    if(i > e1) { // ...} \n    // 4. 仅卸载\n    else if (i > e2) { // ... }\n\n    else {\n        const s1 = i; // 旧节点开始处理索引\n        const s2 = i; // 新节点开始处理索引\n\n        // 5.1 构建新节点key到index的映射\n        // ...\n        // 5.2 处理旧节点（更新和卸载）\n        // ...\n\n        // 5.3 移动和新增\n        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;\n        let j = increasingNewIndexSequence.length - 1;\n\n        for (i = toBePatched - 1; i >= 0; i--) {\n            const nextIndex = s2 + i;\n            const nextChild = c2[nextIndex];\n            const anchor = nextIndex + 1 < l2 ? c2[nextIndex].el : parentAnchor;\n\n            if (newIndexToOldIndexMap[i] === 0) {\n                patch(null, nextChild, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);\n            } else if (moved) {\n                if (j < 0 || i !== increasingNewIndexSequence[j]) {\n                    moved(nextChild, container, anchor, MoveType.REORDER);\n                } else {\n                    j--;\n                }\n            }\n        }\n}\n```\n\n#### 优化思考\n\n- 唯一标识: 我们使用 v-for 编写列表时为什么不建议使用 index 作为 key?\n\n\n\n### 总结\n\n希望本文能够帮助读者深入理解基于数组子节点的Diff更新流程，并在实际项目中应用这一知识，提升应用的性能和用户体验","slug":"源码/vue3/vue3_dom_diff","published":1,"date":"2024-03-22T08:43:51.154Z","updated":"2024-04-01T11:52:13.246Z","_id":"cluct10te0005tsgm2ez84ctu","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在前端开发中，我们经常需要处理包含数组子节点的动态列表或复杂组件。本文将基于源码，梳理数组子节点的Diff更新流程，帮助读者更好地理解Vue3是如何通过Diff算法来高效地更新这些子节点，以提升应用性能。</p>\n<h3 id=\"从头对比\"><a href=\"#从头对比\" class=\"headerlink\" title=\"从头对比\"></a>从头对比</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchKeyedChildren</span> = (<span class=\"params\">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// 当前对比索引</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l2 = c2.<span class=\"property\">length</span>; <span class=\"comment\">// 新节点长度</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e1 = c1.<span class=\"property\">length</span> - <span class=\"number\">1</span>; <span class=\"comment\">// 旧节点结束标识</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e2 = l2 - <span class=\"number\">1</span>; <span class=\"comment\">// 新节点介绍标识</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1. 头对比</span></span><br><span class=\"line\">    <span class=\"comment\">// (a b) c</span></span><br><span class=\"line\">    <span class=\"comment\">// (a b) d e</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; e1 &amp;&amp; i &lt; e2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> n1 = c1[i];</span><br><span class=\"line\">        <span class=\"keyword\">const</span> n2 = c2[i] = optimized ? <span class=\"title function_\">cloneIfMounted</span>(c2[i]) : <span class=\"title function_\">normalizeVNode</span>(c2[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title function_\">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">patch</span>(n1, n2, container, <span class=\"literal\">null</span>, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"从尾部对比\"><a href=\"#从尾部对比\" class=\"headerlink\" title=\"从尾部对比\"></a>从尾部对比</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchKeyedChildren</span> = (<span class=\"params\">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// 当前对比索引</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l2 = c2.<span class=\"property\">length</span>; <span class=\"comment\">// 新节点长度</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e1 = c1.<span class=\"property\">length</span> - <span class=\"number\">1</span>; <span class=\"comment\">// 旧节点结束标识</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e2 = l2 - <span class=\"number\">1</span>; <span class=\"comment\">// 新节点介绍标识</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1. 头对比</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 尾对比</span></span><br><span class=\"line\">    <span class=\"comment\">// a (b c)</span></span><br><span class=\"line\">    <span class=\"comment\">// d e (b c)</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; e1 &amp;&amp; i &lt; e2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> n1 = c1[e1];</span><br><span class=\"line\">        <span class=\"keyword\">const</span> n2 = c2[e2] = optimized ? <span class=\"title function_\">cloneIfMounted</span>(c2[e2]) : <span class=\"title function_\">normalizeVNode</span>(c2[e2]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title function_\">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">patch</span>(n1, n2, container, <span class=\"literal\">null</span>, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        e1--;</span><br><span class=\"line\">        e2--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"仅处理新增\"><a href=\"#仅处理新增\" class=\"headerlink\" title=\"仅处理新增\"></a>仅处理新增</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchKeyedChildren</span> = (<span class=\"params\">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// 当前对比索引</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l2 = c2.<span class=\"property\">length</span>; <span class=\"comment\">// 新节点长度</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e1 = c1.<span class=\"property\">length</span> - <span class=\"number\">1</span>; <span class=\"comment\">// 旧节点结束标识</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e2 = l2 - <span class=\"number\">1</span>; <span class=\"comment\">// 新节点介绍标识</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1. 头对比</span></span><br><span class=\"line\">    <span class=\"comment\">//  ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 从尾部对比</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. 仅新增</span></span><br><span class=\"line\">    <span class=\"comment\">// (a b)</span></span><br><span class=\"line\">    <span class=\"comment\">// (a b) c</span></span><br><span class=\"line\">    <span class=\"comment\">// i = 2, e1 = 1, e2 = 2</span></span><br><span class=\"line\">    <span class=\"comment\">// (a b)</span></span><br><span class=\"line\">    <span class=\"comment\">// c (a b)</span></span><br><span class=\"line\">    <span class=\"comment\">// i = 0, e1 = -1, e2 = 0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt; e1) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt;= e2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> nextPos = e2 + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> anchor = nextPos &lt; l2 ? c2[nextPos].<span class=\"property\">el</span> : parentAnchor;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt;= e2) &#123;</span><br><span class=\"line\">                <span class=\"title function_\">patch</span>(<span class=\"literal\">null</span>, c2[i] = optimized ? <span class=\"title function_\">cloneIfMounted</span>(c2[i]) : <span class=\"title function_\">normalizeVNode</span>(c2[i]), container, anchor, parentComponent, parentSuspense)</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"仅处理卸载\"><a href=\"#仅处理卸载\" class=\"headerlink\" title=\"仅处理卸载\"></a>仅处理卸载</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchKeyedChildren</span> = (<span class=\"params\">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// 当前对比索引</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l2 = c2.<span class=\"property\">length</span>; <span class=\"comment\">// 新节点长度</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e1 = c1.<span class=\"property\">length</span> - <span class=\"number\">1</span>; <span class=\"comment\">// 旧节点结束标识</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e2 = l2 - <span class=\"number\">1</span>; <span class=\"comment\">// 新节点介绍标识</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1. 头对比</span></span><br><span class=\"line\">    <span class=\"comment\">//  ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 从尾部对比</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 3. 仅新增</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &gt; e1) &#123; <span class=\"comment\">// ...&#125; </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4. 仅卸载</span></span><br><span class=\"line\">    <span class=\"comment\">// (a b) c</span></span><br><span class=\"line\">    <span class=\"comment\">// (a b)</span></span><br><span class=\"line\">    <span class=\"comment\">// i = 2, e1 = 2, e2 = 1</span></span><br><span class=\"line\">    <span class=\"comment\">// a (b c)</span></span><br><span class=\"line\">    <span class=\"comment\">// (b c)</span></span><br><span class=\"line\">    <span class=\"comment\">// i = 0, e1 = 0, e2 = -1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &gt; e2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt;= e1) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">unmount</span>(c1[i], parentComponent, parentAnchor, <span class=\"literal\">true</span>);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"处理未知序列\"><a href=\"#处理未知序列\" class=\"headerlink\" title=\"处理未知序列\"></a>处理未知序列</h3><h4 id=\"构建新节点key到index的映射\"><a href=\"#构建新节点key到index的映射\" class=\"headerlink\" title=\"构建新节点key到index的映射\"></a>构建新节点key到index的映射</h4><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchKeyedChildren</span> = (<span class=\"params\">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// 当前对比索引</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l2 = c2.<span class=\"property\">length</span>; <span class=\"comment\">// 新节点长度</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e1 = c1.<span class=\"property\">length</span> - <span class=\"number\">1</span>; <span class=\"comment\">// 旧节点结束标识</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e2 = l2 - <span class=\"number\">1</span>; <span class=\"comment\">// 新节点介绍标识</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1. 头对比</span></span><br><span class=\"line\">    <span class=\"comment\">//  ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 从尾部对比</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 3. 仅新增</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &gt; e1) &#123; <span class=\"comment\">// ...&#125; </span></span><br><span class=\"line\">    <span class=\"comment\">// 4. 仅卸载</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &gt; e2) &#123; <span class=\"comment\">// ... &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> s1 = i; <span class=\"comment\">// 旧节点开始处理索引</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> s2 = i; <span class=\"comment\">// 新节点开始处理索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 5.1 构建新节点key到index的映射</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> keyToNewIndexMap = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = s2; i &lt;= e2; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> nextChild = c2[i] = optimized ? <span class=\"title function_\">cloneIfMounted</span>(c2[i]) : <span class=\"title function_\">normalizeVNode</span>(c2[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextChild.<span class=\"property\">key</span> != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                keyToNewIndexMap.<span class=\"title function_\">set</span>(nextChild.<span class=\"property\">key</span>, i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-处理旧节点（更新和卸载）\"><a href=\"#5-2-处理旧节点（更新和卸载）\" class=\"headerlink\" title=\"5.2 处理旧节点（更新和卸载）\"></a>5.2 处理旧节点（更新和卸载）</h4><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchKeyedChildren</span> = (<span class=\"params\">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// 当前对比索引</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l2 = c2.<span class=\"property\">length</span>; <span class=\"comment\">// 新节点长度</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e1 = c1.<span class=\"property\">length</span> - <span class=\"number\">1</span>; <span class=\"comment\">// 旧节点结束标识</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e2 = l2 - <span class=\"number\">1</span>; <span class=\"comment\">// 新节点介绍标识</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1. 头对比</span></span><br><span class=\"line\">    <span class=\"comment\">//  ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 从尾部对比</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 3. 仅新增</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &gt; e1) &#123; <span class=\"comment\">// ...&#125; </span></span><br><span class=\"line\">    <span class=\"comment\">// 4. 仅卸载</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &gt; e2) &#123; <span class=\"comment\">// ... &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> s1 = i; <span class=\"comment\">// 旧节点开始处理索引</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> s2 = i; <span class=\"comment\">// 新节点开始处理索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 5.1 构建新节点key到index的映射</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 5.2 处理旧节点（更新和卸载）</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> patched = <span class=\"number\">0</span>; <span class=\"comment\">// 已处理的数目</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> toBePatched = e2 - s2 + <span class=\"number\">1</span>; <span class=\"comment\">// 需要处理的数目</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> moved = <span class=\"literal\">false</span>; <span class=\"comment\">// 标记节点是否移动</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> maxNewIndexSoFar = <span class=\"number\">0</span>; <span class=\"comment\">// 辅助判断节点是否移动</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> newIndexToOldIndexMap = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(toBePatched);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = s1; i &lt;= e1; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> prevChild = e1[i];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (patched &gt;= toBePatched) &#123; <span class=\"comment\">// 卸载多余节点</span></span><br><span class=\"line\">                <span class=\"title function_\">unmount</span>(prevChild, parentComponent, parentSuspense, <span class=\"literal\">true</span>);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">let</span> nextIndex;</span><br><span class=\"line\">            newIndex = keyToNewIndexMap.<span class=\"title function_\">get</span>(prevChild.<span class=\"property\">key</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newIndex === <span class=\"literal\">undefined</span>) &#123; <span class=\"comment\">// 新节点找不到则卸载</span></span><br><span class=\"line\">                <span class=\"title function_\">unmount</span>(prevChild, parentComponent, parentAnchor, <span class=\"literal\">true</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                newIndexToOldIndexMap[newIndex - s2] = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class=\"line\">                    maxNewIndexSoFar = newIndex;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    moved = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"title function_\">patch</span>(prevChild, c2[newIndex], <span class=\"literal\">null</span>, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)</span><br><span class=\"line\">                patched++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-3-移动和新增\"><a href=\"#5-3-移动和新增\" class=\"headerlink\" title=\"5.3 移动和新增\"></a>5.3 移动和新增</h4><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchKeyedChildren</span> = (<span class=\"params\">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// 当前对比索引</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l2 = c2.<span class=\"property\">length</span>; <span class=\"comment\">// 新节点长度</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e1 = c1.<span class=\"property\">length</span> - <span class=\"number\">1</span>; <span class=\"comment\">// 旧节点结束标识</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e2 = l2 - <span class=\"number\">1</span>; <span class=\"comment\">// 新节点介绍标识</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1. 头对比</span></span><br><span class=\"line\">    <span class=\"comment\">//  ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 从尾部对比</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 3. 仅新增</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &gt; e1) &#123; <span class=\"comment\">// ...&#125; </span></span><br><span class=\"line\">    <span class=\"comment\">// 4. 仅卸载</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &gt; e2) &#123; <span class=\"comment\">// ... &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> s1 = i; <span class=\"comment\">// 旧节点开始处理索引</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> s2 = i; <span class=\"comment\">// 新节点开始处理索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 5.1 构建新节点key到index的映射</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"comment\">// 5.2 处理旧节点（更新和卸载）</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 5.3 移动和新增</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> increasingNewIndexSequence = moved ? <span class=\"title function_\">getSequence</span>(newIndexToOldIndexMap) : <span class=\"variable constant_\">EMPTY_ARR</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> j = increasingNewIndexSequence.<span class=\"property\">length</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = toBePatched - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> nextIndex = s2 + i;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> nextChild = c2[nextIndex];</span><br><span class=\"line\">            <span class=\"keyword\">const</span> anchor = nextIndex + <span class=\"number\">1</span> &lt; l2 ? c2[nextIndex].<span class=\"property\">el</span> : parentAnchor;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newIndexToOldIndexMap[i] === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"title function_\">patch</span>(<span class=\"literal\">null</span>, nextChild, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (moved) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j &lt; <span class=\"number\">0</span> || i !== increasingNewIndexSequence[j]) &#123;</span><br><span class=\"line\">                    <span class=\"title function_\">moved</span>(nextChild, container, anchor, <span class=\"title class_\">MoveType</span>.<span class=\"property\">REORDER</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    j--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"优化思考\"><a href=\"#优化思考\" class=\"headerlink\" title=\"优化思考\"></a>优化思考</h4><ul>\n<li>唯一标识: 我们使用 v-for 编写列表时为什么不建议使用 index 作为 key?</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>希望本文能够帮助读者深入理解基于数组子节点的Diff更新流程，并在实际项目中应用这一知识，提升应用的性能和用户体验</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":"<p>在前端开发中，我们经常需要处理包含数组子节点的动态列表或复杂组件。本文将基于源码，梳理数组子节点的Diff更新流程，帮助读者更好地理解Vue3是如何通过Diff算法来高效地更新这些子节点，以提升应用性能。</p>\n<h3 id=\"从头对比\"><a href=\"#从头对比\" class=\"headerlink\" title=\"从头对比\"></a>从头对比</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchKeyedChildren</span> = (<span class=\"params\">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// 当前对比索引</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l2 = c2.<span class=\"property\">length</span>; <span class=\"comment\">// 新节点长度</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e1 = c1.<span class=\"property\">length</span> - <span class=\"number\">1</span>; <span class=\"comment\">// 旧节点结束标识</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e2 = l2 - <span class=\"number\">1</span>; <span class=\"comment\">// 新节点介绍标识</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1. 头对比</span></span><br><span class=\"line\">    <span class=\"comment\">// (a b) c</span></span><br><span class=\"line\">    <span class=\"comment\">// (a b) d e</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; e1 &amp;&amp; i &lt; e2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> n1 = c1[i];</span><br><span class=\"line\">        <span class=\"keyword\">const</span> n2 = c2[i] = optimized ? <span class=\"title function_\">cloneIfMounted</span>(c2[i]) : <span class=\"title function_\">normalizeVNode</span>(c2[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title function_\">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">patch</span>(n1, n2, container, <span class=\"literal\">null</span>, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"从尾部对比\"><a href=\"#从尾部对比\" class=\"headerlink\" title=\"从尾部对比\"></a>从尾部对比</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchKeyedChildren</span> = (<span class=\"params\">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// 当前对比索引</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l2 = c2.<span class=\"property\">length</span>; <span class=\"comment\">// 新节点长度</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e1 = c1.<span class=\"property\">length</span> - <span class=\"number\">1</span>; <span class=\"comment\">// 旧节点结束标识</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e2 = l2 - <span class=\"number\">1</span>; <span class=\"comment\">// 新节点介绍标识</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1. 头对比</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 尾对比</span></span><br><span class=\"line\">    <span class=\"comment\">// a (b c)</span></span><br><span class=\"line\">    <span class=\"comment\">// d e (b c)</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; e1 &amp;&amp; i &lt; e2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> n1 = c1[e1];</span><br><span class=\"line\">        <span class=\"keyword\">const</span> n2 = c2[e2] = optimized ? <span class=\"title function_\">cloneIfMounted</span>(c2[e2]) : <span class=\"title function_\">normalizeVNode</span>(c2[e2]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title function_\">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">patch</span>(n1, n2, container, <span class=\"literal\">null</span>, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        e1--;</span><br><span class=\"line\">        e2--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"仅处理新增\"><a href=\"#仅处理新增\" class=\"headerlink\" title=\"仅处理新增\"></a>仅处理新增</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchKeyedChildren</span> = (<span class=\"params\">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// 当前对比索引</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l2 = c2.<span class=\"property\">length</span>; <span class=\"comment\">// 新节点长度</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e1 = c1.<span class=\"property\">length</span> - <span class=\"number\">1</span>; <span class=\"comment\">// 旧节点结束标识</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e2 = l2 - <span class=\"number\">1</span>; <span class=\"comment\">// 新节点介绍标识</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1. 头对比</span></span><br><span class=\"line\">    <span class=\"comment\">//  ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 从尾部对比</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. 仅新增</span></span><br><span class=\"line\">    <span class=\"comment\">// (a b)</span></span><br><span class=\"line\">    <span class=\"comment\">// (a b) c</span></span><br><span class=\"line\">    <span class=\"comment\">// i = 2, e1 = 1, e2 = 2</span></span><br><span class=\"line\">    <span class=\"comment\">// (a b)</span></span><br><span class=\"line\">    <span class=\"comment\">// c (a b)</span></span><br><span class=\"line\">    <span class=\"comment\">// i = 0, e1 = -1, e2 = 0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt; e1) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt;= e2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> nextPos = e2 + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> anchor = nextPos &lt; l2 ? c2[nextPos].<span class=\"property\">el</span> : parentAnchor;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt;= e2) &#123;</span><br><span class=\"line\">                <span class=\"title function_\">patch</span>(<span class=\"literal\">null</span>, c2[i] = optimized ? <span class=\"title function_\">cloneIfMounted</span>(c2[i]) : <span class=\"title function_\">normalizeVNode</span>(c2[i]), container, anchor, parentComponent, parentSuspense)</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"仅处理卸载\"><a href=\"#仅处理卸载\" class=\"headerlink\" title=\"仅处理卸载\"></a>仅处理卸载</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchKeyedChildren</span> = (<span class=\"params\">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// 当前对比索引</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l2 = c2.<span class=\"property\">length</span>; <span class=\"comment\">// 新节点长度</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e1 = c1.<span class=\"property\">length</span> - <span class=\"number\">1</span>; <span class=\"comment\">// 旧节点结束标识</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e2 = l2 - <span class=\"number\">1</span>; <span class=\"comment\">// 新节点介绍标识</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1. 头对比</span></span><br><span class=\"line\">    <span class=\"comment\">//  ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 从尾部对比</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 3. 仅新增</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &gt; e1) &#123; <span class=\"comment\">// ...&#125; </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4. 仅卸载</span></span><br><span class=\"line\">    <span class=\"comment\">// (a b) c</span></span><br><span class=\"line\">    <span class=\"comment\">// (a b)</span></span><br><span class=\"line\">    <span class=\"comment\">// i = 2, e1 = 2, e2 = 1</span></span><br><span class=\"line\">    <span class=\"comment\">// a (b c)</span></span><br><span class=\"line\">    <span class=\"comment\">// (b c)</span></span><br><span class=\"line\">    <span class=\"comment\">// i = 0, e1 = 0, e2 = -1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &gt; e2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt;= e1) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">unmount</span>(c1[i], parentComponent, parentAnchor, <span class=\"literal\">true</span>);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"处理未知序列\"><a href=\"#处理未知序列\" class=\"headerlink\" title=\"处理未知序列\"></a>处理未知序列</h3><h4 id=\"构建新节点key到index的映射\"><a href=\"#构建新节点key到index的映射\" class=\"headerlink\" title=\"构建新节点key到index的映射\"></a>构建新节点key到index的映射</h4><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchKeyedChildren</span> = (<span class=\"params\">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// 当前对比索引</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l2 = c2.<span class=\"property\">length</span>; <span class=\"comment\">// 新节点长度</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e1 = c1.<span class=\"property\">length</span> - <span class=\"number\">1</span>; <span class=\"comment\">// 旧节点结束标识</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e2 = l2 - <span class=\"number\">1</span>; <span class=\"comment\">// 新节点介绍标识</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1. 头对比</span></span><br><span class=\"line\">    <span class=\"comment\">//  ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 从尾部对比</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 3. 仅新增</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &gt; e1) &#123; <span class=\"comment\">// ...&#125; </span></span><br><span class=\"line\">    <span class=\"comment\">// 4. 仅卸载</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &gt; e2) &#123; <span class=\"comment\">// ... &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> s1 = i; <span class=\"comment\">// 旧节点开始处理索引</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> s2 = i; <span class=\"comment\">// 新节点开始处理索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 5.1 构建新节点key到index的映射</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> keyToNewIndexMap = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = s2; i &lt;= e2; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> nextChild = c2[i] = optimized ? <span class=\"title function_\">cloneIfMounted</span>(c2[i]) : <span class=\"title function_\">normalizeVNode</span>(c2[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextChild.<span class=\"property\">key</span> != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                keyToNewIndexMap.<span class=\"title function_\">set</span>(nextChild.<span class=\"property\">key</span>, i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-处理旧节点（更新和卸载）\"><a href=\"#5-2-处理旧节点（更新和卸载）\" class=\"headerlink\" title=\"5.2 处理旧节点（更新和卸载）\"></a>5.2 处理旧节点（更新和卸载）</h4><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchKeyedChildren</span> = (<span class=\"params\">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// 当前对比索引</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l2 = c2.<span class=\"property\">length</span>; <span class=\"comment\">// 新节点长度</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e1 = c1.<span class=\"property\">length</span> - <span class=\"number\">1</span>; <span class=\"comment\">// 旧节点结束标识</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e2 = l2 - <span class=\"number\">1</span>; <span class=\"comment\">// 新节点介绍标识</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1. 头对比</span></span><br><span class=\"line\">    <span class=\"comment\">//  ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 从尾部对比</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 3. 仅新增</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &gt; e1) &#123; <span class=\"comment\">// ...&#125; </span></span><br><span class=\"line\">    <span class=\"comment\">// 4. 仅卸载</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &gt; e2) &#123; <span class=\"comment\">// ... &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> s1 = i; <span class=\"comment\">// 旧节点开始处理索引</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> s2 = i; <span class=\"comment\">// 新节点开始处理索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 5.1 构建新节点key到index的映射</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 5.2 处理旧节点（更新和卸载）</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> patched = <span class=\"number\">0</span>; <span class=\"comment\">// 已处理的数目</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> toBePatched = e2 - s2 + <span class=\"number\">1</span>; <span class=\"comment\">// 需要处理的数目</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> moved = <span class=\"literal\">false</span>; <span class=\"comment\">// 标记节点是否移动</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> maxNewIndexSoFar = <span class=\"number\">0</span>; <span class=\"comment\">// 辅助判断节点是否移动</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> newIndexToOldIndexMap = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(toBePatched);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = s1; i &lt;= e1; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> prevChild = e1[i];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (patched &gt;= toBePatched) &#123; <span class=\"comment\">// 卸载多余节点</span></span><br><span class=\"line\">                <span class=\"title function_\">unmount</span>(prevChild, parentComponent, parentSuspense, <span class=\"literal\">true</span>);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">let</span> nextIndex;</span><br><span class=\"line\">            newIndex = keyToNewIndexMap.<span class=\"title function_\">get</span>(prevChild.<span class=\"property\">key</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newIndex === <span class=\"literal\">undefined</span>) &#123; <span class=\"comment\">// 新节点找不到则卸载</span></span><br><span class=\"line\">                <span class=\"title function_\">unmount</span>(prevChild, parentComponent, parentAnchor, <span class=\"literal\">true</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                newIndexToOldIndexMap[newIndex - s2] = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class=\"line\">                    maxNewIndexSoFar = newIndex;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    moved = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"title function_\">patch</span>(prevChild, c2[newIndex], <span class=\"literal\">null</span>, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)</span><br><span class=\"line\">                patched++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-3-移动和新增\"><a href=\"#5-3-移动和新增\" class=\"headerlink\" title=\"5.3 移动和新增\"></a>5.3 移动和新增</h4><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">patchKeyedChildren</span> = (<span class=\"params\">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// 当前对比索引</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l2 = c2.<span class=\"property\">length</span>; <span class=\"comment\">// 新节点长度</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e1 = c1.<span class=\"property\">length</span> - <span class=\"number\">1</span>; <span class=\"comment\">// 旧节点结束标识</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> e2 = l2 - <span class=\"number\">1</span>; <span class=\"comment\">// 新节点介绍标识</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1. 头对比</span></span><br><span class=\"line\">    <span class=\"comment\">//  ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 从尾部对比</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 3. 仅新增</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &gt; e1) &#123; <span class=\"comment\">// ...&#125; </span></span><br><span class=\"line\">    <span class=\"comment\">// 4. 仅卸载</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &gt; e2) &#123; <span class=\"comment\">// ... &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> s1 = i; <span class=\"comment\">// 旧节点开始处理索引</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> s2 = i; <span class=\"comment\">// 新节点开始处理索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 5.1 构建新节点key到index的映射</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"comment\">// 5.2 处理旧节点（更新和卸载）</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 5.3 移动和新增</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> increasingNewIndexSequence = moved ? <span class=\"title function_\">getSequence</span>(newIndexToOldIndexMap) : <span class=\"variable constant_\">EMPTY_ARR</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> j = increasingNewIndexSequence.<span class=\"property\">length</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = toBePatched - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> nextIndex = s2 + i;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> nextChild = c2[nextIndex];</span><br><span class=\"line\">            <span class=\"keyword\">const</span> anchor = nextIndex + <span class=\"number\">1</span> &lt; l2 ? c2[nextIndex].<span class=\"property\">el</span> : parentAnchor;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newIndexToOldIndexMap[i] === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"title function_\">patch</span>(<span class=\"literal\">null</span>, nextChild, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (moved) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j &lt; <span class=\"number\">0</span> || i !== increasingNewIndexSequence[j]) &#123;</span><br><span class=\"line\">                    <span class=\"title function_\">moved</span>(nextChild, container, anchor, <span class=\"title class_\">MoveType</span>.<span class=\"property\">REORDER</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    j--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"优化思考\"><a href=\"#优化思考\" class=\"headerlink\" title=\"优化思考\"></a>优化思考</h4><ul>\n<li>唯一标识: 我们使用 v-for 编写列表时为什么不建议使用 index 作为 key?</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>希望本文能够帮助读者深入理解基于数组子节点的Diff更新流程，并在实际项目中应用这一知识，提升应用的性能和用户体验</p>\n"},{"title":"Vue3中中获取最长递增子序列","_content":"\n```javascript\nfunction getSequence(arr) {\n    const p = arr.slice(); // 反向链表 可以使用 p = []初始化\n    const result = [0] // 结果值到原数组索引的映射\n    let i, j, u, v, c;\n    const len = arr.length;\n    for (i = 0; i < len; i++) {\n        const arrI = arr[i];\n        if (arrI !== 0) {\n            j = result[result.length - 1]\n            if (arr[j] < arrI) { // 与最后一项对比\n                p[i] = j;\n                result.push(i);\n                continue\n            }\n\n            u = 0;\n            v = result.length - 1;\n            while (u < v) { // 二分查找\n                c = (u + v) >> 1;\n                if (arr[result[c]] < arrI) {\n                    u = c + 1\n                } else {\n                    v = c\n                }\n            }\n            if (arrI < arr[result[u]]) {\n                if (u > 0) {\n                    p[i] = result[u - 1]\n                }\n                result[u] = i\n            }\n        }\n    }\n\n    // 回溯修正\n    u = result.length\n    v = result[u - 1]\n    while (u-- > 0) {\n        result[u] = v\n        v = p[v]\n    }\n    return result\n}\n```","source":"_posts/源码/vue3/最长递增子序列.md","raw":"---\ntitle: vue3中中获取最长递增子序列\n---\n\n```javascript\nfunction getSequence(arr) {\n    const p = arr.slice(); // 反向链表 可以使用 p = []初始化\n    const result = [0] // 结果值到原数组索引的映射\n    let i, j, u, v, c;\n    const len = arr.length;\n    for (i = 0; i < len; i++) {\n        const arrI = arr[i];\n        if (arrI !== 0) {\n            j = result[result.length - 1]\n            if (arr[j] < arrI) { // 与最后一项对比\n                p[i] = j;\n                result.push(i);\n                continue\n            }\n\n            u = 0;\n            v = result.length - 1;\n            while (u < v) { // 二分查找\n                c = (u + v) >> 1;\n                if (arr[result[c]] < arrI) {\n                    u = c + 1\n                } else {\n                    v = c\n                }\n            }\n            if (arrI < arr[result[u]]) {\n                if (u > 0) {\n                    p[i] = result[u - 1]\n                }\n                result[u] = i\n            }\n        }\n    }\n\n    // 回溯修正\n    u = result.length\n    v = result[u - 1]\n    while (u-- > 0) {\n        result[u] = v\n        v = p[v]\n    }\n    return result\n}\n```","slug":"源码/vue3/最长递增子序列","published":1,"date":"2024-03-22T11:17:15.570Z","updated":"2024-03-29T15:16:48.013Z","_id":"cluct10te0006tsgmd2e5fo9x","comments":1,"layout":"post","photos":[],"link":"","content":"<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getSequence</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> p = arr.<span class=\"title function_\">slice</span>(); <span class=\"comment\">// 反向链表 可以使用 p = []初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = [<span class=\"number\">0</span>] <span class=\"comment\">// 结果值到原数组索引的映射</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> i, j, u, v, c;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = arr.<span class=\"property\">length</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> arrI = arr[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arrI !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            j = result[result.<span class=\"property\">length</span> - <span class=\"number\">1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &lt; arrI) &#123; <span class=\"comment\">// 与最后一项对比</span></span><br><span class=\"line\">                p[i] = j;</span><br><span class=\"line\">                result.<span class=\"title function_\">push</span>(i);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            u = <span class=\"number\">0</span>;</span><br><span class=\"line\">            v = result.<span class=\"property\">length</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (u &lt; v) &#123; <span class=\"comment\">// 二分查找</span></span><br><span class=\"line\">                c = (u + v) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (arr[result[c]] &lt; arrI) &#123;</span><br><span class=\"line\">                    u = c + <span class=\"number\">1</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    v = c</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arrI &lt; arr[result[u]]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (u &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    p[i] = result[u - <span class=\"number\">1</span>]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                result[u] = i</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 回溯修正</span></span><br><span class=\"line\">    u = result.<span class=\"property\">length</span></span><br><span class=\"line\">    v = result[u - <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (u-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        result[u] = v</span><br><span class=\"line\">        v = p[v]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getSequence</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> p = arr.<span class=\"title function_\">slice</span>(); <span class=\"comment\">// 反向链表 可以使用 p = []初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = [<span class=\"number\">0</span>] <span class=\"comment\">// 结果值到原数组索引的映射</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> i, j, u, v, c;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = arr.<span class=\"property\">length</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> arrI = arr[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arrI !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            j = result[result.<span class=\"property\">length</span> - <span class=\"number\">1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &lt; arrI) &#123; <span class=\"comment\">// 与最后一项对比</span></span><br><span class=\"line\">                p[i] = j;</span><br><span class=\"line\">                result.<span class=\"title function_\">push</span>(i);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            u = <span class=\"number\">0</span>;</span><br><span class=\"line\">            v = result.<span class=\"property\">length</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (u &lt; v) &#123; <span class=\"comment\">// 二分查找</span></span><br><span class=\"line\">                c = (u + v) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (arr[result[c]] &lt; arrI) &#123;</span><br><span class=\"line\">                    u = c + <span class=\"number\">1</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    v = c</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arrI &lt; arr[result[u]]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (u &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    p[i] = result[u - <span class=\"number\">1</span>]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                result[u] = i</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 回溯修正</span></span><br><span class=\"line\">    u = result.<span class=\"property\">length</span></span><br><span class=\"line\">    v = result[u - <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (u-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        result[u] = v</span><br><span class=\"line\">        v = p[v]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"深入解析学习源码的好处：提升技能与洞察力的关键路径","_content":"\n### 引言：\n对于软件开发者而言，学习和理解开源库或框架的源代码是提升技能和洞察力的重要路径之一。通过深入解析源码，开发者可以获得更深入的理解、发现隐藏的细节和原理，并且能够应用这些知识来解决实际问题。本文将探究学习源码的好处，为开发者们展示为何深入源码是提升技能和开拓思维的关键步骤。\n\n一、深入理解库或框架的设计原理\n通过学习源码，开发者可以深入理解库或框架的设计原理。源码是开发者们思考和设计的产物，通过阅读源码，我们能够了解作者的意图、核心思想以及设计决策的背后原因。这种深入理解使开发者能够更好地使用和扩展这些开源工具，从而提高代码质量和效率。\n\n二、探索高效的算法和数据结构实现\n源码通常包含了高效的算法和数据结构实现。通过学习源码，开发者可以了解到作者在设计过程中所使用的算法和数据结构，并从中学习到优化性能、提高代码效率的技巧。这对于开发高性能应用和解决复杂问题至关重要。\n\n三、发现隐藏的细节和技巧\n源码中往往包含了许多细微而重要的细节和技巧。通过学习源码，开发者可以发现这些隐藏的细节，了解作者是如何处理边缘情况、优雅地解决问题以及实现功能的。这些细节和技巧对于开发者来说是宝贵的经验，能够帮助他们更好地编写可靠、高效的代码。\n\n四、解决实际问题和调试能力提升\n学习源码不仅帮助开发者理解库或框架的内部工作原理，还能够帮助他们解决实际问题。通过深入学习源码，开发者可以更好地理解代码执行的流程和逻辑，从而更轻松地进行调试和排查故障。这种调试能力的提升对于开发者在日常工作中的问题定位和解决至关重要。\n\n五、拓宽思维和创新能力\n学习源码能够拓宽开发者的思维，激发创新能力。通过深入理解他人的设计和实现，开发者可以学习到不同的思考方式和解决问题的思路，从而拓展自己的思维边界。这种跨界的思维碰撞能够激发创新灵感，让开发者在实际项目中提供更加独特和优秀的解决方案。\n\n结论：\n学习源码是提升技能和洞察力的关键路径之一。通过深入理解库或框架的设计原理、探索高效的算法和数据结构实现、发现隐藏的细节和技巧，开发者能够提升自己的编码能力、解决问题的能力和调试技巧。此外，学习源码还能够拓宽思维、激发创新能力，使开发者在实际项目中提供更加优秀和独特的解决方案。因此，鼓励开发者们积极投入学习源码的过程，不断提升自己的技术水平和思维能力，为软件开发领域的进步做出贡献。","source":"_drafts/学习源码.md","raw":"---\ntitle: 深入解析学习源码的好处：提升技能与洞察力的关键路径\n---\n\n### 引言：\n对于软件开发者而言，学习和理解开源库或框架的源代码是提升技能和洞察力的重要路径之一。通过深入解析源码，开发者可以获得更深入的理解、发现隐藏的细节和原理，并且能够应用这些知识来解决实际问题。本文将探究学习源码的好处，为开发者们展示为何深入源码是提升技能和开拓思维的关键步骤。\n\n一、深入理解库或框架的设计原理\n通过学习源码，开发者可以深入理解库或框架的设计原理。源码是开发者们思考和设计的产物，通过阅读源码，我们能够了解作者的意图、核心思想以及设计决策的背后原因。这种深入理解使开发者能够更好地使用和扩展这些开源工具，从而提高代码质量和效率。\n\n二、探索高效的算法和数据结构实现\n源码通常包含了高效的算法和数据结构实现。通过学习源码，开发者可以了解到作者在设计过程中所使用的算法和数据结构，并从中学习到优化性能、提高代码效率的技巧。这对于开发高性能应用和解决复杂问题至关重要。\n\n三、发现隐藏的细节和技巧\n源码中往往包含了许多细微而重要的细节和技巧。通过学习源码，开发者可以发现这些隐藏的细节，了解作者是如何处理边缘情况、优雅地解决问题以及实现功能的。这些细节和技巧对于开发者来说是宝贵的经验，能够帮助他们更好地编写可靠、高效的代码。\n\n四、解决实际问题和调试能力提升\n学习源码不仅帮助开发者理解库或框架的内部工作原理，还能够帮助他们解决实际问题。通过深入学习源码，开发者可以更好地理解代码执行的流程和逻辑，从而更轻松地进行调试和排查故障。这种调试能力的提升对于开发者在日常工作中的问题定位和解决至关重要。\n\n五、拓宽思维和创新能力\n学习源码能够拓宽开发者的思维，激发创新能力。通过深入理解他人的设计和实现，开发者可以学习到不同的思考方式和解决问题的思路，从而拓展自己的思维边界。这种跨界的思维碰撞能够激发创新灵感，让开发者在实际项目中提供更加独特和优秀的解决方案。\n\n结论：\n学习源码是提升技能和洞察力的关键路径之一。通过深入理解库或框架的设计原理、探索高效的算法和数据结构实现、发现隐藏的细节和技巧，开发者能够提升自己的编码能力、解决问题的能力和调试技巧。此外，学习源码还能够拓宽思维、激发创新能力，使开发者在实际项目中提供更加优秀和独特的解决方案。因此，鼓励开发者们积极投入学习源码的过程，不断提升自己的技术水平和思维能力，为软件开发领域的进步做出贡献。","slug":"学习源码","published":0,"date":"2024-03-30T00:44:22.228Z","updated":"2024-03-30T00:45:12.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cludenfjz0000s4gmgsft46g8","content":"<h3 id=\"引言：\"><a href=\"#引言：\" class=\"headerlink\" title=\"引言：\"></a>引言：</h3><p>对于软件开发者而言，学习和理解开源库或框架的源代码是提升技能和洞察力的重要路径之一。通过深入解析源码，开发者可以获得更深入的理解、发现隐藏的细节和原理，并且能够应用这些知识来解决实际问题。本文将探究学习源码的好处，为开发者们展示为何深入源码是提升技能和开拓思维的关键步骤。</p>\n<p>一、深入理解库或框架的设计原理<br>通过学习源码，开发者可以深入理解库或框架的设计原理。源码是开发者们思考和设计的产物，通过阅读源码，我们能够了解作者的意图、核心思想以及设计决策的背后原因。这种深入理解使开发者能够更好地使用和扩展这些开源工具，从而提高代码质量和效率。</p>\n<p>二、探索高效的算法和数据结构实现<br>源码通常包含了高效的算法和数据结构实现。通过学习源码，开发者可以了解到作者在设计过程中所使用的算法和数据结构，并从中学习到优化性能、提高代码效率的技巧。这对于开发高性能应用和解决复杂问题至关重要。</p>\n<p>三、发现隐藏的细节和技巧<br>源码中往往包含了许多细微而重要的细节和技巧。通过学习源码，开发者可以发现这些隐藏的细节，了解作者是如何处理边缘情况、优雅地解决问题以及实现功能的。这些细节和技巧对于开发者来说是宝贵的经验，能够帮助他们更好地编写可靠、高效的代码。</p>\n<p>四、解决实际问题和调试能力提升<br>学习源码不仅帮助开发者理解库或框架的内部工作原理，还能够帮助他们解决实际问题。通过深入学习源码，开发者可以更好地理解代码执行的流程和逻辑，从而更轻松地进行调试和排查故障。这种调试能力的提升对于开发者在日常工作中的问题定位和解决至关重要。</p>\n<p>五、拓宽思维和创新能力<br>学习源码能够拓宽开发者的思维，激发创新能力。通过深入理解他人的设计和实现，开发者可以学习到不同的思考方式和解决问题的思路，从而拓展自己的思维边界。这种跨界的思维碰撞能够激发创新灵感，让开发者在实际项目中提供更加独特和优秀的解决方案。</p>\n<p>结论：<br>学习源码是提升技能和洞察力的关键路径之一。通过深入理解库或框架的设计原理、探索高效的算法和数据结构实现、发现隐藏的细节和技巧，开发者能够提升自己的编码能力、解决问题的能力和调试技巧。此外，学习源码还能够拓宽思维、激发创新能力，使开发者在实际项目中提供更加优秀和独特的解决方案。因此，鼓励开发者们积极投入学习源码的过程，不断提升自己的技术水平和思维能力，为软件开发领域的进步做出贡献。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":"<h3 id=\"引言：\"><a href=\"#引言：\" class=\"headerlink\" title=\"引言：\"></a>引言：</h3><p>对于软件开发者而言，学习和理解开源库或框架的源代码是提升技能和洞察力的重要路径之一。通过深入解析源码，开发者可以获得更深入的理解、发现隐藏的细节和原理，并且能够应用这些知识来解决实际问题。本文将探究学习源码的好处，为开发者们展示为何深入源码是提升技能和开拓思维的关键步骤。</p>\n<p>一、深入理解库或框架的设计原理<br>通过学习源码，开发者可以深入理解库或框架的设计原理。源码是开发者们思考和设计的产物，通过阅读源码，我们能够了解作者的意图、核心思想以及设计决策的背后原因。这种深入理解使开发者能够更好地使用和扩展这些开源工具，从而提高代码质量和效率。</p>\n<p>二、探索高效的算法和数据结构实现<br>源码通常包含了高效的算法和数据结构实现。通过学习源码，开发者可以了解到作者在设计过程中所使用的算法和数据结构，并从中学习到优化性能、提高代码效率的技巧。这对于开发高性能应用和解决复杂问题至关重要。</p>\n<p>三、发现隐藏的细节和技巧<br>源码中往往包含了许多细微而重要的细节和技巧。通过学习源码，开发者可以发现这些隐藏的细节，了解作者是如何处理边缘情况、优雅地解决问题以及实现功能的。这些细节和技巧对于开发者来说是宝贵的经验，能够帮助他们更好地编写可靠、高效的代码。</p>\n<p>四、解决实际问题和调试能力提升<br>学习源码不仅帮助开发者理解库或框架的内部工作原理，还能够帮助他们解决实际问题。通过深入学习源码，开发者可以更好地理解代码执行的流程和逻辑，从而更轻松地进行调试和排查故障。这种调试能力的提升对于开发者在日常工作中的问题定位和解决至关重要。</p>\n<p>五、拓宽思维和创新能力<br>学习源码能够拓宽开发者的思维，激发创新能力。通过深入理解他人的设计和实现，开发者可以学习到不同的思考方式和解决问题的思路，从而拓展自己的思维边界。这种跨界的思维碰撞能够激发创新灵感，让开发者在实际项目中提供更加独特和优秀的解决方案。</p>\n<p>结论：<br>学习源码是提升技能和洞察力的关键路径之一。通过深入理解库或框架的设计原理、探索高效的算法和数据结构实现、发现隐藏的细节和技巧，开发者能够提升自己的编码能力、解决问题的能力和调试技巧。此外，学习源码还能够拓宽思维、激发创新能力，使开发者在实际项目中提供更加优秀和独特的解决方案。因此，鼓励开发者们积极投入学习源码的过程，不断提升自己的技术水平和思维能力，为软件开发领域的进步做出贡献。</p>\n"},{"title":"响应式原理：Reactive对象解析","_content":"\n### reactive\n\n源码中关于**Reactive**部分的定义：\n\n```javascript\nexport function reactive(target) {\n    if(isReadonly(target)) {\n        return target;\n    }\n\n    return createReactiveObject(\n        target, \n        false, \n        mutableHandlers, \n        mutableCollectionHandlers, \n        reactiveMap\n    );\n}\n```\n\n这个函数核心也就是通过**createReactiveObject**把我们传入的**target**变成响应式的\n\n```javascript\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n    if(!isObject(target)) {\n        return target;\n    }\n\n    if(target[ReactiveFlags.RAW] && !(isReadonly && target[ReactiveFlags.IS_REACTIVE])) {\n        return target;\n    }\n\n    const existingProxy = proxyMap.get(target);\n    if(existingProxy) {\n        return existingProxy;\n    }\n\n    const targetType = getTargetType(target);\n    if(targetType === TargetType.INVALID) {\n        return target;\n    }\n\n    const proxy = new Proxy(\n        target, \n        targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers\n    );\n    proxyMap.set(target, proxy);\n\n    return proxy;\n}\n```\n\n上述代码核心流程就是首先经过一系列判断，判断符合要求的**target**才能被响应式。包括target的类型、是否是响应式、是否已经被定义过了、是否是符合要求的类型。最后执行**new Proxy**对target进行代理, 其核心是处理器。我们先来看一下是定义了几种处理器，以及如何确认处理器的类型的\n\n```javascript\nfunction targetType(rawType) {\n    switch (rawType) {\n        case 'Object':\n        case 'Array':\n            return TargetType.COMMON;\n        case 'Map':\n        case 'Set':\n        case 'WeakMap':\n        case 'WeakSet':\n            return TargetType.COLLECTION;\n        default:\n            return TargetType.INVALID;\n    }\n}\n\nfunction getTargetType(value) {\n    return value[ReactiveFlags.SKIP] || !Object.isExtensible(value) ? TargetType.INVALID : targetType(toRawType(value));\n}\nexport const toRawType = (value) => {\n  // toTypeString 转换成字符串的方式，比如 \"[object RawType]\"\n  return toTypeString(value).slice(8, -1)\n}\n```\n\n因为**target**传入进来的是一个**Object**，所以**toRawType**得到的值是**Object**。所以这里的值等于**TargetType.Common**也就是使用**baseHandlers**。若传入进来的是**Map**、**Set**、**WeakMap**、**WeakSet**类型，则使用**collectionHandlers**，本章不进行展开**collectionHandlers**的解析。\n\n接下来看一下**baseHandlers**的实现：\n```javascript\nexport const mutableHandlers = {\n    get,\n    set,\n    deleteProperty,\n    has,\n    ownKeys,\n}\n```\n\n这里就是**Proxy**中的定义**handler**的一些属性\n\n- get：属性读取操作的捕捉器。\n- set：属性设置操作的捕捉器。\n- deleteProperty： delete操作符的捕捉器。\n- has：in操作符的捕捉器。\n- ownKeys：Object.getOwnPropertyNames方法和Object.getOwnPropertySymbols方法的捕捉器。\n\n**reactive**对象响应式的核心就在**set**和**get**中，我们一起来看一下二者的实现\n\n#### get\n\nget的源码实现\n```javascript\nclass BaseReactiveHandler {\n    constructor(_isReadonly = false, _isShallow = false) {\n        this._isReadonly = isReadonly;\n        this._isShallow = _isShallow;\n    }\n\n    get(target, key, receiver) {\n        const isReadonly = this._isReadonly;\n        const isShallow = this._isShallow;\n\n        // 对 ReactiveFlags 的处理部分\n        if (key === ReactiveFlags.IS_REACTIVE) {\n            return !isReadonly;\n        } else if (key === ReactiveFlags.IS_READONLY) {\n            return isReadonly;\n        } else if (key === ReactiveFlags.IS_SHALLOW) {\n            return isShallow;\n        } else if (key === ReactiveFlags.RAW) {\n            if (\n                receiver ===\n                (isReadonly\n                    ? isShallow\n                        ? shallowReadonlyMap\n                        : readonlyMap\n                    : isShallow\n                        ? shallowReactiveMap\n                        : reactiveMap\n                ).get(target) ||\n                Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)\n            ) {\n                return target;\n            }\n\n            return;\n        }\n\n        const targetIsArray = isArray(target);\n\n        if (!isReadonly) {\n            // 过滤数组变异方法\n            if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\n                return Reflect.get(Instrumentations, key, receiver);\n            }\n\n            if (key === 'hasOwnProperty') {\n                return hasOwnProperty;\n            }\n        }\n\n        const res = Reflect.get(target, key, receiver);\n\n        // 过滤 Symbol Key 和 一些不收集依赖的键\n        if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n            return res;\n        }\n\n        if (!isReadonly) {\n            track(target, TrackOpTypes.Get, key);\n        }\n\n        if (isShallow) {\n            return res;\n        }\n\n        if (isRef(res)) { // 不太清楚\n            return targetIsArray && isIntegerKey(key) ? res : res.value;\n        }\n\n        if (isObject(res)) {\n            return isReadonly ? readonly(res) : reactive(res);\n        }\n\n        return res;\n    }\n}\n```\n**get api**核心流程就是首先经过一系列判断, 判断符合要求的**key**才进行依赖收集, 然后根据对不同的类型进行处理返回。不收集依赖的key包括预设属性、symbol类型的自有属性。\n\n当我们的**target**是数组，且**key**值存在**arraInstrumentations**中时，返回**arraInstrumentations**中对应的**key**值。我们再来看看**arraInstrumentations**是个什么：\n\n```javascript\nconst arrayInstrumentations = createArrayInstrumentations()\n\nfunction createArrayInstrumentations() {\n    const instrumentations = {};\n    (['includes', 'indexOf', 'lastIndexOf']).forEach(key => {\n        instrumentations[key] = function (this, ...args) {\n            // toRaw 可以把响应式对象转成原始数据\n            const arr = toRaw(this)\n\n            for (let i = 0, l = this.length; i < l; i++) {\n                // 对数组的每一项进行依赖收集\n                track(arr, TrackOpTypes.GET, i + '')\n            }\n            // 先尝试用参数本身，可能是响应式数据\n            const res = arr[key](...args)\n            if (res === -1 || res === false) {\n                // 如果失败，再尝试把参数转成原始数据\n                return arr[key](...args.map(toRaw))\n            } else {\n                return res\n            }\n        }\n    });\n\n    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\n        instrumentations[key] = function (this, ...args) {\n            pauseTracking()\n            const res = toRaw(this)[key].apply(this, args)\n            resetTracking()\n            return res\n        }\n    })\n    return instrumentations\n}\n```\n\n**arrayInstrumentations**会重写两类函数，一类是查询类函数：**inclues**、**indexOf**、**lastIndeOf**，代表对数组的读取操作。在这些函数中会执行**track**函数，对数组的索引进行依赖收集。\n\n另一类是修改类函数：**push**、**pop**、**shift**、**unshift**、**splice**，代表对数组的修改操作，在这些函数中暂停了全局的追踪功能，防止某些情况下导致死循环。\n\n如果你想了解**track**做了些什么，可以查看我的文章[响应式原理：dep（响应式对象的依赖管理器）]\n\n#### set\n\n上面说完了**get**的流程，我们了解一下依赖收集后的数据结构存储在了**targetMap**中，接下来我们接着看**set**的过程：\n\n```javascript\nclass MutableReactiveHandler extends BaseReactiveHandler {\n    constructor(isShallow = false) {\n        super(false, isShallow);\n    }\n\n    set(target, key, value, receiver) {\n        let oldValue = target[key];\n\n        // 对深层响应式，处理新旧值\n        if (!this._isShallow) {\n            const isOldValueReadonly = isReadonly(oldValue);\n\n            if (!isShallow(value) && !isReadonly(value)) {\n                oldValue = toRaw(oldValue);\n                value = toRaw(value);\n            }\n\n            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n                if (isOldValueReadonly) {\n                    return false;\n                } else {\n                    oldValue.value = value;\n                    return true;\n                }\n            }\n        }\n\n        // 判断是否为已有属性\n        const hadKey = \n            isArray(target) && isIntegerKey(key) \n                ? (Number(key) < target.length) \n                : hasOwn(target, key); \n        const result = Reflect.set(target, key, value, receiver);\n        if (target === toRaw(receiver)) {\n\n            // 触发响应\n            if (!hadKey) {\n                trigger(target, TriggerOpTypes.ADD, key, value);\n            } else if (hasChanged(value, oldValue)) {\n                trigger(target, TriggerOpTypes.SET, key, value, oldValue);\n            }\n        }\n\n        return result;\n    }\n}\n\n```\n\n可以看到**set**接口核心逻辑就是根据是否为渐层响应式来确认原始值和新值，这里默认不是浅层的响应式，所以会先把原始值和新值进行**toRaw**转换，然后通过**Reflect.set**设置值，最后通过**trigger**函数派发通知，并依据**key**是否存在于**target**来确认通知类型是**add**（新增）还是**set**（修改）。\n\n如果你想了解**trigger**做了些什么，可以查看我的文章[响应式原理：dep（响应式对象的依赖管理器）]","source":"_posts/源码/vue3/reactive.md","raw":"---\ntitle: 响应式原理：reactive对象解析\n---\n\n### reactive\n\n源码中关于**Reactive**部分的定义：\n\n```javascript\nexport function reactive(target) {\n    if(isReadonly(target)) {\n        return target;\n    }\n\n    return createReactiveObject(\n        target, \n        false, \n        mutableHandlers, \n        mutableCollectionHandlers, \n        reactiveMap\n    );\n}\n```\n\n这个函数核心也就是通过**createReactiveObject**把我们传入的**target**变成响应式的\n\n```javascript\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n    if(!isObject(target)) {\n        return target;\n    }\n\n    if(target[ReactiveFlags.RAW] && !(isReadonly && target[ReactiveFlags.IS_REACTIVE])) {\n        return target;\n    }\n\n    const existingProxy = proxyMap.get(target);\n    if(existingProxy) {\n        return existingProxy;\n    }\n\n    const targetType = getTargetType(target);\n    if(targetType === TargetType.INVALID) {\n        return target;\n    }\n\n    const proxy = new Proxy(\n        target, \n        targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers\n    );\n    proxyMap.set(target, proxy);\n\n    return proxy;\n}\n```\n\n上述代码核心流程就是首先经过一系列判断，判断符合要求的**target**才能被响应式。包括target的类型、是否是响应式、是否已经被定义过了、是否是符合要求的类型。最后执行**new Proxy**对target进行代理, 其核心是处理器。我们先来看一下是定义了几种处理器，以及如何确认处理器的类型的\n\n```javascript\nfunction targetType(rawType) {\n    switch (rawType) {\n        case 'Object':\n        case 'Array':\n            return TargetType.COMMON;\n        case 'Map':\n        case 'Set':\n        case 'WeakMap':\n        case 'WeakSet':\n            return TargetType.COLLECTION;\n        default:\n            return TargetType.INVALID;\n    }\n}\n\nfunction getTargetType(value) {\n    return value[ReactiveFlags.SKIP] || !Object.isExtensible(value) ? TargetType.INVALID : targetType(toRawType(value));\n}\nexport const toRawType = (value) => {\n  // toTypeString 转换成字符串的方式，比如 \"[object RawType]\"\n  return toTypeString(value).slice(8, -1)\n}\n```\n\n因为**target**传入进来的是一个**Object**，所以**toRawType**得到的值是**Object**。所以这里的值等于**TargetType.Common**也就是使用**baseHandlers**。若传入进来的是**Map**、**Set**、**WeakMap**、**WeakSet**类型，则使用**collectionHandlers**，本章不进行展开**collectionHandlers**的解析。\n\n接下来看一下**baseHandlers**的实现：\n```javascript\nexport const mutableHandlers = {\n    get,\n    set,\n    deleteProperty,\n    has,\n    ownKeys,\n}\n```\n\n这里就是**Proxy**中的定义**handler**的一些属性\n\n- get：属性读取操作的捕捉器。\n- set：属性设置操作的捕捉器。\n- deleteProperty： delete操作符的捕捉器。\n- has：in操作符的捕捉器。\n- ownKeys：Object.getOwnPropertyNames方法和Object.getOwnPropertySymbols方法的捕捉器。\n\n**reactive**对象响应式的核心就在**set**和**get**中，我们一起来看一下二者的实现\n\n#### get\n\nget的源码实现\n```javascript\nclass BaseReactiveHandler {\n    constructor(_isReadonly = false, _isShallow = false) {\n        this._isReadonly = isReadonly;\n        this._isShallow = _isShallow;\n    }\n\n    get(target, key, receiver) {\n        const isReadonly = this._isReadonly;\n        const isShallow = this._isShallow;\n\n        // 对 ReactiveFlags 的处理部分\n        if (key === ReactiveFlags.IS_REACTIVE) {\n            return !isReadonly;\n        } else if (key === ReactiveFlags.IS_READONLY) {\n            return isReadonly;\n        } else if (key === ReactiveFlags.IS_SHALLOW) {\n            return isShallow;\n        } else if (key === ReactiveFlags.RAW) {\n            if (\n                receiver ===\n                (isReadonly\n                    ? isShallow\n                        ? shallowReadonlyMap\n                        : readonlyMap\n                    : isShallow\n                        ? shallowReactiveMap\n                        : reactiveMap\n                ).get(target) ||\n                Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)\n            ) {\n                return target;\n            }\n\n            return;\n        }\n\n        const targetIsArray = isArray(target);\n\n        if (!isReadonly) {\n            // 过滤数组变异方法\n            if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\n                return Reflect.get(Instrumentations, key, receiver);\n            }\n\n            if (key === 'hasOwnProperty') {\n                return hasOwnProperty;\n            }\n        }\n\n        const res = Reflect.get(target, key, receiver);\n\n        // 过滤 Symbol Key 和 一些不收集依赖的键\n        if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n            return res;\n        }\n\n        if (!isReadonly) {\n            track(target, TrackOpTypes.Get, key);\n        }\n\n        if (isShallow) {\n            return res;\n        }\n\n        if (isRef(res)) { // 不太清楚\n            return targetIsArray && isIntegerKey(key) ? res : res.value;\n        }\n\n        if (isObject(res)) {\n            return isReadonly ? readonly(res) : reactive(res);\n        }\n\n        return res;\n    }\n}\n```\n**get api**核心流程就是首先经过一系列判断, 判断符合要求的**key**才进行依赖收集, 然后根据对不同的类型进行处理返回。不收集依赖的key包括预设属性、symbol类型的自有属性。\n\n当我们的**target**是数组，且**key**值存在**arraInstrumentations**中时，返回**arraInstrumentations**中对应的**key**值。我们再来看看**arraInstrumentations**是个什么：\n\n```javascript\nconst arrayInstrumentations = createArrayInstrumentations()\n\nfunction createArrayInstrumentations() {\n    const instrumentations = {};\n    (['includes', 'indexOf', 'lastIndexOf']).forEach(key => {\n        instrumentations[key] = function (this, ...args) {\n            // toRaw 可以把响应式对象转成原始数据\n            const arr = toRaw(this)\n\n            for (let i = 0, l = this.length; i < l; i++) {\n                // 对数组的每一项进行依赖收集\n                track(arr, TrackOpTypes.GET, i + '')\n            }\n            // 先尝试用参数本身，可能是响应式数据\n            const res = arr[key](...args)\n            if (res === -1 || res === false) {\n                // 如果失败，再尝试把参数转成原始数据\n                return arr[key](...args.map(toRaw))\n            } else {\n                return res\n            }\n        }\n    });\n\n    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\n        instrumentations[key] = function (this, ...args) {\n            pauseTracking()\n            const res = toRaw(this)[key].apply(this, args)\n            resetTracking()\n            return res\n        }\n    })\n    return instrumentations\n}\n```\n\n**arrayInstrumentations**会重写两类函数，一类是查询类函数：**inclues**、**indexOf**、**lastIndeOf**，代表对数组的读取操作。在这些函数中会执行**track**函数，对数组的索引进行依赖收集。\n\n另一类是修改类函数：**push**、**pop**、**shift**、**unshift**、**splice**，代表对数组的修改操作，在这些函数中暂停了全局的追踪功能，防止某些情况下导致死循环。\n\n如果你想了解**track**做了些什么，可以查看我的文章[响应式原理：dep（响应式对象的依赖管理器）]\n\n#### set\n\n上面说完了**get**的流程，我们了解一下依赖收集后的数据结构存储在了**targetMap**中，接下来我们接着看**set**的过程：\n\n```javascript\nclass MutableReactiveHandler extends BaseReactiveHandler {\n    constructor(isShallow = false) {\n        super(false, isShallow);\n    }\n\n    set(target, key, value, receiver) {\n        let oldValue = target[key];\n\n        // 对深层响应式，处理新旧值\n        if (!this._isShallow) {\n            const isOldValueReadonly = isReadonly(oldValue);\n\n            if (!isShallow(value) && !isReadonly(value)) {\n                oldValue = toRaw(oldValue);\n                value = toRaw(value);\n            }\n\n            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n                if (isOldValueReadonly) {\n                    return false;\n                } else {\n                    oldValue.value = value;\n                    return true;\n                }\n            }\n        }\n\n        // 判断是否为已有属性\n        const hadKey = \n            isArray(target) && isIntegerKey(key) \n                ? (Number(key) < target.length) \n                : hasOwn(target, key); \n        const result = Reflect.set(target, key, value, receiver);\n        if (target === toRaw(receiver)) {\n\n            // 触发响应\n            if (!hadKey) {\n                trigger(target, TriggerOpTypes.ADD, key, value);\n            } else if (hasChanged(value, oldValue)) {\n                trigger(target, TriggerOpTypes.SET, key, value, oldValue);\n            }\n        }\n\n        return result;\n    }\n}\n\n```\n\n可以看到**set**接口核心逻辑就是根据是否为渐层响应式来确认原始值和新值，这里默认不是浅层的响应式，所以会先把原始值和新值进行**toRaw**转换，然后通过**Reflect.set**设置值，最后通过**trigger**函数派发通知，并依据**key**是否存在于**target**来确认通知类型是**add**（新增）还是**set**（修改）。\n\n如果你想了解**trigger**做了些什么，可以查看我的文章[响应式原理：dep（响应式对象的依赖管理器）]","slug":"源码/vue3/reactive","published":1,"date":"2024-04-03T09:43:47.885Z","updated":"2024-04-03T09:49:19.390Z","_id":"cludenfk50001s4gm9tvz1yia","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"reactive\"><a href=\"#reactive\" class=\"headerlink\" title=\"reactive\"></a>reactive</h3><p>源码中关于<strong>Reactive</strong>部分的定义：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">reactive</span>(<span class=\"params\">target</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"title function_\">isReadonly</span>(target)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">createReactiveObject</span>(</span><br><span class=\"line\">        target, </span><br><span class=\"line\">        <span class=\"literal\">false</span>, </span><br><span class=\"line\">        mutableHandlers, </span><br><span class=\"line\">        mutableCollectionHandlers, </span><br><span class=\"line\">        reactiveMap</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数核心也就是通过<strong>createReactiveObject</strong>把我们传入的<strong>target</strong>变成响应式的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createReactiveObject</span>(<span class=\"params\">target, isReadonly, baseHandlers, collectionHandlers, proxyMap</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"title function_\">isObject</span>(target)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(target[<span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">RAW</span>] &amp;&amp; !(isReadonly &amp;&amp; target[<span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">IS_REACTIVE</span>])) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> existingProxy = proxyMap.<span class=\"title function_\">get</span>(target);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(existingProxy) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> existingProxy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> targetType = <span class=\"title function_\">getTargetType</span>(target);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(targetType === <span class=\"title class_\">TargetType</span>.<span class=\"property\">INVALID</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(</span><br><span class=\"line\">        target, </span><br><span class=\"line\">        targetType === <span class=\"title class_\">TargetType</span>.<span class=\"property\">COLLECTION</span> ? collectionHandlers : baseHandlers</span><br><span class=\"line\">    );</span><br><span class=\"line\">    proxyMap.<span class=\"title function_\">set</span>(target, proxy);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> proxy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码核心流程就是首先经过一系列判断，判断符合要求的<strong>target</strong>才能被响应式。包括target的类型、是否是响应式、是否已经被定义过了、是否是符合要求的类型。最后执行<strong>new Proxy</strong>对target进行代理, 其核心是处理器。我们先来看一下是定义了几种处理器，以及如何确认处理器的类型的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">targetType</span>(<span class=\"params\">rawType</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (rawType) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;Object&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;Array&#x27;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title class_\">TargetType</span>.<span class=\"property\">COMMON</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;Map&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;Set&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;WeakMap&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;WeakSet&#x27;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title class_\">TargetType</span>.<span class=\"property\">COLLECTION</span>;</span><br><span class=\"line\">        <span class=\"attr\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title class_\">TargetType</span>.<span class=\"property\">INVALID</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getTargetType</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value[<span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">SKIP</span>] || !<span class=\"title class_\">Object</span>.<span class=\"title function_\">isExtensible</span>(value) ? <span class=\"title class_\">TargetType</span>.<span class=\"property\">INVALID</span> : <span class=\"title function_\">targetType</span>(<span class=\"title function_\">toRawType</span>(value));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">toRawType</span> = (<span class=\"params\">value</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// toTypeString 转换成字符串的方式，比如 &quot;[object RawType]&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">toTypeString</span>(value).<span class=\"title function_\">slice</span>(<span class=\"number\">8</span>, -<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为<strong>target</strong>传入进来的是一个<strong>Object</strong>，所以<strong>toRawType</strong>得到的值是<strong>Object</strong>。所以这里的值等于<strong>TargetType.Common</strong>也就是使用<strong>baseHandlers</strong>。若传入进来的是<strong>Map</strong>、<strong>Set</strong>、<strong>WeakMap</strong>、<strong>WeakSet</strong>类型，则使用<strong>collectionHandlers</strong>，本章不进行展开<strong>collectionHandlers</strong>的解析。</p>\n<p>接下来看一下<strong>baseHandlers</strong>的实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> mutableHandlers = &#123;</span><br><span class=\"line\">    get,</span><br><span class=\"line\">    set,</span><br><span class=\"line\">    deleteProperty,</span><br><span class=\"line\">    has,</span><br><span class=\"line\">    ownKeys,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就是<strong>Proxy</strong>中的定义<strong>handler</strong>的一些属性</p>\n<ul>\n<li>get：属性读取操作的捕捉器。</li>\n<li>set：属性设置操作的捕捉器。</li>\n<li>deleteProperty： delete操作符的捕捉器。</li>\n<li>has：in操作符的捕捉器。</li>\n<li>ownKeys：Object.getOwnPropertyNames方法和Object.getOwnPropertySymbols方法的捕捉器。</li>\n</ul>\n<p><strong>reactive</strong>对象响应式的核心就在<strong>set</strong>和<strong>get</strong>中，我们一起来看一下二者的实现</p>\n<h4 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h4><p>get的源码实现</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BaseReactiveHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">_isReadonly = <span class=\"literal\">false</span>, _isShallow = <span class=\"literal\">false</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_isReadonly</span> = isReadonly;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_isShallow</span> = _isShallow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">get</span>(<span class=\"params\">target, key, receiver</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> isReadonly = <span class=\"variable language_\">this</span>.<span class=\"property\">_isReadonly</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> isShallow = <span class=\"variable language_\">this</span>.<span class=\"property\">_isShallow</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 对 ReactiveFlags 的处理部分</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key === <span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">IS_REACTIVE</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> !isReadonly;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key === <span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">IS_READONLY</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> isReadonly;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key === <span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">IS_SHALLOW</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> isShallow;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key === <span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">RAW</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (</span><br><span class=\"line\">                receiver ===</span><br><span class=\"line\">                (isReadonly</span><br><span class=\"line\">                    ? isShallow</span><br><span class=\"line\">                        ? shallowReadonlyMap</span><br><span class=\"line\">                        : readonlyMap</span><br><span class=\"line\">                    : isShallow</span><br><span class=\"line\">                        ? shallowReactiveMap</span><br><span class=\"line\">                        : reactiveMap</span><br><span class=\"line\">                ).<span class=\"title function_\">get</span>(target) ||</span><br><span class=\"line\">                <span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(target) === <span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(receiver)</span><br><span class=\"line\">            ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> targetIsArray = <span class=\"title function_\">isArray</span>(target);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isReadonly) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 过滤数组变异方法</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (targetIsArray &amp;&amp; <span class=\"title function_\">hasOwn</span>(arrayInstrumentations, key)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(<span class=\"title class_\">Instrumentations</span>, key, receiver);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key === <span class=\"string\">&#x27;hasOwnProperty&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> hasOwnProperty;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> res = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, key, receiver);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 过滤 Symbol Key 和 一些不收集依赖的键</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title function_\">isSymbol</span>(key) ? builtInSymbols.<span class=\"title function_\">has</span>(key) : <span class=\"title function_\">isNonTrackableKeys</span>(key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isReadonly) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">track</span>(target, <span class=\"title class_\">TrackOpTypes</span>.<span class=\"property\">Get</span>, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isShallow) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title function_\">isRef</span>(res)) &#123; <span class=\"comment\">// 不太清楚</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> targetIsArray &amp;&amp; <span class=\"title function_\">isIntegerKey</span>(key) ? res : res.<span class=\"property\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title function_\">isObject</span>(res)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> isReadonly ? <span class=\"title function_\">readonly</span>(res) : <span class=\"title function_\">reactive</span>(res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>get api</strong>核心流程就是首先经过一系列判断, 判断符合要求的<strong>key</strong>才进行依赖收集, 然后根据对不同的类型进行处理返回。不收集依赖的key包括预设属性、symbol类型的自有属性。</p>\n<p>当我们的<strong>target</strong>是数组，且<strong>key</strong>值存在<strong>arraInstrumentations</strong>中时，返回<strong>arraInstrumentations</strong>中对应的<strong>key</strong>值。我们再来看看<strong>arraInstrumentations</strong>是个什么：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arrayInstrumentations = <span class=\"title function_\">createArrayInstrumentations</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createArrayInstrumentations</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> instrumentations = &#123;&#125;;</span><br><span class=\"line\">    ([<span class=\"string\">&#x27;includes&#x27;</span>, <span class=\"string\">&#x27;indexOf&#x27;</span>, <span class=\"string\">&#x27;lastIndexOf&#x27;</span>]).<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">        instrumentations[key] = <span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"variable language_\">this</span>, ...args</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// toRaw 可以把响应式对象转成原始数据</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> arr = <span class=\"title function_\">toRaw</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = <span class=\"variable language_\">this</span>.<span class=\"property\">length</span>; i &lt; l; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 对数组的每一项进行依赖收集</span></span><br><span class=\"line\">                <span class=\"title function_\">track</span>(arr, <span class=\"title class_\">TrackOpTypes</span>.<span class=\"property\">GET</span>, i + <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 先尝试用参数本身，可能是响应式数据</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> res = arr[key](...args)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (res === -<span class=\"number\">1</span> || res === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果失败，再尝试把参数转成原始数据</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> arr[key](...args.<span class=\"title function_\">map</span>(toRaw))</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> res</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"string\">&#x27;push&#x27;</span>, <span class=\"string\">&#x27;pop&#x27;</span>, <span class=\"string\">&#x27;shift&#x27;</span>, <span class=\"string\">&#x27;unshift&#x27;</span>, <span class=\"string\">&#x27;splice&#x27;</span>].<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">        instrumentations[key] = <span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"variable language_\">this</span>, ...args</span>) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">pauseTracking</span>()</span><br><span class=\"line\">            <span class=\"keyword\">const</span> res = <span class=\"title function_\">toRaw</span>(<span class=\"variable language_\">this</span>)[key].<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, args)</span><br><span class=\"line\">            <span class=\"title function_\">resetTracking</span>()</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instrumentations</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>arrayInstrumentations</strong>会重写两类函数，一类是查询类函数：<strong>inclues</strong>、<strong>indexOf</strong>、<strong>lastIndeOf</strong>，代表对数组的读取操作。在这些函数中会执行<strong>track</strong>函数，对数组的索引进行依赖收集。</p>\n<p>另一类是修改类函数：<strong>push</strong>、<strong>pop</strong>、<strong>shift</strong>、<strong>unshift</strong>、<strong>splice</strong>，代表对数组的修改操作，在这些函数中暂停了全局的追踪功能，防止某些情况下导致死循环。</p>\n<p>如果你想了解<strong>track</strong>做了些什么，可以查看我的文章[响应式原理：dep（响应式对象的依赖管理器）]</p>\n<h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h4><p>上面说完了<strong>get</strong>的流程，我们了解一下依赖收集后的数据结构存储在了<strong>targetMap</strong>中，接下来我们接着看<strong>set</strong>的过程：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MutableReactiveHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">BaseReactiveHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">isShallow = <span class=\"literal\">false</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>(<span class=\"literal\">false</span>, isShallow);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">set</span>(<span class=\"params\">target, key, value, receiver</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> oldValue = target[key];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 对深层响应式，处理新旧值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"variable language_\">this</span>.<span class=\"property\">_isShallow</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> isOldValueReadonly = <span class=\"title function_\">isReadonly</span>(oldValue);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"title function_\">isShallow</span>(value) &amp;&amp; !<span class=\"title function_\">isReadonly</span>(value)) &#123;</span><br><span class=\"line\">                oldValue = <span class=\"title function_\">toRaw</span>(oldValue);</span><br><span class=\"line\">                value = <span class=\"title function_\">toRaw</span>(value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"title function_\">isArray</span>(target) &amp;&amp; <span class=\"title function_\">isRef</span>(oldValue) &amp;&amp; !<span class=\"title function_\">isRef</span>(value)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isOldValueReadonly) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    oldValue.<span class=\"property\">value</span> = value;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断是否为已有属性</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> hadKey = </span><br><span class=\"line\">            <span class=\"title function_\">isArray</span>(target) &amp;&amp; <span class=\"title function_\">isIntegerKey</span>(key) </span><br><span class=\"line\">                ? (<span class=\"title class_\">Number</span>(key) &lt; target.<span class=\"property\">length</span>) </span><br><span class=\"line\">                : <span class=\"title function_\">hasOwn</span>(target, key); </span><br><span class=\"line\">        <span class=\"keyword\">const</span> result = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, key, value, receiver);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (target === <span class=\"title function_\">toRaw</span>(receiver)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 触发响应</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!hadKey) &#123;</span><br><span class=\"line\">                <span class=\"title function_\">trigger</span>(target, <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">ADD</span>, key, value);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">hasChanged</span>(value, oldValue)) &#123;</span><br><span class=\"line\">                <span class=\"title function_\">trigger</span>(target, <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">SET</span>, key, value, oldValue);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>可以看到<strong>set</strong>接口核心逻辑就是根据是否为渐层响应式来确认原始值和新值，这里默认不是浅层的响应式，所以会先把原始值和新值进行<strong>toRaw</strong>转换，然后通过<strong>Reflect.set</strong>设置值，最后通过<strong>trigger</strong>函数派发通知，并依据<strong>key</strong>是否存在于<strong>target</strong>来确认通知类型是<strong>add</strong>（新增）还是<strong>set</strong>（修改）。</p>\n<p>如果你想了解<strong>trigger</strong>做了些什么，可以查看我的文章[响应式原理：dep（响应式对象的依赖管理器）]</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":"<h3 id=\"reactive\"><a href=\"#reactive\" class=\"headerlink\" title=\"reactive\"></a>reactive</h3><p>源码中关于<strong>Reactive</strong>部分的定义：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">reactive</span>(<span class=\"params\">target</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"title function_\">isReadonly</span>(target)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">createReactiveObject</span>(</span><br><span class=\"line\">        target, </span><br><span class=\"line\">        <span class=\"literal\">false</span>, </span><br><span class=\"line\">        mutableHandlers, </span><br><span class=\"line\">        mutableCollectionHandlers, </span><br><span class=\"line\">        reactiveMap</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数核心也就是通过<strong>createReactiveObject</strong>把我们传入的<strong>target</strong>变成响应式的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createReactiveObject</span>(<span class=\"params\">target, isReadonly, baseHandlers, collectionHandlers, proxyMap</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"title function_\">isObject</span>(target)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(target[<span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">RAW</span>] &amp;&amp; !(isReadonly &amp;&amp; target[<span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">IS_REACTIVE</span>])) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> existingProxy = proxyMap.<span class=\"title function_\">get</span>(target);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(existingProxy) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> existingProxy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> targetType = <span class=\"title function_\">getTargetType</span>(target);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(targetType === <span class=\"title class_\">TargetType</span>.<span class=\"property\">INVALID</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(</span><br><span class=\"line\">        target, </span><br><span class=\"line\">        targetType === <span class=\"title class_\">TargetType</span>.<span class=\"property\">COLLECTION</span> ? collectionHandlers : baseHandlers</span><br><span class=\"line\">    );</span><br><span class=\"line\">    proxyMap.<span class=\"title function_\">set</span>(target, proxy);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> proxy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码核心流程就是首先经过一系列判断，判断符合要求的<strong>target</strong>才能被响应式。包括target的类型、是否是响应式、是否已经被定义过了、是否是符合要求的类型。最后执行<strong>new Proxy</strong>对target进行代理, 其核心是处理器。我们先来看一下是定义了几种处理器，以及如何确认处理器的类型的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">targetType</span>(<span class=\"params\">rawType</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (rawType) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;Object&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;Array&#x27;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title class_\">TargetType</span>.<span class=\"property\">COMMON</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;Map&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;Set&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;WeakMap&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;WeakSet&#x27;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title class_\">TargetType</span>.<span class=\"property\">COLLECTION</span>;</span><br><span class=\"line\">        <span class=\"attr\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title class_\">TargetType</span>.<span class=\"property\">INVALID</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getTargetType</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value[<span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">SKIP</span>] || !<span class=\"title class_\">Object</span>.<span class=\"title function_\">isExtensible</span>(value) ? <span class=\"title class_\">TargetType</span>.<span class=\"property\">INVALID</span> : <span class=\"title function_\">targetType</span>(<span class=\"title function_\">toRawType</span>(value));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">toRawType</span> = (<span class=\"params\">value</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// toTypeString 转换成字符串的方式，比如 &quot;[object RawType]&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">toTypeString</span>(value).<span class=\"title function_\">slice</span>(<span class=\"number\">8</span>, -<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为<strong>target</strong>传入进来的是一个<strong>Object</strong>，所以<strong>toRawType</strong>得到的值是<strong>Object</strong>。所以这里的值等于<strong>TargetType.Common</strong>也就是使用<strong>baseHandlers</strong>。若传入进来的是<strong>Map</strong>、<strong>Set</strong>、<strong>WeakMap</strong>、<strong>WeakSet</strong>类型，则使用<strong>collectionHandlers</strong>，本章不进行展开<strong>collectionHandlers</strong>的解析。</p>\n<p>接下来看一下<strong>baseHandlers</strong>的实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> mutableHandlers = &#123;</span><br><span class=\"line\">    get,</span><br><span class=\"line\">    set,</span><br><span class=\"line\">    deleteProperty,</span><br><span class=\"line\">    has,</span><br><span class=\"line\">    ownKeys,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就是<strong>Proxy</strong>中的定义<strong>handler</strong>的一些属性</p>\n<ul>\n<li>get：属性读取操作的捕捉器。</li>\n<li>set：属性设置操作的捕捉器。</li>\n<li>deleteProperty： delete操作符的捕捉器。</li>\n<li>has：in操作符的捕捉器。</li>\n<li>ownKeys：Object.getOwnPropertyNames方法和Object.getOwnPropertySymbols方法的捕捉器。</li>\n</ul>\n<p><strong>reactive</strong>对象响应式的核心就在<strong>set</strong>和<strong>get</strong>中，我们一起来看一下二者的实现</p>\n<h4 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h4><p>get的源码实现</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BaseReactiveHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">_isReadonly = <span class=\"literal\">false</span>, _isShallow = <span class=\"literal\">false</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_isReadonly</span> = isReadonly;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_isShallow</span> = _isShallow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">get</span>(<span class=\"params\">target, key, receiver</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> isReadonly = <span class=\"variable language_\">this</span>.<span class=\"property\">_isReadonly</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> isShallow = <span class=\"variable language_\">this</span>.<span class=\"property\">_isShallow</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 对 ReactiveFlags 的处理部分</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key === <span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">IS_REACTIVE</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> !isReadonly;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key === <span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">IS_READONLY</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> isReadonly;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key === <span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">IS_SHALLOW</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> isShallow;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key === <span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">RAW</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (</span><br><span class=\"line\">                receiver ===</span><br><span class=\"line\">                (isReadonly</span><br><span class=\"line\">                    ? isShallow</span><br><span class=\"line\">                        ? shallowReadonlyMap</span><br><span class=\"line\">                        : readonlyMap</span><br><span class=\"line\">                    : isShallow</span><br><span class=\"line\">                        ? shallowReactiveMap</span><br><span class=\"line\">                        : reactiveMap</span><br><span class=\"line\">                ).<span class=\"title function_\">get</span>(target) ||</span><br><span class=\"line\">                <span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(target) === <span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(receiver)</span><br><span class=\"line\">            ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> targetIsArray = <span class=\"title function_\">isArray</span>(target);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isReadonly) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 过滤数组变异方法</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (targetIsArray &amp;&amp; <span class=\"title function_\">hasOwn</span>(arrayInstrumentations, key)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(<span class=\"title class_\">Instrumentations</span>, key, receiver);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key === <span class=\"string\">&#x27;hasOwnProperty&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> hasOwnProperty;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> res = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, key, receiver);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 过滤 Symbol Key 和 一些不收集依赖的键</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title function_\">isSymbol</span>(key) ? builtInSymbols.<span class=\"title function_\">has</span>(key) : <span class=\"title function_\">isNonTrackableKeys</span>(key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isReadonly) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">track</span>(target, <span class=\"title class_\">TrackOpTypes</span>.<span class=\"property\">Get</span>, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isShallow) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title function_\">isRef</span>(res)) &#123; <span class=\"comment\">// 不太清楚</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> targetIsArray &amp;&amp; <span class=\"title function_\">isIntegerKey</span>(key) ? res : res.<span class=\"property\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title function_\">isObject</span>(res)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> isReadonly ? <span class=\"title function_\">readonly</span>(res) : <span class=\"title function_\">reactive</span>(res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>get api</strong>核心流程就是首先经过一系列判断, 判断符合要求的<strong>key</strong>才进行依赖收集, 然后根据对不同的类型进行处理返回。不收集依赖的key包括预设属性、symbol类型的自有属性。</p>\n<p>当我们的<strong>target</strong>是数组，且<strong>key</strong>值存在<strong>arraInstrumentations</strong>中时，返回<strong>arraInstrumentations</strong>中对应的<strong>key</strong>值。我们再来看看<strong>arraInstrumentations</strong>是个什么：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arrayInstrumentations = <span class=\"title function_\">createArrayInstrumentations</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createArrayInstrumentations</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> instrumentations = &#123;&#125;;</span><br><span class=\"line\">    ([<span class=\"string\">&#x27;includes&#x27;</span>, <span class=\"string\">&#x27;indexOf&#x27;</span>, <span class=\"string\">&#x27;lastIndexOf&#x27;</span>]).<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">        instrumentations[key] = <span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"variable language_\">this</span>, ...args</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// toRaw 可以把响应式对象转成原始数据</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> arr = <span class=\"title function_\">toRaw</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = <span class=\"variable language_\">this</span>.<span class=\"property\">length</span>; i &lt; l; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 对数组的每一项进行依赖收集</span></span><br><span class=\"line\">                <span class=\"title function_\">track</span>(arr, <span class=\"title class_\">TrackOpTypes</span>.<span class=\"property\">GET</span>, i + <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 先尝试用参数本身，可能是响应式数据</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> res = arr[key](...args)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (res === -<span class=\"number\">1</span> || res === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果失败，再尝试把参数转成原始数据</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> arr[key](...args.<span class=\"title function_\">map</span>(toRaw))</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> res</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"string\">&#x27;push&#x27;</span>, <span class=\"string\">&#x27;pop&#x27;</span>, <span class=\"string\">&#x27;shift&#x27;</span>, <span class=\"string\">&#x27;unshift&#x27;</span>, <span class=\"string\">&#x27;splice&#x27;</span>].<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">        instrumentations[key] = <span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"variable language_\">this</span>, ...args</span>) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">pauseTracking</span>()</span><br><span class=\"line\">            <span class=\"keyword\">const</span> res = <span class=\"title function_\">toRaw</span>(<span class=\"variable language_\">this</span>)[key].<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, args)</span><br><span class=\"line\">            <span class=\"title function_\">resetTracking</span>()</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instrumentations</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>arrayInstrumentations</strong>会重写两类函数，一类是查询类函数：<strong>inclues</strong>、<strong>indexOf</strong>、<strong>lastIndeOf</strong>，代表对数组的读取操作。在这些函数中会执行<strong>track</strong>函数，对数组的索引进行依赖收集。</p>\n<p>另一类是修改类函数：<strong>push</strong>、<strong>pop</strong>、<strong>shift</strong>、<strong>unshift</strong>、<strong>splice</strong>，代表对数组的修改操作，在这些函数中暂停了全局的追踪功能，防止某些情况下导致死循环。</p>\n<p>如果你想了解<strong>track</strong>做了些什么，可以查看我的文章[响应式原理：dep（响应式对象的依赖管理器）]</p>\n<h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h4><p>上面说完了<strong>get</strong>的流程，我们了解一下依赖收集后的数据结构存储在了<strong>targetMap</strong>中，接下来我们接着看<strong>set</strong>的过程：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MutableReactiveHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">BaseReactiveHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">isShallow = <span class=\"literal\">false</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>(<span class=\"literal\">false</span>, isShallow);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">set</span>(<span class=\"params\">target, key, value, receiver</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> oldValue = target[key];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 对深层响应式，处理新旧值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"variable language_\">this</span>.<span class=\"property\">_isShallow</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> isOldValueReadonly = <span class=\"title function_\">isReadonly</span>(oldValue);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"title function_\">isShallow</span>(value) &amp;&amp; !<span class=\"title function_\">isReadonly</span>(value)) &#123;</span><br><span class=\"line\">                oldValue = <span class=\"title function_\">toRaw</span>(oldValue);</span><br><span class=\"line\">                value = <span class=\"title function_\">toRaw</span>(value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"title function_\">isArray</span>(target) &amp;&amp; <span class=\"title function_\">isRef</span>(oldValue) &amp;&amp; !<span class=\"title function_\">isRef</span>(value)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isOldValueReadonly) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    oldValue.<span class=\"property\">value</span> = value;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断是否为已有属性</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> hadKey = </span><br><span class=\"line\">            <span class=\"title function_\">isArray</span>(target) &amp;&amp; <span class=\"title function_\">isIntegerKey</span>(key) </span><br><span class=\"line\">                ? (<span class=\"title class_\">Number</span>(key) &lt; target.<span class=\"property\">length</span>) </span><br><span class=\"line\">                : <span class=\"title function_\">hasOwn</span>(target, key); </span><br><span class=\"line\">        <span class=\"keyword\">const</span> result = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, key, value, receiver);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (target === <span class=\"title function_\">toRaw</span>(receiver)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 触发响应</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!hadKey) &#123;</span><br><span class=\"line\">                <span class=\"title function_\">trigger</span>(target, <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">ADD</span>, key, value);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">hasChanged</span>(value, oldValue)) &#123;</span><br><span class=\"line\">                <span class=\"title function_\">trigger</span>(target, <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">SET</span>, key, value, oldValue);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>可以看到<strong>set</strong>接口核心逻辑就是根据是否为渐层响应式来确认原始值和新值，这里默认不是浅层的响应式，所以会先把原始值和新值进行<strong>toRaw</strong>转换，然后通过<strong>Reflect.set</strong>设置值，最后通过<strong>trigger</strong>函数派发通知，并依据<strong>key</strong>是否存在于<strong>target</strong>来确认通知类型是<strong>add</strong>（新增）还是<strong>set</strong>（修改）。</p>\n<p>如果你想了解<strong>trigger</strong>做了些什么，可以查看我的文章[响应式原理：dep（响应式对象的依赖管理器）]</p>\n"},{"title":"Vue3中computed模块源码解析","_content":"\n### Computed\n\n源码中关于**computed**部分的定义：\n\n```javascript\nexport function computed(getterOptions, debugOptions, isSSR = false) {\n    let getter;\n    let setter;\n\n    const onlyGetter = isFunction(getterOptions);\n\n    if (onlyGetter) {\n        getter = getterOptions;\n    } else {\n        getter = getterOptions.get;\n        setter = getterOptions.set;\n    }\n\n    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n\n    return cRef;\n}\n```\n\n上述代理核心流程就是先进行参数归一化, 然后生成并返回一个实例化对象。让我们一起看一下啊**ComputedRefImpl**的实现\n\n```javascript\nexport class ComputedRefImpl {\n    constructor(getter, _setter, isReadonly, isSSR) {\n        this.getter = getter;\n        this._setter = _setter;\n\n        // 实例化副作用 暂不清楚_dirtyLevel属性更新逻辑\n        this.effect = new ReactiveEffect(\n            () => getter(this._value),\n            () => triggerRefValue(\n                this,\n                this.effect._dirtyLevel === DirtyLevels.MaybeDirty_ComputedSideEffect\n                    ? DirtyLevels.MaybeDirty_ComputedSideEffect\n                    : DirtyLevels.MaybeDirty,\n            )\n        );\n        \n        this.effect.computed = this; // 一个标记，会优先于其他普通副作用函数先执行\n        this.effect.active = this._cacheable = !isSSR; // 暂不知道active用途\n        this[ReactiveFlags.IS_READONLY] = isReadonly;\n    }\n\n    get value() {\n        const self = toRaw(this);\n\n        // 脏值则进行更新\n        if(\n            (!self._cacheable || self.effect.dirty) &&\n            hasChanged(self._value, (self._value) = self.effect.run())\n        ) {\n            triggerRefValue(self, DirtyLevels.Dirty);\n        }\n\n        // 依赖收集\n        trackRefValue(self);\n\n        if(self.effect._dirtyLevel >= DirtyLevels.MaybeDirty_ComputedSideEffect) {\n            triggerRefValue(self, DirtyLevels.MaybeDirty_ComputedSideEffect);\n        }\n\n        return self._value;\n    }\n    // 执行setter\n    set value(newValue) {\n        this._setter(newValue);\n    }\n}\n```\n\n简单看一下该类的实现，在构造函数的时候，创建一个副作用对像**effect**。并为**effect**额外定义了一个**computed**属性执行当前响应式对象**cRef**对象。\n\n另外，定义了一个**ComputedRefImpl.value getter**方法，当我们通过**cRef.value**取值的时候，会判断是否有脏值，脏值处理核心就是调用**trggerRefValue**，如果你想了解**trackRefValue**、**trggerRefValue做了些什么，可以查看我的文章[响应式原理：dep（响应式对象的依赖管理器）]\n\n其还定义了一个**ComputedRefImpl.value setter**方法，该方法就是执行过程传入进来得**computed.value setter**函数。\n\n有了上面得介绍，我们来看一个具体的例子，看看**computed**是如何执行的：\n\n```html\n<script src=\"../../dist/vue.global.js\"></script>\n\n<div id=\"demo\">\n  <div>\n    {{ sum.value }}\n  </div>\n  <button @click=\"add\">add</button>\n</div>\n\n<script>\n  Vue.createApp({\n    setup() {\n      const a = Vue.ref(1);\n\n      const sum = Vue.computed(getter);\n      function getter() {\n        return a.value + 1\n      }\n\n      function add() {\n        a.value = 2;\n      }\n\n      return { sum }\n    },\n  }).mount('#demo')\n</script>\n```\n\n1. **computed**函数执行，初始化过程中，生成了一个**computed effect**.\n2. 上述的template会被编译为**render**函数，**render**执行，访问了**sum.value**，触发了收集，此时收集的副作用为**render effect**, 会执行**ComputedRefImpl.value getter**，此时的**self._dirty = true**执行**effect.run()**也就是执行了**computed.value getter**函数，得到**_value = 1**\n3. **computed.value getter**函数体内访问了**a.value**触发了对**a**的依赖收集，此时收集到的依赖为**computed effect**。\n4. 按钮点击后，执行**add**更新了**a.value**值触发了**computed effect**的**trigger**，也就是执行**render**。\n5. 执行**render**会访问**ComputedRefImpl.value getter**, 会执行**computed effect.run()**触发**computed.value getter**函数的执行。因为此时的**_dirty = true**, 所以**get value**会重新计算**_value**的值为**sum.value = 3**。\n6. **sum.value**的值变化后，触发了**triggerRefvalue**, 即**render**会重新执行。\n\n\n","source":"_posts/源码/vue3/computed.md","raw":"---\ntitle: vue3中computed模块源码解析\n---\n\n### Computed\n\n源码中关于**computed**部分的定义：\n\n```javascript\nexport function computed(getterOptions, debugOptions, isSSR = false) {\n    let getter;\n    let setter;\n\n    const onlyGetter = isFunction(getterOptions);\n\n    if (onlyGetter) {\n        getter = getterOptions;\n    } else {\n        getter = getterOptions.get;\n        setter = getterOptions.set;\n    }\n\n    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n\n    return cRef;\n}\n```\n\n上述代理核心流程就是先进行参数归一化, 然后生成并返回一个实例化对象。让我们一起看一下啊**ComputedRefImpl**的实现\n\n```javascript\nexport class ComputedRefImpl {\n    constructor(getter, _setter, isReadonly, isSSR) {\n        this.getter = getter;\n        this._setter = _setter;\n\n        // 实例化副作用 暂不清楚_dirtyLevel属性更新逻辑\n        this.effect = new ReactiveEffect(\n            () => getter(this._value),\n            () => triggerRefValue(\n                this,\n                this.effect._dirtyLevel === DirtyLevels.MaybeDirty_ComputedSideEffect\n                    ? DirtyLevels.MaybeDirty_ComputedSideEffect\n                    : DirtyLevels.MaybeDirty,\n            )\n        );\n        \n        this.effect.computed = this; // 一个标记，会优先于其他普通副作用函数先执行\n        this.effect.active = this._cacheable = !isSSR; // 暂不知道active用途\n        this[ReactiveFlags.IS_READONLY] = isReadonly;\n    }\n\n    get value() {\n        const self = toRaw(this);\n\n        // 脏值则进行更新\n        if(\n            (!self._cacheable || self.effect.dirty) &&\n            hasChanged(self._value, (self._value) = self.effect.run())\n        ) {\n            triggerRefValue(self, DirtyLevels.Dirty);\n        }\n\n        // 依赖收集\n        trackRefValue(self);\n\n        if(self.effect._dirtyLevel >= DirtyLevels.MaybeDirty_ComputedSideEffect) {\n            triggerRefValue(self, DirtyLevels.MaybeDirty_ComputedSideEffect);\n        }\n\n        return self._value;\n    }\n    // 执行setter\n    set value(newValue) {\n        this._setter(newValue);\n    }\n}\n```\n\n简单看一下该类的实现，在构造函数的时候，创建一个副作用对像**effect**。并为**effect**额外定义了一个**computed**属性执行当前响应式对象**cRef**对象。\n\n另外，定义了一个**ComputedRefImpl.value getter**方法，当我们通过**cRef.value**取值的时候，会判断是否有脏值，脏值处理核心就是调用**trggerRefValue**，如果你想了解**trackRefValue**、**trggerRefValue做了些什么，可以查看我的文章[响应式原理：dep（响应式对象的依赖管理器）]\n\n其还定义了一个**ComputedRefImpl.value setter**方法，该方法就是执行过程传入进来得**computed.value setter**函数。\n\n有了上面得介绍，我们来看一个具体的例子，看看**computed**是如何执行的：\n\n```html\n<script src=\"../../dist/vue.global.js\"></script>\n\n<div id=\"demo\">\n  <div>\n    {{ sum.value }}\n  </div>\n  <button @click=\"add\">add</button>\n</div>\n\n<script>\n  Vue.createApp({\n    setup() {\n      const a = Vue.ref(1);\n\n      const sum = Vue.computed(getter);\n      function getter() {\n        return a.value + 1\n      }\n\n      function add() {\n        a.value = 2;\n      }\n\n      return { sum }\n    },\n  }).mount('#demo')\n</script>\n```\n\n1. **computed**函数执行，初始化过程中，生成了一个**computed effect**.\n2. 上述的template会被编译为**render**函数，**render**执行，访问了**sum.value**，触发了收集，此时收集的副作用为**render effect**, 会执行**ComputedRefImpl.value getter**，此时的**self._dirty = true**执行**effect.run()**也就是执行了**computed.value getter**函数，得到**_value = 1**\n3. **computed.value getter**函数体内访问了**a.value**触发了对**a**的依赖收集，此时收集到的依赖为**computed effect**。\n4. 按钮点击后，执行**add**更新了**a.value**值触发了**computed effect**的**trigger**，也就是执行**render**。\n5. 执行**render**会访问**ComputedRefImpl.value getter**, 会执行**computed effect.run()**触发**computed.value getter**函数的执行。因为此时的**_dirty = true**, 所以**get value**会重新计算**_value**的值为**sum.value = 3**。\n6. **sum.value**的值变化后，触发了**triggerRefvalue**, 即**render**会重新执行。\n\n\n","slug":"源码/vue3/computed","published":1,"date":"2024-03-30T02:01:04.141Z","updated":"2024-04-03T10:56:44.572Z","_id":"clugqkaks000070gm5fm71100","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"Computed\"><a href=\"#Computed\" class=\"headerlink\" title=\"Computed\"></a>Computed</h3><p>源码中关于<strong>computed</strong>部分的定义：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">computed</span>(<span class=\"params\">getterOptions, debugOptions, isSSR = <span class=\"literal\">false</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> getter;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> setter;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> onlyGetter = <span class=\"title function_\">isFunction</span>(getterOptions);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (onlyGetter) &#123;</span><br><span class=\"line\">        getter = getterOptions;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        getter = getterOptions.<span class=\"property\">get</span>;</span><br><span class=\"line\">        setter = getterOptions.<span class=\"property\">set</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> cRef = <span class=\"keyword\">new</span> <span class=\"title class_\">ComputedRefImpl</span>(getter, setter, onlyGetter || !setter, isSSR);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cRef;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代理核心流程就是先进行参数归一化, 然后生成并返回一个实例化对象。让我们一起看一下啊<strong>ComputedRefImpl</strong>的实现</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ComputedRefImpl</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">getter, _setter, isReadonly, isSSR</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">getter</span> = getter;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_setter</span> = _setter;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 实例化副作用 暂不清楚_dirtyLevel属性更新逻辑</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">effect</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(</span><br><span class=\"line\">            <span class=\"function\">() =&gt;</span> <span class=\"title function_\">getter</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">_value</span>),</span><br><span class=\"line\">            <span class=\"function\">() =&gt;</span> <span class=\"title function_\">triggerRefValue</span>(</span><br><span class=\"line\">                <span class=\"variable language_\">this</span>,</span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"property\">effect</span>.<span class=\"property\">_dirtyLevel</span> === <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">MaybeDirty_ComputedSideEffect</span></span><br><span class=\"line\">                    ? <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">MaybeDirty_ComputedSideEffect</span></span><br><span class=\"line\">                    : <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">MaybeDirty</span>,</span><br><span class=\"line\">            )</span><br><span class=\"line\">        );</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">effect</span>.<span class=\"property\">computed</span> = <span class=\"variable language_\">this</span>; <span class=\"comment\">// 一个标记，会优先于其他普通副作用函数先执行</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">effect</span>.<span class=\"property\">active</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">_cacheable</span> = !isSSR; <span class=\"comment\">// 暂不知道active用途</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>[<span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">IS_READONLY</span>] = isReadonly;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> self = <span class=\"title function_\">toRaw</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 脏值则进行更新</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(</span><br><span class=\"line\">            (!self.<span class=\"property\">_cacheable</span> || self.<span class=\"property\">effect</span>.<span class=\"property\">dirty</span>) &amp;&amp;</span><br><span class=\"line\">            <span class=\"title function_\">hasChanged</span>(self.<span class=\"property\">_value</span>, (self.<span class=\"property\">_value</span>) = self.<span class=\"property\">effect</span>.<span class=\"title function_\">run</span>())</span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">triggerRefValue</span>(self, <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">Dirty</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 依赖收集</span></span><br><span class=\"line\">        <span class=\"title function_\">trackRefValue</span>(self);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(self.<span class=\"property\">effect</span>.<span class=\"property\">_dirtyLevel</span> &gt;= <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">MaybeDirty_ComputedSideEffect</span>) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">triggerRefValue</span>(self, <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">MaybeDirty_ComputedSideEffect</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.<span class=\"property\">_value</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 执行setter</span></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title function_\">value</span>(<span class=\"params\">newValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">_setter</span>(newValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>简单看一下该类的实现，在构造函数的时候，创建一个副作用对像<strong>effect</strong>。并为<strong>effect</strong>额外定义了一个<strong>computed</strong>属性执行当前响应式对象<strong>cRef</strong>对象。</p>\n<p>另外，定义了一个<strong>ComputedRefImpl.value getter</strong>方法，当我们通过<strong>cRef.value</strong>取值的时候，会判断是否有脏值，脏值处理核心就是调用<strong>trggerRefValue</strong>，如果你想了解<strong>trackRefValue</strong>、**trggerRefValue做了些什么，可以查看我的文章[响应式原理：dep（响应式对象的依赖管理器）]</p>\n<p>其还定义了一个<strong>ComputedRefImpl.value setter</strong>方法，该方法就是执行过程传入进来得<strong>computed.value setter</strong>函数。</p>\n<p>有了上面得介绍，我们来看一个具体的例子，看看<strong>computed</strong>是如何执行的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;../../dist/vue.global.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;demo&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    &#123;&#123; sum.value &#125;&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;add&quot;</span>&gt;</span>add<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title class_\">Vue</span>.<span class=\"title function_\">createApp</span>(&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"title function_\">setup</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">const</span> a = <span class=\"title class_\">Vue</span>.<span class=\"title function_\">ref</span>(<span class=\"number\">1</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">const</span> sum = <span class=\"title class_\">Vue</span>.<span class=\"title function_\">computed</span>(getter);</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">function</span> <span class=\"title function_\">getter</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">return</span> a.<span class=\"property\">value</span> + <span class=\"number\">1</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">      &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        a.<span class=\"property\">value</span> = <span class=\"number\">2</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">return</span> &#123; sum &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;).<span class=\"title function_\">mount</span>(<span class=\"string\">&#x27;#demo&#x27;</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><strong>computed</strong>函数执行，初始化过程中，生成了一个<strong>computed effect</strong>.</li>\n<li>上述的template会被编译为<strong>render</strong>函数，<strong>render</strong>执行，访问了<strong>sum.value</strong>，触发了收集，此时收集的副作用为<strong>render effect</strong>, 会执行<strong>ComputedRefImpl.value getter</strong>，此时的<strong>self._dirty &#x3D; true</strong>执行<strong>effect.run()<strong>也就是执行了</strong>computed.value getter</strong>函数，得到**_value &#x3D; 1**</li>\n<li><strong>computed.value getter</strong>函数体内访问了<strong>a.value</strong>触发了对<strong>a</strong>的依赖收集，此时收集到的依赖为<strong>computed effect</strong>。</li>\n<li>按钮点击后，执行<strong>add</strong>更新了<strong>a.value</strong>值触发了<strong>computed effect</strong>的<strong>trigger</strong>，也就是执行<strong>render</strong>。</li>\n<li>执行<strong>render</strong>会访问<strong>ComputedRefImpl.value getter</strong>, 会执行<strong>computed effect.run()<strong>触发</strong>computed.value getter</strong>函数的执行。因为此时的**_dirty &#x3D; true**, 所以<strong>get value</strong>会重新计算**_value<strong>的值为</strong>sum.value &#x3D; 3**。</li>\n<li><strong>sum.value</strong>的值变化后，触发了<strong>triggerRefvalue</strong>, 即<strong>render</strong>会重新执行。</li>\n</ol>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/default_bg.png","cover_type":"img","excerpt":"","more":"<h3 id=\"Computed\"><a href=\"#Computed\" class=\"headerlink\" title=\"Computed\"></a>Computed</h3><p>源码中关于<strong>computed</strong>部分的定义：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">computed</span>(<span class=\"params\">getterOptions, debugOptions, isSSR = <span class=\"literal\">false</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> getter;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> setter;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> onlyGetter = <span class=\"title function_\">isFunction</span>(getterOptions);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (onlyGetter) &#123;</span><br><span class=\"line\">        getter = getterOptions;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        getter = getterOptions.<span class=\"property\">get</span>;</span><br><span class=\"line\">        setter = getterOptions.<span class=\"property\">set</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> cRef = <span class=\"keyword\">new</span> <span class=\"title class_\">ComputedRefImpl</span>(getter, setter, onlyGetter || !setter, isSSR);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cRef;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代理核心流程就是先进行参数归一化, 然后生成并返回一个实例化对象。让我们一起看一下啊<strong>ComputedRefImpl</strong>的实现</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ComputedRefImpl</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">getter, _setter, isReadonly, isSSR</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">getter</span> = getter;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_setter</span> = _setter;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 实例化副作用 暂不清楚_dirtyLevel属性更新逻辑</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">effect</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(</span><br><span class=\"line\">            <span class=\"function\">() =&gt;</span> <span class=\"title function_\">getter</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">_value</span>),</span><br><span class=\"line\">            <span class=\"function\">() =&gt;</span> <span class=\"title function_\">triggerRefValue</span>(</span><br><span class=\"line\">                <span class=\"variable language_\">this</span>,</span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"property\">effect</span>.<span class=\"property\">_dirtyLevel</span> === <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">MaybeDirty_ComputedSideEffect</span></span><br><span class=\"line\">                    ? <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">MaybeDirty_ComputedSideEffect</span></span><br><span class=\"line\">                    : <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">MaybeDirty</span>,</span><br><span class=\"line\">            )</span><br><span class=\"line\">        );</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">effect</span>.<span class=\"property\">computed</span> = <span class=\"variable language_\">this</span>; <span class=\"comment\">// 一个标记，会优先于其他普通副作用函数先执行</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">effect</span>.<span class=\"property\">active</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">_cacheable</span> = !isSSR; <span class=\"comment\">// 暂不知道active用途</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>[<span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">IS_READONLY</span>] = isReadonly;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> self = <span class=\"title function_\">toRaw</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 脏值则进行更新</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(</span><br><span class=\"line\">            (!self.<span class=\"property\">_cacheable</span> || self.<span class=\"property\">effect</span>.<span class=\"property\">dirty</span>) &amp;&amp;</span><br><span class=\"line\">            <span class=\"title function_\">hasChanged</span>(self.<span class=\"property\">_value</span>, (self.<span class=\"property\">_value</span>) = self.<span class=\"property\">effect</span>.<span class=\"title function_\">run</span>())</span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">triggerRefValue</span>(self, <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">Dirty</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 依赖收集</span></span><br><span class=\"line\">        <span class=\"title function_\">trackRefValue</span>(self);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(self.<span class=\"property\">effect</span>.<span class=\"property\">_dirtyLevel</span> &gt;= <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">MaybeDirty_ComputedSideEffect</span>) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">triggerRefValue</span>(self, <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">MaybeDirty_ComputedSideEffect</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.<span class=\"property\">_value</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 执行setter</span></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title function_\">value</span>(<span class=\"params\">newValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">_setter</span>(newValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>简单看一下该类的实现，在构造函数的时候，创建一个副作用对像<strong>effect</strong>。并为<strong>effect</strong>额外定义了一个<strong>computed</strong>属性执行当前响应式对象<strong>cRef</strong>对象。</p>\n<p>另外，定义了一个<strong>ComputedRefImpl.value getter</strong>方法，当我们通过<strong>cRef.value</strong>取值的时候，会判断是否有脏值，脏值处理核心就是调用<strong>trggerRefValue</strong>，如果你想了解<strong>trackRefValue</strong>、**trggerRefValue做了些什么，可以查看我的文章[响应式原理：dep（响应式对象的依赖管理器）]</p>\n<p>其还定义了一个<strong>ComputedRefImpl.value setter</strong>方法，该方法就是执行过程传入进来得<strong>computed.value setter</strong>函数。</p>\n<p>有了上面得介绍，我们来看一个具体的例子，看看<strong>computed</strong>是如何执行的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;../../dist/vue.global.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;demo&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    &#123;&#123; sum.value &#125;&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;add&quot;</span>&gt;</span>add<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"title class_\">Vue</span>.<span class=\"title function_\">createApp</span>(&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"title function_\">setup</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">const</span> a = <span class=\"title class_\">Vue</span>.<span class=\"title function_\">ref</span>(<span class=\"number\">1</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">const</span> sum = <span class=\"title class_\">Vue</span>.<span class=\"title function_\">computed</span>(getter);</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">function</span> <span class=\"title function_\">getter</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">return</span> a.<span class=\"property\">value</span> + <span class=\"number\">1</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">      &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        a.<span class=\"property\">value</span> = <span class=\"number\">2</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">return</span> &#123; sum &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;).<span class=\"title function_\">mount</span>(<span class=\"string\">&#x27;#demo&#x27;</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><strong>computed</strong>函数执行，初始化过程中，生成了一个<strong>computed effect</strong>.</li>\n<li>上述的template会被编译为<strong>render</strong>函数，<strong>render</strong>执行，访问了<strong>sum.value</strong>，触发了收集，此时收集的副作用为<strong>render effect</strong>, 会执行<strong>ComputedRefImpl.value getter</strong>，此时的<strong>self._dirty &#x3D; true</strong>执行<strong>effect.run()<strong>也就是执行了</strong>computed.value getter</strong>函数，得到**_value &#x3D; 1**</li>\n<li><strong>computed.value getter</strong>函数体内访问了<strong>a.value</strong>触发了对<strong>a</strong>的依赖收集，此时收集到的依赖为<strong>computed effect</strong>。</li>\n<li>按钮点击后，执行<strong>add</strong>更新了<strong>a.value</strong>值触发了<strong>computed effect</strong>的<strong>trigger</strong>，也就是执行<strong>render</strong>。</li>\n<li>执行<strong>render</strong>会访问<strong>ComputedRefImpl.value getter</strong>, 会执行<strong>computed effect.run()<strong>触发</strong>computed.value getter</strong>函数的执行。因为此时的**_dirty &#x3D; true**, 所以<strong>get value</strong>会重新计算**_value<strong>的值为</strong>sum.value &#x3D; 3**。</li>\n<li><strong>sum.value</strong>的值变化后，触发了<strong>triggerRefvalue</strong>, 即<strong>render</strong>会重新执行。</li>\n</ol>\n"},{"title":"响应式原理：ReactiveEffect响应式副作用探秘","_content":"\n响应式对象中的执行函数、响应式触发器、调度器都是由**reactiveEffect**类进行管理的，学习本章，你将会明白**effect**、**computed**、**doWatch**、**setupRenderEffect**是如何通过**reativeEffect**控制执行函数、响应式触发器、调度器的执行时机的。\n\n### ReactiveEffect\n\n源码定义\n\n```javascript\nexport class ReactiveEffect {\n    constructor(fn, trigger, scheduler, scope) {\n        this.fn = fn;\n        this.trigger = trigger;\n        this.scheduler = scheduler;\n\n        this._runnings = 0; // 运行时状态 \n        this._trackId = 0; // 依赖标识\n        this._depsLength = 0; // 绑定该effect的deps长度\n        this.deps = []; // 绑定该effect的deps\n        recordEffectScope(this, scope); // 记录副作用范围\n    }\n\n    run() {\n        this._dirtyLevel = DirtyLevels.NotDirty; // 设置脏值等级\n        if (!this.active) {\n            return this.fn(); // 若副作用函数不在响应式上下文中，则执行fn不收集依赖\n        }\n\n        let lastShouldTrack = shouldTrack; // 解决effect嵌套\n        let lastEffect = activeEffect; // 解决effect嵌套\n        try {\n            shouldTrack = true;\n            activeEffect = this; // 记录活动副作用实例\n            this._runnings++;\n            preCleanupEffect(this); // 属性初始化\n            return this.fn(); // 运行回调函数（依赖收集，依赖清理）\n        } finally {\n            postCleanupEffect(this); // 依赖清理\n            this._runnings--;\n            activeEffect = lastEffect;\n            shouldTrack = lastShouldTrack;\n        }\n    }\n}\n```\n\n**run**接口的主要逻辑是处理先处理**fn**不在响应式上下文的情况，然后初始化**lastShouldTrack、lastEffect**解决effect嵌套问题，其次一些状态的初始化，包括**shouldTrack**、**activeEffect**、**_running**、**deps**、**_depsLength**。\n\n初始化属性后执行**fn**触发依赖收集，\n\n最后执行完依赖清理后，重置部分状态，重置状态包括**_running**、**activeEffect**、**shouldTrack**。\n\n我们来看一下**preCleanupEffect**和**postCleanupEffect**的实现\n\n```javascript\nfunction preCleanupEffect(effect) {\n    // 属性处理\n    effect._trackId++;\n    effect._depsLength = 0;\n}\n\nfunction postCleanupEffect(effect) {\n    // 清楚依赖副作用\n    if (effect.deps.length > effect._depsLength) {\n        for (let i = effect._depsLength; i < effect.deps.length; i++) {\n            cleanupDepEffect(effect.deps[i], effect);\n        }\n    }\n}\n```\n\n可以看到**preCleanupEffect**只是做了一些属性的初始化，**postCleanupEffect**遍历绑定当前**effect**的dep，清理**dep**下的**effect**。\n\n```javascript\nfunction cleanupDepEffect(dep, effect) {\n    const trackId = dep.get(effect); // 获取依赖标识\n    if (trackId !== undefined && effect._trackId !== trackId) {\n        dep.delete(effect); // 依赖删除\n        if (dep.size === 0) {\n            dep.cleanup(); // 执行回调\n        }\n    }\n}\n```\n\n\n\n### effect\n\n```javascript\nexport function effect(fn, options) {\n    // 如果 fn 已经是一个 effect 函数了，则指向原始函数\n    if (fn.effect instanceof ReactiveEffect) {\n        fn = fn.effect.fn;\n    }\n\n    // 初始化响应式副作用实例\n    const _effect = new ReactiveEffect(fn, NOOP, () => {\n        if (_effect.dirty) {\n            _effect.run();\n        }\n    })\n\n    // 选项逻辑处理\n    if (options) {\n        extend(_effect, options); // 合并对象\n        if (options.scope) recordEffectScope(_effect, options.scope); // 记录副作用范围\n    }\n\n    /// 副作用运行\n    if (!options || !options.lazy) {\n        _effect.run();\n    }\n\n    const runner = _effect.run.bind(_effect);\n    runner.effect = _effect;\n    return runner; // 返回运行器\n}\n```\n\n**effect**通过传入一个调度器执行fn\n\n### ComputedRefImpl\n\n```javascript\nexport class ComputedRefImpl {\n    constructor(getter, _setter, isReadonly, isSSR) {\n        // 实例化副作用\n        this.effect = new ReactiveEffect(\n            () => getter(this._value),\n            () => triggerRefValue(\n                this,\n                this.effect._dirtyLevel === DirtyLevels.MaybeDirty_ComputedSideEffect\n                    ? DirtyLevels.MaybeDirty_ComputedSideEffect\n                    : DirtyLevels.MaybeDirty,\n            )\n        );\n    }\n\n    get value() {\n        const self = toRaw(this);\n        self._value = self.effect.run();\n\n        return self._value;\n    }\n}\n```\n\n**ComputedRefImpl.value getter**执行**effect.run**后，执行**computed.value getter**触发响应式依赖收集，响应式变量更新后执行**computed effect**响应\n\n### doWatch\n```javascript\nconst effect = new ReactiveEffect(getter, NOOP, scheduler)\n```\n\n### setupRenderEffect\n```javascript\nconst effect = (instance.effect = new ReactiveEffect(\n      componentUpdateFn,\n      NOOP,\n      () => queueJob(update),\n      instance.scope, // track it in component's effect scope\n    ))\n```","source":"_posts/源码/vue3/effect.md","raw":"---\ntitle: 响应式原理：ReactiveEffect响应式副作用探秘\n---\n\n响应式对象中的执行函数、响应式触发器、调度器都是由**reactiveEffect**类进行管理的，学习本章，你将会明白**effect**、**computed**、**doWatch**、**setupRenderEffect**是如何通过**reativeEffect**控制执行函数、响应式触发器、调度器的执行时机的。\n\n### ReactiveEffect\n\n源码定义\n\n```javascript\nexport class ReactiveEffect {\n    constructor(fn, trigger, scheduler, scope) {\n        this.fn = fn;\n        this.trigger = trigger;\n        this.scheduler = scheduler;\n\n        this._runnings = 0; // 运行时状态 \n        this._trackId = 0; // 依赖标识\n        this._depsLength = 0; // 绑定该effect的deps长度\n        this.deps = []; // 绑定该effect的deps\n        recordEffectScope(this, scope); // 记录副作用范围\n    }\n\n    run() {\n        this._dirtyLevel = DirtyLevels.NotDirty; // 设置脏值等级\n        if (!this.active) {\n            return this.fn(); // 若副作用函数不在响应式上下文中，则执行fn不收集依赖\n        }\n\n        let lastShouldTrack = shouldTrack; // 解决effect嵌套\n        let lastEffect = activeEffect; // 解决effect嵌套\n        try {\n            shouldTrack = true;\n            activeEffect = this; // 记录活动副作用实例\n            this._runnings++;\n            preCleanupEffect(this); // 属性初始化\n            return this.fn(); // 运行回调函数（依赖收集，依赖清理）\n        } finally {\n            postCleanupEffect(this); // 依赖清理\n            this._runnings--;\n            activeEffect = lastEffect;\n            shouldTrack = lastShouldTrack;\n        }\n    }\n}\n```\n\n**run**接口的主要逻辑是处理先处理**fn**不在响应式上下文的情况，然后初始化**lastShouldTrack、lastEffect**解决effect嵌套问题，其次一些状态的初始化，包括**shouldTrack**、**activeEffect**、**_running**、**deps**、**_depsLength**。\n\n初始化属性后执行**fn**触发依赖收集，\n\n最后执行完依赖清理后，重置部分状态，重置状态包括**_running**、**activeEffect**、**shouldTrack**。\n\n我们来看一下**preCleanupEffect**和**postCleanupEffect**的实现\n\n```javascript\nfunction preCleanupEffect(effect) {\n    // 属性处理\n    effect._trackId++;\n    effect._depsLength = 0;\n}\n\nfunction postCleanupEffect(effect) {\n    // 清楚依赖副作用\n    if (effect.deps.length > effect._depsLength) {\n        for (let i = effect._depsLength; i < effect.deps.length; i++) {\n            cleanupDepEffect(effect.deps[i], effect);\n        }\n    }\n}\n```\n\n可以看到**preCleanupEffect**只是做了一些属性的初始化，**postCleanupEffect**遍历绑定当前**effect**的dep，清理**dep**下的**effect**。\n\n```javascript\nfunction cleanupDepEffect(dep, effect) {\n    const trackId = dep.get(effect); // 获取依赖标识\n    if (trackId !== undefined && effect._trackId !== trackId) {\n        dep.delete(effect); // 依赖删除\n        if (dep.size === 0) {\n            dep.cleanup(); // 执行回调\n        }\n    }\n}\n```\n\n\n\n### effect\n\n```javascript\nexport function effect(fn, options) {\n    // 如果 fn 已经是一个 effect 函数了，则指向原始函数\n    if (fn.effect instanceof ReactiveEffect) {\n        fn = fn.effect.fn;\n    }\n\n    // 初始化响应式副作用实例\n    const _effect = new ReactiveEffect(fn, NOOP, () => {\n        if (_effect.dirty) {\n            _effect.run();\n        }\n    })\n\n    // 选项逻辑处理\n    if (options) {\n        extend(_effect, options); // 合并对象\n        if (options.scope) recordEffectScope(_effect, options.scope); // 记录副作用范围\n    }\n\n    /// 副作用运行\n    if (!options || !options.lazy) {\n        _effect.run();\n    }\n\n    const runner = _effect.run.bind(_effect);\n    runner.effect = _effect;\n    return runner; // 返回运行器\n}\n```\n\n**effect**通过传入一个调度器执行fn\n\n### ComputedRefImpl\n\n```javascript\nexport class ComputedRefImpl {\n    constructor(getter, _setter, isReadonly, isSSR) {\n        // 实例化副作用\n        this.effect = new ReactiveEffect(\n            () => getter(this._value),\n            () => triggerRefValue(\n                this,\n                this.effect._dirtyLevel === DirtyLevels.MaybeDirty_ComputedSideEffect\n                    ? DirtyLevels.MaybeDirty_ComputedSideEffect\n                    : DirtyLevels.MaybeDirty,\n            )\n        );\n    }\n\n    get value() {\n        const self = toRaw(this);\n        self._value = self.effect.run();\n\n        return self._value;\n    }\n}\n```\n\n**ComputedRefImpl.value getter**执行**effect.run**后，执行**computed.value getter**触发响应式依赖收集，响应式变量更新后执行**computed effect**响应\n\n### doWatch\n```javascript\nconst effect = new ReactiveEffect(getter, NOOP, scheduler)\n```\n\n### setupRenderEffect\n```javascript\nconst effect = (instance.effect = new ReactiveEffect(\n      componentUpdateFn,\n      NOOP,\n      () => queueJob(update),\n      instance.scope, // track it in component's effect scope\n    ))\n```","slug":"源码/vue3/effect","published":1,"date":"2024-04-03T03:26:32.142Z","updated":"2024-04-03T14:06:34.197Z","_id":"cluj8y5wa00007wgmccm88l01","comments":1,"layout":"post","photos":[],"link":"","content":"<p>响应式对象中的执行函数、响应式触发器、调度器都是由<strong>reactiveEffect</strong>类进行管理的，学习本章，你将会明白<strong>effect</strong>、<strong>computed</strong>、<strong>doWatch</strong>、<strong>setupRenderEffect</strong>是如何通过<strong>reativeEffect</strong>控制执行函数、响应式触发器、调度器的执行时机的。</p>\n<h3 id=\"ReactiveEffect\"><a href=\"#ReactiveEffect\" class=\"headerlink\" title=\"ReactiveEffect\"></a>ReactiveEffect</h3><p>源码定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReactiveEffect</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">fn, trigger, scheduler, scope</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">fn</span> = fn;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">trigger</span> = trigger;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">scheduler</span> = scheduler;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_runnings</span> = <span class=\"number\">0</span>; <span class=\"comment\">// 运行时状态 </span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_trackId</span> = <span class=\"number\">0</span>; <span class=\"comment\">// 依赖标识</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_depsLength</span> = <span class=\"number\">0</span>; <span class=\"comment\">// 绑定该effect的deps长度</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">deps</span> = []; <span class=\"comment\">// 绑定该effect的deps</span></span><br><span class=\"line\">        <span class=\"title function_\">recordEffectScope</span>(<span class=\"variable language_\">this</span>, scope); <span class=\"comment\">// 记录副作用范围</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">run</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_dirtyLevel</span> = <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">NotDirty</span>; <span class=\"comment\">// 设置脏值等级</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"variable language_\">this</span>.<span class=\"property\">active</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">fn</span>(); <span class=\"comment\">// 若副作用函数不在响应式上下文中，则执行fn不收集依赖</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> lastShouldTrack = shouldTrack; <span class=\"comment\">// 解决effect嵌套</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> lastEffect = activeEffect; <span class=\"comment\">// 解决effect嵌套</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            shouldTrack = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            activeEffect = <span class=\"variable language_\">this</span>; <span class=\"comment\">// 记录活动副作用实例</span></span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">_runnings</span>++;</span><br><span class=\"line\">            <span class=\"title function_\">preCleanupEffect</span>(<span class=\"variable language_\">this</span>); <span class=\"comment\">// 属性初始化</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">fn</span>(); <span class=\"comment\">// 运行回调函数（依赖收集，依赖清理）</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"title function_\">postCleanupEffect</span>(<span class=\"variable language_\">this</span>); <span class=\"comment\">// 依赖清理</span></span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">_runnings</span>--;</span><br><span class=\"line\">            activeEffect = lastEffect;</span><br><span class=\"line\">            shouldTrack = lastShouldTrack;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>run</strong>接口的主要逻辑是处理先处理<strong>fn</strong>不在响应式上下文的情况，然后初始化<strong>lastShouldTrack、lastEffect</strong>解决effect嵌套问题，其次一些状态的初始化，包括<strong>shouldTrack</strong>、<strong>activeEffect</strong>、**_running<strong>、</strong>deps<strong>、</strong>_depsLength**。</p>\n<p>初始化属性后执行<strong>fn</strong>触发依赖收集，</p>\n<p>最后执行完依赖清理后，重置部分状态，重置状态包括**_running<strong>、</strong>activeEffect<strong>、</strong>shouldTrack**。</p>\n<p>我们来看一下<strong>preCleanupEffect</strong>和<strong>postCleanupEffect</strong>的实现</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">preCleanupEffect</span>(<span class=\"params\">effect</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 属性处理</span></span><br><span class=\"line\">    effect.<span class=\"property\">_trackId</span>++;</span><br><span class=\"line\">    effect.<span class=\"property\">_depsLength</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">postCleanupEffect</span>(<span class=\"params\">effect</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 清楚依赖副作用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (effect.<span class=\"property\">deps</span>.<span class=\"property\">length</span> &gt; effect.<span class=\"property\">_depsLength</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = effect.<span class=\"property\">_depsLength</span>; i &lt; effect.<span class=\"property\">deps</span>.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">cleanupDepEffect</span>(effect.<span class=\"property\">deps</span>[i], effect);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到<strong>preCleanupEffect</strong>只是做了一些属性的初始化，<strong>postCleanupEffect</strong>遍历绑定当前<strong>effect</strong>的dep，清理<strong>dep</strong>下的<strong>effect</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">cleanupDepEffect</span>(<span class=\"params\">dep, effect</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> trackId = dep.<span class=\"title function_\">get</span>(effect); <span class=\"comment\">// 获取依赖标识</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (trackId !== <span class=\"literal\">undefined</span> &amp;&amp; effect.<span class=\"property\">_trackId</span> !== trackId) &#123;</span><br><span class=\"line\">        dep.<span class=\"title function_\">delete</span>(effect); <span class=\"comment\">// 依赖删除</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dep.<span class=\"property\">size</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            dep.<span class=\"title function_\">cleanup</span>(); <span class=\"comment\">// 执行回调</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"effect\"><a href=\"#effect\" class=\"headerlink\" title=\"effect\"></a>effect</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">effect</span>(<span class=\"params\">fn, options</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 fn 已经是一个 effect 函数了，则指向原始函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fn.<span class=\"property\">effect</span> <span class=\"keyword\">instanceof</span> <span class=\"title class_\">ReactiveEffect</span>) &#123;</span><br><span class=\"line\">        fn = fn.<span class=\"property\">effect</span>.<span class=\"property\">fn</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化响应式副作用实例</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> _effect = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(fn, <span class=\"variable constant_\">NOOP</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_effect.<span class=\"property\">dirty</span>) &#123;</span><br><span class=\"line\">            _effect.<span class=\"title function_\">run</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 选项逻辑处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">extend</span>(_effect, options); <span class=\"comment\">// 合并对象</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (options.<span class=\"property\">scope</span>) <span class=\"title function_\">recordEffectScope</span>(_effect, options.<span class=\"property\">scope</span>); <span class=\"comment\">// 记录副作用范围</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// 副作用运行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!options || !options.<span class=\"property\">lazy</span>) &#123;</span><br><span class=\"line\">        _effect.<span class=\"title function_\">run</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> runner = _effect.<span class=\"property\">run</span>.<span class=\"title function_\">bind</span>(_effect);</span><br><span class=\"line\">    runner.<span class=\"property\">effect</span> = _effect;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> runner; <span class=\"comment\">// 返回运行器</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>effect</strong>通过传入一个调度器执行fn</p>\n<h3 id=\"ComputedRefImpl\"><a href=\"#ComputedRefImpl\" class=\"headerlink\" title=\"ComputedRefImpl\"></a>ComputedRefImpl</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ComputedRefImpl</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">getter, _setter, isReadonly, isSSR</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 实例化副作用</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">effect</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(</span><br><span class=\"line\">            <span class=\"function\">() =&gt;</span> <span class=\"title function_\">getter</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">_value</span>),</span><br><span class=\"line\">            <span class=\"function\">() =&gt;</span> <span class=\"title function_\">triggerRefValue</span>(</span><br><span class=\"line\">                <span class=\"variable language_\">this</span>,</span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"property\">effect</span>.<span class=\"property\">_dirtyLevel</span> === <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">MaybeDirty_ComputedSideEffect</span></span><br><span class=\"line\">                    ? <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">MaybeDirty_ComputedSideEffect</span></span><br><span class=\"line\">                    : <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">MaybeDirty</span>,</span><br><span class=\"line\">            )</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> self = <span class=\"title function_\">toRaw</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">        self.<span class=\"property\">_value</span> = self.<span class=\"property\">effect</span>.<span class=\"title function_\">run</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.<span class=\"property\">_value</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ComputedRefImpl.value getter</strong>执行<strong>effect.run</strong>后，执行<strong>computed.value getter</strong>触发响应式依赖收集，响应式变量更新后执行<strong>computed effect</strong>响应</p>\n<h3 id=\"doWatch\"><a href=\"#doWatch\" class=\"headerlink\" title=\"doWatch\"></a>doWatch</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> effect = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(getter, <span class=\"variable constant_\">NOOP</span>, scheduler)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"setupRenderEffect\"><a href=\"#setupRenderEffect\" class=\"headerlink\" title=\"setupRenderEffect\"></a>setupRenderEffect</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> effect = (instance.<span class=\"property\">effect</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(</span><br><span class=\"line\">      componentUpdateFn,</span><br><span class=\"line\">      <span class=\"variable constant_\">NOOP</span>,</span><br><span class=\"line\">      <span class=\"function\">() =&gt;</span> <span class=\"title function_\">queueJob</span>(update),</span><br><span class=\"line\">      instance.<span class=\"property\">scope</span>, <span class=\"comment\">// track it in component&#x27;s effect scope</span></span><br><span class=\"line\">    ))</span><br></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":"<p>响应式对象中的执行函数、响应式触发器、调度器都是由<strong>reactiveEffect</strong>类进行管理的，学习本章，你将会明白<strong>effect</strong>、<strong>computed</strong>、<strong>doWatch</strong>、<strong>setupRenderEffect</strong>是如何通过<strong>reativeEffect</strong>控制执行函数、响应式触发器、调度器的执行时机的。</p>\n<h3 id=\"ReactiveEffect\"><a href=\"#ReactiveEffect\" class=\"headerlink\" title=\"ReactiveEffect\"></a>ReactiveEffect</h3><p>源码定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReactiveEffect</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">fn, trigger, scheduler, scope</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">fn</span> = fn;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">trigger</span> = trigger;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">scheduler</span> = scheduler;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_runnings</span> = <span class=\"number\">0</span>; <span class=\"comment\">// 运行时状态 </span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_trackId</span> = <span class=\"number\">0</span>; <span class=\"comment\">// 依赖标识</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_depsLength</span> = <span class=\"number\">0</span>; <span class=\"comment\">// 绑定该effect的deps长度</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">deps</span> = []; <span class=\"comment\">// 绑定该effect的deps</span></span><br><span class=\"line\">        <span class=\"title function_\">recordEffectScope</span>(<span class=\"variable language_\">this</span>, scope); <span class=\"comment\">// 记录副作用范围</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">run</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_dirtyLevel</span> = <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">NotDirty</span>; <span class=\"comment\">// 设置脏值等级</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"variable language_\">this</span>.<span class=\"property\">active</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">fn</span>(); <span class=\"comment\">// 若副作用函数不在响应式上下文中，则执行fn不收集依赖</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> lastShouldTrack = shouldTrack; <span class=\"comment\">// 解决effect嵌套</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> lastEffect = activeEffect; <span class=\"comment\">// 解决effect嵌套</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            shouldTrack = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            activeEffect = <span class=\"variable language_\">this</span>; <span class=\"comment\">// 记录活动副作用实例</span></span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">_runnings</span>++;</span><br><span class=\"line\">            <span class=\"title function_\">preCleanupEffect</span>(<span class=\"variable language_\">this</span>); <span class=\"comment\">// 属性初始化</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">fn</span>(); <span class=\"comment\">// 运行回调函数（依赖收集，依赖清理）</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"title function_\">postCleanupEffect</span>(<span class=\"variable language_\">this</span>); <span class=\"comment\">// 依赖清理</span></span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">_runnings</span>--;</span><br><span class=\"line\">            activeEffect = lastEffect;</span><br><span class=\"line\">            shouldTrack = lastShouldTrack;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>run</strong>接口的主要逻辑是处理先处理<strong>fn</strong>不在响应式上下文的情况，然后初始化<strong>lastShouldTrack、lastEffect</strong>解决effect嵌套问题，其次一些状态的初始化，包括<strong>shouldTrack</strong>、<strong>activeEffect</strong>、**_running<strong>、</strong>deps<strong>、</strong>_depsLength**。</p>\n<p>初始化属性后执行<strong>fn</strong>触发依赖收集，</p>\n<p>最后执行完依赖清理后，重置部分状态，重置状态包括**_running<strong>、</strong>activeEffect<strong>、</strong>shouldTrack**。</p>\n<p>我们来看一下<strong>preCleanupEffect</strong>和<strong>postCleanupEffect</strong>的实现</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">preCleanupEffect</span>(<span class=\"params\">effect</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 属性处理</span></span><br><span class=\"line\">    effect.<span class=\"property\">_trackId</span>++;</span><br><span class=\"line\">    effect.<span class=\"property\">_depsLength</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">postCleanupEffect</span>(<span class=\"params\">effect</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 清楚依赖副作用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (effect.<span class=\"property\">deps</span>.<span class=\"property\">length</span> &gt; effect.<span class=\"property\">_depsLength</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = effect.<span class=\"property\">_depsLength</span>; i &lt; effect.<span class=\"property\">deps</span>.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">cleanupDepEffect</span>(effect.<span class=\"property\">deps</span>[i], effect);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到<strong>preCleanupEffect</strong>只是做了一些属性的初始化，<strong>postCleanupEffect</strong>遍历绑定当前<strong>effect</strong>的dep，清理<strong>dep</strong>下的<strong>effect</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">cleanupDepEffect</span>(<span class=\"params\">dep, effect</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> trackId = dep.<span class=\"title function_\">get</span>(effect); <span class=\"comment\">// 获取依赖标识</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (trackId !== <span class=\"literal\">undefined</span> &amp;&amp; effect.<span class=\"property\">_trackId</span> !== trackId) &#123;</span><br><span class=\"line\">        dep.<span class=\"title function_\">delete</span>(effect); <span class=\"comment\">// 依赖删除</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dep.<span class=\"property\">size</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            dep.<span class=\"title function_\">cleanup</span>(); <span class=\"comment\">// 执行回调</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"effect\"><a href=\"#effect\" class=\"headerlink\" title=\"effect\"></a>effect</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">effect</span>(<span class=\"params\">fn, options</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 fn 已经是一个 effect 函数了，则指向原始函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fn.<span class=\"property\">effect</span> <span class=\"keyword\">instanceof</span> <span class=\"title class_\">ReactiveEffect</span>) &#123;</span><br><span class=\"line\">        fn = fn.<span class=\"property\">effect</span>.<span class=\"property\">fn</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化响应式副作用实例</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> _effect = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(fn, <span class=\"variable constant_\">NOOP</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_effect.<span class=\"property\">dirty</span>) &#123;</span><br><span class=\"line\">            _effect.<span class=\"title function_\">run</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 选项逻辑处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">extend</span>(_effect, options); <span class=\"comment\">// 合并对象</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (options.<span class=\"property\">scope</span>) <span class=\"title function_\">recordEffectScope</span>(_effect, options.<span class=\"property\">scope</span>); <span class=\"comment\">// 记录副作用范围</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// 副作用运行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!options || !options.<span class=\"property\">lazy</span>) &#123;</span><br><span class=\"line\">        _effect.<span class=\"title function_\">run</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> runner = _effect.<span class=\"property\">run</span>.<span class=\"title function_\">bind</span>(_effect);</span><br><span class=\"line\">    runner.<span class=\"property\">effect</span> = _effect;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> runner; <span class=\"comment\">// 返回运行器</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>effect</strong>通过传入一个调度器执行fn</p>\n<h3 id=\"ComputedRefImpl\"><a href=\"#ComputedRefImpl\" class=\"headerlink\" title=\"ComputedRefImpl\"></a>ComputedRefImpl</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ComputedRefImpl</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">getter, _setter, isReadonly, isSSR</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 实例化副作用</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">effect</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(</span><br><span class=\"line\">            <span class=\"function\">() =&gt;</span> <span class=\"title function_\">getter</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">_value</span>),</span><br><span class=\"line\">            <span class=\"function\">() =&gt;</span> <span class=\"title function_\">triggerRefValue</span>(</span><br><span class=\"line\">                <span class=\"variable language_\">this</span>,</span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"property\">effect</span>.<span class=\"property\">_dirtyLevel</span> === <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">MaybeDirty_ComputedSideEffect</span></span><br><span class=\"line\">                    ? <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">MaybeDirty_ComputedSideEffect</span></span><br><span class=\"line\">                    : <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">MaybeDirty</span>,</span><br><span class=\"line\">            )</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> self = <span class=\"title function_\">toRaw</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">        self.<span class=\"property\">_value</span> = self.<span class=\"property\">effect</span>.<span class=\"title function_\">run</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.<span class=\"property\">_value</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ComputedRefImpl.value getter</strong>执行<strong>effect.run</strong>后，执行<strong>computed.value getter</strong>触发响应式依赖收集，响应式变量更新后执行<strong>computed effect</strong>响应</p>\n<h3 id=\"doWatch\"><a href=\"#doWatch\" class=\"headerlink\" title=\"doWatch\"></a>doWatch</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> effect = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(getter, <span class=\"variable constant_\">NOOP</span>, scheduler)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"setupRenderEffect\"><a href=\"#setupRenderEffect\" class=\"headerlink\" title=\"setupRenderEffect\"></a>setupRenderEffect</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> effect = (instance.<span class=\"property\">effect</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(</span><br><span class=\"line\">      componentUpdateFn,</span><br><span class=\"line\">      <span class=\"variable constant_\">NOOP</span>,</span><br><span class=\"line\">      <span class=\"function\">() =&gt;</span> <span class=\"title function_\">queueJob</span>(update),</span><br><span class=\"line\">      instance.<span class=\"property\">scope</span>, <span class=\"comment\">// track it in component&#x27;s effect scope</span></span><br><span class=\"line\">    ))</span><br></pre></td></tr></table></figure>"},{"title":"响应式原理：Dep（响应式对象的依赖管理器）","_content":"\n### 前言\n\n在本章开始之前，需要有一个前置认知：Vue响应式的核心就是响应式对象和函数，对象改变，函数执行。在响应式中，dep起到是一个中间者的角色，看完本章，你将会明白**reactive**、**ref**响应式对象是如何通过**dep**通知函数的执行的。\n\ndep实际上是一个map对象，键是effect对象，值为依赖标识。\n\n```javascript\nexport const createDep = (cleanup, computed) => {\n    const dep = new Map();\n    dep.cleanup = cleanup;\n    dep.computed = computed;\n}\n```\n\n不同的响应式对象会创建用于存储**dep**的不同的数据结构，并使用**dep**进行通知函数执行，我们先来看一下**reactive**对象的dep结构创建以及函数调用通知过程。\n\n### ref\n\n#### 依赖收集（对象构建）\n\n让我看一下**ref**创建用于存储**dep**的不同的数据结构的流程。\n\n\n```javascript\nlet shouldTrack = true;\nlet activeEffect; // ReactiveEffect实例\n\nconst targetMap = new WeakMap();\nexport function track(target, type, key) {\n    if (shouldTrack && activeEffect) {\n        let depsMap = targetMap.get(target);\n\n        // 初始化依赖映射\n        if (!depsMap) {\n            targetMap.set(target, (depsMap = new Map()));\n        }\n\n        let dep = depsMap.get(key);\n        // 设置依赖\n        if (!dep) {\n            depsMap.set(key, (dep = createDep(() => depsMap.delete(key))));\n        }\n\n        // 收集副作用\n        trackEffect(activeEffect, dep);\n    }\n}\n\nexport function trackEffect(effect, dep, debuggerEventExtraInfo) {\n    if (dep.get(effect) !== effect._trackId) { // effect._trackId 在ReactiveEffect.run时设置\n        dep.set(effect, effect._trackId); // 设置副作用标识\n        const oldDep = effect.deps[effect._depslength];\n        if (oldDep !== dep) {\n            if (oldDep) {\n                cleanupDepEffect(oldDep, effect); // 清理dep下的副作用\n            }\n            effect.deps[effect._depslength++] = dep; // 标识副作用绑定到哪个dep\n        } else {\n            effect._depslength++; // 标识副作用绑定到多少dep下\n        }\n    }\n}\n```\n\n上面函数有点绕，其实核心就是在生成一个数据结构，什么样的数据结构呢？我们来画个图看看：\n\n![Imgur](https://i.imgur.com/X7hex8a.png)\n\n我们创建了全局的**targetMap**，它的键是**target**，值是**depsMap**；这个**depsMap**的键是**target**的**key**，值是**dep**集合，**dep**集合中存储的是依赖的副作用函数**effect**。\n\n#### 响应处理（函数执行）\n\n看一下源码定义\n\n```javascript\n\nexport function trigger(target, type, key, newValue, oldValue, oldTarget) {\n    const depsMap = targetMap.get(target);\n\n    // 处理未收集\n    if (!depsMap) {\n        return\n    }\n\n    let deps = []; // 需要被处理依赖\n    if (type === TriggerOpTypes.CLEAR) { // 操作为清理 \n        deps = [...depsMap.values()];\n    } else if (key === 'length' && isArray(target)) {\n        const newLength = Number(newValue);\n        depsMap.forEach((dep, key) => {\n            if (key === 'length' || (!isSymbol(key) && key >= newLength)) {\n                deps.push(dep);\n            }\n        });\n    } else {\n        if (key !== void 0) {\n            deps.push(depsMap.get(key));\n        }\n\n        switch (type) {\n            case TriggerOpTypes.ADD:\n                if (!isArray(target)) {\n                    deps.push(depsMap.get(ITERACE_KEY)); // 暂不理解\n                    if (isMap(target)) {\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY)); // 暂不理解\n                    }\n                } else if (isIntegerKey(key)) {\n                    deps.push(depsMap.get('length')); // // 暂不理解\n                }\n\n                break;\n            case TriggerOpTypes.DELETE:\n                if ((!isArray(target))) {\n                    deps.push(depsMap.get(ITERACE_KEY)); // 暂不理解\n                    if (isMap(target)) {\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY)); // 暂不理解\n                    }\n                }\n\n                break;\n            case TriggerOptypes.SET:\n                if (isMap(target)) {\n                    deps.push(depsMap.get(ITERACE_KEY)); // 暂不理解\n                }\n        }\n    }\n\n    // 暂停调度\n    pauseScheduling();\n\n    // 遍历依赖，执行副作用\n    for (const dep of deps) {\n        if (dep) {\n            triggerEffects(dep, DirtyLevels.Dirty)\n        }\n    }\n\n    // 重置调调\n    resetScheduling();\n}\n```\n\n述代码的核心流程就是获取需要响应的依赖，首先处理预留清理响应操作类型，所有依赖都需要被清理，其次修改属性为**length**且**target**为数组时，访问**length**属性的依赖以及数组中超过新数组长度的元素依赖需要被清理。获取需要响应的依赖后，暂停全局调度后，遍历执行**triggerEffects**，最后重置调度。\n\n我们来看一下**triggerEffects**的实现\n\n```javascript\nexport function triggerEffects(dep, dirtyLevels, debuggerEventExtraInfo) {\n    pasuScheduling(); // 暂停全局调度\n    // 遍历dep\n    for (const effect of dep.keys()) {\n        let tracking;\n        if (\n            effect._dirtyLevel < dirtyLevel &&\n            (tracking ??= dep.get(effect) === effect._trackId)\n        ) {\n            effect._shouldSchedule ||= effect._dirtyLevel === dirtyLevels.NotDirty;\n            effect._dirtyLevel = dirtyLevel;\n        }\n\n        if (\n            effect._shouldSchedule &&\n            (tracking ??= dep.get(effect === effect._trackId) === effect._trackId)\n        ) {\n            effect.trigger(); // 执行函数\n\n            if (!effect._runnings || effect.allRecurse &&\n                effect._dirtyLevel !== dirtyLevels.MaybeDirty_ComputedSideEffect\n            ) { // 副作用不在运行中或者副作用允许递归且_dirtyLevel值不为2\n                effect._shouldSchedule = false;\n\n                if (effect.scheduler) {\n                    queueEffectSchedulers.push(effect.scheduler);\n                }\n            }\n        }\n    }\n    resetScheduling(); // 执行调度\n}\n```\n\n上述代码的主要逻辑是，先暂停全局调度，然后遍历副作用对象，更新**_shouldSchedule**标识，然后根据**_shouldSchedule**判断是否执行调度函数，最后重新执行全局调度。\n\n到这里我们就解析完**reactive**对象所创建用于存储**dep**的数据结构，以及**dep**进行通知函数执行的过程了。\n\n### ref\n\n#### 依赖收集（对象构建）\n\n让我看一下**ref**创建用于存储**dep**的不同的数据结构流程。\n\n```javascript\nexport function trackRefValue(ref) {\n    if (shouldTrack && activeEffect) {\n        ref = toRaw(ref);\n        ref.dep ??= createDep(() => (ref.dep = undefined), ref instanceof ComputedRefImpl ? ref : undefined);\n        trackEffect(activeEffect, ref.dep);\n    }\n}\n```\n\n可以发现，**ref**并没有创建额外的变量用于存储**dep**而是直接绑定到dep属性下面，然后复用**trackEffect**逻辑进行依赖收集。\n\n#### 响应处理（函数执行）\n看一下源码定义\n\n```javascript\nexport function triggerRefValue(ref, dirtyLevel, newValue) {\n    ref = toRaw(ref);\n    const dep = ref.dep;\n    if (dep) {\n        triggerEffects(dep, dirtyLevel);\n    }\n}\n```\n\n可以发现，除了用于存储dep的数据结构不同外，**traEffect**以及**triggerEffects**都得到了很好的复用。","source":"_posts/源码/vue3/dep.md","raw":"---\ntitle: 响应式原理：dep（响应式对象的依赖管理器）\n---\n\n### 前言\n\n在本章开始之前，需要有一个前置认知：Vue响应式的核心就是响应式对象和函数，对象改变，函数执行。在响应式中，dep起到是一个中间者的角色，看完本章，你将会明白**reactive**、**ref**响应式对象是如何通过**dep**通知函数的执行的。\n\ndep实际上是一个map对象，键是effect对象，值为依赖标识。\n\n```javascript\nexport const createDep = (cleanup, computed) => {\n    const dep = new Map();\n    dep.cleanup = cleanup;\n    dep.computed = computed;\n}\n```\n\n不同的响应式对象会创建用于存储**dep**的不同的数据结构，并使用**dep**进行通知函数执行，我们先来看一下**reactive**对象的dep结构创建以及函数调用通知过程。\n\n### ref\n\n#### 依赖收集（对象构建）\n\n让我看一下**ref**创建用于存储**dep**的不同的数据结构的流程。\n\n\n```javascript\nlet shouldTrack = true;\nlet activeEffect; // ReactiveEffect实例\n\nconst targetMap = new WeakMap();\nexport function track(target, type, key) {\n    if (shouldTrack && activeEffect) {\n        let depsMap = targetMap.get(target);\n\n        // 初始化依赖映射\n        if (!depsMap) {\n            targetMap.set(target, (depsMap = new Map()));\n        }\n\n        let dep = depsMap.get(key);\n        // 设置依赖\n        if (!dep) {\n            depsMap.set(key, (dep = createDep(() => depsMap.delete(key))));\n        }\n\n        // 收集副作用\n        trackEffect(activeEffect, dep);\n    }\n}\n\nexport function trackEffect(effect, dep, debuggerEventExtraInfo) {\n    if (dep.get(effect) !== effect._trackId) { // effect._trackId 在ReactiveEffect.run时设置\n        dep.set(effect, effect._trackId); // 设置副作用标识\n        const oldDep = effect.deps[effect._depslength];\n        if (oldDep !== dep) {\n            if (oldDep) {\n                cleanupDepEffect(oldDep, effect); // 清理dep下的副作用\n            }\n            effect.deps[effect._depslength++] = dep; // 标识副作用绑定到哪个dep\n        } else {\n            effect._depslength++; // 标识副作用绑定到多少dep下\n        }\n    }\n}\n```\n\n上面函数有点绕，其实核心就是在生成一个数据结构，什么样的数据结构呢？我们来画个图看看：\n\n![Imgur](https://i.imgur.com/X7hex8a.png)\n\n我们创建了全局的**targetMap**，它的键是**target**，值是**depsMap**；这个**depsMap**的键是**target**的**key**，值是**dep**集合，**dep**集合中存储的是依赖的副作用函数**effect**。\n\n#### 响应处理（函数执行）\n\n看一下源码定义\n\n```javascript\n\nexport function trigger(target, type, key, newValue, oldValue, oldTarget) {\n    const depsMap = targetMap.get(target);\n\n    // 处理未收集\n    if (!depsMap) {\n        return\n    }\n\n    let deps = []; // 需要被处理依赖\n    if (type === TriggerOpTypes.CLEAR) { // 操作为清理 \n        deps = [...depsMap.values()];\n    } else if (key === 'length' && isArray(target)) {\n        const newLength = Number(newValue);\n        depsMap.forEach((dep, key) => {\n            if (key === 'length' || (!isSymbol(key) && key >= newLength)) {\n                deps.push(dep);\n            }\n        });\n    } else {\n        if (key !== void 0) {\n            deps.push(depsMap.get(key));\n        }\n\n        switch (type) {\n            case TriggerOpTypes.ADD:\n                if (!isArray(target)) {\n                    deps.push(depsMap.get(ITERACE_KEY)); // 暂不理解\n                    if (isMap(target)) {\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY)); // 暂不理解\n                    }\n                } else if (isIntegerKey(key)) {\n                    deps.push(depsMap.get('length')); // // 暂不理解\n                }\n\n                break;\n            case TriggerOpTypes.DELETE:\n                if ((!isArray(target))) {\n                    deps.push(depsMap.get(ITERACE_KEY)); // 暂不理解\n                    if (isMap(target)) {\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY)); // 暂不理解\n                    }\n                }\n\n                break;\n            case TriggerOptypes.SET:\n                if (isMap(target)) {\n                    deps.push(depsMap.get(ITERACE_KEY)); // 暂不理解\n                }\n        }\n    }\n\n    // 暂停调度\n    pauseScheduling();\n\n    // 遍历依赖，执行副作用\n    for (const dep of deps) {\n        if (dep) {\n            triggerEffects(dep, DirtyLevels.Dirty)\n        }\n    }\n\n    // 重置调调\n    resetScheduling();\n}\n```\n\n述代码的核心流程就是获取需要响应的依赖，首先处理预留清理响应操作类型，所有依赖都需要被清理，其次修改属性为**length**且**target**为数组时，访问**length**属性的依赖以及数组中超过新数组长度的元素依赖需要被清理。获取需要响应的依赖后，暂停全局调度后，遍历执行**triggerEffects**，最后重置调度。\n\n我们来看一下**triggerEffects**的实现\n\n```javascript\nexport function triggerEffects(dep, dirtyLevels, debuggerEventExtraInfo) {\n    pasuScheduling(); // 暂停全局调度\n    // 遍历dep\n    for (const effect of dep.keys()) {\n        let tracking;\n        if (\n            effect._dirtyLevel < dirtyLevel &&\n            (tracking ??= dep.get(effect) === effect._trackId)\n        ) {\n            effect._shouldSchedule ||= effect._dirtyLevel === dirtyLevels.NotDirty;\n            effect._dirtyLevel = dirtyLevel;\n        }\n\n        if (\n            effect._shouldSchedule &&\n            (tracking ??= dep.get(effect === effect._trackId) === effect._trackId)\n        ) {\n            effect.trigger(); // 执行函数\n\n            if (!effect._runnings || effect.allRecurse &&\n                effect._dirtyLevel !== dirtyLevels.MaybeDirty_ComputedSideEffect\n            ) { // 副作用不在运行中或者副作用允许递归且_dirtyLevel值不为2\n                effect._shouldSchedule = false;\n\n                if (effect.scheduler) {\n                    queueEffectSchedulers.push(effect.scheduler);\n                }\n            }\n        }\n    }\n    resetScheduling(); // 执行调度\n}\n```\n\n上述代码的主要逻辑是，先暂停全局调度，然后遍历副作用对象，更新**_shouldSchedule**标识，然后根据**_shouldSchedule**判断是否执行调度函数，最后重新执行全局调度。\n\n到这里我们就解析完**reactive**对象所创建用于存储**dep**的数据结构，以及**dep**进行通知函数执行的过程了。\n\n### ref\n\n#### 依赖收集（对象构建）\n\n让我看一下**ref**创建用于存储**dep**的不同的数据结构流程。\n\n```javascript\nexport function trackRefValue(ref) {\n    if (shouldTrack && activeEffect) {\n        ref = toRaw(ref);\n        ref.dep ??= createDep(() => (ref.dep = undefined), ref instanceof ComputedRefImpl ? ref : undefined);\n        trackEffect(activeEffect, ref.dep);\n    }\n}\n```\n\n可以发现，**ref**并没有创建额外的变量用于存储**dep**而是直接绑定到dep属性下面，然后复用**trackEffect**逻辑进行依赖收集。\n\n#### 响应处理（函数执行）\n看一下源码定义\n\n```javascript\nexport function triggerRefValue(ref, dirtyLevel, newValue) {\n    ref = toRaw(ref);\n    const dep = ref.dep;\n    if (dep) {\n        triggerEffects(dep, dirtyLevel);\n    }\n}\n```\n\n可以发现，除了用于存储dep的数据结构不同外，**traEffect**以及**triggerEffects**都得到了很好的复用。","slug":"源码/vue3/dep","published":1,"date":"2024-04-03T01:31:33.380Z","updated":"2024-04-03T03:26:02.401Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cluj8y5we00017wgmhxsw7my1","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在本章开始之前，需要有一个前置认知：Vue响应式的核心就是响应式对象和函数，对象改变，函数执行。在响应式中，dep起到是一个中间者的角色，看完本章，你将会明白<strong>reactive</strong>、<strong>ref</strong>响应式对象是如何通过<strong>dep</strong>通知函数的执行的。</p>\n<p>dep实际上是一个map对象，键是effect对象，值为依赖标识。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">createDep</span> = (<span class=\"params\">cleanup, computed</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> dep = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>();</span><br><span class=\"line\">    dep.<span class=\"property\">cleanup</span> = cleanup;</span><br><span class=\"line\">    dep.<span class=\"property\">computed</span> = computed;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不同的响应式对象会创建用于存储<strong>dep</strong>的不同的数据结构，并使用<strong>dep</strong>进行通知函数执行，我们先来看一下<strong>reactive</strong>对象的dep结构创建以及函数调用通知过程。</p>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><h4 id=\"依赖收集（对象构建）\"><a href=\"#依赖收集（对象构建）\" class=\"headerlink\" title=\"依赖收集（对象构建）\"></a>依赖收集（对象构建）</h4><p>让我看一下<strong>ref</strong>创建用于存储<strong>dep</strong>的不同的数据结构的流程。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> shouldTrack = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> activeEffect; <span class=\"comment\">// ReactiveEffect实例</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> targetMap = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakMap</span>();</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">track</span>(<span class=\"params\">target, type, key</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> depsMap = targetMap.<span class=\"title function_\">get</span>(target);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化依赖映射</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!depsMap) &#123;</span><br><span class=\"line\">            targetMap.<span class=\"title function_\">set</span>(target, (depsMap = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>()));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> dep = depsMap.<span class=\"title function_\">get</span>(key);</span><br><span class=\"line\">        <span class=\"comment\">// 设置依赖</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!dep) &#123;</span><br><span class=\"line\">            depsMap.<span class=\"title function_\">set</span>(key, (dep = <span class=\"title function_\">createDep</span>(<span class=\"function\">() =&gt;</span> depsMap.<span class=\"title function_\">delete</span>(key))));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 收集副作用</span></span><br><span class=\"line\">        <span class=\"title function_\">trackEffect</span>(activeEffect, dep);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">trackEffect</span>(<span class=\"params\">effect, dep, debuggerEventExtraInfo</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dep.<span class=\"title function_\">get</span>(effect) !== effect.<span class=\"property\">_trackId</span>) &#123; <span class=\"comment\">// effect._trackId 在ReactiveEffect.run时设置</span></span><br><span class=\"line\">        dep.<span class=\"title function_\">set</span>(effect, effect.<span class=\"property\">_trackId</span>); <span class=\"comment\">// 设置副作用标识</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> oldDep = effect.<span class=\"property\">deps</span>[effect.<span class=\"property\">_depslength</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldDep !== dep) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (oldDep) &#123;</span><br><span class=\"line\">                <span class=\"title function_\">cleanupDepEffect</span>(oldDep, effect); <span class=\"comment\">// 清理dep下的副作用</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            effect.<span class=\"property\">deps</span>[effect.<span class=\"property\">_depslength</span>++] = dep; <span class=\"comment\">// 标识副作用绑定到哪个dep</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            effect.<span class=\"property\">_depslength</span>++; <span class=\"comment\">// 标识副作用绑定到多少dep下</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面函数有点绕，其实核心就是在生成一个数据结构，什么样的数据结构呢？我们来画个图看看：</p>\n<p><img src=\"https://i.imgur.com/X7hex8a.png\" alt=\"Imgur\"></p>\n<p>我们创建了全局的<strong>targetMap</strong>，它的键是<strong>target</strong>，值是<strong>depsMap</strong>；这个<strong>depsMap</strong>的键是<strong>target</strong>的<strong>key</strong>，值是<strong>dep</strong>集合，<strong>dep</strong>集合中存储的是依赖的副作用函数<strong>effect</strong>。</p>\n<h4 id=\"响应处理（函数执行）\"><a href=\"#响应处理（函数执行）\" class=\"headerlink\" title=\"响应处理（函数执行）\"></a>响应处理（函数执行）</h4><p>看一下源码定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">trigger</span>(<span class=\"params\">target, type, key, newValue, oldValue, oldTarget</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> depsMap = targetMap.<span class=\"title function_\">get</span>(target);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 处理未收集</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!depsMap) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> deps = []; <span class=\"comment\">// 需要被处理依赖</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type === <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">CLEAR</span>) &#123; <span class=\"comment\">// 操作为清理 </span></span><br><span class=\"line\">        deps = [...depsMap.<span class=\"title function_\">values</span>()];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key === <span class=\"string\">&#x27;length&#x27;</span> &amp;&amp; <span class=\"title function_\">isArray</span>(target)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> newLength = <span class=\"title class_\">Number</span>(newValue);</span><br><span class=\"line\">        depsMap.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">dep, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key === <span class=\"string\">&#x27;length&#x27;</span> || (!<span class=\"title function_\">isSymbol</span>(key) &amp;&amp; key &gt;= newLength)) &#123;</span><br><span class=\"line\">                deps.<span class=\"title function_\">push</span>(dep);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key !== <span class=\"keyword\">void</span> <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(key));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (type) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">ADD</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!<span class=\"title function_\">isArray</span>(target)) &#123;</span><br><span class=\"line\">                    deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">ITERACE_KEY</span>)); <span class=\"comment\">// 暂不理解</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"title function_\">isMap</span>(target)) &#123;</span><br><span class=\"line\">                        deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">MAP_KEY_ITERATE_KEY</span>)); <span class=\"comment\">// 暂不理解</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isIntegerKey</span>(key)) &#123;</span><br><span class=\"line\">                    deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;length&#x27;</span>)); <span class=\"comment\">// // 暂不理解</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">DELETE</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((!<span class=\"title function_\">isArray</span>(target))) &#123;</span><br><span class=\"line\">                    deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">ITERACE_KEY</span>)); <span class=\"comment\">// 暂不理解</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"title function_\">isMap</span>(target)) &#123;</span><br><span class=\"line\">                        deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">MAP_KEY_ITERATE_KEY</span>)); <span class=\"comment\">// 暂不理解</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"title class_\">TriggerOptypes</span>.<span class=\"property\">SET</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"title function_\">isMap</span>(target)) &#123;</span><br><span class=\"line\">                    deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">ITERACE_KEY</span>)); <span class=\"comment\">// 暂不理解</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 暂停调度</span></span><br><span class=\"line\">    <span class=\"title function_\">pauseScheduling</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历依赖，执行副作用</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> dep <span class=\"keyword\">of</span> deps) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dep) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">triggerEffects</span>(dep, <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">Dirty</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重置调调</span></span><br><span class=\"line\">    <span class=\"title function_\">resetScheduling</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>述代码的核心流程就是获取需要响应的依赖，首先处理预留清理响应操作类型，所有依赖都需要被清理，其次修改属性为<strong>length</strong>且<strong>target</strong>为数组时，访问<strong>length</strong>属性的依赖以及数组中超过新数组长度的元素依赖需要被清理。获取需要响应的依赖后，暂停全局调度后，遍历执行<strong>triggerEffects</strong>，最后重置调度。</p>\n<p>我们来看一下<strong>triggerEffects</strong>的实现</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">triggerEffects</span>(<span class=\"params\">dep, dirtyLevels, debuggerEventExtraInfo</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">pasuScheduling</span>(); <span class=\"comment\">// 暂停全局调度</span></span><br><span class=\"line\">    <span class=\"comment\">// 遍历dep</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> effect <span class=\"keyword\">of</span> dep.<span class=\"title function_\">keys</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> tracking;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (</span><br><span class=\"line\">            effect.<span class=\"property\">_dirtyLevel</span> &lt; dirtyLevel &amp;&amp;</span><br><span class=\"line\">            (tracking ??= dep.<span class=\"title function_\">get</span>(effect) === effect.<span class=\"property\">_trackId</span>)</span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">            effect.<span class=\"property\">_shouldSchedule</span> ||= effect.<span class=\"property\">_dirtyLevel</span> === dirtyLevels.<span class=\"property\">NotDirty</span>;</span><br><span class=\"line\">            effect.<span class=\"property\">_dirtyLevel</span> = dirtyLevel;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (</span><br><span class=\"line\">            effect.<span class=\"property\">_shouldSchedule</span> &amp;&amp;</span><br><span class=\"line\">            (tracking ??= dep.<span class=\"title function_\">get</span>(effect === effect.<span class=\"property\">_trackId</span>) === effect.<span class=\"property\">_trackId</span>)</span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">            effect.<span class=\"title function_\">trigger</span>(); <span class=\"comment\">// 执行函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!effect.<span class=\"property\">_runnings</span> || effect.<span class=\"property\">allRecurse</span> &amp;&amp;</span><br><span class=\"line\">                effect.<span class=\"property\">_dirtyLevel</span> !== dirtyLevels.<span class=\"property\">MaybeDirty_ComputedSideEffect</span></span><br><span class=\"line\">            ) &#123; <span class=\"comment\">// 副作用不在运行中或者副作用允许递归且_dirtyLevel值不为2</span></span><br><span class=\"line\">                effect.<span class=\"property\">_shouldSchedule</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (effect.<span class=\"property\">scheduler</span>) &#123;</span><br><span class=\"line\">                    queueEffectSchedulers.<span class=\"title function_\">push</span>(effect.<span class=\"property\">scheduler</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">resetScheduling</span>(); <span class=\"comment\">// 执行调度</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码的主要逻辑是，先暂停全局调度，然后遍历副作用对象，更新**_shouldSchedule<strong>标识，然后根据</strong>_shouldSchedule**判断是否执行调度函数，最后重新执行全局调度。</p>\n<p>到这里我们就解析完<strong>reactive</strong>对象所创建用于存储<strong>dep</strong>的数据结构，以及<strong>dep</strong>进行通知函数执行的过程了。</p>\n<h3 id=\"ref-1\"><a href=\"#ref-1\" class=\"headerlink\" title=\"ref\"></a>ref</h3><h4 id=\"依赖收集（对象构建）-1\"><a href=\"#依赖收集（对象构建）-1\" class=\"headerlink\" title=\"依赖收集（对象构建）\"></a>依赖收集（对象构建）</h4><p>让我看一下<strong>ref</strong>创建用于存储<strong>dep</strong>的不同的数据结构流程。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">trackRefValue</span>(<span class=\"params\">ref</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;</span><br><span class=\"line\">        ref = <span class=\"title function_\">toRaw</span>(ref);</span><br><span class=\"line\">        ref.<span class=\"property\">dep</span> ??= <span class=\"title function_\">createDep</span>(<span class=\"function\">() =&gt;</span> (ref.<span class=\"property\">dep</span> = <span class=\"literal\">undefined</span>), ref <span class=\"keyword\">instanceof</span> <span class=\"title class_\">ComputedRefImpl</span> ? ref : <span class=\"literal\">undefined</span>);</span><br><span class=\"line\">        <span class=\"title function_\">trackEffect</span>(activeEffect, ref.<span class=\"property\">dep</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现，<strong>ref</strong>并没有创建额外的变量用于存储<strong>dep</strong>而是直接绑定到dep属性下面，然后复用<strong>trackEffect</strong>逻辑进行依赖收集。</p>\n<h4 id=\"响应处理（函数执行）-1\"><a href=\"#响应处理（函数执行）-1\" class=\"headerlink\" title=\"响应处理（函数执行）\"></a>响应处理（函数执行）</h4><p>看一下源码定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">triggerRefValue</span>(<span class=\"params\">ref, dirtyLevel, newValue</span>) &#123;</span><br><span class=\"line\">    ref = <span class=\"title function_\">toRaw</span>(ref);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> dep = ref.<span class=\"property\">dep</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dep) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">triggerEffects</span>(dep, dirtyLevel);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现，除了用于存储dep的数据结构不同外，<strong>traEffect</strong>以及<strong>triggerEffects</strong>都得到了很好的复用。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#4ebde9","excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在本章开始之前，需要有一个前置认知：Vue响应式的核心就是响应式对象和函数，对象改变，函数执行。在响应式中，dep起到是一个中间者的角色，看完本章，你将会明白<strong>reactive</strong>、<strong>ref</strong>响应式对象是如何通过<strong>dep</strong>通知函数的执行的。</p>\n<p>dep实际上是一个map对象，键是effect对象，值为依赖标识。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">createDep</span> = (<span class=\"params\">cleanup, computed</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> dep = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>();</span><br><span class=\"line\">    dep.<span class=\"property\">cleanup</span> = cleanup;</span><br><span class=\"line\">    dep.<span class=\"property\">computed</span> = computed;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不同的响应式对象会创建用于存储<strong>dep</strong>的不同的数据结构，并使用<strong>dep</strong>进行通知函数执行，我们先来看一下<strong>reactive</strong>对象的dep结构创建以及函数调用通知过程。</p>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><h4 id=\"依赖收集（对象构建）\"><a href=\"#依赖收集（对象构建）\" class=\"headerlink\" title=\"依赖收集（对象构建）\"></a>依赖收集（对象构建）</h4><p>让我看一下<strong>ref</strong>创建用于存储<strong>dep</strong>的不同的数据结构的流程。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> shouldTrack = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> activeEffect; <span class=\"comment\">// ReactiveEffect实例</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> targetMap = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakMap</span>();</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">track</span>(<span class=\"params\">target, type, key</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> depsMap = targetMap.<span class=\"title function_\">get</span>(target);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化依赖映射</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!depsMap) &#123;</span><br><span class=\"line\">            targetMap.<span class=\"title function_\">set</span>(target, (depsMap = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>()));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> dep = depsMap.<span class=\"title function_\">get</span>(key);</span><br><span class=\"line\">        <span class=\"comment\">// 设置依赖</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!dep) &#123;</span><br><span class=\"line\">            depsMap.<span class=\"title function_\">set</span>(key, (dep = <span class=\"title function_\">createDep</span>(<span class=\"function\">() =&gt;</span> depsMap.<span class=\"title function_\">delete</span>(key))));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 收集副作用</span></span><br><span class=\"line\">        <span class=\"title function_\">trackEffect</span>(activeEffect, dep);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">trackEffect</span>(<span class=\"params\">effect, dep, debuggerEventExtraInfo</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dep.<span class=\"title function_\">get</span>(effect) !== effect.<span class=\"property\">_trackId</span>) &#123; <span class=\"comment\">// effect._trackId 在ReactiveEffect.run时设置</span></span><br><span class=\"line\">        dep.<span class=\"title function_\">set</span>(effect, effect.<span class=\"property\">_trackId</span>); <span class=\"comment\">// 设置副作用标识</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> oldDep = effect.<span class=\"property\">deps</span>[effect.<span class=\"property\">_depslength</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldDep !== dep) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (oldDep) &#123;</span><br><span class=\"line\">                <span class=\"title function_\">cleanupDepEffect</span>(oldDep, effect); <span class=\"comment\">// 清理dep下的副作用</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            effect.<span class=\"property\">deps</span>[effect.<span class=\"property\">_depslength</span>++] = dep; <span class=\"comment\">// 标识副作用绑定到哪个dep</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            effect.<span class=\"property\">_depslength</span>++; <span class=\"comment\">// 标识副作用绑定到多少dep下</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面函数有点绕，其实核心就是在生成一个数据结构，什么样的数据结构呢？我们来画个图看看：</p>\n<p><img src=\"https://i.imgur.com/X7hex8a.png\" alt=\"Imgur\"></p>\n<p>我们创建了全局的<strong>targetMap</strong>，它的键是<strong>target</strong>，值是<strong>depsMap</strong>；这个<strong>depsMap</strong>的键是<strong>target</strong>的<strong>key</strong>，值是<strong>dep</strong>集合，<strong>dep</strong>集合中存储的是依赖的副作用函数<strong>effect</strong>。</p>\n<h4 id=\"响应处理（函数执行）\"><a href=\"#响应处理（函数执行）\" class=\"headerlink\" title=\"响应处理（函数执行）\"></a>响应处理（函数执行）</h4><p>看一下源码定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">trigger</span>(<span class=\"params\">target, type, key, newValue, oldValue, oldTarget</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> depsMap = targetMap.<span class=\"title function_\">get</span>(target);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 处理未收集</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!depsMap) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> deps = []; <span class=\"comment\">// 需要被处理依赖</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type === <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">CLEAR</span>) &#123; <span class=\"comment\">// 操作为清理 </span></span><br><span class=\"line\">        deps = [...depsMap.<span class=\"title function_\">values</span>()];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key === <span class=\"string\">&#x27;length&#x27;</span> &amp;&amp; <span class=\"title function_\">isArray</span>(target)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> newLength = <span class=\"title class_\">Number</span>(newValue);</span><br><span class=\"line\">        depsMap.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">dep, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key === <span class=\"string\">&#x27;length&#x27;</span> || (!<span class=\"title function_\">isSymbol</span>(key) &amp;&amp; key &gt;= newLength)) &#123;</span><br><span class=\"line\">                deps.<span class=\"title function_\">push</span>(dep);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key !== <span class=\"keyword\">void</span> <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(key));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (type) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">ADD</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!<span class=\"title function_\">isArray</span>(target)) &#123;</span><br><span class=\"line\">                    deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">ITERACE_KEY</span>)); <span class=\"comment\">// 暂不理解</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"title function_\">isMap</span>(target)) &#123;</span><br><span class=\"line\">                        deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">MAP_KEY_ITERATE_KEY</span>)); <span class=\"comment\">// 暂不理解</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isIntegerKey</span>(key)) &#123;</span><br><span class=\"line\">                    deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;length&#x27;</span>)); <span class=\"comment\">// // 暂不理解</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">DELETE</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((!<span class=\"title function_\">isArray</span>(target))) &#123;</span><br><span class=\"line\">                    deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">ITERACE_KEY</span>)); <span class=\"comment\">// 暂不理解</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"title function_\">isMap</span>(target)) &#123;</span><br><span class=\"line\">                        deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">MAP_KEY_ITERATE_KEY</span>)); <span class=\"comment\">// 暂不理解</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"title class_\">TriggerOptypes</span>.<span class=\"property\">SET</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"title function_\">isMap</span>(target)) &#123;</span><br><span class=\"line\">                    deps.<span class=\"title function_\">push</span>(depsMap.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">ITERACE_KEY</span>)); <span class=\"comment\">// 暂不理解</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 暂停调度</span></span><br><span class=\"line\">    <span class=\"title function_\">pauseScheduling</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历依赖，执行副作用</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> dep <span class=\"keyword\">of</span> deps) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dep) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">triggerEffects</span>(dep, <span class=\"title class_\">DirtyLevels</span>.<span class=\"property\">Dirty</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重置调调</span></span><br><span class=\"line\">    <span class=\"title function_\">resetScheduling</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>述代码的核心流程就是获取需要响应的依赖，首先处理预留清理响应操作类型，所有依赖都需要被清理，其次修改属性为<strong>length</strong>且<strong>target</strong>为数组时，访问<strong>length</strong>属性的依赖以及数组中超过新数组长度的元素依赖需要被清理。获取需要响应的依赖后，暂停全局调度后，遍历执行<strong>triggerEffects</strong>，最后重置调度。</p>\n<p>我们来看一下<strong>triggerEffects</strong>的实现</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">triggerEffects</span>(<span class=\"params\">dep, dirtyLevels, debuggerEventExtraInfo</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">pasuScheduling</span>(); <span class=\"comment\">// 暂停全局调度</span></span><br><span class=\"line\">    <span class=\"comment\">// 遍历dep</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> effect <span class=\"keyword\">of</span> dep.<span class=\"title function_\">keys</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> tracking;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (</span><br><span class=\"line\">            effect.<span class=\"property\">_dirtyLevel</span> &lt; dirtyLevel &amp;&amp;</span><br><span class=\"line\">            (tracking ??= dep.<span class=\"title function_\">get</span>(effect) === effect.<span class=\"property\">_trackId</span>)</span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">            effect.<span class=\"property\">_shouldSchedule</span> ||= effect.<span class=\"property\">_dirtyLevel</span> === dirtyLevels.<span class=\"property\">NotDirty</span>;</span><br><span class=\"line\">            effect.<span class=\"property\">_dirtyLevel</span> = dirtyLevel;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (</span><br><span class=\"line\">            effect.<span class=\"property\">_shouldSchedule</span> &amp;&amp;</span><br><span class=\"line\">            (tracking ??= dep.<span class=\"title function_\">get</span>(effect === effect.<span class=\"property\">_trackId</span>) === effect.<span class=\"property\">_trackId</span>)</span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">            effect.<span class=\"title function_\">trigger</span>(); <span class=\"comment\">// 执行函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!effect.<span class=\"property\">_runnings</span> || effect.<span class=\"property\">allRecurse</span> &amp;&amp;</span><br><span class=\"line\">                effect.<span class=\"property\">_dirtyLevel</span> !== dirtyLevels.<span class=\"property\">MaybeDirty_ComputedSideEffect</span></span><br><span class=\"line\">            ) &#123; <span class=\"comment\">// 副作用不在运行中或者副作用允许递归且_dirtyLevel值不为2</span></span><br><span class=\"line\">                effect.<span class=\"property\">_shouldSchedule</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (effect.<span class=\"property\">scheduler</span>) &#123;</span><br><span class=\"line\">                    queueEffectSchedulers.<span class=\"title function_\">push</span>(effect.<span class=\"property\">scheduler</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">resetScheduling</span>(); <span class=\"comment\">// 执行调度</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码的主要逻辑是，先暂停全局调度，然后遍历副作用对象，更新**_shouldSchedule<strong>标识，然后根据</strong>_shouldSchedule**判断是否执行调度函数，最后重新执行全局调度。</p>\n<p>到这里我们就解析完<strong>reactive</strong>对象所创建用于存储<strong>dep</strong>的数据结构，以及<strong>dep</strong>进行通知函数执行的过程了。</p>\n<h3 id=\"ref-1\"><a href=\"#ref-1\" class=\"headerlink\" title=\"ref\"></a>ref</h3><h4 id=\"依赖收集（对象构建）-1\"><a href=\"#依赖收集（对象构建）-1\" class=\"headerlink\" title=\"依赖收集（对象构建）\"></a>依赖收集（对象构建）</h4><p>让我看一下<strong>ref</strong>创建用于存储<strong>dep</strong>的不同的数据结构流程。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">trackRefValue</span>(<span class=\"params\">ref</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;</span><br><span class=\"line\">        ref = <span class=\"title function_\">toRaw</span>(ref);</span><br><span class=\"line\">        ref.<span class=\"property\">dep</span> ??= <span class=\"title function_\">createDep</span>(<span class=\"function\">() =&gt;</span> (ref.<span class=\"property\">dep</span> = <span class=\"literal\">undefined</span>), ref <span class=\"keyword\">instanceof</span> <span class=\"title class_\">ComputedRefImpl</span> ? ref : <span class=\"literal\">undefined</span>);</span><br><span class=\"line\">        <span class=\"title function_\">trackEffect</span>(activeEffect, ref.<span class=\"property\">dep</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现，<strong>ref</strong>并没有创建额外的变量用于存储<strong>dep</strong>而是直接绑定到dep属性下面，然后复用<strong>trackEffect</strong>逻辑进行依赖收集。</p>\n<h4 id=\"响应处理（函数执行）-1\"><a href=\"#响应处理（函数执行）-1\" class=\"headerlink\" title=\"响应处理（函数执行）\"></a>响应处理（函数执行）</h4><p>看一下源码定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">triggerRefValue</span>(<span class=\"params\">ref, dirtyLevel, newValue</span>) &#123;</span><br><span class=\"line\">    ref = <span class=\"title function_\">toRaw</span>(ref);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> dep = ref.<span class=\"property\">dep</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dep) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">triggerEffects</span>(dep, dirtyLevel);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现，除了用于存储dep的数据结构不同外，<strong>traEffect</strong>以及<strong>triggerEffects</strong>都得到了很好的复用。</p>\n"},{"title":"响应式原理：Watch函数的实现","_content":"\n### 参数归一化\n\n我知道**watch**的**source**参数接受类型有**ref**, **computed**, **reactive**, **gertter**或者组合成数组类型\n\n```javascript\nexport function watch(source, cb, options) {\n    return dowatch(source, cb, options);\n}\n\nexport function doWatch(source, cb, { immediate, deep, flush, once, onTrack, onTrigger } = EMPTY_OBJ) {\n    const warnInvalidSource = (s) => {\n        // 一些警告\n    }\n\n    const instance = currentInstance;\n    const reactiveGetter = source =>\n        deep === true ? source : traverse(source, deep === false ? 1 : undefined);\n\n    let getter;\n    let forceTrigger = false;\n    let isMultiSource = false;\n\n    // 参数归一化\n    if (isRef(source)) {\n        getter = () => source.value;\n        forceTrigger = isShallow(source);\n    } else if (isReactive(source)) {\n        getter = () => reactiveGetter(source);\n        forceTrigger = true;\n    } else if (isArray(source)) {\n        isMultiSource = true;\n        forceTrigger = source.some(s => isReactive(s) || isShallow(s));\n        getter = () => source.map(s => {\n            if (isRef(s)) {\n                return s.value;\n            } else if (isReactive(s)) {\n                return reactiveGetter(s);\n            } else if (isFunction(s)) {\n                return callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER);\n            } else {\n                warnInvalidSource(s);\n            }\n        });\n    } else if (isFunction(source)) {\n        if (cb) {\n            getter = () => callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER);\n        } else {\n            getter = () => {\n                if (cleanup) {\n                    cleanup();\n                }\n                return callWithAsyncErrorHandling(\n                    source,\n                    instance,\n                    ErrorCodes.WATCH_GETTER,\n                    [onCleanup]\n                );\n            }\n        }\n    } else {\n        getter = Noop;\n        warnInvalidSource(s);\n    }\n\n    // ...\n}\n```\n\n可以发现**watch**实际通过**doWatch**实现的，**doWatch**第一步就是**watch**的参数**source**进行归一化处理。以达到我们访问**getter**会触发响应式数据的依赖收集的目的。\n\n### 深层响应式处理\n\n```javascript\nexport function doWatch(source, cb, { immediate, deep, flush, once, onTrack, onTrigger } = EMPTY_OBJ) {\n    // ...\n    if (cb && deep) {\n        const baseGetter = getter;\n        getter = () => traverse(baseGetter());\n    }\n\n    // ...\n}\n\nexport function traverse(value, depth, currentDepth = 0, seen) {\n    if (!isObject(value) || value[ReactiveFlags.SKIP]) { // 跳出递归方式\n        return value;\n    }\n\n    if (depth && depth > 0) {\n        if (currentDepth >= depth) {\n            return value;\n        }\n        currentDepth++;\n    }\n\n    seen = seen || new Set();\n    if (seen.has(value)) { // 重复值则跳出\n        return value;\n    }\n    seen.add(value);\n\n    // 对各种类型进行属性访问，达到依赖收集效果\n    if (isRef(value)) {\n        traverse(value.value, depth, currentDepth, seen);\n    } else if (isArray(value)) {\n        for (let i = 0; i < value.length; i++) {\n            traverse(value[i], depth, currentDepth, seen);\n        }\n    } else if (isSet(value) || isMap(value)) {\n        value.forEach(v => {\n            traverse(v, depth, currentDepth, seen);\n        })\n    } else if (isPlainObject(value)) {\n        for (const key in value) {\n            traverse(value[key], depth, currentDepth, seen);\n        }\n    }\n\n    return value;\n}\n```\n\n可以发现深层响应式处理核心在**traverse**函数，该函数为递归函数，当**value**不为对象时，直接返回**value**。 提供了**depth**对监听层级进行管理，不传则为深层监听。提供**seen**处理重复值跳出。最后时对不同类型对象属性进行访问，达到依赖收集的效果。\n\n### 提供清理钩子\n\n```javascript\nexport function doWatch(source, cb, { immediate, deep, flush, once, onTrack, onTrigger } = EMPTY_OBJ) {\n    // ...\n    // 提供清理钩子\n    let cleanup;\n    let onCleanup = fn => {\n        cleanup = effect.onStop = () => {\n            callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP);\n            cleanup = effect.onStop = undefined;\n        }\n    }\n\n    let ssrCleanup;\n    if (__SSR__ && isInSSRComponentSetup) {\n        onCleanup = Noop;\n        if (!cb) {\n            getter();\n        } else if (immediate) {\n            callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [\n                getter(),\n                isMultiSource ? [] : undefined,\n                onCleanup\n            ]);\n        }\n\n        if (flush === 'sync') {\n            const ctx = useSSRContext();\n            ssrCleanup = ctx.__watchHandles || (ctx.__watchHandles = []);\n        } else {\n            return NOOP;\n        }\n    }\n    // ...\n}\n```\n\n**onCleanup**将会成为**cb**的第三个实参，我们可以根据业务需要执行**onCleanup**。\n\n### 定义工作函数\n\n```javascript\nexport function doWatch(source, cb, { immediate, deep, flush, once, onTrack, onTrigger } = EMPTY_OBJ) {\n    // ...\n    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;\n    const job = () => { // 定义工作函数\n        if (!effect.active || !effect.dirty) { // 不在响应式上下文或无脏值\n            return;\n        }\n\n        if (cb) {\n            const newValue = effect.run();\n            if (\n                deep ||\n                forceTrigger ||\n                (isMultiSource\n                    ? newValue.some((v, i) => hasChanged(v, oldValue[i]))\n                    : hasChanged(newValue, oldValue)\n                )\n            ) {\n                if (cleanup) {\n                    cleanup();\n                }\n                callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [\n                    newValue,\n                    oldValue === INITIAL_WATCHER_VALUE\n                        ? undefined\n                        : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE\n                            ? []\n                            : oldValue,\n                    onCleanup\n                ]);\n            }\n        } else {\n            effect.run();\n        }\n    }\n\n    job.allowRecurse = !!cb;\n\n    // ...\n}\n```\n\n可以发现**job**函数主要逻辑是先判断**watch**函数执行上下文，以及是否有脏值，然后执行**effect.run**，即执行归一化化后的**getter**函数达到依赖收集效果。若接受了**cb**函数，根据是否存在脏值执行**cb**,b并更新**oldValue**值。\n\n### 定义调度器\n\n```javascript\nexport function doWatch(source, cb, { immediate, deep, flush, once, onTrack, onTrigger } = EMPTY_OBJ) {\n    // ...\n    let scheduler; // 定义调度器\n    if (flush === 'sync') {\n        scheduler = job;\n    } else if (flush === 'post') {\n        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\n    } else {\n        job.pre = true;\n        if (instance) job.id = instance.id;\n        scheduler = () => queueJob(job);\n    }\n    // ...\n}\n```\n\n### 构建ReactiveEffect\n\n```javascript\nexport function doWatch(source, cb, { immediate, deep, flush, once, onTrack, onTrigger } = EMPTY_OBJ) {\n    // ...\n    const effect = new ReactiveEffect(getter, NOOP, scheduler);\n    // ...\n}\n```\n\n可以发现前面定义的**getter**, **job**其实都是服务于构建**ReactiveEffect**实例的。\n\n### 定义监听卸载\n\n```javascript\nexport function doWatch(source, cb, { immediate, deep, flush, once, onTrack, onTrigger } = EMPTY_OBJ) {\n    // ...\n    const scope = getCurrentScope();\n    const unwatch = () => {\n        effect.stop(); // 清楚依赖\n        if (scope) {\n            remove(scope.effects, effect);\n        }\n    }\n    // ...\n}\n```\n\n### 首次执行\n\n```javascript\nexport function doWatch(source, cb, { immediate, deep, flush, once, onTrack, onTrigger } = EMPTY_OBJ) {\n    // ...\nif (cb) {\n        if (immediate) {\n            job();\n        } else {\n            oldValue = effect.run();\n        }\n    } else if (flush === 'post') {\n        queuePostRenderEffect(\n            effect.run.bind(effect),\n            instance && instance.suspense\n        );\n    } else {\n        effect.run();\n    }\n\n    if (__SSR__ && ssrCleanup) ssrCleanup.push(unwatch);\n\n    return unwatch;\n}\n```\n\n","source":"_posts/源码/vue3/watch.md","raw":"---\ntitle: 响应式原理：watch函数的实现\n---\n\n### 参数归一化\n\n我知道**watch**的**source**参数接受类型有**ref**, **computed**, **reactive**, **gertter**或者组合成数组类型\n\n```javascript\nexport function watch(source, cb, options) {\n    return dowatch(source, cb, options);\n}\n\nexport function doWatch(source, cb, { immediate, deep, flush, once, onTrack, onTrigger } = EMPTY_OBJ) {\n    const warnInvalidSource = (s) => {\n        // 一些警告\n    }\n\n    const instance = currentInstance;\n    const reactiveGetter = source =>\n        deep === true ? source : traverse(source, deep === false ? 1 : undefined);\n\n    let getter;\n    let forceTrigger = false;\n    let isMultiSource = false;\n\n    // 参数归一化\n    if (isRef(source)) {\n        getter = () => source.value;\n        forceTrigger = isShallow(source);\n    } else if (isReactive(source)) {\n        getter = () => reactiveGetter(source);\n        forceTrigger = true;\n    } else if (isArray(source)) {\n        isMultiSource = true;\n        forceTrigger = source.some(s => isReactive(s) || isShallow(s));\n        getter = () => source.map(s => {\n            if (isRef(s)) {\n                return s.value;\n            } else if (isReactive(s)) {\n                return reactiveGetter(s);\n            } else if (isFunction(s)) {\n                return callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER);\n            } else {\n                warnInvalidSource(s);\n            }\n        });\n    } else if (isFunction(source)) {\n        if (cb) {\n            getter = () => callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER);\n        } else {\n            getter = () => {\n                if (cleanup) {\n                    cleanup();\n                }\n                return callWithAsyncErrorHandling(\n                    source,\n                    instance,\n                    ErrorCodes.WATCH_GETTER,\n                    [onCleanup]\n                );\n            }\n        }\n    } else {\n        getter = Noop;\n        warnInvalidSource(s);\n    }\n\n    // ...\n}\n```\n\n可以发现**watch**实际通过**doWatch**实现的，**doWatch**第一步就是**watch**的参数**source**进行归一化处理。以达到我们访问**getter**会触发响应式数据的依赖收集的目的。\n\n### 深层响应式处理\n\n```javascript\nexport function doWatch(source, cb, { immediate, deep, flush, once, onTrack, onTrigger } = EMPTY_OBJ) {\n    // ...\n    if (cb && deep) {\n        const baseGetter = getter;\n        getter = () => traverse(baseGetter());\n    }\n\n    // ...\n}\n\nexport function traverse(value, depth, currentDepth = 0, seen) {\n    if (!isObject(value) || value[ReactiveFlags.SKIP]) { // 跳出递归方式\n        return value;\n    }\n\n    if (depth && depth > 0) {\n        if (currentDepth >= depth) {\n            return value;\n        }\n        currentDepth++;\n    }\n\n    seen = seen || new Set();\n    if (seen.has(value)) { // 重复值则跳出\n        return value;\n    }\n    seen.add(value);\n\n    // 对各种类型进行属性访问，达到依赖收集效果\n    if (isRef(value)) {\n        traverse(value.value, depth, currentDepth, seen);\n    } else if (isArray(value)) {\n        for (let i = 0; i < value.length; i++) {\n            traverse(value[i], depth, currentDepth, seen);\n        }\n    } else if (isSet(value) || isMap(value)) {\n        value.forEach(v => {\n            traverse(v, depth, currentDepth, seen);\n        })\n    } else if (isPlainObject(value)) {\n        for (const key in value) {\n            traverse(value[key], depth, currentDepth, seen);\n        }\n    }\n\n    return value;\n}\n```\n\n可以发现深层响应式处理核心在**traverse**函数，该函数为递归函数，当**value**不为对象时，直接返回**value**。 提供了**depth**对监听层级进行管理，不传则为深层监听。提供**seen**处理重复值跳出。最后时对不同类型对象属性进行访问，达到依赖收集的效果。\n\n### 提供清理钩子\n\n```javascript\nexport function doWatch(source, cb, { immediate, deep, flush, once, onTrack, onTrigger } = EMPTY_OBJ) {\n    // ...\n    // 提供清理钩子\n    let cleanup;\n    let onCleanup = fn => {\n        cleanup = effect.onStop = () => {\n            callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP);\n            cleanup = effect.onStop = undefined;\n        }\n    }\n\n    let ssrCleanup;\n    if (__SSR__ && isInSSRComponentSetup) {\n        onCleanup = Noop;\n        if (!cb) {\n            getter();\n        } else if (immediate) {\n            callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [\n                getter(),\n                isMultiSource ? [] : undefined,\n                onCleanup\n            ]);\n        }\n\n        if (flush === 'sync') {\n            const ctx = useSSRContext();\n            ssrCleanup = ctx.__watchHandles || (ctx.__watchHandles = []);\n        } else {\n            return NOOP;\n        }\n    }\n    // ...\n}\n```\n\n**onCleanup**将会成为**cb**的第三个实参，我们可以根据业务需要执行**onCleanup**。\n\n### 定义工作函数\n\n```javascript\nexport function doWatch(source, cb, { immediate, deep, flush, once, onTrack, onTrigger } = EMPTY_OBJ) {\n    // ...\n    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;\n    const job = () => { // 定义工作函数\n        if (!effect.active || !effect.dirty) { // 不在响应式上下文或无脏值\n            return;\n        }\n\n        if (cb) {\n            const newValue = effect.run();\n            if (\n                deep ||\n                forceTrigger ||\n                (isMultiSource\n                    ? newValue.some((v, i) => hasChanged(v, oldValue[i]))\n                    : hasChanged(newValue, oldValue)\n                )\n            ) {\n                if (cleanup) {\n                    cleanup();\n                }\n                callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [\n                    newValue,\n                    oldValue === INITIAL_WATCHER_VALUE\n                        ? undefined\n                        : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE\n                            ? []\n                            : oldValue,\n                    onCleanup\n                ]);\n            }\n        } else {\n            effect.run();\n        }\n    }\n\n    job.allowRecurse = !!cb;\n\n    // ...\n}\n```\n\n可以发现**job**函数主要逻辑是先判断**watch**函数执行上下文，以及是否有脏值，然后执行**effect.run**，即执行归一化化后的**getter**函数达到依赖收集效果。若接受了**cb**函数，根据是否存在脏值执行**cb**,b并更新**oldValue**值。\n\n### 定义调度器\n\n```javascript\nexport function doWatch(source, cb, { immediate, deep, flush, once, onTrack, onTrigger } = EMPTY_OBJ) {\n    // ...\n    let scheduler; // 定义调度器\n    if (flush === 'sync') {\n        scheduler = job;\n    } else if (flush === 'post') {\n        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\n    } else {\n        job.pre = true;\n        if (instance) job.id = instance.id;\n        scheduler = () => queueJob(job);\n    }\n    // ...\n}\n```\n\n### 构建ReactiveEffect\n\n```javascript\nexport function doWatch(source, cb, { immediate, deep, flush, once, onTrack, onTrigger } = EMPTY_OBJ) {\n    // ...\n    const effect = new ReactiveEffect(getter, NOOP, scheduler);\n    // ...\n}\n```\n\n可以发现前面定义的**getter**, **job**其实都是服务于构建**ReactiveEffect**实例的。\n\n### 定义监听卸载\n\n```javascript\nexport function doWatch(source, cb, { immediate, deep, flush, once, onTrack, onTrigger } = EMPTY_OBJ) {\n    // ...\n    const scope = getCurrentScope();\n    const unwatch = () => {\n        effect.stop(); // 清楚依赖\n        if (scope) {\n            remove(scope.effects, effect);\n        }\n    }\n    // ...\n}\n```\n\n### 首次执行\n\n```javascript\nexport function doWatch(source, cb, { immediate, deep, flush, once, onTrack, onTrigger } = EMPTY_OBJ) {\n    // ...\nif (cb) {\n        if (immediate) {\n            job();\n        } else {\n            oldValue = effect.run();\n        }\n    } else if (flush === 'post') {\n        queuePostRenderEffect(\n            effect.run.bind(effect),\n            instance && instance.suspense\n        );\n    } else {\n        effect.run();\n    }\n\n    if (__SSR__ && ssrCleanup) ssrCleanup.push(unwatch);\n\n    return unwatch;\n}\n```\n\n","slug":"源码/vue3/watch","published":1,"date":"2024-04-03T14:11:14.651Z","updated":"2024-04-04T08:13:56.778Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clukyo980000018gm1bl066e9","content":"<h3 id=\"参数归一化\"><a href=\"#参数归一化\" class=\"headerlink\" title=\"参数归一化\"></a>参数归一化</h3><p>我知道<strong>watch</strong>的<strong>source</strong>参数接受类型有<strong>ref</strong>, <strong>computed</strong>, <strong>reactive</strong>, <strong>gertter</strong>或者组合成数组类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">watch</span>(<span class=\"params\">source, cb, options</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">dowatch</span>(source, cb, options);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">warnInvalidSource</span> = (<span class=\"params\">s</span>) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 一些警告</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> instance = currentInstance;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">reactiveGetter</span> = source =&gt;</span><br><span class=\"line\">        deep === <span class=\"literal\">true</span> ? source : <span class=\"title function_\">traverse</span>(source, deep === <span class=\"literal\">false</span> ? <span class=\"number\">1</span> : <span class=\"literal\">undefined</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> getter;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> forceTrigger = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> isMultiSource = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 参数归一化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title function_\">isRef</span>(source)) &#123;</span><br><span class=\"line\">        getter = <span class=\"function\">() =&gt;</span> source.<span class=\"property\">value</span>;</span><br><span class=\"line\">        forceTrigger = <span class=\"title function_\">isShallow</span>(source);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isReactive</span>(source)) &#123;</span><br><span class=\"line\">        getter = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">reactiveGetter</span>(source);</span><br><span class=\"line\">        forceTrigger = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isArray</span>(source)) &#123;</span><br><span class=\"line\">        isMultiSource = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        forceTrigger = source.<span class=\"title function_\">some</span>(<span class=\"function\"><span class=\"params\">s</span> =&gt;</span> <span class=\"title function_\">isReactive</span>(s) || <span class=\"title function_\">isShallow</span>(s));</span><br><span class=\"line\">        getter = <span class=\"function\">() =&gt;</span> source.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">s</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"title function_\">isRef</span>(s)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> s.<span class=\"property\">value</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isReactive</span>(s)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"title function_\">reactiveGetter</span>(s);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isFunction</span>(s)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"title function_\">callWithErrorHandling</span>(s, instance, <span class=\"title class_\">ErrorCodes</span>.<span class=\"property\">WATCH_GETTER</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"title function_\">warnInvalidSource</span>(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isFunction</span>(source)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cb) &#123;</span><br><span class=\"line\">            getter = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">callWithErrorHandling</span>(source, instance, <span class=\"title class_\">ErrorCodes</span>.<span class=\"property\">WATCH_GETTER</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            getter = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cleanup) &#123;</span><br><span class=\"line\">                    <span class=\"title function_\">cleanup</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"title function_\">callWithAsyncErrorHandling</span>(</span><br><span class=\"line\">                    source,</span><br><span class=\"line\">                    instance,</span><br><span class=\"line\">                    <span class=\"title class_\">ErrorCodes</span>.<span class=\"property\">WATCH_GETTER</span>,</span><br><span class=\"line\">                    [onCleanup]</span><br><span class=\"line\">                );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        getter = <span class=\"title class_\">Noop</span>;</span><br><span class=\"line\">        <span class=\"title function_\">warnInvalidSource</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现<strong>watch</strong>实际通过<strong>doWatch</strong>实现的，<strong>doWatch</strong>第一步就是<strong>watch</strong>的参数<strong>source</strong>进行归一化处理。以达到我们访问<strong>getter</strong>会触发响应式数据的依赖收集的目的。</p>\n<h3 id=\"深层响应式处理\"><a href=\"#深层响应式处理\" class=\"headerlink\" title=\"深层响应式处理\"></a>深层响应式处理</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cb &amp;&amp; deep) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> baseGetter = getter;</span><br><span class=\"line\">        getter = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">traverse</span>(<span class=\"title function_\">baseGetter</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">value, depth, currentDepth = <span class=\"number\">0</span>, seen</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"title function_\">isObject</span>(value) || value[<span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">SKIP</span>]) &#123; <span class=\"comment\">// 跳出递归方式</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (depth &amp;&amp; depth &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentDepth &gt;= depth) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        currentDepth++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    seen = seen || <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (seen.<span class=\"title function_\">has</span>(value)) &#123; <span class=\"comment\">// 重复值则跳出</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    seen.<span class=\"title function_\">add</span>(value);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对各种类型进行属性访问，达到依赖收集效果</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title function_\">isRef</span>(value)) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">traverse</span>(value.<span class=\"property\">value</span>, depth, currentDepth, seen);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isArray</span>(value)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; value.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">traverse</span>(value[i], depth, currentDepth, seen);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isSet</span>(value) || <span class=\"title function_\">isMap</span>(value)) &#123;</span><br><span class=\"line\">        value.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"title function_\">traverse</span>(v, depth, currentDepth, seen);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isPlainObject</span>(value)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> value) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">traverse</span>(value[key], depth, currentDepth, seen);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现深层响应式处理核心在<strong>traverse</strong>函数，该函数为递归函数，当<strong>value</strong>不为对象时，直接返回<strong>value</strong>。 提供了<strong>depth</strong>对监听层级进行管理，不传则为深层监听。提供<strong>seen</strong>处理重复值跳出。最后时对不同类型对象属性进行访问，达到依赖收集的效果。</p>\n<h3 id=\"提供清理钩子\"><a href=\"#提供清理钩子\" class=\"headerlink\" title=\"提供清理钩子\"></a>提供清理钩子</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 提供清理钩子</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> cleanup;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"title function_\">onCleanup</span> = fn =&gt; &#123;</span><br><span class=\"line\">        cleanup = effect.<span class=\"property\">onStop</span> = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"title function_\">callWithErrorHandling</span>(fn, instance, <span class=\"title class_\">ErrorCodes</span>.<span class=\"property\">WATCH_CLEANUP</span>);</span><br><span class=\"line\">            cleanup = effect.<span class=\"property\">onStop</span> = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> ssrCleanup;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (__SSR__ &amp;&amp; isInSSRComponentSetup) &#123;</span><br><span class=\"line\">        onCleanup = <span class=\"title class_\">Noop</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cb) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">getter</span>();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (immediate) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">callWithAsyncErrorHandling</span>(cb, instance, <span class=\"title class_\">ErrorCodes</span>.<span class=\"property\">WATCH_CALLBACK</span>, [</span><br><span class=\"line\">                <span class=\"title function_\">getter</span>(),</span><br><span class=\"line\">                isMultiSource ? [] : <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">                onCleanup</span><br><span class=\"line\">            ]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flush === <span class=\"string\">&#x27;sync&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> ctx = <span class=\"title function_\">useSSRContext</span>();</span><br><span class=\"line\">            ssrCleanup = ctx.<span class=\"property\">__watchHandles</span> || (ctx.<span class=\"property\">__watchHandles</span> = []);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable constant_\">NOOP</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>onCleanup</strong>将会成为<strong>cb</strong>的第三个实参，我们可以根据业务需要执行<strong>onCleanup</strong>。</p>\n<h3 id=\"定义工作函数\"><a href=\"#定义工作函数\" class=\"headerlink\" title=\"定义工作函数\"></a>定义工作函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> oldValue = isMultiSource ? <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(source.<span class=\"property\">length</span>).<span class=\"title function_\">fill</span>(<span class=\"variable constant_\">INITIAL_WATCHER_VALUE</span>) : <span class=\"variable constant_\">INITIAL_WATCHER_VALUE</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">job</span> = (<span class=\"params\"></span>) =&gt; &#123; <span class=\"comment\">// 定义工作函数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!effect.<span class=\"property\">active</span> || !effect.<span class=\"property\">dirty</span>) &#123; <span class=\"comment\">// 不在响应式上下文或无脏值</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cb) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> newValue = effect.<span class=\"title function_\">run</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (</span><br><span class=\"line\">                deep ||</span><br><span class=\"line\">                forceTrigger ||</span><br><span class=\"line\">                (isMultiSource</span><br><span class=\"line\">                    ? newValue.<span class=\"title function_\">some</span>(<span class=\"function\">(<span class=\"params\">v, i</span>) =&gt;</span> <span class=\"title function_\">hasChanged</span>(v, oldValue[i]))</span><br><span class=\"line\">                    : <span class=\"title function_\">hasChanged</span>(newValue, oldValue)</span><br><span class=\"line\">                )</span><br><span class=\"line\">            ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cleanup) &#123;</span><br><span class=\"line\">                    <span class=\"title function_\">cleanup</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"title function_\">callWithAsyncErrorHandling</span>(cb, instance, <span class=\"title class_\">ErrorCodes</span>.<span class=\"property\">WATCH_CALLBACK</span>, [</span><br><span class=\"line\">                    newValue,</span><br><span class=\"line\">                    oldValue === <span class=\"variable constant_\">INITIAL_WATCHER_VALUE</span></span><br><span class=\"line\">                        ? <span class=\"literal\">undefined</span></span><br><span class=\"line\">                        : isMultiSource &amp;&amp; oldValue[<span class=\"number\">0</span>] === <span class=\"variable constant_\">INITIAL_WATCHER_VALUE</span></span><br><span class=\"line\">                            ? []</span><br><span class=\"line\">                            : oldValue,</span><br><span class=\"line\">                    onCleanup</span><br><span class=\"line\">                ]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            effect.<span class=\"title function_\">run</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    job.<span class=\"property\">allowRecurse</span> = !!cb;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现<strong>job</strong>函数主要逻辑是先判断<strong>watch</strong>函数执行上下文，以及是否有脏值，然后执行<strong>effect.run</strong>，即执行归一化化后的<strong>getter</strong>函数达到依赖收集效果。若接受了<strong>cb</strong>函数，根据是否存在脏值执行<strong>cb</strong>,b并更新<strong>oldValue</strong>值。</p>\n<h3 id=\"定义调度器\"><a href=\"#定义调度器\" class=\"headerlink\" title=\"定义调度器\"></a>定义调度器</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> scheduler; <span class=\"comment\">// 定义调度器</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flush === <span class=\"string\">&#x27;sync&#x27;</span>) &#123;</span><br><span class=\"line\">        scheduler = job;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (flush === <span class=\"string\">&#x27;post&#x27;</span>) &#123;</span><br><span class=\"line\">        scheduler = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">queuePostRenderEffect</span>(job, instance &amp;&amp; instance.<span class=\"property\">suspense</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        job.<span class=\"property\">pre</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance) job.<span class=\"property\">id</span> = instance.<span class=\"property\">id</span>;</span><br><span class=\"line\">        scheduler = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">queueJob</span>(job);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"构建ReactiveEffect\"><a href=\"#构建ReactiveEffect\" class=\"headerlink\" title=\"构建ReactiveEffect\"></a>构建ReactiveEffect</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> effect = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(getter, <span class=\"variable constant_\">NOOP</span>, scheduler);</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现前面定义的<strong>getter</strong>, <strong>job</strong>其实都是服务于构建<strong>ReactiveEffect</strong>实例的。</p>\n<h3 id=\"定义监听卸载\"><a href=\"#定义监听卸载\" class=\"headerlink\" title=\"定义监听卸载\"></a>定义监听卸载</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> scope = <span class=\"title function_\">getCurrentScope</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">unwatch</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">        effect.<span class=\"title function_\">stop</span>(); <span class=\"comment\">// 清楚依赖</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (scope) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">remove</span>(scope.<span class=\"property\">effects</span>, effect);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"首次执行\"><a href=\"#首次执行\" class=\"headerlink\" title=\"首次执行\"></a>首次执行</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (cb) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (immediate) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">job</span>();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            oldValue = effect.<span class=\"title function_\">run</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (flush === <span class=\"string\">&#x27;post&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">queuePostRenderEffect</span>(</span><br><span class=\"line\">            effect.<span class=\"property\">run</span>.<span class=\"title function_\">bind</span>(effect),</span><br><span class=\"line\">            instance &amp;&amp; instance.<span class=\"property\">suspense</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        effect.<span class=\"title function_\">run</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (__SSR__ &amp;&amp; ssrCleanup) ssrCleanup.<span class=\"title function_\">push</span>(unwatch);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> unwatch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"#f0bc6c","excerpt":"","more":"<h3 id=\"参数归一化\"><a href=\"#参数归一化\" class=\"headerlink\" title=\"参数归一化\"></a>参数归一化</h3><p>我知道<strong>watch</strong>的<strong>source</strong>参数接受类型有<strong>ref</strong>, <strong>computed</strong>, <strong>reactive</strong>, <strong>gertter</strong>或者组合成数组类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">watch</span>(<span class=\"params\">source, cb, options</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">dowatch</span>(source, cb, options);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">warnInvalidSource</span> = (<span class=\"params\">s</span>) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 一些警告</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> instance = currentInstance;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">reactiveGetter</span> = source =&gt;</span><br><span class=\"line\">        deep === <span class=\"literal\">true</span> ? source : <span class=\"title function_\">traverse</span>(source, deep === <span class=\"literal\">false</span> ? <span class=\"number\">1</span> : <span class=\"literal\">undefined</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> getter;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> forceTrigger = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> isMultiSource = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 参数归一化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title function_\">isRef</span>(source)) &#123;</span><br><span class=\"line\">        getter = <span class=\"function\">() =&gt;</span> source.<span class=\"property\">value</span>;</span><br><span class=\"line\">        forceTrigger = <span class=\"title function_\">isShallow</span>(source);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isReactive</span>(source)) &#123;</span><br><span class=\"line\">        getter = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">reactiveGetter</span>(source);</span><br><span class=\"line\">        forceTrigger = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isArray</span>(source)) &#123;</span><br><span class=\"line\">        isMultiSource = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        forceTrigger = source.<span class=\"title function_\">some</span>(<span class=\"function\"><span class=\"params\">s</span> =&gt;</span> <span class=\"title function_\">isReactive</span>(s) || <span class=\"title function_\">isShallow</span>(s));</span><br><span class=\"line\">        getter = <span class=\"function\">() =&gt;</span> source.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">s</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"title function_\">isRef</span>(s)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> s.<span class=\"property\">value</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isReactive</span>(s)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"title function_\">reactiveGetter</span>(s);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isFunction</span>(s)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"title function_\">callWithErrorHandling</span>(s, instance, <span class=\"title class_\">ErrorCodes</span>.<span class=\"property\">WATCH_GETTER</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"title function_\">warnInvalidSource</span>(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isFunction</span>(source)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cb) &#123;</span><br><span class=\"line\">            getter = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">callWithErrorHandling</span>(source, instance, <span class=\"title class_\">ErrorCodes</span>.<span class=\"property\">WATCH_GETTER</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            getter = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cleanup) &#123;</span><br><span class=\"line\">                    <span class=\"title function_\">cleanup</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"title function_\">callWithAsyncErrorHandling</span>(</span><br><span class=\"line\">                    source,</span><br><span class=\"line\">                    instance,</span><br><span class=\"line\">                    <span class=\"title class_\">ErrorCodes</span>.<span class=\"property\">WATCH_GETTER</span>,</span><br><span class=\"line\">                    [onCleanup]</span><br><span class=\"line\">                );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        getter = <span class=\"title class_\">Noop</span>;</span><br><span class=\"line\">        <span class=\"title function_\">warnInvalidSource</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现<strong>watch</strong>实际通过<strong>doWatch</strong>实现的，<strong>doWatch</strong>第一步就是<strong>watch</strong>的参数<strong>source</strong>进行归一化处理。以达到我们访问<strong>getter</strong>会触发响应式数据的依赖收集的目的。</p>\n<h3 id=\"深层响应式处理\"><a href=\"#深层响应式处理\" class=\"headerlink\" title=\"深层响应式处理\"></a>深层响应式处理</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cb &amp;&amp; deep) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> baseGetter = getter;</span><br><span class=\"line\">        getter = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">traverse</span>(<span class=\"title function_\">baseGetter</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">value, depth, currentDepth = <span class=\"number\">0</span>, seen</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"title function_\">isObject</span>(value) || value[<span class=\"title class_\">ReactiveFlags</span>.<span class=\"property\">SKIP</span>]) &#123; <span class=\"comment\">// 跳出递归方式</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (depth &amp;&amp; depth &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentDepth &gt;= depth) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        currentDepth++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    seen = seen || <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (seen.<span class=\"title function_\">has</span>(value)) &#123; <span class=\"comment\">// 重复值则跳出</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    seen.<span class=\"title function_\">add</span>(value);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对各种类型进行属性访问，达到依赖收集效果</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title function_\">isRef</span>(value)) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">traverse</span>(value.<span class=\"property\">value</span>, depth, currentDepth, seen);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isArray</span>(value)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; value.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">traverse</span>(value[i], depth, currentDepth, seen);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isSet</span>(value) || <span class=\"title function_\">isMap</span>(value)) &#123;</span><br><span class=\"line\">        value.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"title function_\">traverse</span>(v, depth, currentDepth, seen);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"title function_\">isPlainObject</span>(value)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> value) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">traverse</span>(value[key], depth, currentDepth, seen);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现深层响应式处理核心在<strong>traverse</strong>函数，该函数为递归函数，当<strong>value</strong>不为对象时，直接返回<strong>value</strong>。 提供了<strong>depth</strong>对监听层级进行管理，不传则为深层监听。提供<strong>seen</strong>处理重复值跳出。最后时对不同类型对象属性进行访问，达到依赖收集的效果。</p>\n<h3 id=\"提供清理钩子\"><a href=\"#提供清理钩子\" class=\"headerlink\" title=\"提供清理钩子\"></a>提供清理钩子</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 提供清理钩子</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> cleanup;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"title function_\">onCleanup</span> = fn =&gt; &#123;</span><br><span class=\"line\">        cleanup = effect.<span class=\"property\">onStop</span> = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"title function_\">callWithErrorHandling</span>(fn, instance, <span class=\"title class_\">ErrorCodes</span>.<span class=\"property\">WATCH_CLEANUP</span>);</span><br><span class=\"line\">            cleanup = effect.<span class=\"property\">onStop</span> = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> ssrCleanup;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (__SSR__ &amp;&amp; isInSSRComponentSetup) &#123;</span><br><span class=\"line\">        onCleanup = <span class=\"title class_\">Noop</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cb) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">getter</span>();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (immediate) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">callWithAsyncErrorHandling</span>(cb, instance, <span class=\"title class_\">ErrorCodes</span>.<span class=\"property\">WATCH_CALLBACK</span>, [</span><br><span class=\"line\">                <span class=\"title function_\">getter</span>(),</span><br><span class=\"line\">                isMultiSource ? [] : <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">                onCleanup</span><br><span class=\"line\">            ]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flush === <span class=\"string\">&#x27;sync&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> ctx = <span class=\"title function_\">useSSRContext</span>();</span><br><span class=\"line\">            ssrCleanup = ctx.<span class=\"property\">__watchHandles</span> || (ctx.<span class=\"property\">__watchHandles</span> = []);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable constant_\">NOOP</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>onCleanup</strong>将会成为<strong>cb</strong>的第三个实参，我们可以根据业务需要执行<strong>onCleanup</strong>。</p>\n<h3 id=\"定义工作函数\"><a href=\"#定义工作函数\" class=\"headerlink\" title=\"定义工作函数\"></a>定义工作函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> oldValue = isMultiSource ? <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(source.<span class=\"property\">length</span>).<span class=\"title function_\">fill</span>(<span class=\"variable constant_\">INITIAL_WATCHER_VALUE</span>) : <span class=\"variable constant_\">INITIAL_WATCHER_VALUE</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">job</span> = (<span class=\"params\"></span>) =&gt; &#123; <span class=\"comment\">// 定义工作函数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!effect.<span class=\"property\">active</span> || !effect.<span class=\"property\">dirty</span>) &#123; <span class=\"comment\">// 不在响应式上下文或无脏值</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cb) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> newValue = effect.<span class=\"title function_\">run</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (</span><br><span class=\"line\">                deep ||</span><br><span class=\"line\">                forceTrigger ||</span><br><span class=\"line\">                (isMultiSource</span><br><span class=\"line\">                    ? newValue.<span class=\"title function_\">some</span>(<span class=\"function\">(<span class=\"params\">v, i</span>) =&gt;</span> <span class=\"title function_\">hasChanged</span>(v, oldValue[i]))</span><br><span class=\"line\">                    : <span class=\"title function_\">hasChanged</span>(newValue, oldValue)</span><br><span class=\"line\">                )</span><br><span class=\"line\">            ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cleanup) &#123;</span><br><span class=\"line\">                    <span class=\"title function_\">cleanup</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"title function_\">callWithAsyncErrorHandling</span>(cb, instance, <span class=\"title class_\">ErrorCodes</span>.<span class=\"property\">WATCH_CALLBACK</span>, [</span><br><span class=\"line\">                    newValue,</span><br><span class=\"line\">                    oldValue === <span class=\"variable constant_\">INITIAL_WATCHER_VALUE</span></span><br><span class=\"line\">                        ? <span class=\"literal\">undefined</span></span><br><span class=\"line\">                        : isMultiSource &amp;&amp; oldValue[<span class=\"number\">0</span>] === <span class=\"variable constant_\">INITIAL_WATCHER_VALUE</span></span><br><span class=\"line\">                            ? []</span><br><span class=\"line\">                            : oldValue,</span><br><span class=\"line\">                    onCleanup</span><br><span class=\"line\">                ]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            effect.<span class=\"title function_\">run</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    job.<span class=\"property\">allowRecurse</span> = !!cb;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现<strong>job</strong>函数主要逻辑是先判断<strong>watch</strong>函数执行上下文，以及是否有脏值，然后执行<strong>effect.run</strong>，即执行归一化化后的<strong>getter</strong>函数达到依赖收集效果。若接受了<strong>cb</strong>函数，根据是否存在脏值执行<strong>cb</strong>,b并更新<strong>oldValue</strong>值。</p>\n<h3 id=\"定义调度器\"><a href=\"#定义调度器\" class=\"headerlink\" title=\"定义调度器\"></a>定义调度器</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> scheduler; <span class=\"comment\">// 定义调度器</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flush === <span class=\"string\">&#x27;sync&#x27;</span>) &#123;</span><br><span class=\"line\">        scheduler = job;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (flush === <span class=\"string\">&#x27;post&#x27;</span>) &#123;</span><br><span class=\"line\">        scheduler = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">queuePostRenderEffect</span>(job, instance &amp;&amp; instance.<span class=\"property\">suspense</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        job.<span class=\"property\">pre</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance) job.<span class=\"property\">id</span> = instance.<span class=\"property\">id</span>;</span><br><span class=\"line\">        scheduler = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">queueJob</span>(job);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"构建ReactiveEffect\"><a href=\"#构建ReactiveEffect\" class=\"headerlink\" title=\"构建ReactiveEffect\"></a>构建ReactiveEffect</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> effect = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(getter, <span class=\"variable constant_\">NOOP</span>, scheduler);</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现前面定义的<strong>getter</strong>, <strong>job</strong>其实都是服务于构建<strong>ReactiveEffect</strong>实例的。</p>\n<h3 id=\"定义监听卸载\"><a href=\"#定义监听卸载\" class=\"headerlink\" title=\"定义监听卸载\"></a>定义监听卸载</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> scope = <span class=\"title function_\">getCurrentScope</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">unwatch</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">        effect.<span class=\"title function_\">stop</span>(); <span class=\"comment\">// 清楚依赖</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (scope) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">remove</span>(scope.<span class=\"property\">effects</span>, effect);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"首次执行\"><a href=\"#首次执行\" class=\"headerlink\" title=\"首次执行\"></a>首次执行</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">doWatch</span>(<span class=\"params\">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (cb) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (immediate) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">job</span>();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            oldValue = effect.<span class=\"title function_\">run</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (flush === <span class=\"string\">&#x27;post&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">queuePostRenderEffect</span>(</span><br><span class=\"line\">            effect.<span class=\"property\">run</span>.<span class=\"title function_\">bind</span>(effect),</span><br><span class=\"line\">            instance &amp;&amp; instance.<span class=\"property\">suspense</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        effect.<span class=\"title function_\">run</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (__SSR__ &amp;&amp; ssrCleanup) ssrCleanup.<span class=\"title function_\">push</span>(unwatch);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> unwatch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cltzslokc0009sovcajyz2jrd","category_id":"cltzsloke000csovcfy7h5805","_id":"cltzslokk000nsovcfggr0hxx"},{"post_id":"cltzslokm000ssovc9es1f3ze","category_id":"cltzsloke000csovcfy7h5805","_id":"cltzsloko000wsovcac9qbjnm"},{"post_id":"cltzslokn000vsovc2sykerah","category_id":"cltzsloke000csovcfy7h5805","_id":"cltzslokp0010sovcci1zbvn5"},{"post_id":"cltzsloko000xsovc5m0t21hn","category_id":"cltzsloke000csovcfy7h5805","_id":"cltzslokq0012sovc40158qar"},{"post_id":"cltzsloko000ysovc5td00ul0","category_id":"cltzsloke000csovcfy7h5805","_id":"cltzslokr0014sovcg66icsmj"},{"post_id":"cltzslokp000zsovc551g6yl0","category_id":"cltzsloke000csovcfy7h5805","_id":"cltzslokr0016sovc18g12ugx"},{"post_id":"cltzslokp0011sovc21hphbfw","category_id":"cltzsloke000csovcfy7h5805","_id":"cltzsloks0018sovc61vici5w"},{"post_id":"cltzslokq0013sovchko75wik","category_id":"cltzsloke000csovcfy7h5805","_id":"cltzsloks001asovcc2yx6spw"},{"post_id":"cltzslokr0015sovcdaa3hy2v","category_id":"cltzsloke000csovcfy7h5805","_id":"cltzslokt001csovc0dqzd1ac"},{"post_id":"cltzslokr0017sovcehbi4hj4","category_id":"cltzsloke000csovcfy7h5805","_id":"cltzsloku001esovcczco740q"}],"PostTag":[],"Tag":[]}}