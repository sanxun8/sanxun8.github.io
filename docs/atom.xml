<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>屯货三旬的个人网站</title>
  
  
  <link href="https://sanxun8.github.io/atom.xml" rel="self"/>
  
  <link href="https://sanxun8.github.io/"/>
  <updated>2024-03-30T13:15:25.170Z</updated>
  <id>https://sanxun8.github.io/</id>
  
  <author>
    <name>屯货三旬</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue3中computed模块源码解析</title>
    <link href="https://sanxun8.github.io/2024/03/30/%E6%BA%90%E7%A0%81/vue3/computed/"/>
    <id>https://sanxun8.github.io/2024/03/30/%E6%BA%90%E7%A0%81/vue3/computed/</id>
    <published>2024-03-30T02:01:04.141Z</published>
    <updated>2024-03-30T13:15:25.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Computed"><a href="#Computed" class="headerlink" title="Computed"></a>Computed</h3><p>源码中关于<strong>computed</strong>部分的定义：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">computed</span>(<span class="params">getterOptions, debugOptions, isSSR = <span class="literal">false</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> getter;</span><br><span class="line">    <span class="keyword">let</span> setter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> onlyGetter = <span class="title function_">isFunction</span>(getterOptions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (onlyGetter) &#123;</span><br><span class="line">        getter = getterOptions;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        getter = getterOptions.<span class="property">get</span>;</span><br><span class="line">        setter = getterOptions.<span class="property">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> cRef = <span class="keyword">new</span> <span class="title class_">ComputedRefImpl</span>(getter, setter, onlyGetter || !setter, isSSR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cRef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代理核心流程就是先进行参数归一化, 然后生成并返回一个实例化对象。让我们一起看一下啊<strong>ComputedRefImpl</strong>的实现</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ComputedRefImpl</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">getter, _setter, isReadonly, isSSR</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">getter</span> = getter;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_setter</span> = _setter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化副作用</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">effect</span> = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(</span><br><span class="line">            <span class="function">() =&gt;</span> <span class="title function_">getter</span>(<span class="variable language_">this</span>.<span class="property">_value</span>),</span><br><span class="line">            <span class="function">() =&gt;</span> <span class="title function_">triggerRefValue</span>(</span><br><span class="line">                <span class="variable language_">this</span>,</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">effect</span>.<span class="property">_dirtyLevel</span> === <span class="title class_">DirtyLevels</span>.<span class="property">MaybeDirty_ComputedSideEffect</span></span><br><span class="line">                    ? <span class="title class_">DirtyLevels</span>.<span class="property">MaybeDirty_ComputedSideEffect</span></span><br><span class="line">                    : <span class="title class_">DirtyLevels</span>.<span class="property">MaybeDirty</span>,</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">effect</span>.<span class="property">computed</span> = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">effect</span>.<span class="property">active</span> = <span class="variable language_">this</span>.<span class="property">_cacheable</span> = !isSSR;</span><br><span class="line">        <span class="variable language_">this</span>[<span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>] = isReadonly;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">        <span class="keyword">const</span> self = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 脏值则进行更新</span></span><br><span class="line">        <span class="keyword">if</span>(</span><br><span class="line">            (!self.<span class="property">_cacheable</span> || self.<span class="property">effect</span>.<span class="property">dirty</span>) &amp;&amp;</span><br><span class="line">            <span class="title function_">hasChanged</span>(self.<span class="property">_value</span>, (self.<span class="property">_value</span>) = self.<span class="property">effect</span>.<span class="title function_">run</span>())</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="title function_">triggerRefValue</span>(self, <span class="title class_">DirtyLevels</span>.<span class="property">Dirty</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依赖收集</span></span><br><span class="line">        <span class="title function_">trackRefValue</span>(self);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(self.<span class="property">effect</span>.<span class="property">_dirtyLevel</span> &gt;= <span class="title class_">DirtyLevels</span>.<span class="property">MaybeDirty_ComputedSideEffect</span>) &#123;</span><br><span class="line">            <span class="title function_">triggerRefValue</span>(self, <span class="title class_">DirtyLevels</span>.<span class="property">MaybeDirty_ComputedSideEffect</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.<span class="property">_value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行setter</span></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">_setter</span>(newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Computed&quot;&gt;&lt;a href=&quot;#Computed&quot; class=&quot;headerlink&quot; title=&quot;Computed&quot;&gt;&lt;/a&gt;Computed&lt;/h3&gt;&lt;p&gt;源码中关于&lt;strong&gt;computed&lt;/strong&gt;部分的定义：&lt;/p&gt;
&lt;figu</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>响应式原理：Reactive对象的响应式解析</title>
    <link href="https://sanxun8.github.io/2024/03/22/%E6%BA%90%E7%A0%81/vue3/reactive/"/>
    <id>https://sanxun8.github.io/2024/03/22/%E6%BA%90%E7%A0%81/vue3/reactive/</id>
    <published>2024-03-22T12:33:48.158Z</published>
    <updated>2024-04-01T11:51:37.562Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于vue中的响应式都是基于<strong>ReactiveEffect</strong>实现的的，<strong>effect</strong>为其使用之一。本小节基于<strong>effect</strong>理解<strong>ref</strong>对象的响应过程。若你想了解<strong>effect</strong>，你可以查看我往期的文章。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    user.<span class="property">name</span> = <span class="string">&#x27;tom&#x27;</span>;</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h3 id="Reactive"><a href="#Reactive" class="headerlink" title="Reactive"></a>Reactive</h3><p>源码中关于<strong>Reactive</strong>部分的定义：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">isReadonly</span>(target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(</span><br><span class="line">        target, </span><br><span class="line">        <span class="literal">false</span>, </span><br><span class="line">        mutableHandlers, </span><br><span class="line">        mutableCollectionHandlers, </span><br><span class="line">        reactiveMap</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数核心也就是通过<strong>createReactiveObject</strong>把我们传入的<strong>target</strong>变成响应式的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params">target, isReadonly, baseHandlers, collectionHandlers, proxyMap</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_">isObject</span>(target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(target[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>] &amp;&amp; !(isReadonly &amp;&amp; target[<span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> existingProxy = proxyMap.<span class="title function_">get</span>(target);</span><br><span class="line">    <span class="keyword">if</span>(existingProxy) &#123;</span><br><span class="line">        <span class="keyword">return</span> existingProxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> targetType = <span class="title function_">getTargetType</span>(target);</span><br><span class="line">    <span class="keyword">if</span>(targetType === <span class="title class_">TargetType</span>.<span class="property">INVALID</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">        target, </span><br><span class="line">        targetType === <span class="title class_">TargetType</span>.<span class="property">COLLECTION</span> ? collectionHandlers : baseHandlers</span><br><span class="line">    );</span><br><span class="line">    proxyMap.<span class="title function_">set</span>(target, proxy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码核心流程就是首先经过一系列判断，判断符合要求的<strong>target</strong>才能被响应式。包括target的类型、是否是响应式、是否已经被定义过了、是否是符合要求的类型。最后执行<strong>new Proxy</strong>对target进行代理, 其核心是处理器。我们先来看一下是定义了几种处理器，以及如何确认处理器的类型的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">targetType</span>(<span class="params">rawType</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (rawType) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Object&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Array&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">TargetType</span>.<span class="property">COMMON</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Map&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Set&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;WeakMap&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;WeakSet&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">TargetType</span>.<span class="property">COLLECTION</span>;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">TargetType</span>.<span class="property">INVALID</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTargetType</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value[<span class="title class_">ReactiveFlags</span>.<span class="property">SKIP</span>] || !<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(value) ? <span class="title class_">TargetType</span>.<span class="property">INVALID</span> : <span class="title function_">targetType</span>(<span class="title function_">toRawType</span>(value));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">toRawType</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// toTypeString 转换成字符串的方式，比如 &quot;[object RawType]&quot;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">toTypeString</span>(value).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<strong>target</strong>传入进来的是一个<strong>Object</strong>，所以<strong>toRawType</strong>得到的值是<strong>Object</strong>。所以这里的值等于<strong>TargetType.Common</strong>也就是使用<strong>baseHandlers</strong>。若传入进来的是<strong>Map</strong>、<strong>Set</strong>、<strong>WeakMap</strong>、<strong>WeakSet</strong>类型，则使用<strong>collectionHandlers</strong>，本章不进行展开<strong>collectionHandlers</strong>的解析。</p><p>接下来看一下<strong>baseHandlers</strong>的实现：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mutableHandlers = &#123;</span><br><span class="line">    get,</span><br><span class="line">    set,</span><br><span class="line">    deleteProperty,</span><br><span class="line">    has,</span><br><span class="line">    ownKeys,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是<strong>Proxy</strong>中的定义<strong>handler</strong>的一些属性</p><ul><li>get：属性读取操作的捕捉器。</li><li>set：属性设置操作的捕捉器。</li><li>deleteProperty： delete操作符的捕捉器。</li><li>has：in操作符的捕捉器。</li><li>ownKeys：Object.getOwnPropertyNames方法和Object.getOwnPropertySymbols方法的捕捉器。</li></ul><p><strong>reactive</strong>对象响应式的核心就在<strong>set</strong>和<strong>get</strong>中，我们一起来看一下二者的实现</p><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>get的源码实现</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseReactiveHandler</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">_isReadonly = <span class="literal">false</span>, _isShallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_isReadonly</span> = isReadonly;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_isShallow</span> = _isShallow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> isReadonly = <span class="variable language_">this</span>.<span class="property">_isReadonly</span>;</span><br><span class="line">        <span class="keyword">const</span> isShallow = <span class="variable language_">this</span>.<span class="property">_isShallow</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对 ReactiveFlags 的处理部分</span></span><br><span class="line">        <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> !isReadonly;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> isReadonly;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_SHALLOW</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> isShallow;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                receiver ===</span><br><span class="line">                (isReadonly</span><br><span class="line">                    ? isShallow</span><br><span class="line">                        ? shallowReadonlyMap</span><br><span class="line">                        : readonlyMap</span><br><span class="line">                    : isShallow</span><br><span class="line">                        ? shallowReactiveMap</span><br><span class="line">                        : reactiveMap</span><br><span class="line">                ).<span class="title function_">get</span>(target) ||</span><br><span class="line">                <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(target) === <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(receiver)</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> targetIsArray = <span class="title function_">isArray</span>(target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">            <span class="comment">// 过滤数组变异方法</span></span><br><span class="line">            <span class="keyword">if</span> (targetIsArray &amp;&amp; <span class="title function_">hasOwn</span>(arrayInstrumentations, key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(<span class="title class_">Instrumentations</span>, key, receiver);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (key === <span class="string">&#x27;hasOwnProperty&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> hasOwnProperty;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 过滤 Symbol Key 和 一些不收集依赖的键</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isSymbol</span>(key) ? builtInSymbols.<span class="title function_">has</span>(key) : <span class="title function_">isNonTrackableKeys</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">            <span class="title function_">track</span>(target, <span class="title class_">TrackOpTypes</span>.<span class="property">Get</span>, key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isShallow) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isRef</span>(res)) &#123; <span class="comment">// 不太清楚</span></span><br><span class="line">            <span class="keyword">return</span> targetIsArray &amp;&amp; <span class="title function_">isIntegerKey</span>(key) ? res : res.<span class="property">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isObject</span>(res)) &#123;</span><br><span class="line">            <span class="keyword">return</span> isReadonly ? <span class="title function_">readonly</span>(res) : <span class="title function_">reactive</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>get api</strong>核心流程就是首先经过一系列判断, 判断符合要求的<strong>key</strong>才进行依赖收集, 然后根据对不同的类型进行处理返回。不收集依赖的key包括预设属性、symbol类型的自有属性。</p><p>当我们的<strong>target</strong>是数组，且<strong>key</strong>值存在<strong>arraInstrumentations</strong>中时，返回<strong>arraInstrumentations</strong>中对应的<strong>key</strong>值。我们再来看看<strong>arraInstrumentations</strong>是个什么：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayInstrumentations = <span class="title function_">createArrayInstrumentations</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createArrayInstrumentations</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> instrumentations = &#123;&#125;;</span><br><span class="line">    ([<span class="string">&#x27;includes&#x27;</span>, <span class="string">&#x27;indexOf&#x27;</span>, <span class="string">&#x27;lastIndexOf&#x27;</span>]).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        instrumentations[key] = <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>, ...args</span>) &#123;</span><br><span class="line">            <span class="comment">// toRaw 可以把响应式对象转成原始数据</span></span><br><span class="line">            <span class="keyword">const</span> arr = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="variable language_">this</span>.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="comment">// 对数组的每一项进行依赖收集</span></span><br><span class="line">                <span class="title function_">track</span>(arr, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, i + <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 先尝试用参数本身，可能是响应式数据</span></span><br><span class="line">            <span class="keyword">const</span> res = arr[key](...args)</span><br><span class="line">            <span class="keyword">if</span> (res === -<span class="number">1</span> || res === <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果失败，再尝试把参数转成原始数据</span></span><br><span class="line">                <span class="keyword">return</span> arr[key](...args.<span class="title function_">map</span>(toRaw))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>, <span class="string">&#x27;unshift&#x27;</span>, <span class="string">&#x27;splice&#x27;</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        instrumentations[key] = <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>, ...args</span>) &#123;</span><br><span class="line">            <span class="title function_">pauseTracking</span>()</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>)[key].<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">            <span class="title function_">resetTracking</span>()</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instrumentations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>arrayInstrumentations</strong>会重写两类函数，一类是查询类函数：<strong>inclues</strong>、<strong>indexOf</strong>、<strong>lastIndeOf</strong>，代表对数组的读取操作。在这些函数中会执行<strong>track</strong>函数，对数组的索引进行依赖收集。</p><p>另一类是修改类函数：<strong>push</strong>、<strong>pop</strong>、<strong>shift</strong>、<strong>unshift</strong>、<strong>splice</strong>，代表对数组的修改操作，在这些函数中暂停了全局的追踪功能，防止某些情况下导致死循环。</p><p>再回过来看<strong>get api</strong>，接下来的操作就是通过<strong>track(target, TrackOpTypes.Get, key)<strong>进行依赖收集，我们再来一起看一下</strong>track</strong>的实现：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shouldTrack = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> activeEffect; <span class="comment">// ReactiveEffect实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target, type, key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;</span><br><span class="line">        <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化依赖映射</span></span><br><span class="line">        <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">            targetMap.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key);</span><br><span class="line">        <span class="comment">// 设置依赖</span></span><br><span class="line">        <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">            depsMap.<span class="title function_">set</span>(key, (dep = <span class="title function_">createDep</span>(<span class="function">() =&gt;</span> depsMap.<span class="title function_">delete</span>(key))));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收集副作用</span></span><br><span class="line">        <span class="title function_">trackEffect</span>(activeEffect, dep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackEffect</span>(<span class="params">effect, dep, debuggerEventEXtraInfo</span>) &#123;</span><br><span class="line">    <span class="comment">// 待完善</span></span><br><span class="line">    <span class="comment">// 设置依赖标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除依赖副作用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用收集回调</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dep.<span class="title function_">get</span>(effect) !== effect.<span class="property">_trackId</span>) &#123;</span><br><span class="line">        dep.<span class="title function_">set</span>(effect, effect.<span class="property">_trackId</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>上面函数有点绕，其实核心就是在生成一个数据结构，什么样的数据结构呢？我们来画个图看看：</p><p><img src="https://i.imgur.com/X7hex8a.png" alt="Imgur"></p><p>我们创建了全局的<strong>targetMap</strong>，它的键是<strong>target</strong>，值是<strong>depsMap</strong>；这个<strong>depsMap</strong>的键是<strong>target</strong>的<strong>key</strong>，值是<strong>dep</strong>集合，<strong>dep</strong>集合中存储的是依赖的副作用函数<strong>effect</strong>。</p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>上面说完了<strong>get</strong>的流程，我们了解一下依赖收集后的数据结构存储在了<strong>targetMap</strong>中，接下来我们接着看<strong>set</strong>的过程：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MutableReactiveHandler</span> <span class="keyword">extends</span> <span class="title class_ inherited__">BaseReactiveHandler</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">isShallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(<span class="literal">false</span>, isShallow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> oldValue = target[key];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对深层响应式，处理新旧值</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_isShallow</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> isOldValueReadonly = <span class="title function_">isReadonly</span>(oldValue);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="title function_">isShallow</span>(value) &amp;&amp; !<span class="title function_">isReadonly</span>(value)) &#123;</span><br><span class="line">                oldValue = <span class="title function_">toRaw</span>(oldValue);</span><br><span class="line">                value = <span class="title function_">toRaw</span>(value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isRef</span>(oldValue) &amp;&amp; !<span class="title function_">isRef</span>(value)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isOldValueReadonly) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    oldValue.<span class="property">value</span> = value;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否为已有属性</span></span><br><span class="line">        <span class="keyword">const</span> hadKey = </span><br><span class="line">            <span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isIntegerKey</span>(key) </span><br><span class="line">                ? (<span class="title class_">Number</span>(key) &lt; target.<span class="property">length</span>) </span><br><span class="line">                : <span class="title function_">hasOwn</span>(target, key); </span><br><span class="line">        <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">        <span class="keyword">if</span> (target === <span class="title function_">toRaw</span>(receiver)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 触发响应</span></span><br><span class="line">            <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">                <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>, key, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(value, oldValue)) &#123;</span><br><span class="line">                <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>, key, value, oldValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到<strong>set</strong>接口核心逻辑就是根据是否为渐层响应式来确认原始值和新值，这里默认不是浅层的响应式，所以会先把原始值和新值进行<strong>toRaw</strong>转换，然后通过<strong>Reflect.set</strong>设置值，最后通过<strong>trigger</strong>函数派发通知，并依据<strong>key</strong>是否存在于<strong>target</strong>来确认通知类型是<strong>add</strong>（新增）还是<strong>set</strong>（修改）。</p><p>接下来核心就是<strong>trigger</strong>的逻辑，是如何实现触发响应的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, type, key, newValue, oldValue, oldTarget</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> depsMap = targetMap.<span class="title function_">get</span>(target);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理未收集</span></span><br><span class="line">    <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> deps = []; <span class="comment">// 需要被处理依赖</span></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="title class_">TriggerOpTypes</span>.<span class="property">CLEAR</span>) &#123; <span class="comment">// 操作为清理 </span></span><br><span class="line">        deps = [...depsMap.<span class="title function_">values</span>()];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span> &amp;&amp; <span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">        <span class="keyword">const</span> newLength = <span class="title class_">Number</span>(newValue);</span><br><span class="line">        depsMap.<span class="title function_">forEach</span>(<span class="function">(<span class="params">dep, key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span> || (!<span class="title function_">isSymbol</span>(key) &amp;&amp; key &gt;= newLength)) &#123;</span><br><span class="line">                deps.<span class="title function_">push</span>(dep);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key !== <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">            deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>:</span><br><span class="line">                <span class="keyword">if</span> (!<span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">                    deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERACE_KEY</span>)); <span class="comment">// 暂不理解</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="title function_">isMap</span>(target)) &#123;</span><br><span class="line">                        deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">MAP_KEY_ITERATE_KEY</span>)); <span class="comment">// 暂不理解</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isIntegerKey</span>(key)) &#123;</span><br><span class="line">                    deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="string">&#x27;length&#x27;</span>)); <span class="comment">// // 暂不理解</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="title class_">TriggerOpTypes</span>.<span class="property">DELETE</span>:</span><br><span class="line">                <span class="keyword">if</span> ((!<span class="title function_">isArray</span>(target))) &#123;</span><br><span class="line">                    deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERACE_KEY</span>)); <span class="comment">// 暂不理解</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="title function_">isMap</span>(target)) &#123;</span><br><span class="line">                        deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">MAP_KEY_ITERATE_KEY</span>)); <span class="comment">// 暂不理解</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="title class_">TriggerOptypes</span>.<span class="property">SET</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">isMap</span>(target)) &#123;</span><br><span class="line">                    deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERACE_KEY</span>)); <span class="comment">// 暂不理解</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂停调度</span></span><br><span class="line">    <span class="title function_">pauseScheduling</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历依赖，执行副作用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> dep <span class="keyword">of</span> deps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep) &#123;</span><br><span class="line">            <span class="title function_">triggerEffects</span>(dep, <span class="title class_">DirtyLevels</span>.<span class="property">Dirty</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置调调</span></span><br><span class="line">    <span class="title function_">resetScheduling</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackEffect</span>(<span class="params">effect, dep, debuggerEventEXtraInfo</span>) &#123;</span><br><span class="line">    <span class="comment">// 待完善</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置依赖标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除依赖副作用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用收集回调</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dep.<span class="title function_">get</span>(effect) !== effect.<span class="property">_trackId</span>) &#123;</span><br><span class="line">        dep.<span class="title function_">set</span>(effect, effect.<span class="property">_trackId</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>上述代码的核心流程就是获取需要响应的依赖，首先是响应操作类型为清理时，所有依赖都需要被清理，其次修改<strong>length</strong>属性且<strong>target</strong>为数组时，访问<strong>length</strong>属性的依赖以及数组中超过新数组长度的元素依赖需要被清理。获取需要响应的依赖后，暂停全局调度后，遍历执行其副作用函数，最后重置调度。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，我们讲完了对<strong>reactive</strong>对象响应式的依赖收集和触发过程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;由于vue中的响应式都是基于&lt;strong&gt;ReactiveEffect&lt;/strong&gt;实现的的，&lt;strong&gt;effect&lt;/stro</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>响应式原理：Ref对象的响应式解析</title>
    <link href="https://sanxun8.github.io/2024/03/22/%E6%BA%90%E7%A0%81/vue3/ref/"/>
    <id>https://sanxun8.github.io/2024/03/22/%E6%BA%90%E7%A0%81/vue3/ref/</id>
    <published>2024-03-22T12:33:24.547Z</published>
    <updated>2024-04-01T11:51:34.600Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于vue中的响应式都是基于<strong>ReactiveEffect</strong>实现的的，<strong>effect</strong>为其使用之一。本小节基于<strong>effect</strong>理解<strong>ref</strong>对象的响应过程。若你想了解<strong>effect</strong>，你可以查看我往期的文章。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isLike = <span class="title function_">ref</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(isLike.<span class="property">value</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    isLike.<span class="property">value</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p><strong>effect</strong>默认会调用回调函数，当访问了<strong>isLike.value</strong>, 会执行<strong>trackRefValue</strong>收集依赖，当给<strong>isLike.value</strong>重新赋值后，会执行<strong>triggerRefValue</strong>触发响应。而<strong>trackRefValue、triggerRefValue</strong>在源码中是如何调用的、做了哪些事情，跟着我的步伐，你将会得到答案。</p><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><p>源码中关于<strong>ref</strong>部分的定义：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ref</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createRef</span>(value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的核心也就是通过<strong>createRef</strong>把我们传入的<strong>value</strong>变成响应式的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createRef</span>(<span class="params">rawValue, shallow</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isRef</span>(rawValue)) &#123;</span><br><span class="line">        <span class="keyword">return</span> rawValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RefImpl</span>(rawValue, shallow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先经过判断，判断符合要求的<strong>value</strong>才能被响应式。一起来看看这个<strong>API</strong>的实现：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RefImpl</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">value, __v_isShallow</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">__v_isShallow</span> = __v_isShallow;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_rawValue</span> = __v_isShallow ? value : <span class="title function_">toRaw</span>(value);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_value</span> = __v_isShallow ? value : <span class="title function_">toReactive</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">        <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>); <span class="comment">// 收集依赖</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> useDirectValue = <span class="variable language_">this</span>.<span class="property">__v_isShallow</span> || <span class="title function_">isShallow</span>(newVal) || <span class="title function_">isReadonly</span>(newVal);</span><br><span class="line">        newVal = useDirectValue ? newVal : <span class="title function_">toRaw</span>(newVal);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(newVal, <span class="variable language_">this</span>.<span class="property">_rawValue</span>)) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_rawValue</span> = newVal;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_value</span> = useDirectValue ? newVal : <span class="title function_">toReactive</span>(newVal);</span><br><span class="line">            <span class="title function_">triggerRefValue</span>(<span class="variable language_">this</span>, <span class="title class_">DirtyLevels</span>.<span class="property">Dirty</span>, newVal); <span class="comment">// 触发相应</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用<strong>value getter</strong>时，会调用<strong>trackRefValue</strong>收集依赖，让我们看一下<strong>trackRefValue</strong>的实现</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackRefValue</span>(<span class="params">ref</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;</span><br><span class="line">        ref = <span class="title function_">toRaw</span>(ref);</span><br><span class="line">        ref.<span class="property">dep</span> ??= <span class="title function_">createDep</span>(<span class="function">() =&gt;</span> (ref.<span class="property">dep</span> = <span class="literal">undefined</span>), ref <span class="keyword">instanceof</span> <span class="title class_">ComputedRefImpl</span> ? ref : <span class="literal">undefined</span>);</span><br><span class="line">        <span class="title function_">trackEffect</span>(activeEffect, ref.<span class="property">dep</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>trackRefValue会给ref增加依赖dep属性存储副作用函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">createDep</span> = (<span class="params">cleanup, computed</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    dep.<span class="property">cleanup</span> = cleanup;</span><br><span class="line">    dep.<span class="property">computed</span> = computed;</span><br><span class="line">    <span class="keyword">return</span> dep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackEffect</span>(<span class="params">effect, dep, debuggerEventExtraInfo</span>) &#123;</span><br><span class="line">    <span class="comment">// 待完善</span></span><br><span class="line">    <span class="comment">// 设置依赖标识</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用<strong>value setter</strong>时，会调用<strong>triggerRefValue</strong>触发更新，让我们看一下<strong>triggerRefValue</strong>的实现</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerRefValue</span>(<span class="params">ref, dirtyLevel, newValue</span>) &#123;</span><br><span class="line">    ref = <span class="title function_">toRaw</span>(ref);</span><br><span class="line">    <span class="keyword">const</span> dep = ref.<span class="property">dep</span>;</span><br><span class="line">    <span class="keyword">if</span> (dep) &#123;</span><br><span class="line">        <span class="title function_">triggerEffects</span>(dep, dirtyLevel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其核心就是调用用<strong>triggerEffects</strong>触发副作用函数执行</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerEffects</span>(<span class="params">dep, dirtyLevel, debuggerEventExtraInfo</span>) &#123;</span><br><span class="line">    <span class="comment">// 待完善</span></span><br><span class="line">    <span class="comment">// 暂停调度</span></span><br><span class="line">    <span class="comment">// 遍历依赖，执行副作用函数</span></span><br><span class="line">    <span class="comment">// 重置调度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，我们讲完了对<strong>ref</strong>对象响应式的依赖收集和触发过程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;由于vue中的响应式都是基于&lt;strong&gt;ReactiveEffect&lt;/strong&gt;实现的的，&lt;strong&gt;effect&lt;/stro</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue3中中获取最长递增子序列</title>
    <link href="https://sanxun8.github.io/2024/03/22/%E6%BA%90%E7%A0%81/vue3/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://sanxun8.github.io/2024/03/22/%E6%BA%90%E7%A0%81/vue3/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2024-03-22T11:17:15.570Z</published>
    <updated>2024-03-29T15:16:48.013Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSequence</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> p = arr.<span class="title function_">slice</span>(); <span class="comment">// 反向链表 可以使用 p = []初始化</span></span><br><span class="line">    <span class="keyword">const</span> result = [<span class="number">0</span>] <span class="comment">// 结果值到原数组索引的映射</span></span><br><span class="line">    <span class="keyword">let</span> i, j, u, v, c;</span><br><span class="line">    <span class="keyword">const</span> len = arr.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> arrI = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (arrI !== <span class="number">0</span>) &#123;</span><br><span class="line">            j = result[result.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arrI) &#123; <span class="comment">// 与最后一项对比</span></span><br><span class="line">                p[i] = j;</span><br><span class="line">                result.<span class="title function_">push</span>(i);</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            u = <span class="number">0</span>;</span><br><span class="line">            v = result.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (u &lt; v) &#123; <span class="comment">// 二分查找</span></span><br><span class="line">                c = (u + v) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (arr[result[c]] &lt; arrI) &#123;</span><br><span class="line">                    u = c + <span class="number">1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    v = c</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arrI &lt; arr[result[u]]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (u &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    p[i] = result[u - <span class="number">1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">                result[u] = i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯修正</span></span><br><span class="line">    u = result.<span class="property">length</span></span><br><span class="line">    v = result[u - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> (u-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        result[u] = v</span><br><span class="line">        v = p[v]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>渲染器：数组节点中的Dom Diff</title>
    <link href="https://sanxun8.github.io/2024/03/22/%E6%BA%90%E7%A0%81/vue3/vue3_dom_diff/"/>
    <id>https://sanxun8.github.io/2024/03/22/%E6%BA%90%E7%A0%81/vue3/vue3_dom_diff/</id>
    <published>2024-03-22T08:43:51.154Z</published>
    <updated>2024-04-01T11:52:13.246Z</updated>
    
    <content type="html"><![CDATA[<p>在前端开发中，我们经常需要处理包含数组子节点的动态列表或复杂组件。本文将基于源码，梳理数组子节点的Diff更新流程，帮助读者更好地理解Vue3是如何通过Diff算法来高效地更新这些子节点，以提升应用性能。</p><h3 id="从头对比"><a href="#从头对比" class="headerlink" title="从头对比"></a>从头对比</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 当前对比索引</span></span><br><span class="line">    <span class="keyword">const</span> l2 = c2.<span class="property">length</span>; <span class="comment">// 新节点长度</span></span><br><span class="line">    <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 旧节点结束标识</span></span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>; <span class="comment">// 新节点介绍标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 头对比</span></span><br><span class="line">    <span class="comment">// (a b) c</span></span><br><span class="line">    <span class="comment">// (a b) d e</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; e1 &amp;&amp; i &lt; e2) &#123;</span><br><span class="line">        <span class="keyword">const</span> n1 = c1[i];</span><br><span class="line">        <span class="keyword">const</span> n2 = c2[i] = optimized ? <span class="title function_">cloneIfMounted</span>(c2[i]) : <span class="title function_">normalizeVNode</span>(c2[i]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class="line">            <span class="title function_">patch</span>(n1, n2, container, <span class="literal">null</span>, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从尾部对比"><a href="#从尾部对比" class="headerlink" title="从尾部对比"></a>从尾部对比</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 当前对比索引</span></span><br><span class="line">    <span class="keyword">const</span> l2 = c2.<span class="property">length</span>; <span class="comment">// 新节点长度</span></span><br><span class="line">    <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 旧节点结束标识</span></span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>; <span class="comment">// 新节点介绍标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 头对比</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 尾对比</span></span><br><span class="line">    <span class="comment">// a (b c)</span></span><br><span class="line">    <span class="comment">// d e (b c)</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; e1 &amp;&amp; i &lt; e2) &#123;</span><br><span class="line">        <span class="keyword">const</span> n1 = c1[e1];</span><br><span class="line">        <span class="keyword">const</span> n2 = c2[e2] = optimized ? <span class="title function_">cloneIfMounted</span>(c2[e2]) : <span class="title function_">normalizeVNode</span>(c2[e2]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class="line">            <span class="title function_">patch</span>(n1, n2, container, <span class="literal">null</span>, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        e1--;</span><br><span class="line">        e2--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="仅处理新增"><a href="#仅处理新增" class="headerlink" title="仅处理新增"></a>仅处理新增</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 当前对比索引</span></span><br><span class="line">    <span class="keyword">const</span> l2 = c2.<span class="property">length</span>; <span class="comment">// 新节点长度</span></span><br><span class="line">    <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 旧节点结束标识</span></span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>; <span class="comment">// 新节点介绍标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 头对比</span></span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    <span class="comment">// 2. 从尾部对比</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 仅新增</span></span><br><span class="line">    <span class="comment">// (a b)</span></span><br><span class="line">    <span class="comment">// (a b) c</span></span><br><span class="line">    <span class="comment">// i = 2, e1 = 1, e2 = 2</span></span><br><span class="line">    <span class="comment">// (a b)</span></span><br><span class="line">    <span class="comment">// c (a b)</span></span><br><span class="line">    <span class="comment">// i = 0, e1 = -1, e2 = 0</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; e1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= e2) &#123;</span><br><span class="line">            <span class="keyword">const</span> nextPos = e2 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">const</span> anchor = nextPos &lt; l2 ? c2[nextPos].<span class="property">el</span> : parentAnchor;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= e2) &#123;</span><br><span class="line">                <span class="title function_">patch</span>(<span class="literal">null</span>, c2[i] = optimized ? <span class="title function_">cloneIfMounted</span>(c2[i]) : <span class="title function_">normalizeVNode</span>(c2[i]), container, anchor, parentComponent, parentSuspense)</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="仅处理卸载"><a href="#仅处理卸载" class="headerlink" title="仅处理卸载"></a>仅处理卸载</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 当前对比索引</span></span><br><span class="line">    <span class="keyword">const</span> l2 = c2.<span class="property">length</span>; <span class="comment">// 新节点长度</span></span><br><span class="line">    <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 旧节点结束标识</span></span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>; <span class="comment">// 新节点介绍标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 头对比</span></span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    <span class="comment">// 2. 从尾部对比</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 3. 仅新增</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; e1) &#123; <span class="comment">// ...&#125; </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 仅卸载</span></span><br><span class="line">    <span class="comment">// (a b) c</span></span><br><span class="line">    <span class="comment">// (a b)</span></span><br><span class="line">    <span class="comment">// i = 2, e1 = 2, e2 = 1</span></span><br><span class="line">    <span class="comment">// a (b c)</span></span><br><span class="line">    <span class="comment">// (b c)</span></span><br><span class="line">    <span class="comment">// i = 0, e1 = 0, e2 = -1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= e1) &#123;</span><br><span class="line">            <span class="title function_">unmount</span>(c1[i], parentComponent, parentAnchor, <span class="literal">true</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理未知序列"><a href="#处理未知序列" class="headerlink" title="处理未知序列"></a>处理未知序列</h3><h4 id="构建新节点key到index的映射"><a href="#构建新节点key到index的映射" class="headerlink" title="构建新节点key到index的映射"></a>构建新节点key到index的映射</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 当前对比索引</span></span><br><span class="line">    <span class="keyword">const</span> l2 = c2.<span class="property">length</span>; <span class="comment">// 新节点长度</span></span><br><span class="line">    <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 旧节点结束标识</span></span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>; <span class="comment">// 新节点介绍标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 头对比</span></span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    <span class="comment">// 2. 从尾部对比</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 3. 仅新增</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; e1) &#123; <span class="comment">// ...&#125; </span></span><br><span class="line">    <span class="comment">// 4. 仅卸载</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123; <span class="comment">// ... &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> s1 = i; <span class="comment">// 旧节点开始处理索引</span></span><br><span class="line">        <span class="keyword">const</span> s2 = i; <span class="comment">// 新节点开始处理索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.1 构建新节点key到index的映射</span></span><br><span class="line">        <span class="keyword">const</span> keyToNewIndexMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">        <span class="keyword">for</span> (i = s2; i &lt;= e2; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> nextChild = c2[i] = optimized ? <span class="title function_">cloneIfMounted</span>(c2[i]) : <span class="title function_">normalizeVNode</span>(c2[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nextChild.<span class="property">key</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">                keyToNewIndexMap.<span class="title function_">set</span>(nextChild.<span class="property">key</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-处理旧节点（更新和卸载）"><a href="#5-2-处理旧节点（更新和卸载）" class="headerlink" title="5.2 处理旧节点（更新和卸载）"></a>5.2 处理旧节点（更新和卸载）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 当前对比索引</span></span><br><span class="line">    <span class="keyword">const</span> l2 = c2.<span class="property">length</span>; <span class="comment">// 新节点长度</span></span><br><span class="line">    <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 旧节点结束标识</span></span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>; <span class="comment">// 新节点介绍标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 头对比</span></span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    <span class="comment">// 2. 从尾部对比</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 3. 仅新增</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; e1) &#123; <span class="comment">// ...&#125; </span></span><br><span class="line">    <span class="comment">// 4. 仅卸载</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123; <span class="comment">// ... &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> s1 = i; <span class="comment">// 旧节点开始处理索引</span></span><br><span class="line">        <span class="keyword">const</span> s2 = i; <span class="comment">// 新节点开始处理索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.1 构建新节点key到index的映射</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.2 处理旧节点（更新和卸载）</span></span><br><span class="line">        <span class="keyword">let</span> patched = <span class="number">0</span>; <span class="comment">// 已处理的数目</span></span><br><span class="line">        <span class="keyword">const</span> toBePatched = e2 - s2 + <span class="number">1</span>; <span class="comment">// 需要处理的数目</span></span><br><span class="line">        <span class="keyword">let</span> moved = <span class="literal">false</span>; <span class="comment">// 标记节点是否移动</span></span><br><span class="line">        <span class="keyword">let</span> maxNewIndexSoFar = <span class="number">0</span>; <span class="comment">// 辅助判断节点是否移动</span></span><br><span class="line">        <span class="keyword">const</span> newIndexToOldIndexMap = <span class="keyword">new</span> <span class="title class_">Array</span>(toBePatched);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = s1; i &lt;= e1; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> prevChild = e1[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (patched &gt;= toBePatched) &#123; <span class="comment">// 卸载多余节点</span></span><br><span class="line">                <span class="title function_">unmount</span>(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> nextIndex;</span><br><span class="line">            newIndex = keyToNewIndexMap.<span class="title function_">get</span>(prevChild.<span class="property">key</span>);</span><br><span class="line">            <span class="keyword">if</span> (newIndex === <span class="literal">undefined</span>) &#123; <span class="comment">// 新节点找不到则卸载</span></span><br><span class="line">                <span class="title function_">unmount</span>(prevChild, parentComponent, parentAnchor, <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newIndexToOldIndexMap[newIndex - s2] = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class="line">                    maxNewIndexSoFar = newIndex;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    moved = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_">patch</span>(prevChild, c2[newIndex], <span class="literal">null</span>, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)</span><br><span class="line">                patched++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-移动和新增"><a href="#5-3-移动和新增" class="headerlink" title="5.3 移动和新增"></a>5.3 移动和新增</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 当前对比索引</span></span><br><span class="line">    <span class="keyword">const</span> l2 = c2.<span class="property">length</span>; <span class="comment">// 新节点长度</span></span><br><span class="line">    <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 旧节点结束标识</span></span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>; <span class="comment">// 新节点介绍标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 头对比</span></span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    <span class="comment">// 2. 从尾部对比</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 3. 仅新增</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; e1) &#123; <span class="comment">// ...&#125; </span></span><br><span class="line">    <span class="comment">// 4. 仅卸载</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123; <span class="comment">// ... &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> s1 = i; <span class="comment">// 旧节点开始处理索引</span></span><br><span class="line">        <span class="keyword">const</span> s2 = i; <span class="comment">// 新节点开始处理索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.1 构建新节点key到index的映射</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 5.2 处理旧节点（更新和卸载）</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.3 移动和新增</span></span><br><span class="line">        <span class="keyword">const</span> increasingNewIndexSequence = moved ? <span class="title function_">getSequence</span>(newIndexToOldIndexMap) : <span class="variable constant_">EMPTY_ARR</span>;</span><br><span class="line">        <span class="keyword">let</span> j = increasingNewIndexSequence.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = toBePatched - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">const</span> nextIndex = s2 + i;</span><br><span class="line">            <span class="keyword">const</span> nextChild = c2[nextIndex];</span><br><span class="line">            <span class="keyword">const</span> anchor = nextIndex + <span class="number">1</span> &lt; l2 ? c2[nextIndex].<span class="property">el</span> : parentAnchor;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newIndexToOldIndexMap[i] === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="title function_">patch</span>(<span class="literal">null</span>, nextChild, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (moved) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; <span class="number">0</span> || i !== increasingNewIndexSequence[j]) &#123;</span><br><span class="line">                    <span class="title function_">moved</span>(nextChild, container, anchor, <span class="title class_">MoveType</span>.<span class="property">REORDER</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化思考"><a href="#优化思考" class="headerlink" title="优化思考"></a>优化思考</h4><ul><li>唯一标识: 我们使用 v-for 编写列表时为什么不建议使用 index 作为 key?</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>希望本文能够帮助读者深入理解基于数组子节点的Diff更新流程，并在实际项目中应用这一知识，提升应用的性能和用户体验</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在前端开发中，我们经常需要处理包含数组子节点的动态列表或复杂组件。本文将基于源码，梳理数组子节点的Diff更新流程，帮助读者更好地理解Vue3是如何通过Diff算法来高效地更新这些子节点，以提升应用性能。&lt;/p&gt;
&lt;h3 id=&quot;从头对比&quot;&gt;&lt;a href=&quot;#从头对比&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue2中nextTick的实现</title>
    <link href="https://sanxun8.github.io/2024/03/21/%E6%BA%90%E7%A0%81/vue2/vue2_nextTeck/"/>
    <id>https://sanxun8.github.io/2024/03/21/%E6%BA%90%E7%A0%81/vue2/vue2_nextTeck/</id>
    <published>2024-03-21T12:56:44.097Z</published>
    <updated>2024-03-29T15:13:35.007Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> inBrowser = <span class="keyword">typeof</span> <span class="variable language_">window</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="variable language_">window</span>) !== <span class="string">&#x27;[object Object]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> nextTick = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> callbacks = [];</span><br><span class="line">    <span class="keyword">let</span> pendding = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> timeFunc;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">nextTickHandler</span>(<span class="params"></span>) &#123;</span><br><span class="line">        pendding = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">const</span> copies = callbacks.<span class="title function_">slice</span>(<span class="number">0</span>);</span><br><span class="line">        callbacks = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            copies[i]();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">MutationObserver</span> === <span class="string">&#x27;undefined&#x27;</span>) &#123; <span class="comment">// cb同步执行</span></span><br><span class="line">        <span class="keyword">let</span> counter = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(nextTickHandler)</span><br><span class="line">        <span class="keyword">const</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter));</span><br><span class="line">        observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">            <span class="attr">characterData</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        timeFunc = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            counter = (counter + <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">            textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// cb同步执行</span></span><br><span class="line">        <span class="keyword">const</span> context = inBrowser ? <span class="variable language_">window</span> : <span class="keyword">typeof</span> <span class="variable language_">global</span> !== <span class="string">&#x27;undefined&#x27;</span> ? <span class="variable language_">global</span> : &#123;&#125;;</span><br><span class="line">        timeFunc = context.<span class="property">setImmediate</span> || <span class="built_in">setTimeout</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">cb, ctx</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> func = ctx ? <span class="keyword">function</span>(<span class="params"></span>) &#123;cb.<span class="title function_">call</span>(ctx);&#125; : cb;</span><br><span class="line">        callbacks.<span class="title function_">push</span>(func);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pendding) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        pendding = <span class="literal">true</span>;</span><br><span class="line">        <span class="title function_">timeFunc</span>(nextTickHandler, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; inBrowser = &lt;spa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>中介者模式：简化对象间的通信</title>
    <link href="https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-03-19T06:12:59.572Z</published>
    <updated>2024-03-25T09:55:19.471Z</updated>
    
    <content type="html"><![CDATA[<p>中介者模式（Mediator Pattern）是一种行为型设计模式，用于解耦多个对象之间的通信，并将其集中处理。通过引入一个中介者对象，各个对象不再直接相互通信，而是通过中介者进行交互。这种模式可以减少对象间的耦合度，提高系统的可维护性和灵活性。</p><hr><h3 id="示例场景-vue2中收集响应式依赖-通过Dep类集中处理依赖更新"><a href="#示例场景-vue2中收集响应式依赖-通过Dep类集中处理依赖更新" class="headerlink" title="示例场景(vue2中收集响应式依赖, 通过Dep类集中处理依赖更新)"></a>示例场景(vue2中收集响应式依赖, 通过Dep类集中处理依赖更新)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中介模式</span></span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span>; <span class="comment">// 使用闭包实现唯一标识</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = uid++;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addSub</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">removeSub</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">    <span class="title function_">remove</span>(<span class="variable language_">this</span>.<span class="property">subs</span>, sub); <span class="comment">// 一个工具函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">depend</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">      <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">addDep</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">slice</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].<span class="title function_">update</span>();  <span class="comment">// 调用Watcher.prototype.addDep</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图模型对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">    <span class="title function_">addDep</span>(<span class="params">dep</span>) &#123;</span><br><span class="line">        dep.<span class="title function_">addSub</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 更新视图</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模型对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReacitve</span>(<span class="params">obj, key, value, customSetter</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="attr">enumeralbe</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">                dep.<span class="title function_">depend</span>() <span class="comment">// 收集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            dep.<span class="title function_">notify</span>(); <span class="comment">// 通知</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该案例中使用了<strong>Dep类</strong>充当中介者角色, <strong>模型对象</strong>不直接与<strong>视图模型对象</strong>直接通信, 避免了响应式数据挟持后书写视图更新的负责逻辑代码;</p><h3 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h3><p>假设我们正在开发一个聊天室应用程序，其中包含多个用户（User）和一个聊天室（ChatRoom）。用户之间可以相互发送消息，同时聊天室也可以将消息广播给所有用户。</p><p>在这个场景中，可以使用中介者模式来简化用户和聊天室之间的通信。聊天室充当中介者，用户充当同事类。用户之间的消息不再直接发送给其他用户，而是通过聊天室中介者进行转发。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>中介者模式的核心思想是将对象间的通信行为集中管理，通过引入一个中介者对象来协调各个对象之间的交互。</li><li>中介者模式的核心组成部分: 中介者, 交互对象(可能是同事类);</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。</p><p>通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。</p><p>敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;中介者模式（Mediator Pattern）是一种行为型设计模式，用于解耦多个对象之间的通信，并将其集中处理。通过引入一个中介者对象，各个对象不再直接相互通信，而是通过中介者进行交互。这种模式可以减少对象间的耦合度，提高系统的可维护性和灵活性。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>建造者模式：构建复杂对象的灵活设计模式</title>
    <link href="https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-03-19T06:12:53.157Z</published>
    <updated>2024-03-25T10:01:31.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。"><a href="#建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。" class="headerlink" title="建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。"></a>建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。</h2><h3 id="示例场景-创建一个计算机对象"><a href="#示例场景-创建一个计算机对象" class="headerlink" title="示例场景(创建一个计算机对象)"></a>示例场景(创建一个计算机对象)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Product: 表示要构建的复杂对象​</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;​</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cpu</span> = <span class="string">&quot;&quot;</span>;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">gpu</span> = <span class="string">&quot;&quot;</span>;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ram</span> = <span class="number">0</span>;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storage</span> = <span class="string">&quot;&quot;</span>;​</span><br><span class="line">  &#125;​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">describe</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Computer with CPU: <span class="subst">$&#123;<span class="variable language_">this</span>.cpu&#125;</span>, GPU: <span class="subst">$&#123;<span class="variable language_">this</span>.gpu&#125;</span>, RAM: <span class="subst">$&#123;<span class="variable language_">this</span>.ram&#125;</span>GB, Storage: <span class="subst">$&#123;<span class="variable language_">this</span>.storage&#125;</span>`</span>;​</span><br><span class="line">  &#125;​</span><br><span class="line">&#125;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// Builder: 声明构建复杂对象的接口​</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerBuilder</span> &#123;​</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">computer</span> = <span class="keyword">new</span> <span class="title class_">Computer</span>();​</span><br><span class="line">  &#125;​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">setCPU</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">computer</span>.<span class="property">cpu</span> = <span class="string">&quot;AMD 5600G&quot;</span>;​</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;​</span><br><span class="line">  &#125;​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">setGPU</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">computer</span>.<span class="property">gpu</span> = <span class="string">&quot;核显&quot;</span>;​</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;​</span><br><span class="line">  &#125;​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">setRAM</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">computer</span>.<span class="property">ram</span> = <span class="number">16</span>;​</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;​</span><br><span class="line">  &#125;​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">setStorage</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">computer</span>.<span class="property">storage</span> = <span class="string">&quot;500G&quot;</span>;​</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;​</span><br><span class="line">  &#125;​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">build</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">computer</span>;​</span><br><span class="line">  &#125;​</span><br><span class="line">&#125;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// Director: 负责使用 Builder 构建对象​</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerEngineer</span> &#123;​</span><br><span class="line">  <span class="title function_">constructComputer</span>(<span class="params">builder</span>) &#123;​</span><br><span class="line">    <span class="keyword">return</span> builder​</span><br><span class="line">      .<span class="title function_">setCPU</span>()​</span><br><span class="line">      .<span class="title function_">setGPU</span>()​</span><br><span class="line">      .<span class="title function_">setRAM</span>()​</span><br><span class="line">      .<span class="title function_">setStorage</span>()​</span><br><span class="line">      .<span class="title function_">build</span>();​</span><br><span class="line">  &#125;​</span><br><span class="line">&#125;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 使用建造者模式创建复杂对象​</span></span><br><span class="line"><span class="keyword">const</span> engineer = <span class="keyword">new</span> <span class="title class_">ComputerEngineer</span>();​</span><br><span class="line"><span class="keyword">const</span> builder = <span class="keyword">new</span> <span class="title class_">ComputerBuilder</span>();​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> computer = engineer.<span class="title function_">constructComputer</span>(builder);​</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>建造者模式的核心思想是将对象的构建过程和表示分离;</li><li>建造者模式的核心组成部分是: 构建对象类, 构建器类, 指挥者类;</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。</p><p>通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。</p><p>敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。&quot;&gt;&lt;a href=&quot;#建造者模式是一种创建型设计</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>工厂模式：灵活创建对象的设计模式</title>
    <link href="https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-03-19T06:12:52.958Z</published>
    <updated>2024-03-24T10:50:30.808Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式是一种创建型设计模式，它通过使用工厂方法或抽象工厂，将对象的实例化过程封装起来，使得客户端与具体的对象创建过程解耦。工厂模式可以根据不同的条件或参数来创建不同的对象，提供了一种灵活的对象创建方式。</p><hr><h3 id="实现工厂模式的方式"><a href="#实现工厂模式的方式" class="headerlink" title="实现工厂模式的方式"></a>实现工厂模式的方式</h3><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="title function_">createShape</span>(<span class="params">type</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(type === <span class="string">&#x27;circle&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type === <span class="string">&#x27;rectangle&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;无效的形状&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;绘制接口必须实现&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同的具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;绘制圆&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;绘制矩形&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> <span class="title class_">ShapeFactory</span>(<span class="string">&#x27;circle&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> <span class="title class_">ShapeFactory</span>(<span class="string">&#x27;rectangle&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="title function_">createShape</span>(<span class="params">type</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;创建形状接口必须实现&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleFactory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="title function_">createShape</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RectangleFactory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="title function_">createShape</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;绘制接口必须实现&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不同的具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;绘制圆&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>  <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;绘制矩形&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> <span class="title class_">CircleFactory</span>();</span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> <span class="title class_">RectFactory</span>();</span><br></pre></td></tr></table></figure><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">H5Factory</span> &#123;</span><br><span class="line">    <span class="title function_">createButton</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">H5Button</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">createIcon</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">H5Icon</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WxFactory</span> &#123;</span><br><span class="line">     <span class="title function_">createButton</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WxButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">createIcon</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WxIcon</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同的具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">H5Button</span> &#123;</span><br><span class="line">    <span class="title function_">description</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是个按钮&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">H5Icon</span> &#123;</span><br><span class="line">    <span class="title function_">description</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是个图标&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WxButton</span> &#123;</span><br><span class="line">    <span class="title function_">description</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是个按钮&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WxIcon</span> &#123;</span><br><span class="line">    <span class="title function_">description</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是个图标&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> h5Factory = <span class="keyword">new</span> <span class="title function_">H5Factory</span>();</span><br><span class="line"><span class="keyword">const</span> wxFactory = <span class="keyword">new</span> <span class="title function_">wxFactory</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> h5Button = <span class="keyword">new</span> h5Factory.<span class="title function_">createButton</span>();</span><br><span class="line"><span class="keyword">const</span> h5Icon = <span class="keyword">new</span> h5Factory.<span class="title function_">createIcon</span>();</span><br></pre></td></tr></table></figure><h3 id="简单工厂、工厂方法、抽象工厂模式的区别"><a href="#简单工厂、工厂方法、抽象工厂模式的区别" class="headerlink" title="简单工厂、工厂方法、抽象工厂模式的区别"></a>简单工厂、工厂方法、抽象工厂模式的区别</h3><ul><li>关注点不同: <ul><li>简单工厂使用一个接口创建所有产品； </li><li>工厂方法将产品实例化放到不同的工厂中，关注产品的从属性；</li><li>抽象工厂关注的是一个工厂包含多个产品对应的接口，关注的是产品族的创建；</li></ul></li><li>组成结构不同：<ul><li>简单工厂主要含有工厂类、具体产品类，工厂类下仅含有一个创建产品的接口；</li><li>工厂方法主要含有抽象工厂类、具体工厂类、具体产品类；</li><li>抽象工厂主要含有工厂类，具体产品A类，具体产品B类，工厂类下含有创建产品族的方法；</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>工厂模式的核心思想是将对象的实例化过程封装起来，通过一个接口进行实例化，使得客户端与具体的对象创建过程解耦。</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。</p><p>通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。</p><p>敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;工厂模式是一种创建型设计模式，它通过使用工厂方法或抽象工厂，将对象的实例化过程封装起来，使得客户端与具体的对象创建过程解耦。工厂模式可以根据不同的条件或参数来创建不同的对象，提供了一种灵活的对象创建方式。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;实现工厂模式的方式&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>单例模式：实现全局唯一实例的设计模式</title>
    <link href="https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-03-19T06:12:52.789Z</published>
    <updated>2024-03-23T09:30:29.280Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式是一种常见的设计模式，它通过限制类的实例化次数，确保只有一个实例存在。</p><h3 id="示例场景-vue3创建渲染器"><a href="#示例场景-vue3创建渲染器" class="headerlink" title="示例场景(vue3创建渲染器)"></a>示例场景(vue3创建渲染器)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> renderer;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ensureRenderer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> renderer || <span class="title function_">createRender</span>(rendererOptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他实现方式"><a href="#其他实现方式" class="headerlink" title="其他实现方式"></a>其他实现方式</h3><p>由于 JavaScript 的事件循环机制和单线程执行，实现单例模式考虑的没那那么复杂，实现起来比较简单。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Singleton</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> instance;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">createInstance</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="string">&#x27;I am the instance&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">getInstance</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!instance) &#123;</span><br><span class="line">                instance = <span class="title function_">createInstance</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> instance = <span class="title class_">Singleton</span>.<span class="title function_">getInstance</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二，直接使用对象字面量</span></span><br><span class="line"><span class="keyword">const</span> messageManager = &#123;</span><br><span class="line">    <span class="title function_">success</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">    <span class="title function_">error</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(messageManager)</span><br></pre></td></tr></table></figure><h3 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h3><ul><li>全局配置：单例模式可以用于管理全局的配置信息，确保在应用中只有一个配置实例被使用。</li><li>日志记录器：单例模式可以用于创建全局唯一的日志记录器，方便在应用中统一管理和记录日志信息</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>单例模式的核心思想是需要确保一个类只有一个实例。</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。</p><p>通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。</p><p>敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;单例模式是一种常见的设计模式，它通过限制类的实例化次数，确保只有一个实例存在。&lt;/p&gt;
&lt;h3 id=&quot;示例场景-vue3创建渲染器&quot;&gt;&lt;a href=&quot;#示例场景-vue3创建渲染器&quot; class=&quot;headerlink&quot; title=&quot;示例场景(vue3创建渲染器)&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>渲染器：数据访问是如何被代理的？</title>
    <link href="https://sanxun8.github.io/2024/03/13/%E6%BA%90%E7%A0%81/vue3/3-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84/"/>
    <id>https://sanxun8.github.io/2024/03/13/%E6%BA%90%E7%A0%81/vue3/3-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84/</id>
    <published>2024-03-13T13:19:55.092Z</published>
    <updated>2024-03-20T00:50:15.318Z</updated>
    
    <content type="html"><![CDATA[<h2 id="渲染器：数据访问是如何被代理的？"><a href="#渲染器：数据访问是如何被代理的？" class="headerlink" title="渲染器：数据访问是如何被代理的？"></a>渲染器：数据访问是如何被代理的？</h2><h3 id="源码定义-对组件实例上下文进行代理"><a href="#源码定义-对组件实例上下文进行代理" class="headerlink" title="源码定义: 对组件实例上下文进行代理"></a>源码定义: 对组件实例上下文进行代理</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setupStatefulComponent</span>(<span class="params">instance, isSSR</span>) &#123;</span><br><span class="line">  instance.<span class="property">accessCache</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">  instance.<span class="property">proxy</span> = <span class="title function_">markRaw</span>(<span class="keyword">new</span> <span class="title class_">Proxy</span>(instance.<span class="property">ctx</span>, <span class="title class_">PublicInstanceProxyHandlers</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PublicInstanceProxyHandlers-get"><a href="#PublicInstanceProxyHandlers-get" class="headerlink" title="PublicInstanceProxyHandlers.get"></a>PublicInstanceProxyHandlers.get</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const PublicInstanceProxyHandlers = &#123;</span><br><span class="line">  get(&#123; _: instance &#125;, key) &#123;</span><br><span class="line">    const &#123; ctx, setupState, data, props, accessCache, type, appContext &#125; = instance</span><br><span class="line">    if (__DEV__ &amp;&amp; key === &#x27;__isVue&#x27;) &#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let normalizedProps;  // 预定义模块所需变量</span><br><span class="line">    if (key[0] !== &#x27;$&#x27;) &#123; // 处理非预留属性</span><br><span class="line">      const n = accessCache[key] // 读取缓存内容</span><br><span class="line">      if (n !== undefined) &#123;</span><br><span class="line">        switch (n) &#123;</span><br><span class="line">          case AccessTypes.SETUP:</span><br><span class="line">            return setupState[key]</span><br><span class="line">          case AccessTypes.DATA:</span><br><span class="line">            return data[key]</span><br><span class="line">          case AccessTypes.CONTEXT:</span><br><span class="line">            return ctx[key]</span><br><span class="line">          case AccessTypes.PROPS:</span><br><span class="line">            return props[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (hasSetupBinding(setupState, key)) &#123;</span><br><span class="line">        accessCache![key] = AccessTypes.SETUP</span><br><span class="line">        return setupState[key]</span><br><span class="line">      &#125; else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123;</span><br><span class="line">        accessCache![key] = AccessTypes.DATA</span><br><span class="line">        return data[key]</span><br><span class="line">      &#125; else if (</span><br><span class="line">        (normalizedProps = instance.propsOptions[0]) &amp;&amp;</span><br><span class="line">        hasOwn(normalizedProps, key)</span><br><span class="line">      ) &#123;</span><br><span class="line">        accessCache![key] = AccessTypes.PROPS</span><br><span class="line">        return props![key]</span><br><span class="line">      &#125; else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123;</span><br><span class="line">        accessCache![key] = AccessTypes.CONTEXT</span><br><span class="line">        return ctx[key]</span><br><span class="line">      &#125; else if (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) &#123;</span><br><span class="line">        accessCache![key] = AccessTypes.OTHER</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const publicGetter = publicPropertiesMap[key] // 开始处理预留属性</span><br><span class="line">    let cssModule, globalProperties</span><br><span class="line">    if (publicGetter) &#123;</span><br><span class="line">      // $保留字开头的相关逻辑</span><br><span class="line">    &#125; else if (</span><br><span class="line">      (cssModule = type.__cssModules) &amp;&amp;</span><br><span class="line">      (cssModule = cssModule[key])</span><br><span class="line">    ) &#123;</span><br><span class="line">      return cssModule</span><br><span class="line">    &#125; else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123;</span><br><span class="line">      accessCache![key] = AccessTypes.CONTEXT</span><br><span class="line">      return ctx[key]</span><br><span class="line">    &#125; else if (</span><br><span class="line">      ((globalProperties = appContext.config.globalProperties),</span><br><span class="line">        hasOwn(globalProperties, key))</span><br><span class="line">    ) &#123;</span><br><span class="line">      if (__COMPAT__) &#123;</span><br><span class="line">        const desc = Object.getOwnPropertyDescriptor(globalProperties, key)!</span><br><span class="line">        if (desc.get) &#123;</span><br><span class="line">          return desc.get.call(instance.proxy)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          const val = globalProperties[key]</span><br><span class="line">          return isFunction(val)</span><br><span class="line">            ? Object.assign(val.bind(instance.proxy), val)</span><br><span class="line">            : val</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return globalProperties[key]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (</span><br><span class="line">      // 一些告警</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h4><ol><li>访问顺序为<code>setupState</code>》<code>data</code>》<code>prop</code>》<code>ctx</code></li><li>使用<code>空间换时间</code>进行了优化，使用<code>accessCache</code>标记<code>key</code>存在于哪个属性上，减少了频繁调用<code>hasOwn</code>耗费性能。</li></ol><h3 id="PublicInstanceProxyHandlers-get-1"><a href="#PublicInstanceProxyHandlers-get-1" class="headerlink" title="PublicInstanceProxyHandlers .get"></a>PublicInstanceProxyHandlers .get</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const PublicInstanceProxyHandlers = &#123;</span><br><span class="line">  set(&#123; _: instance &#125;, key, value) &#123;</span><br><span class="line">    const &#123; data, setupState, ctx &#125; = instance</span><br><span class="line">    if (hasSetupBinding(setupState, key)) &#123;</span><br><span class="line">      setupState[key] = value</span><br><span class="line">      return true</span><br><span class="line">    &#125; else if (</span><br><span class="line">      __DEV__ &amp;&amp;</span><br><span class="line">      setupState.__isScriptSetup &amp;&amp;</span><br><span class="line">      hasOwn(setupState, key)</span><br><span class="line">    ) &#123;</span><br><span class="line">      warn(`Cannot mutate &lt;script setup&gt; binding &quot;$&#123;key&#125;&quot; from Options API.`)</span><br><span class="line">      return false</span><br><span class="line">    &#125; else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123;</span><br><span class="line">      data[key] = value</span><br><span class="line">      return true</span><br><span class="line">    &#125; else if (hasOwn(instance.props, key)) &#123;</span><br><span class="line">      __DEV__ &amp;&amp; warn(`Attempting to mutate prop &quot;$&#123;key&#125;&quot;. Props are readonly.`)</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">    if (key[0] === &#x27;$&#x27; &amp;&amp; key.slice(1) in instance) &#123;</span><br><span class="line">      __DEV__ &amp;&amp;</span><br><span class="line">      warn(</span><br><span class="line">        `Attempting to mutate public property &quot;$&#123;key&#125;&quot;. ` +</span><br><span class="line">        `Properties starting with $ are reserved and readonly.`,</span><br><span class="line">      )</span><br><span class="line">      return false</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (__DEV__ &amp;&amp; key in instance.appContext.config.globalProperties) &#123;</span><br><span class="line">        Object.defineProperty(ctx, key, &#123;</span><br><span class="line">          enumerable: true,</span><br><span class="line">          configurable: true,</span><br><span class="line">          value,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        ctx[key] = value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong> 更改顺序为：<code>setupState</code> 》<code>data</code> 》<code>props</code> 》<code>globalProperties</code></p><h3 id="PublicInstanceProxyHandlers-has"><a href="#PublicInstanceProxyHandlers-has" class="headerlink" title="PublicInstanceProxyHandlers .has"></a>PublicInstanceProxyHandlers .has</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const PublicInstanceProxyHandlers = &#123;</span><br><span class="line">  has(&#123;_: &#123; data, setupState, accessCache, ctx, appContext, propsOptions &#125;&#125;, key) &#123;</span><br><span class="line">    let normalizedProps</span><br><span class="line">    return (</span><br><span class="line">      !!accessCache[key] ||</span><br><span class="line">      (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) ||</span><br><span class="line">      hasSetupBinding(setupState, key) ||</span><br><span class="line">      ((normalizedProps = propsOptions[0]) &amp;&amp; hasOwn(normalizedProps, key)) ||</span><br><span class="line">      hasOwn(ctx, key) ||</span><br><span class="line">      hasOwn(publicPropertiesMap, key) || // $保留字开头的函数</span><br><span class="line">      hasOwn(appContext.config.globalProperties, key)</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong> 访问顺序为<code>data </code>》<code>setupState</code>》<code>props</code>》<code>ctx</code>》<code>publicPropertiesMap</code>》<code>globalProperties</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;渲染器：数据访问是如何被代理的？&quot;&gt;&lt;a href=&quot;#渲染器：数据访问是如何被代理的？&quot; class=&quot;headerlink&quot; title=&quot;渲染器：数据访问是如何被代理的？&quot;&gt;&lt;/a&gt;渲染器：数据访问是如何被代理的？&lt;/h2&gt;&lt;h3 id=&quot;源码定义-对组件实</summary>
      
    
    
    
    
  </entry>
  
</feed>
