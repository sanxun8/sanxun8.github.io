<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>屯货三旬的个人网站</title>
  
  
  <link href="https://sanxun8.github.io/atom.xml" rel="self"/>
  
  <link href="https://sanxun8.github.io/"/>
  <updated>2024-04-05T08:53:30.752Z</updated>
  <id>https://sanxun8.github.io/</id>
  
  <author>
    <name>屯货三旬</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>响应式原理：Watch函数的实现</title>
    <link href="https://sanxun8.github.io/2024/04/03/%E6%BA%90%E7%A0%81/vue3/watch/"/>
    <id>https://sanxun8.github.io/2024/04/03/%E6%BA%90%E7%A0%81/vue3/watch/</id>
    <published>2024-04-03T14:11:14.651Z</published>
    <updated>2024-04-05T08:53:30.752Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参数归一化"><a href="#参数归一化" class="headerlink" title="参数归一化"></a>参数归一化</h3><p>我知道<strong>watch</strong>的<strong>source</strong>参数接受类型有<strong>ref</strong>, <strong>computed</strong>, <strong>reactive</strong>, <strong>gertter</strong>或者组合成数组类型</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">watch</span>(<span class="params">source, cb, options</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">dowatch</span>(source, cb, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">doWatch</span>(<span class="params">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">warnInvalidSource</span> = (<span class="params">s</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 一些警告</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> instance = currentInstance;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reactiveGetter</span> = source =&gt;</span><br><span class="line">        deep === <span class="literal">true</span> ? source : <span class="title function_">traverse</span>(source, deep === <span class="literal">false</span> ? <span class="number">1</span> : <span class="literal">undefined</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> getter;</span><br><span class="line">    <span class="keyword">let</span> forceTrigger = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> isMultiSource = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数归一化</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isRef</span>(source)) &#123;</span><br><span class="line">        getter = <span class="function">() =&gt;</span> source.<span class="property">value</span>;</span><br><span class="line">        forceTrigger = <span class="title function_">isShallow</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isReactive</span>(source)) &#123;</span><br><span class="line">        getter = <span class="function">() =&gt;</span> <span class="title function_">reactiveGetter</span>(source);</span><br><span class="line">        forceTrigger = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isArray</span>(source)) &#123;</span><br><span class="line">        isMultiSource = <span class="literal">true</span>;</span><br><span class="line">        forceTrigger = source.<span class="title function_">some</span>(<span class="function"><span class="params">s</span> =&gt;</span> <span class="title function_">isReactive</span>(s) || <span class="title function_">isShallow</span>(s));</span><br><span class="line">        getter = <span class="function">() =&gt;</span> source.<span class="title function_">map</span>(<span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isRef</span>(s)) &#123;</span><br><span class="line">                <span class="keyword">return</span> s.<span class="property">value</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isReactive</span>(s)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">reactiveGetter</span>(s);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isFunction</span>(s)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">callWithErrorHandling</span>(s, instance, <span class="title class_">ErrorCodes</span>.<span class="property">WATCH_GETTER</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">warnInvalidSource</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isFunction</span>(source)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">            getter = <span class="function">() =&gt;</span> <span class="title function_">callWithErrorHandling</span>(source, instance, <span class="title class_">ErrorCodes</span>.<span class="property">WATCH_GETTER</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cleanup) &#123;</span><br><span class="line">                    <span class="title function_">cleanup</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">callWithAsyncErrorHandling</span>(</span><br><span class="line">                    source,</span><br><span class="line">                    instance,</span><br><span class="line">                    <span class="title class_">ErrorCodes</span>.<span class="property">WATCH_GETTER</span>,</span><br><span class="line">                    [onCleanup]</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        getter = <span class="title class_">Noop</span>;</span><br><span class="line">        <span class="title function_">warnInvalidSource</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现<strong>watch</strong>实际通过<strong>doWatch</strong>实现的，<strong>doWatch</strong>第一步就是<strong>watch</strong>的参数<strong>source</strong>进行归一化处理。以达到我们访问<strong>getter</strong>会触发响应式数据的依赖收集的目的。</p><h3 id="深层响应式处理"><a href="#深层响应式处理" class="headerlink" title="深层响应式处理"></a>深层响应式处理</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">doWatch</span>(<span class="params">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (cb &amp;&amp; deep) &#123;</span><br><span class="line">        <span class="keyword">const</span> baseGetter = getter;</span><br><span class="line">        getter = <span class="function">() =&gt;</span> <span class="title function_">traverse</span>(<span class="title function_">baseGetter</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">traverse</span>(<span class="params">value, depth, currentDepth = <span class="number">0</span>, seen</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isObject</span>(value) || value[<span class="title class_">ReactiveFlags</span>.<span class="property">SKIP</span>]) &#123; <span class="comment">// 跳出递归方式</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (depth &amp;&amp; depth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentDepth &gt;= depth) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        currentDepth++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    seen = seen || <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">if</span> (seen.<span class="title function_">has</span>(value)) &#123; <span class="comment">// 重复值则跳出</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    seen.<span class="title function_">add</span>(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对各种类型进行属性访问，达到依赖收集效果</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isRef</span>(value)) &#123;</span><br><span class="line">        <span class="title function_">traverse</span>(value.<span class="property">value</span>, depth, currentDepth, seen);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; value.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="title function_">traverse</span>(value[i], depth, currentDepth, seen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isSet</span>(value) || <span class="title function_">isMap</span>(value)) &#123;</span><br><span class="line">        value.<span class="title function_">forEach</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">traverse</span>(v, depth, currentDepth, seen);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isPlainObject</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> value) &#123;</span><br><span class="line">            <span class="title function_">traverse</span>(value[key], depth, currentDepth, seen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现深层响应式处理核心在<strong>traverse</strong>函数，该函数为递归函数，当<strong>value</strong>不为对象时，直接返回<strong>value</strong>。 提供了<strong>depth</strong>对监听层级进行管理，不传则为深层监听。提供<strong>seen</strong>处理重复值跳出。最后时对不同类型对象属性进行访问，达到依赖收集的效果。</p><h3 id="提供清理钩子"><a href="#提供清理钩子" class="headerlink" title="提供清理钩子"></a>提供清理钩子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">doWatch</span>(<span class="params">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 提供清理钩子</span></span><br><span class="line">    <span class="keyword">let</span> cleanup;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">onCleanup</span> = fn =&gt; &#123;</span><br><span class="line">        cleanup = effect.<span class="property">onStop</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">callWithErrorHandling</span>(fn, instance, <span class="title class_">ErrorCodes</span>.<span class="property">WATCH_CLEANUP</span>);</span><br><span class="line">            cleanup = effect.<span class="property">onStop</span> = <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ssrCleanup;</span><br><span class="line">    <span class="keyword">if</span> (__SSR__ &amp;&amp; isInSSRComponentSetup) &#123;</span><br><span class="line">        onCleanup = <span class="title class_">Noop</span>;</span><br><span class="line">        <span class="keyword">if</span> (!cb) &#123;</span><br><span class="line">            <span class="title function_">getter</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="title function_">callWithAsyncErrorHandling</span>(cb, instance, <span class="title class_">ErrorCodes</span>.<span class="property">WATCH_CALLBACK</span>, [</span><br><span class="line">                <span class="title function_">getter</span>(),</span><br><span class="line">                isMultiSource ? [] : <span class="literal">undefined</span>,</span><br><span class="line">                onCleanup</span><br><span class="line">            ]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flush === <span class="string">&#x27;sync&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> ctx = <span class="title function_">useSSRContext</span>();</span><br><span class="line">            ssrCleanup = ctx.<span class="property">__watchHandles</span> || (ctx.<span class="property">__watchHandles</span> = []);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable constant_">NOOP</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>onCleanup</strong>将会成为<strong>cb</strong>的第三个实参，我们可以根据业务需要执行<strong>onCleanup</strong>。</p><h3 id="定义工作函数"><a href="#定义工作函数" class="headerlink" title="定义工作函数"></a>定义工作函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">doWatch</span>(<span class="params">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> oldValue = isMultiSource ? <span class="keyword">new</span> <span class="title class_">Array</span>(source.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="variable constant_">INITIAL_WATCHER_VALUE</span>) : <span class="variable constant_">INITIAL_WATCHER_VALUE</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">job</span> = (<span class="params"></span>) =&gt; &#123; <span class="comment">// 定义工作函数</span></span><br><span class="line">        <span class="keyword">if</span> (!effect.<span class="property">active</span> || !effect.<span class="property">dirty</span>) &#123; <span class="comment">// 不在响应式上下文或无脏值</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">            <span class="keyword">const</span> newValue = effect.<span class="title function_">run</span>();</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                deep ||</span><br><span class="line">                forceTrigger ||</span><br><span class="line">                (isMultiSource</span><br><span class="line">                    ? newValue.<span class="title function_">some</span>(<span class="function">(<span class="params">v, i</span>) =&gt;</span> <span class="title function_">hasChanged</span>(v, oldValue[i]))</span><br><span class="line">                    : <span class="title function_">hasChanged</span>(newValue, oldValue)</span><br><span class="line">                )</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cleanup) &#123;</span><br><span class="line">                    <span class="title function_">cleanup</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_">callWithAsyncErrorHandling</span>(cb, instance, <span class="title class_">ErrorCodes</span>.<span class="property">WATCH_CALLBACK</span>, [</span><br><span class="line">                    newValue,</span><br><span class="line">                    oldValue === <span class="variable constant_">INITIAL_WATCHER_VALUE</span></span><br><span class="line">                        ? <span class="literal">undefined</span></span><br><span class="line">                        : isMultiSource &amp;&amp; oldValue[<span class="number">0</span>] === <span class="variable constant_">INITIAL_WATCHER_VALUE</span></span><br><span class="line">                            ? []</span><br><span class="line">                            : oldValue,</span><br><span class="line">                    onCleanup</span><br><span class="line">                ]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            effect.<span class="title function_">run</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    job.<span class="property">allowRecurse</span> = !!cb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现<strong>job</strong>函数主要逻辑是先判断<strong>watch</strong>函数执行上下文，以及是否有脏值，然后执行<strong>effect.run</strong>，即执行归一化化后的<strong>getter</strong>函数达到依赖收集效果。若接受了<strong>cb</strong>函数，根据是否存在脏值执行<strong>cb</strong>,b并更新<strong>oldValue</strong>值。</p><h3 id="定义调度器"><a href="#定义调度器" class="headerlink" title="定义调度器"></a>定义调度器</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">doWatch</span>(<span class="params">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> scheduler; <span class="comment">// 定义调度器</span></span><br><span class="line">    <span class="keyword">if</span> (flush === <span class="string">&#x27;sync&#x27;</span>) &#123;</span><br><span class="line">        scheduler = job;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">        scheduler = <span class="function">() =&gt;</span> <span class="title function_">queuePostRenderEffect</span>(job, instance &amp;&amp; instance.<span class="property">suspense</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        job.<span class="property">pre</span> = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (instance) job.<span class="property">id</span> = instance.<span class="property">id</span>;</span><br><span class="line">        scheduler = <span class="function">() =&gt;</span> <span class="title function_">queueJob</span>(job);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建ReactiveEffect"><a href="#构建ReactiveEffect" class="headerlink" title="构建ReactiveEffect"></a>构建ReactiveEffect</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">doWatch</span>(<span class="params">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> effect = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(getter, <span class="variable constant_">NOOP</span>, scheduler);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现前面定义的<strong>getter</strong>, <strong>job</strong>其实都是服务于构建<strong>ReactiveEffect</strong>实例的。</p><h3 id="定义监听卸载"><a href="#定义监听卸载" class="headerlink" title="定义监听卸载"></a>定义监听卸载</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">doWatch</span>(<span class="params">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> scope = <span class="title function_">getCurrentScope</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">unwatch</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        effect.<span class="title function_">stop</span>(); <span class="comment">// 清楚依赖</span></span><br><span class="line">        <span class="keyword">if</span> (scope) &#123;</span><br><span class="line">            <span class="title function_">remove</span>(scope.<span class="property">effects</span>, effect);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="首次执行"><a href="#首次执行" class="headerlink" title="首次执行"></a>首次执行</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">doWatch</span>(<span class="params">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (cb) &#123;</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="title function_">job</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            oldValue = effect.<span class="title function_">run</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">queuePostRenderEffect</span>(</span><br><span class="line">            effect.<span class="property">run</span>.<span class="title function_">bind</span>(effect),</span><br><span class="line">            instance &amp;&amp; instance.<span class="property">suspense</span></span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        effect.<span class="title function_">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__SSR__ &amp;&amp; ssrCleanup) ssrCleanup.<span class="title function_">push</span>(unwatch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unwatch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里<strong>doWatch</strong>流程就已经走完，我们对知识做个扩展，了解一下<strong>watchEffect</strong>是如何实现的</p><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">watchEffect</span>(<span class="params">effect, options</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">doWatch</span>(effect, <span class="literal">null</span>, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，<strong>watchEffect</strong>实际上也是<strong>doWatch</strong>一种使用形式，传入<strong>source</strong>的值为函数，不传<strong>cb</strong>函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;参数归一化&quot;&gt;&lt;a href=&quot;#参数归一化&quot; class=&quot;headerlink&quot; title=&quot;参数归一化&quot;&gt;&lt;/a&gt;参数归一化&lt;/h3&gt;&lt;p&gt;我知道&lt;strong&gt;watch&lt;/strong&gt;的&lt;strong&gt;source&lt;/strong&gt;参数接受类型有&lt;s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>响应式原理：Reactive对象解析</title>
    <link href="https://sanxun8.github.io/2024/04/03/%E6%BA%90%E7%A0%81/vue3/reactive/"/>
    <id>https://sanxun8.github.io/2024/04/03/%E6%BA%90%E7%A0%81/vue3/reactive/</id>
    <published>2024-04-03T09:43:47.885Z</published>
    <updated>2024-04-04T09:04:05.427Z</updated>
    
    <content type="html"><![CDATA[<h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><p>源码中关于<strong>Reactive</strong>部分的定义：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">isReadonly</span>(target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(</span><br><span class="line">        target, </span><br><span class="line">        <span class="literal">false</span>, </span><br><span class="line">        mutableHandlers, </span><br><span class="line">        mutableCollectionHandlers, </span><br><span class="line">        reactiveMap</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数核心也就是通过<strong>createReactiveObject</strong>把我们传入的<strong>target</strong>变成响应式的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params">target, isReadonly, baseHandlers, collectionHandlers, proxyMap</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_">isObject</span>(target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(target[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>] &amp;&amp; !(isReadonly &amp;&amp; target[<span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> existingProxy = proxyMap.<span class="title function_">get</span>(target);</span><br><span class="line">    <span class="keyword">if</span>(existingProxy) &#123;</span><br><span class="line">        <span class="keyword">return</span> existingProxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> targetType = <span class="title function_">getTargetType</span>(target);</span><br><span class="line">    <span class="keyword">if</span>(targetType === <span class="title class_">TargetType</span>.<span class="property">INVALID</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">        target, </span><br><span class="line">        targetType === <span class="title class_">TargetType</span>.<span class="property">COLLECTION</span> ? collectionHandlers : baseHandlers</span><br><span class="line">    );</span><br><span class="line">    proxyMap.<span class="title function_">set</span>(target, proxy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码核心流程就是首先经过一系列判断，判断符合要求的<strong>target</strong>才能被响应式。包括target的类型、是否是响应式、是否已经被定义过了、是否是符合要求的类型。最后执行<strong>new Proxy</strong>对target进行代理, 其核心是处理器。我们先来看一下是定义了几种处理器，以及如何确认处理器的类型的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">targetType</span>(<span class="params">rawType</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (rawType) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Object&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Array&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">TargetType</span>.<span class="property">COMMON</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Map&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Set&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;WeakMap&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;WeakSet&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">TargetType</span>.<span class="property">COLLECTION</span>;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">TargetType</span>.<span class="property">INVALID</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTargetType</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value[<span class="title class_">ReactiveFlags</span>.<span class="property">SKIP</span>] || !<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(value) ? <span class="title class_">TargetType</span>.<span class="property">INVALID</span> : <span class="title function_">targetType</span>(<span class="title function_">toRawType</span>(value));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">toRawType</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// toTypeString 转换成字符串的方式，比如 &quot;[object RawType]&quot;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">toTypeString</span>(value).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<strong>target</strong>传入进来的是一个<strong>Object</strong>，所以<strong>toRawType</strong>得到的值是<strong>Object</strong>。所以这里的值等于<strong>TargetType.Common</strong>也就是使用<strong>baseHandlers</strong>。若传入进来的是<strong>Map</strong>、<strong>Set</strong>、<strong>WeakMap</strong>、<strong>WeakSet</strong>类型，则使用<strong>collectionHandlers</strong>，本章不进行展开<strong>collectionHandlers</strong>的解析。</p><p>接下来看一下<strong>baseHandlers</strong>的实现：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mutableHandlers = &#123;</span><br><span class="line">    get,</span><br><span class="line">    set,</span><br><span class="line">    deleteProperty,</span><br><span class="line">    has,</span><br><span class="line">    ownKeys,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是<strong>Proxy</strong>中的定义<strong>handler</strong>的一些属性</p><ul><li>get：属性读取操作的捕捉器。</li><li>set：属性设置操作的捕捉器。</li><li>deleteProperty： delete操作符的捕捉器。</li><li>has：in操作符的捕捉器。</li><li>ownKeys：Object.getOwnPropertyNames方法和Object.getOwnPropertySymbols方法的捕捉器。</li></ul><p><strong>reactive</strong>对象响应式的核心就在<strong>set</strong>和<strong>get</strong>中，我们一起来看一下二者的实现</p><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>get的源码实现</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseReactiveHandler</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">_isReadonly = <span class="literal">false</span>, _isShallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_isReadonly</span> = isReadonly;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_isShallow</span> = _isShallow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> isReadonly = <span class="variable language_">this</span>.<span class="property">_isReadonly</span>;</span><br><span class="line">        <span class="keyword">const</span> isShallow = <span class="variable language_">this</span>.<span class="property">_isShallow</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对 ReactiveFlags 的处理部分</span></span><br><span class="line">        <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> !isReadonly;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> isReadonly;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_SHALLOW</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> isShallow;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                receiver ===</span><br><span class="line">                (isReadonly</span><br><span class="line">                    ? isShallow</span><br><span class="line">                        ? shallowReadonlyMap</span><br><span class="line">                        : readonlyMap</span><br><span class="line">                    : isShallow</span><br><span class="line">                        ? shallowReactiveMap</span><br><span class="line">                        : reactiveMap</span><br><span class="line">                ).<span class="title function_">get</span>(target) ||</span><br><span class="line">                <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(target) === <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(receiver)</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> targetIsArray = <span class="title function_">isArray</span>(target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">            <span class="comment">// 过滤数组变异方法</span></span><br><span class="line">            <span class="keyword">if</span> (targetIsArray &amp;&amp; <span class="title function_">hasOwn</span>(arrayInstrumentations, key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(<span class="title class_">Instrumentations</span>, key, receiver);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (key === <span class="string">&#x27;hasOwnProperty&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> hasOwnProperty;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 过滤 Symbol Key 和 一些不收集依赖的键</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isSymbol</span>(key) ? builtInSymbols.<span class="title function_">has</span>(key) : <span class="title function_">isNonTrackableKeys</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">            <span class="title function_">track</span>(target, <span class="title class_">TrackOpTypes</span>.<span class="property">Get</span>, key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isShallow) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isRef</span>(res)) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetIsArray &amp;&amp; <span class="title function_">isIntegerKey</span>(key) ? res : res.<span class="property">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isObject</span>(res)) &#123;</span><br><span class="line">            <span class="keyword">return</span> isReadonly ? <span class="title function_">readonly</span>(res) : <span class="title function_">reactive</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>get api</strong>核心流程就是首先经过一系列判断, 判断符合要求的<strong>key</strong>才进行依赖收集, 然后根据对不同的类型进行处理返回。不收集依赖的key包括预设属性、symbol类型的自有属性。</p><p>当我们的<strong>target</strong>是数组，且<strong>key</strong>值存在<strong>arrayInstrumentations</strong>中时，返回<strong>arrayInstrumentations</strong>中对应的<strong>key</strong>值。我们再来看看<strong>arrayInstrumentations</strong>是个什么：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayInstrumentations = <span class="title function_">createArrayInstrumentations</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createArrayInstrumentations</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> instrumentations = &#123;&#125;;</span><br><span class="line">    ([<span class="string">&#x27;includes&#x27;</span>, <span class="string">&#x27;indexOf&#x27;</span>, <span class="string">&#x27;lastIndexOf&#x27;</span>]).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        instrumentations[key] = <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>, ...args</span>) &#123;</span><br><span class="line">            <span class="comment">// toRaw 可以把响应式对象转成原始数据</span></span><br><span class="line">            <span class="keyword">const</span> arr = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="variable language_">this</span>.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="comment">// 对数组的每一项进行依赖收集</span></span><br><span class="line">                <span class="title function_">track</span>(arr, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, i + <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 先尝试用参数本身，可能是响应式数据</span></span><br><span class="line">            <span class="keyword">const</span> res = arr[key](...args)</span><br><span class="line">            <span class="keyword">if</span> (res === -<span class="number">1</span> || res === <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果失败，再尝试把参数转成原始数据</span></span><br><span class="line">                <span class="keyword">return</span> arr[key](...args.<span class="title function_">map</span>(toRaw))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>, <span class="string">&#x27;unshift&#x27;</span>, <span class="string">&#x27;splice&#x27;</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        instrumentations[key] = <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>, ...args</span>) &#123;</span><br><span class="line">            <span class="title function_">pauseTracking</span>()</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>)[key].<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">            <span class="title function_">resetTracking</span>()</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instrumentations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>arrayInstrumentations</strong>会重写两类函数，一类是查询类函数：<strong>inclues</strong>、<strong>indexOf</strong>、<strong>lastIndeOf</strong>，代表对数组的读取操作。在这些函数中会执行<strong>track</strong>函数，对数组的索引进行依赖收集。</p><p>另一类是修改类函数：<strong>push</strong>、<strong>pop</strong>、<strong>shift</strong>、<strong>unshift</strong>、<strong>splice</strong>，代表对数组的修改操作，在这些函数中暂停了全局的追踪功能，防止某些情况下导致死循环。</p><p>如果你想了解<strong>track</strong>做了些什么，可以查看我的文章<a href="https://sanxun8.github.io/2024/04/03/%E6%BA%90%E7%A0%81/vue3/dep/">响应式原理：dep（响应式对象的依赖管理器）</a></p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>上面说完了<strong>get</strong>的流程，我们了解一下依赖收集后的数据结构存储在了<strong>targetMap</strong>中，接下来我们接着看<strong>set</strong>的过程：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MutableReactiveHandler</span> <span class="keyword">extends</span> <span class="title class_ inherited__">BaseReactiveHandler</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">isShallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(<span class="literal">false</span>, isShallow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> oldValue = target[key];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对深层响应式，处理新旧值</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_isShallow</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> isOldValueReadonly = <span class="title function_">isReadonly</span>(oldValue);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="title function_">isShallow</span>(value) &amp;&amp; !<span class="title function_">isReadonly</span>(value)) &#123;</span><br><span class="line">                oldValue = <span class="title function_">toRaw</span>(oldValue);</span><br><span class="line">                value = <span class="title function_">toRaw</span>(value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isRef</span>(oldValue) &amp;&amp; !<span class="title function_">isRef</span>(value)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isOldValueReadonly) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    oldValue.<span class="property">value</span> = value;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否为已有属性</span></span><br><span class="line">        <span class="keyword">const</span> hadKey = </span><br><span class="line">            <span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isIntegerKey</span>(key) </span><br><span class="line">                ? (<span class="title class_">Number</span>(key) &lt; target.<span class="property">length</span>) </span><br><span class="line">                : <span class="title function_">hasOwn</span>(target, key); </span><br><span class="line">        <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">        <span class="keyword">if</span> (target === <span class="title function_">toRaw</span>(receiver)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 触发响应</span></span><br><span class="line">            <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">                <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>, key, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(value, oldValue)) &#123;</span><br><span class="line">                <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>, key, value, oldValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到<strong>set</strong>接口核心逻辑就是根据是否为渐层响应式来确认原始值和新值，这里默认不是浅层的响应式，所以会先把原始值和新值进行<strong>toRaw</strong>转换，然后通过<strong>Reflect.set</strong>设置值，最后通过<strong>trigger</strong>函数派发通知，并依据<strong>key</strong>是否存在于<strong>target</strong>来确认通知类型是<strong>add</strong>（新增）还是<strong>set</strong>（修改）。</p><p>如果你想了解<strong>trigger</strong>做了些什么，可以查看我的文章[响应式原理：dep（响应式对象的依赖管理器）]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;reactive&quot;&gt;&lt;a href=&quot;#reactive&quot; class=&quot;headerlink&quot; title=&quot;reactive&quot;&gt;&lt;/a&gt;reactive&lt;/h3&gt;&lt;p&gt;源码中关于&lt;strong&gt;Reactive&lt;/strong&gt;部分的定义：&lt;/p&gt;
&lt;figu</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>响应式原理：ReactiveEffect响应式副作用探秘</title>
    <link href="https://sanxun8.github.io/2024/04/03/%E6%BA%90%E7%A0%81/vue3/effect/"/>
    <id>https://sanxun8.github.io/2024/04/03/%E6%BA%90%E7%A0%81/vue3/effect/</id>
    <published>2024-04-03T03:26:32.142Z</published>
    <updated>2024-04-05T09:58:57.362Z</updated>
    
    <content type="html"><![CDATA[<p>响应式对象中的执行函数、响应式触发器、调度器都是由<strong>reactiveEffect</strong>类进行管理的，学习本章，你将会明白<strong>effect</strong>、<strong>computed</strong>、<strong>doWatch</strong>、<strong>setupRenderEffect</strong>是如何通过<strong>reativeEffect</strong>控制执行函数、响应式触发器、调度器的执行时机的。</p><h3 id="ReactiveEffect"><a href="#ReactiveEffect" class="headerlink" title="ReactiveEffect"></a>ReactiveEffect</h3><p>源码定义</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ReactiveEffect</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">fn, trigger, scheduler, scope</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">fn</span> = fn;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">trigger</span> = trigger;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scheduler</span> = scheduler;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_runnings</span> = <span class="number">0</span>; <span class="comment">// 运行时状态 </span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_trackId</span> = <span class="number">0</span>; <span class="comment">// 依赖标识</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_depsLength</span> = <span class="number">0</span>; <span class="comment">// 绑定该effect的deps长度</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">deps</span> = []; <span class="comment">// 绑定该effect的deps</span></span><br><span class="line">        <span class="title function_">recordEffectScope</span>(<span class="variable language_">this</span>, scope); <span class="comment">// 记录副作用范围</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_dirtyLevel</span> = <span class="title class_">DirtyLevels</span>.<span class="property">NotDirty</span>; <span class="comment">// 设置脏值等级</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">active</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">fn</span>(); <span class="comment">// 若副作用函数不在响应式上下文中，则执行fn不收集依赖</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> lastShouldTrack = shouldTrack; <span class="comment">// 解决effect嵌套</span></span><br><span class="line">        <span class="keyword">let</span> lastEffect = activeEffect; <span class="comment">// 解决effect嵌套</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            shouldTrack = <span class="literal">true</span>;</span><br><span class="line">            activeEffect = <span class="variable language_">this</span>; <span class="comment">// 记录活动副作用实例</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_runnings</span>++;</span><br><span class="line">            <span class="title function_">preCleanupEffect</span>(<span class="variable language_">this</span>); <span class="comment">// 属性初始化</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">fn</span>(); <span class="comment">// 运行回调函数（依赖收集，依赖清理）</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="title function_">postCleanupEffect</span>(<span class="variable language_">this</span>); <span class="comment">// 依赖清理</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_runnings</span>--;</span><br><span class="line">            activeEffect = lastEffect;</span><br><span class="line">            shouldTrack = lastShouldTrack;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>run</strong>接口的主要逻辑是处理先处理<strong>fn</strong>不在响应式上下文的情况，然后初始化<strong>lastShouldTrack、lastEffect</strong>解决effect嵌套问题，其次一些状态的初始化，包括<strong>shouldTrack</strong>、<strong>activeEffect</strong>、**_running<strong>、</strong>deps<strong>、</strong>_depsLength**。</p><p>初始化属性后执行<strong>fn</strong>触发依赖收集，</p><p>最后执行完依赖清理后，重置部分状态，重置状态包括**_running<strong>、</strong>activeEffect<strong>、</strong>shouldTrack**。</p><p>我们来看一下<strong>preCleanupEffect</strong>和<strong>postCleanupEffect</strong>的实现</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">preCleanupEffect</span>(<span class="params">effect</span>) &#123;</span><br><span class="line">    <span class="comment">// 属性处理</span></span><br><span class="line">    effect.<span class="property">_trackId</span>++;</span><br><span class="line">    effect.<span class="property">_depsLength</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">postCleanupEffect</span>(<span class="params">effect</span>) &#123;</span><br><span class="line">    <span class="comment">// 清楚依赖副作用</span></span><br><span class="line">    <span class="keyword">if</span> (effect.<span class="property">deps</span>.<span class="property">length</span> &gt; effect.<span class="property">_depsLength</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = effect.<span class="property">_depsLength</span>; i &lt; effect.<span class="property">deps</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="title function_">cleanupDepEffect</span>(effect.<span class="property">deps</span>[i], effect);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<strong>preCleanupEffect</strong>只是做了一些属性的初始化，<strong>postCleanupEffect</strong>遍历绑定当前<strong>effect</strong>的dep，清理<strong>dep</strong>下的<strong>effect</strong>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cleanupDepEffect</span>(<span class="params">dep, effect</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> trackId = dep.<span class="title function_">get</span>(effect); <span class="comment">// 获取依赖标识</span></span><br><span class="line">    <span class="keyword">if</span> (trackId !== <span class="literal">undefined</span> &amp;&amp; effect.<span class="property">_trackId</span> !== trackId) &#123;</span><br><span class="line">        dep.<span class="title function_">delete</span>(effect); <span class="comment">// 依赖删除</span></span><br><span class="line">        <span class="keyword">if</span> (dep.<span class="property">size</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            dep.<span class="title function_">cleanup</span>(); <span class="comment">// 执行回调</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们简单梳理一下<strong>ReactiveEffect</strong>实例接口调用逻辑，当我们调用<strong>ReactiveEffect.run</strong>会运行<strong>fn</strong>触发依赖收集，当响应式数据变化后会通知<strong>ReactiveEffect.trgger</strong>和<strong>ReactiveEffect。shcedule</strong>执行，具体依赖通知可以查看我的文章: <a href="https://sanxun8.github.io/2024/04/03/%E6%BA%90%E7%A0%81/vue3/dep/">响应式原理：dep（响应式对象的依赖管理器）</a>。</p><p>我们知道当我们对一个响应式数据进行访问时，会触发响应式依赖收集，<strong>ReactiveEffect.run</strong>就是调用<strong>ReactiveEffect.fn</strong>达到依赖收集效果，但<strong>ReactiveEffect.run</strong>首次是在在哪里调用，以及后续响应式更新如何调用<strong>ReactiveEffect.run</strong>。带着这两个问题，我们来理解一下<strong>effect</strong>、<strong>computed</strong>、<strong>doWatch</strong>、<strong>setupRenderEffect</strong>对<strong>ReactiveEffect</strong>的使用情况。</p><h3 id="effect"><a href="#effect" class="headerlink" title="effect"></a>effect</h3><p>有了以上知识，我们了解一下<strong>effect</strong>函数是如何调用<strong>ReactiveEffect.run</strong>触发依赖收集，当依赖变化后又做了哪些事情</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn, options</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 fn 已经是一个 effect 函数了，则指向原始函数</span></span><br><span class="line">    <span class="keyword">if</span> (fn.<span class="property">effect</span> <span class="keyword">instanceof</span> <span class="title class_">ReactiveEffect</span>) &#123;</span><br><span class="line">        fn = fn.<span class="property">effect</span>.<span class="property">fn</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化响应式副作用实例</span></span><br><span class="line">    <span class="keyword">const</span> _effect = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(fn, <span class="variable constant_">NOOP</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_effect.<span class="property">dirty</span>) &#123;</span><br><span class="line">            _effect.<span class="title function_">run</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选项逻辑处理</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">        <span class="title function_">extend</span>(_effect, options); <span class="comment">// 合并对象</span></span><br><span class="line">        <span class="keyword">if</span> (options.<span class="property">scope</span>) <span class="title function_">recordEffectScope</span>(_effect, options.<span class="property">scope</span>); <span class="comment">// 记录副作用范围</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 副作用运行</span></span><br><span class="line">    <span class="keyword">if</span> (!options || !options.<span class="property">lazy</span>) &#123;</span><br><span class="line">        _effect.<span class="title function_">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> runner = _effect.<span class="property">run</span>.<span class="title function_">bind</span>(_effect);</span><br><span class="line">    runner.<span class="property">effect</span> = _effect;</span><br><span class="line">    <span class="keyword">return</span> runner; <span class="comment">// 返回运行器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>effect</strong>首先处理<strong>fn</strong>为副作用函数时，指向回原函数，然后构建一个<strong>ReactiveEffect</strong>实例，通过传入一个<strong>schedule</strong>函数达到从新执行<strong>fn</strong>效果。然后就是<strong>options</strong>逻辑的处理。当我们不传options时，默认执行<strong>ReactiveEffect.run</strong>达到依赖收集效果，函数返回<strong>ReactiveEffect.run</strong>函数，可以根据业务自由调用。</p><h3 id="ComputedRefImpl"><a href="#ComputedRefImpl" class="headerlink" title="ComputedRefImpl"></a>ComputedRefImpl</h3><p>有些同学可能不了解<strong>ComputedRefImpl</strong>是个什么，<strong>ComputedRefIml</strong>实际时<strong>computed</strong>对象的构造器的，我们接着来了解一个<strong>ComputedRefImpl</strong>是如何调用<strong>ReactiveEffect.run</strong>触发依赖收集的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">computed</span>(<span class="params">getterOptions, debugOptions, isSSR = <span class="literal">false</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> getter;</span><br><span class="line">    <span class="keyword">let</span> setter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> onlyGetter = <span class="title function_">isFunction</span>(getterOptions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (onlyGetter) &#123;</span><br><span class="line">        getter = getterOptions;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        getter = getterOptions.<span class="property">get</span>;</span><br><span class="line">        setter = getterOptions.<span class="property">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> cRef = <span class="keyword">new</span> <span class="title class_">ComputedRefImpl</span>(getter, setter, onlyGetter || !setter, isSSR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cRef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ComputedRefImpl</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">getter, _setter, isReadonly, isSSR</span>) &#123;</span><br><span class="line">        <span class="comment">// 实例化副作用</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">effect</span> = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(</span><br><span class="line">            <span class="function">() =&gt;</span> <span class="title function_">getter</span>(<span class="variable language_">this</span>.<span class="property">_value</span>),</span><br><span class="line">            <span class="function">() =&gt;</span> <span class="title function_">triggerRefValue</span>(</span><br><span class="line">                <span class="variable language_">this</span>,</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">effect</span>.<span class="property">_dirtyLevel</span> === <span class="title class_">DirtyLevels</span>.<span class="property">MaybeDirty_ComputedSideEffect</span></span><br><span class="line">                    ? <span class="title class_">DirtyLevels</span>.<span class="property">MaybeDirty_ComputedSideEffect</span></span><br><span class="line">                    : <span class="title class_">DirtyLevels</span>.<span class="property">MaybeDirty</span>,</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">        <span class="keyword">const</span> self = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>);</span><br><span class="line">        self.<span class="property">_value</span> = self.<span class="property">effect</span>.<span class="title function_">run</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.<span class="property">_value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，当我们<strong>ComputedRefImpl.value getter</strong>访问时，会触发<strong>ReactiveEffect.run</strong>从而调用<strong>computed.value getter</strong>触发依赖收集</p><h3 id="doWatch"><a href="#doWatch" class="headerlink" title="doWatch"></a>doWatch</h3><p>如果你还不了解<strong>doWatch</strong>是个什么，你可以查看一下我的文章：<a href="https://sanxun8.github.io/2024/04/03/%E6%BA%90%E7%A0%81/vue3/watch/">响应式原理：Watch 函数的实现</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">doWatch</span>(<span class="params">source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">job</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        effect.<span class="title function_">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> effect = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(getter, <span class="variable constant_">NOOP</span>, scheduler);</span><br><span class="line"></span><br><span class="line">    effect.<span class="title function_">run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对<strong>doWatch</strong>的实现代码进行大量缩减。从上述代码以及前面对<strong>ReactiveEffect</strong>认识，我们可以发现，<strong>doWatch</strong>实际上定义了个<strong>getter</strong>函数对响应式依赖进行收集。这里不对<strong>scheduler</strong>定义进行展开，你可以简单理解为scheduler实际就是执行<strong>job</strong>函数，从而达到执行<strong>getter</strong>效果，而<strong>ReactiveEffect.run</strong>的首次调用是在<strong>doWatch</strong>内部执行的。</p><h3 id="setupRenderEffect"><a href="#setupRenderEffect" class="headerlink" title="setupRenderEffect"></a>setupRenderEffect</h3><p>setupRenderEffect是组件更新的核心</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">baseCreateRenderer</span>(<span class="params">options, createHydrationFns</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">setupRenderEffect</span> = (<span class="params"></span></span><br><span class="line"><span class="params">    instance,</span></span><br><span class="line"><span class="params">    initialVNode,</span></span><br><span class="line"><span class="params">    container,</span></span><br><span class="line"><span class="params">    anchor,</span></span><br><span class="line"><span class="params">    parentSuspense,</span></span><br><span class="line"><span class="params">    namspace,</span></span><br><span class="line"><span class="params">    optimized,</span></span><br><span class="line"><span class="params">  </span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> effect = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(componentUpdateFn, <span class="variable constant_">NOOP</span>, <span class="function">() =&gt;</span> <span class="title function_">queueJob</span>(update), instance.<span class="property">scope</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">update</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (effect.<span class="property">dirty</span>) &#123;</span><br><span class="line">            effect.<span class="title function_">run</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">update</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道组件编译后会编译成<strong>render</strong>函数，这里我们可以理解<strong>componentUpdateFn</strong>实际就是调用组件<strong>render</strong>达到响应式数据依赖收集的效果，而传输的<strong>scheduler</strong>调度器就简单理解成对<strong>update</strong>函数的调用，而<strong>ReactiveEffect.run</strong>的首次调用也是在<strong>setupRenderEffect</strong>调用的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;响应式对象中的执行函数、响应式触发器、调度器都是由&lt;strong&gt;reactiveEffect&lt;/strong&gt;类进行管理的，学习本章，你将会明白&lt;strong&gt;effect&lt;/strong&gt;、&lt;strong&gt;computed&lt;/strong&gt;、&lt;strong&gt;doWatc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>响应式原理：Dep（响应式对象的依赖管理器）</title>
    <link href="https://sanxun8.github.io/2024/04/03/%E6%BA%90%E7%A0%81/vue3/dep/"/>
    <id>https://sanxun8.github.io/2024/04/03/%E6%BA%90%E7%A0%81/vue3/dep/</id>
    <published>2024-04-03T01:31:33.380Z</published>
    <updated>2024-04-05T08:59:02.758Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在本章开始之前，需要有一个前置认知：Vue响应式的核心就是响应式对象和函数，对象改变，函数执行。在响应式中，dep起到是一个中间者的角色，看完本章，你将会明白<strong>reactive</strong>、<strong>ref</strong>响应式对象是如何通过<strong>dep</strong>通知函数的执行的。</p><p>dep实际上是一个map对象，键是effect对象，值为依赖标识。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">createDep</span> = (<span class="params">cleanup, computed</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    dep.<span class="property">cleanup</span> = cleanup;</span><br><span class="line">    dep.<span class="property">computed</span> = computed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的响应式对象会创建用于存储<strong>dep</strong>的不同的数据结构，并使用<strong>dep</strong>进行通知函数执行，我们先来看一下<strong>reactive</strong>对象的dep结构创建以及函数调用通知过程。</p><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><h4 id="依赖收集（对象构建）"><a href="#依赖收集（对象构建）" class="headerlink" title="依赖收集（对象构建）"></a>依赖收集（对象构建）</h4><p>让我看一下<strong>reactive</strong>创建用于存储<strong>dep</strong>的不同的数据结构的流程。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shouldTrack = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> activeEffect; <span class="comment">// ReactiveEffect实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target, type, key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;</span><br><span class="line">        <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化依赖映射</span></span><br><span class="line">        <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">            targetMap.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key);</span><br><span class="line">        <span class="comment">// 设置依赖</span></span><br><span class="line">        <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">            depsMap.<span class="title function_">set</span>(key, (dep = <span class="title function_">createDep</span>(<span class="function">() =&gt;</span> depsMap.<span class="title function_">delete</span>(key))));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收集副作用</span></span><br><span class="line">        <span class="title function_">trackEffect</span>(activeEffect, dep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackEffect</span>(<span class="params">effect, dep, debuggerEventExtraInfo</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dep.<span class="title function_">get</span>(effect) !== effect.<span class="property">_trackId</span>) &#123; <span class="comment">// effect._trackId 在ReactiveEffect.run时设置</span></span><br><span class="line">        dep.<span class="title function_">set</span>(effect, effect.<span class="property">_trackId</span>); <span class="comment">// 设置副作用标识</span></span><br><span class="line">        <span class="keyword">const</span> oldDep = effect.<span class="property">deps</span>[effect.<span class="property">_depslength</span>];</span><br><span class="line">        <span class="keyword">if</span> (oldDep !== dep) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldDep) &#123;</span><br><span class="line">                <span class="title function_">cleanupDepEffect</span>(oldDep, effect); <span class="comment">// 清理dep下的副作用</span></span><br><span class="line">            &#125;</span><br><span class="line">            effect.<span class="property">deps</span>[effect.<span class="property">_depslength</span>++] = dep; <span class="comment">// 标识副作用绑定到哪个dep</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            effect.<span class="property">_depslength</span>++; <span class="comment">// 标识副作用绑定到多少dep下</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数有点绕，其实核心就是在生成一个数据结构，什么样的数据结构呢？我们来画个图看看：</p><p><img src="https://i.imgur.com/X7hex8a.png" alt="Imgur"></p><p>我们创建了全局的<strong>targetMap</strong>，它的键是<strong>target</strong>，值是<strong>depsMap</strong>；这个<strong>depsMap</strong>的键是<strong>target</strong>的<strong>key</strong>，值是<strong>dep</strong>集合，<strong>dep</strong>集合中存储的是依赖的副作用函数<strong>effect</strong>。</p><h4 id="响应处理（函数执行）"><a href="#响应处理（函数执行）" class="headerlink" title="响应处理（函数执行）"></a>响应处理（函数执行）</h4><p>看一下源码定义</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, type, key, newValue, oldValue, oldTarget</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> depsMap = targetMap.<span class="title function_">get</span>(target);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理未收集</span></span><br><span class="line">    <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> deps = []; <span class="comment">// 需要被处理依赖</span></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="title class_">TriggerOpTypes</span>.<span class="property">CLEAR</span>) &#123; <span class="comment">// 操作为清理 </span></span><br><span class="line">        deps = [...depsMap.<span class="title function_">values</span>()];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span> &amp;&amp; <span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">        <span class="keyword">const</span> newLength = <span class="title class_">Number</span>(newValue);</span><br><span class="line">        depsMap.<span class="title function_">forEach</span>(<span class="function">(<span class="params">dep, key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span> || (!<span class="title function_">isSymbol</span>(key) &amp;&amp; key &gt;= newLength)) &#123;</span><br><span class="line">                deps.<span class="title function_">push</span>(dep);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key !== <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">            deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>:</span><br><span class="line">                <span class="keyword">if</span> (!<span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">                    deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERACE_KEY</span>)); <span class="comment">// 暂不理解</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="title function_">isMap</span>(target)) &#123;</span><br><span class="line">                        deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">MAP_KEY_ITERATE_KEY</span>)); <span class="comment">// 暂不理解</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isIntegerKey</span>(key)) &#123;</span><br><span class="line">                    deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="string">&#x27;length&#x27;</span>)); <span class="comment">// // 暂不理解</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="title class_">TriggerOpTypes</span>.<span class="property">DELETE</span>:</span><br><span class="line">                <span class="keyword">if</span> ((!<span class="title function_">isArray</span>(target))) &#123;</span><br><span class="line">                    deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERACE_KEY</span>)); <span class="comment">// 暂不理解</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="title function_">isMap</span>(target)) &#123;</span><br><span class="line">                        deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">MAP_KEY_ITERATE_KEY</span>)); <span class="comment">// 暂不理解</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="title class_">TriggerOptypes</span>.<span class="property">SET</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">isMap</span>(target)) &#123;</span><br><span class="line">                    deps.<span class="title function_">push</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERACE_KEY</span>)); <span class="comment">// 暂不理解</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂停调度</span></span><br><span class="line">    <span class="title function_">pauseScheduling</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历依赖，执行副作用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> dep <span class="keyword">of</span> deps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep) &#123;</span><br><span class="line">            <span class="title function_">triggerEffects</span>(dep, <span class="title class_">DirtyLevels</span>.<span class="property">Dirty</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置调调</span></span><br><span class="line">    <span class="title function_">resetScheduling</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>述代码的核心流程就是获取需要响应的依赖，首先处理预留清理响应操作类型，所有依赖都需要被清理，其次修改属性为<strong>length</strong>且<strong>target</strong>为数组时，访问<strong>length</strong>属性的依赖以及数组中超过新数组长度的元素依赖需要被清理。获取需要响应的依赖后，暂停全局调度后，遍历执行<strong>triggerEffects</strong>，最后重置调度。</p><p>我们来看一下<strong>triggerEffects</strong>的实现</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerEffects</span>(<span class="params">dep, dirtyLevels, debuggerEventExtraInfo</span>) &#123;</span><br><span class="line">    <span class="title function_">pasuScheduling</span>(); <span class="comment">// 暂停全局调度</span></span><br><span class="line">    <span class="comment">// 遍历dep</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> effect <span class="keyword">of</span> dep.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">        <span class="keyword">let</span> tracking;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            effect.<span class="property">_dirtyLevel</span> &lt; dirtyLevel &amp;&amp;</span><br><span class="line">            (tracking ??= dep.<span class="title function_">get</span>(effect) === effect.<span class="property">_trackId</span>)</span><br><span class="line">        ) &#123;</span><br><span class="line">            effect.<span class="property">_shouldSchedule</span> ||= effect.<span class="property">_dirtyLevel</span> === dirtyLevels.<span class="property">NotDirty</span>;</span><br><span class="line">            effect.<span class="property">_dirtyLevel</span> = dirtyLevel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            effect.<span class="property">_shouldSchedule</span> &amp;&amp;</span><br><span class="line">            (tracking ??= dep.<span class="title function_">get</span>(effect === effect.<span class="property">_trackId</span>) === effect.<span class="property">_trackId</span>)</span><br><span class="line">        ) &#123;</span><br><span class="line">            effect.<span class="title function_">trigger</span>(); <span class="comment">// 执行函数</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!effect.<span class="property">_runnings</span> || effect.<span class="property">allRecurse</span> &amp;&amp;</span><br><span class="line">                effect.<span class="property">_dirtyLevel</span> !== dirtyLevels.<span class="property">MaybeDirty_ComputedSideEffect</span></span><br><span class="line">            ) &#123; <span class="comment">// 副作用不在运行中或者副作用允许递归且_dirtyLevel值不为2</span></span><br><span class="line">                effect.<span class="property">_shouldSchedule</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (effect.<span class="property">scheduler</span>) &#123;</span><br><span class="line">                    queueEffectSchedulers.<span class="title function_">push</span>(effect.<span class="property">scheduler</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">resetScheduling</span>(); <span class="comment">// 执行调度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的主要逻辑是，先暂停全局调度，然后遍历副作用对象，更新**_shouldSchedule<strong>标识，然后根据</strong>_shouldSchedule**判断是否执行调度函数，最后重新执行全局调度。</p><p>到这里我们就解析完<strong>reactive</strong>对象所创建用于存储<strong>dep</strong>的数据结构，以及<strong>dep</strong>进行通知函数执行的过程了。</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><h4 id="依赖收集（对象构建）-1"><a href="#依赖收集（对象构建）-1" class="headerlink" title="依赖收集（对象构建）"></a>依赖收集（对象构建）</h4><p>让我看一下<strong>ref</strong>创建用于存储<strong>dep</strong>的不同的数据结构流程。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trackRefValue</span>(<span class="params">ref</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;</span><br><span class="line">        ref = <span class="title function_">toRaw</span>(ref);</span><br><span class="line">        ref.<span class="property">dep</span> ??= <span class="title function_">createDep</span>(<span class="function">() =&gt;</span> (ref.<span class="property">dep</span> = <span class="literal">undefined</span>), ref <span class="keyword">instanceof</span> <span class="title class_">ComputedRefImpl</span> ? ref : <span class="literal">undefined</span>);</span><br><span class="line">        <span class="title function_">trackEffect</span>(activeEffect, ref.<span class="property">dep</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，<strong>ref</strong>并没有创建额外的变量用于存储<strong>dep</strong>而是直接绑定到dep属性下面，然后复用<strong>trackEffect</strong>逻辑进行依赖收集。</p><h4 id="响应处理（函数执行）-1"><a href="#响应处理（函数执行）-1" class="headerlink" title="响应处理（函数执行）"></a>响应处理（函数执行）</h4><p>看一下源码定义</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triggerRefValue</span>(<span class="params">ref, dirtyLevel, newValue</span>) &#123;</span><br><span class="line">    ref = <span class="title function_">toRaw</span>(ref);</span><br><span class="line">    <span class="keyword">const</span> dep = ref.<span class="property">dep</span>;</span><br><span class="line">    <span class="keyword">if</span> (dep) &#123;</span><br><span class="line">        <span class="title function_">triggerEffects</span>(dep, dirtyLevel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，除了用于存储dep的数据结构不同外，<strong>traEffect</strong>以及<strong>triggerEffects</strong>都得到了很好的复用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在本章开始之前，需要有一个前置认知：Vue响应式的核心就是响应式对象和函数，对象改变，函数执行。在响应式中，dep起到是一个中间者的角色，看</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue3中computed模块源码解析</title>
    <link href="https://sanxun8.github.io/2024/03/30/%E6%BA%90%E7%A0%81/vue3/computed/"/>
    <id>https://sanxun8.github.io/2024/03/30/%E6%BA%90%E7%A0%81/vue3/computed/</id>
    <published>2024-03-30T02:01:04.141Z</published>
    <updated>2024-04-05T08:57:58.759Z</updated>
    
    <content type="html"><![CDATA[<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>源码中关于<strong>computed</strong>部分的定义：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">computed</span>(<span class="params">getterOptions, debugOptions, isSSR = <span class="literal">false</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> getter;</span><br><span class="line">    <span class="keyword">let</span> setter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> onlyGetter = <span class="title function_">isFunction</span>(getterOptions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (onlyGetter) &#123;</span><br><span class="line">        getter = getterOptions;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        getter = getterOptions.<span class="property">get</span>;</span><br><span class="line">        setter = getterOptions.<span class="property">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> cRef = <span class="keyword">new</span> <span class="title class_">ComputedRefImpl</span>(getter, setter, onlyGetter || !setter, isSSR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cRef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代理核心流程就是先进行参数归一化, 然后生成并返回一个实例化对象。让我们一起看一下啊<strong>ComputedRefImpl</strong>的实现</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ComputedRefImpl</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">getter, _setter, isReadonly, isSSR</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">getter</span> = getter;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_setter</span> = _setter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化副作用 暂不清楚_dirtyLevel属性更新逻辑</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">effect</span> = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(</span><br><span class="line">            <span class="function">() =&gt;</span> <span class="title function_">getter</span>(<span class="variable language_">this</span>.<span class="property">_value</span>),</span><br><span class="line">            <span class="function">() =&gt;</span> <span class="title function_">triggerRefValue</span>(</span><br><span class="line">                <span class="variable language_">this</span>,</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">effect</span>.<span class="property">_dirtyLevel</span> === <span class="title class_">DirtyLevels</span>.<span class="property">MaybeDirty_ComputedSideEffect</span></span><br><span class="line">                    ? <span class="title class_">DirtyLevels</span>.<span class="property">MaybeDirty_ComputedSideEffect</span></span><br><span class="line">                    : <span class="title class_">DirtyLevels</span>.<span class="property">MaybeDirty</span>,</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">effect</span>.<span class="property">computed</span> = <span class="variable language_">this</span>; <span class="comment">// 一个标记，会优先于其他普通副作用函数先执行</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">effect</span>.<span class="property">active</span> = <span class="variable language_">this</span>.<span class="property">_cacheable</span> = !isSSR; <span class="comment">// 暂不知道active用途</span></span><br><span class="line">        <span class="variable language_">this</span>[<span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>] = isReadonly;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">        <span class="keyword">const</span> self = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 脏值则进行更新</span></span><br><span class="line">        <span class="keyword">if</span>(</span><br><span class="line">            (!self.<span class="property">_cacheable</span> || self.<span class="property">effect</span>.<span class="property">dirty</span>) &amp;&amp;</span><br><span class="line">            <span class="title function_">hasChanged</span>(self.<span class="property">_value</span>, (self.<span class="property">_value</span>) = self.<span class="property">effect</span>.<span class="title function_">run</span>())</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="title function_">triggerRefValue</span>(self, <span class="title class_">DirtyLevels</span>.<span class="property">Dirty</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依赖收集</span></span><br><span class="line">        <span class="title function_">trackRefValue</span>(self);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(self.<span class="property">effect</span>.<span class="property">_dirtyLevel</span> &gt;= <span class="title class_">DirtyLevels</span>.<span class="property">MaybeDirty_ComputedSideEffect</span>) &#123;</span><br><span class="line">            <span class="title function_">triggerRefValue</span>(self, <span class="title class_">DirtyLevels</span>.<span class="property">MaybeDirty_ComputedSideEffect</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.<span class="property">_value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行setter</span></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">_setter</span>(newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单看一下该类的实现，在构造函数的时候，创建一个副作用对像<strong>effect</strong>。并为<strong>effect</strong>额外定义了一个<strong>computed</strong>属性执行当前响应式对象<strong>cRef</strong>对象。</p><p>另外，定义了一个<strong>ComputedRefImpl.value getter</strong>方法，当我们通过<strong>cRef.value</strong>取值的时候，会判断是否有脏值，脏值处理核心就是调用<strong>trggerRefValue</strong>，如果你想了解<strong>trackRefValue</strong>、**trggerRefValue做了些什么，可以查看我的文章[响应式原理：dep（响应式对象的依赖管理器）]</p><p>其还定义了一个<strong>ComputedRefImpl.value setter</strong>方法，该方法就是执行过程传入进来得<strong>computed.value setter</strong>函数。</p><p>有了上面得介绍，我们来看一个具体的例子，看看<strong>computed</strong>是如何执行的：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../../dist/vue.global.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;&#123; sum.value &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> a = <span class="title class_">Vue</span>.<span class="title function_">ref</span>(<span class="number">1</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> sum = <span class="title class_">Vue</span>.<span class="title function_">computed</span>(getter);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">getter</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> a.<span class="property">value</span> + <span class="number">1</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        a.<span class="property">value</span> = <span class="number">2</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123; sum &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">  &#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#demo&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><strong>computed</strong>函数执行，初始化过程中，生成了一个<strong>computed effect</strong>.</li><li>上述的template会被编译为<strong>render</strong>函数，<strong>render</strong>执行，访问了<strong>sum.value</strong>，触发了收集，此时收集的副作用为<strong>render effect</strong>, 会执行<strong>ComputedRefImpl.value getter</strong>，此时的<strong>self._dirty &#x3D; true</strong>执行<strong>effect.run()<strong>也就是执行了</strong>computed.value getter</strong>函数，得到**_value &#x3D; 1**</li><li><strong>computed.value getter</strong>函数体内访问了<strong>a.value</strong>触发了对<strong>a</strong>的依赖收集，此时收集到的依赖为<strong>computed effect</strong>。</li><li>按钮点击后，执行<strong>add</strong>更新了<strong>a.value</strong>值触发了<strong>computed effect</strong>的<strong>trigger</strong>，也就是执行<strong>render</strong>。</li><li>执行<strong>render</strong>会访问<strong>ComputedRefImpl.value getter</strong>, 会执行<strong>computed effect.run()<strong>触发</strong>computed.value getter</strong>函数的执行。因为此时的**_dirty &#x3D; true**, 所以<strong>get value</strong>会重新计算**_value<strong>的值为</strong>sum.value &#x3D; 3**。</li><li><strong>sum.value</strong>的值变化后，触发了<strong>triggerRefvalue</strong>, 即<strong>render</strong>会重新执行。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;computed&quot;&gt;&lt;a href=&quot;#computed&quot; class=&quot;headerlink&quot; title=&quot;computed&quot;&gt;&lt;/a&gt;computed&lt;/h3&gt;&lt;p&gt;源码中关于&lt;strong&gt;computed&lt;/strong&gt;部分的定义：&lt;/p&gt;
&lt;figu</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>响应式原理：Ref对象解析</title>
    <link href="https://sanxun8.github.io/2024/03/22/%E6%BA%90%E7%A0%81/vue3/ref/"/>
    <id>https://sanxun8.github.io/2024/03/22/%E6%BA%90%E7%A0%81/vue3/ref/</id>
    <published>2024-03-22T12:33:24.547Z</published>
    <updated>2024-04-05T08:56:11.409Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><p>源码中关于<strong>ref</strong>部分的定义：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ref</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createRef</span>(value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的核心也就是通过<strong>createRef</strong>把我们传入的<strong>value</strong>变成响应式的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createRef</span>(<span class="params">rawValue, shallow</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isRef</span>(rawValue)) &#123;</span><br><span class="line">        <span class="keyword">return</span> rawValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RefImpl</span>(rawValue, shallow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先经过判断，判断符合要求的<strong>value</strong>才能被响应式。一起来看看这个<strong>API</strong>的实现：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RefImpl</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">value, __v_isShallow</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">__v_isShallow</span> = __v_isShallow;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_rawValue</span> = __v_isShallow ? value : <span class="title function_">toRaw</span>(value);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_value</span> = __v_isShallow ? value : <span class="title function_">toReactive</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">        <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>); <span class="comment">// 收集依赖</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> useDirectValue = <span class="variable language_">this</span>.<span class="property">__v_isShallow</span> || <span class="title function_">isShallow</span>(newVal) || <span class="title function_">isReadonly</span>(newVal);</span><br><span class="line">        newVal = useDirectValue ? newVal : <span class="title function_">toRaw</span>(newVal);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(newVal, <span class="variable language_">this</span>.<span class="property">_rawValue</span>)) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_rawValue</span> = newVal;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_value</span> = useDirectValue ? newVal : <span class="title function_">toReactive</span>(newVal);</span><br><span class="line">            <span class="title function_">triggerRefValue</span>(<span class="variable language_">this</span>, <span class="title class_">DirtyLevels</span>.<span class="property">Dirty</span>, newVal); <span class="comment">// 触发响应</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，<strong>RefImpl</strong>定义了<strong>value gettter</strong>用于依赖的收集，定义了<strong>value setter</strong>用于触发响应。如果你想了解<strong>trackRefValue</strong>、<strong>triggerRefValue</strong>做了些什么，可以查看我的文章<a href="https://sanxun8.github.io/2024/04/03/%E6%BA%90%E7%A0%81/vue3/dep/">响应式原理：dep（响应式对象的依赖管理器）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Ref&quot;&gt;&lt;a href=&quot;#Ref&quot; class=&quot;headerlink&quot; title=&quot;Ref&quot;&gt;&lt;/a&gt;Ref&lt;/h3&gt;&lt;p&gt;源码中关于&lt;strong&gt;ref&lt;/strong&gt;部分的定义：&lt;/p&gt;
&lt;figure class=&quot;highlight javas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue3中中获取最长递增子序列</title>
    <link href="https://sanxun8.github.io/2024/03/22/%E6%BA%90%E7%A0%81/vue3/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://sanxun8.github.io/2024/03/22/%E6%BA%90%E7%A0%81/vue3/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2024-03-22T11:17:15.570Z</published>
    <updated>2024-03-29T15:16:48.013Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSequence</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> p = arr.<span class="title function_">slice</span>(); <span class="comment">// 反向链表 可以使用 p = []初始化</span></span><br><span class="line">    <span class="keyword">const</span> result = [<span class="number">0</span>] <span class="comment">// 结果值到原数组索引的映射</span></span><br><span class="line">    <span class="keyword">let</span> i, j, u, v, c;</span><br><span class="line">    <span class="keyword">const</span> len = arr.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> arrI = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (arrI !== <span class="number">0</span>) &#123;</span><br><span class="line">            j = result[result.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arrI) &#123; <span class="comment">// 与最后一项对比</span></span><br><span class="line">                p[i] = j;</span><br><span class="line">                result.<span class="title function_">push</span>(i);</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            u = <span class="number">0</span>;</span><br><span class="line">            v = result.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (u &lt; v) &#123; <span class="comment">// 二分查找</span></span><br><span class="line">                c = (u + v) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (arr[result[c]] &lt; arrI) &#123;</span><br><span class="line">                    u = c + <span class="number">1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    v = c</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arrI &lt; arr[result[u]]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (u &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    p[i] = result[u - <span class="number">1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">                result[u] = i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯修正</span></span><br><span class="line">    u = result.<span class="property">length</span></span><br><span class="line">    v = result[u - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> (u-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        result[u] = v</span><br><span class="line">        v = p[v]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>渲染器：数组节点中的Dom Diff</title>
    <link href="https://sanxun8.github.io/2024/03/22/%E6%BA%90%E7%A0%81/vue3/vue3_dom_diff/"/>
    <id>https://sanxun8.github.io/2024/03/22/%E6%BA%90%E7%A0%81/vue3/vue3_dom_diff/</id>
    <published>2024-03-22T08:43:51.154Z</published>
    <updated>2024-04-01T11:52:13.246Z</updated>
    
    <content type="html"><![CDATA[<p>在前端开发中，我们经常需要处理包含数组子节点的动态列表或复杂组件。本文将基于源码，梳理数组子节点的Diff更新流程，帮助读者更好地理解Vue3是如何通过Diff算法来高效地更新这些子节点，以提升应用性能。</p><h3 id="从头对比"><a href="#从头对比" class="headerlink" title="从头对比"></a>从头对比</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 当前对比索引</span></span><br><span class="line">    <span class="keyword">const</span> l2 = c2.<span class="property">length</span>; <span class="comment">// 新节点长度</span></span><br><span class="line">    <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 旧节点结束标识</span></span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>; <span class="comment">// 新节点介绍标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 头对比</span></span><br><span class="line">    <span class="comment">// (a b) c</span></span><br><span class="line">    <span class="comment">// (a b) d e</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; e1 &amp;&amp; i &lt; e2) &#123;</span><br><span class="line">        <span class="keyword">const</span> n1 = c1[i];</span><br><span class="line">        <span class="keyword">const</span> n2 = c2[i] = optimized ? <span class="title function_">cloneIfMounted</span>(c2[i]) : <span class="title function_">normalizeVNode</span>(c2[i]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class="line">            <span class="title function_">patch</span>(n1, n2, container, <span class="literal">null</span>, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从尾部对比"><a href="#从尾部对比" class="headerlink" title="从尾部对比"></a>从尾部对比</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 当前对比索引</span></span><br><span class="line">    <span class="keyword">const</span> l2 = c2.<span class="property">length</span>; <span class="comment">// 新节点长度</span></span><br><span class="line">    <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 旧节点结束标识</span></span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>; <span class="comment">// 新节点介绍标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 头对比</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 尾对比</span></span><br><span class="line">    <span class="comment">// a (b c)</span></span><br><span class="line">    <span class="comment">// d e (b c)</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; e1 &amp;&amp; i &lt; e2) &#123;</span><br><span class="line">        <span class="keyword">const</span> n1 = c1[e1];</span><br><span class="line">        <span class="keyword">const</span> n2 = c2[e2] = optimized ? <span class="title function_">cloneIfMounted</span>(c2[e2]) : <span class="title function_">normalizeVNode</span>(c2[e2]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class="line">            <span class="title function_">patch</span>(n1, n2, container, <span class="literal">null</span>, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        e1--;</span><br><span class="line">        e2--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="仅处理新增"><a href="#仅处理新增" class="headerlink" title="仅处理新增"></a>仅处理新增</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 当前对比索引</span></span><br><span class="line">    <span class="keyword">const</span> l2 = c2.<span class="property">length</span>; <span class="comment">// 新节点长度</span></span><br><span class="line">    <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 旧节点结束标识</span></span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>; <span class="comment">// 新节点介绍标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 头对比</span></span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    <span class="comment">// 2. 从尾部对比</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 仅新增</span></span><br><span class="line">    <span class="comment">// (a b)</span></span><br><span class="line">    <span class="comment">// (a b) c</span></span><br><span class="line">    <span class="comment">// i = 2, e1 = 1, e2 = 2</span></span><br><span class="line">    <span class="comment">// (a b)</span></span><br><span class="line">    <span class="comment">// c (a b)</span></span><br><span class="line">    <span class="comment">// i = 0, e1 = -1, e2 = 0</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; e1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= e2) &#123;</span><br><span class="line">            <span class="keyword">const</span> nextPos = e2 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">const</span> anchor = nextPos &lt; l2 ? c2[nextPos].<span class="property">el</span> : parentAnchor;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= e2) &#123;</span><br><span class="line">                <span class="title function_">patch</span>(<span class="literal">null</span>, c2[i] = optimized ? <span class="title function_">cloneIfMounted</span>(c2[i]) : <span class="title function_">normalizeVNode</span>(c2[i]), container, anchor, parentComponent, parentSuspense)</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="仅处理卸载"><a href="#仅处理卸载" class="headerlink" title="仅处理卸载"></a>仅处理卸载</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 当前对比索引</span></span><br><span class="line">    <span class="keyword">const</span> l2 = c2.<span class="property">length</span>; <span class="comment">// 新节点长度</span></span><br><span class="line">    <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 旧节点结束标识</span></span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>; <span class="comment">// 新节点介绍标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 头对比</span></span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    <span class="comment">// 2. 从尾部对比</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 3. 仅新增</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; e1) &#123; <span class="comment">// ...&#125; </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 仅卸载</span></span><br><span class="line">    <span class="comment">// (a b) c</span></span><br><span class="line">    <span class="comment">// (a b)</span></span><br><span class="line">    <span class="comment">// i = 2, e1 = 2, e2 = 1</span></span><br><span class="line">    <span class="comment">// a (b c)</span></span><br><span class="line">    <span class="comment">// (b c)</span></span><br><span class="line">    <span class="comment">// i = 0, e1 = 0, e2 = -1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= e1) &#123;</span><br><span class="line">            <span class="title function_">unmount</span>(c1[i], parentComponent, parentAnchor, <span class="literal">true</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理未知序列"><a href="#处理未知序列" class="headerlink" title="处理未知序列"></a>处理未知序列</h3><h4 id="构建新节点key到index的映射"><a href="#构建新节点key到index的映射" class="headerlink" title="构建新节点key到index的映射"></a>构建新节点key到index的映射</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 当前对比索引</span></span><br><span class="line">    <span class="keyword">const</span> l2 = c2.<span class="property">length</span>; <span class="comment">// 新节点长度</span></span><br><span class="line">    <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 旧节点结束标识</span></span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>; <span class="comment">// 新节点介绍标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 头对比</span></span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    <span class="comment">// 2. 从尾部对比</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 3. 仅新增</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; e1) &#123; <span class="comment">// ...&#125; </span></span><br><span class="line">    <span class="comment">// 4. 仅卸载</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123; <span class="comment">// ... &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> s1 = i; <span class="comment">// 旧节点开始处理索引</span></span><br><span class="line">        <span class="keyword">const</span> s2 = i; <span class="comment">// 新节点开始处理索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.1 构建新节点key到index的映射</span></span><br><span class="line">        <span class="keyword">const</span> keyToNewIndexMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">        <span class="keyword">for</span> (i = s2; i &lt;= e2; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> nextChild = c2[i] = optimized ? <span class="title function_">cloneIfMounted</span>(c2[i]) : <span class="title function_">normalizeVNode</span>(c2[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nextChild.<span class="property">key</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">                keyToNewIndexMap.<span class="title function_">set</span>(nextChild.<span class="property">key</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-处理旧节点（更新和卸载）"><a href="#5-2-处理旧节点（更新和卸载）" class="headerlink" title="5.2 处理旧节点（更新和卸载）"></a>5.2 处理旧节点（更新和卸载）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 当前对比索引</span></span><br><span class="line">    <span class="keyword">const</span> l2 = c2.<span class="property">length</span>; <span class="comment">// 新节点长度</span></span><br><span class="line">    <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 旧节点结束标识</span></span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>; <span class="comment">// 新节点介绍标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 头对比</span></span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    <span class="comment">// 2. 从尾部对比</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 3. 仅新增</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; e1) &#123; <span class="comment">// ...&#125; </span></span><br><span class="line">    <span class="comment">// 4. 仅卸载</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123; <span class="comment">// ... &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> s1 = i; <span class="comment">// 旧节点开始处理索引</span></span><br><span class="line">        <span class="keyword">const</span> s2 = i; <span class="comment">// 新节点开始处理索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.1 构建新节点key到index的映射</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.2 处理旧节点（更新和卸载）</span></span><br><span class="line">        <span class="keyword">let</span> patched = <span class="number">0</span>; <span class="comment">// 已处理的数目</span></span><br><span class="line">        <span class="keyword">const</span> toBePatched = e2 - s2 + <span class="number">1</span>; <span class="comment">// 需要处理的数目</span></span><br><span class="line">        <span class="keyword">let</span> moved = <span class="literal">false</span>; <span class="comment">// 标记节点是否移动</span></span><br><span class="line">        <span class="keyword">let</span> maxNewIndexSoFar = <span class="number">0</span>; <span class="comment">// 辅助判断节点是否移动</span></span><br><span class="line">        <span class="keyword">const</span> newIndexToOldIndexMap = <span class="keyword">new</span> <span class="title class_">Array</span>(toBePatched);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = s1; i &lt;= e1; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> prevChild = e1[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (patched &gt;= toBePatched) &#123; <span class="comment">// 卸载多余节点</span></span><br><span class="line">                <span class="title function_">unmount</span>(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> nextIndex;</span><br><span class="line">            newIndex = keyToNewIndexMap.<span class="title function_">get</span>(prevChild.<span class="property">key</span>);</span><br><span class="line">            <span class="keyword">if</span> (newIndex === <span class="literal">undefined</span>) &#123; <span class="comment">// 新节点找不到则卸载</span></span><br><span class="line">                <span class="title function_">unmount</span>(prevChild, parentComponent, parentAnchor, <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newIndexToOldIndexMap[newIndex - s2] = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class="line">                    maxNewIndexSoFar = newIndex;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    moved = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_">patch</span>(prevChild, c2[newIndex], <span class="literal">null</span>, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)</span><br><span class="line">                patched++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-移动和新增"><a href="#5-3-移动和新增" class="headerlink" title="5.3 移动和新增"></a>5.3 移动和新增</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 当前对比索引</span></span><br><span class="line">    <span class="keyword">const</span> l2 = c2.<span class="property">length</span>; <span class="comment">// 新节点长度</span></span><br><span class="line">    <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 旧节点结束标识</span></span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>; <span class="comment">// 新节点介绍标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 头对比</span></span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    <span class="comment">// 2. 从尾部对比</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 3. 仅新增</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; e1) &#123; <span class="comment">// ...&#125; </span></span><br><span class="line">    <span class="comment">// 4. 仅卸载</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123; <span class="comment">// ... &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> s1 = i; <span class="comment">// 旧节点开始处理索引</span></span><br><span class="line">        <span class="keyword">const</span> s2 = i; <span class="comment">// 新节点开始处理索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.1 构建新节点key到index的映射</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 5.2 处理旧节点（更新和卸载）</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.3 移动和新增</span></span><br><span class="line">        <span class="keyword">const</span> increasingNewIndexSequence = moved ? <span class="title function_">getSequence</span>(newIndexToOldIndexMap) : <span class="variable constant_">EMPTY_ARR</span>;</span><br><span class="line">        <span class="keyword">let</span> j = increasingNewIndexSequence.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = toBePatched - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">const</span> nextIndex = s2 + i;</span><br><span class="line">            <span class="keyword">const</span> nextChild = c2[nextIndex];</span><br><span class="line">            <span class="keyword">const</span> anchor = nextIndex + <span class="number">1</span> &lt; l2 ? c2[nextIndex].<span class="property">el</span> : parentAnchor;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newIndexToOldIndexMap[i] === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="title function_">patch</span>(<span class="literal">null</span>, nextChild, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (moved) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; <span class="number">0</span> || i !== increasingNewIndexSequence[j]) &#123;</span><br><span class="line">                    <span class="title function_">moved</span>(nextChild, container, anchor, <span class="title class_">MoveType</span>.<span class="property">REORDER</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化思考"><a href="#优化思考" class="headerlink" title="优化思考"></a>优化思考</h4><ul><li>唯一标识: 我们使用 v-for 编写列表时为什么不建议使用 index 作为 key?</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>希望本文能够帮助读者深入理解基于数组子节点的Diff更新流程，并在实际项目中应用这一知识，提升应用的性能和用户体验</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在前端开发中，我们经常需要处理包含数组子节点的动态列表或复杂组件。本文将基于源码，梳理数组子节点的Diff更新流程，帮助读者更好地理解Vue3是如何通过Diff算法来高效地更新这些子节点，以提升应用性能。&lt;/p&gt;
&lt;h3 id=&quot;从头对比&quot;&gt;&lt;a href=&quot;#从头对比&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue2中nextTick的实现</title>
    <link href="https://sanxun8.github.io/2024/03/21/%E6%BA%90%E7%A0%81/vue2/vue2_nextTeck/"/>
    <id>https://sanxun8.github.io/2024/03/21/%E6%BA%90%E7%A0%81/vue2/vue2_nextTeck/</id>
    <published>2024-03-21T12:56:44.097Z</published>
    <updated>2024-03-29T15:13:35.007Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> inBrowser = <span class="keyword">typeof</span> <span class="variable language_">window</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="variable language_">window</span>) !== <span class="string">&#x27;[object Object]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> nextTick = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> callbacks = [];</span><br><span class="line">    <span class="keyword">let</span> pendding = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> timeFunc;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">nextTickHandler</span>(<span class="params"></span>) &#123;</span><br><span class="line">        pendding = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">const</span> copies = callbacks.<span class="title function_">slice</span>(<span class="number">0</span>);</span><br><span class="line">        callbacks = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            copies[i]();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">MutationObserver</span> === <span class="string">&#x27;undefined&#x27;</span>) &#123; <span class="comment">// cb同步执行</span></span><br><span class="line">        <span class="keyword">let</span> counter = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(nextTickHandler)</span><br><span class="line">        <span class="keyword">const</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter));</span><br><span class="line">        observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">            <span class="attr">characterData</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        timeFunc = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            counter = (counter + <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">            textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// cb同步执行</span></span><br><span class="line">        <span class="keyword">const</span> context = inBrowser ? <span class="variable language_">window</span> : <span class="keyword">typeof</span> <span class="variable language_">global</span> !== <span class="string">&#x27;undefined&#x27;</span> ? <span class="variable language_">global</span> : &#123;&#125;;</span><br><span class="line">        timeFunc = context.<span class="property">setImmediate</span> || <span class="built_in">setTimeout</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">cb, ctx</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> func = ctx ? <span class="keyword">function</span>(<span class="params"></span>) &#123;cb.<span class="title function_">call</span>(ctx);&#125; : cb;</span><br><span class="line">        callbacks.<span class="title function_">push</span>(func);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pendding) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        pendding = <span class="literal">true</span>;</span><br><span class="line">        <span class="title function_">timeFunc</span>(nextTickHandler, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; inBrowser = &lt;spa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>中介者模式：简化对象间的通信</title>
    <link href="https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-03-19T06:12:59.572Z</published>
    <updated>2024-03-25T09:55:19.471Z</updated>
    
    <content type="html"><![CDATA[<p>中介者模式（Mediator Pattern）是一种行为型设计模式，用于解耦多个对象之间的通信，并将其集中处理。通过引入一个中介者对象，各个对象不再直接相互通信，而是通过中介者进行交互。这种模式可以减少对象间的耦合度，提高系统的可维护性和灵活性。</p><hr><h3 id="示例场景-vue2中收集响应式依赖-通过Dep类集中处理依赖更新"><a href="#示例场景-vue2中收集响应式依赖-通过Dep类集中处理依赖更新" class="headerlink" title="示例场景(vue2中收集响应式依赖, 通过Dep类集中处理依赖更新)"></a>示例场景(vue2中收集响应式依赖, 通过Dep类集中处理依赖更新)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中介模式</span></span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span>; <span class="comment">// 使用闭包实现唯一标识</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = uid++;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addSub</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">removeSub</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">    <span class="title function_">remove</span>(<span class="variable language_">this</span>.<span class="property">subs</span>, sub); <span class="comment">// 一个工具函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">depend</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">      <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">addDep</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">slice</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].<span class="title function_">update</span>();  <span class="comment">// 调用Watcher.prototype.addDep</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图模型对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">    <span class="title function_">addDep</span>(<span class="params">dep</span>) &#123;</span><br><span class="line">        dep.<span class="title function_">addSub</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 更新视图</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模型对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReacitve</span>(<span class="params">obj, key, value, customSetter</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="attr">enumeralbe</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">                dep.<span class="title function_">depend</span>() <span class="comment">// 收集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            dep.<span class="title function_">notify</span>(); <span class="comment">// 通知</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该案例中使用了<strong>Dep类</strong>充当中介者角色, <strong>模型对象</strong>不直接与<strong>视图模型对象</strong>直接通信, 避免了响应式数据挟持后书写视图更新的负责逻辑代码;</p><h3 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h3><p>假设我们正在开发一个聊天室应用程序，其中包含多个用户（User）和一个聊天室（ChatRoom）。用户之间可以相互发送消息，同时聊天室也可以将消息广播给所有用户。</p><p>在这个场景中，可以使用中介者模式来简化用户和聊天室之间的通信。聊天室充当中介者，用户充当同事类。用户之间的消息不再直接发送给其他用户，而是通过聊天室中介者进行转发。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>中介者模式的核心思想是将对象间的通信行为集中管理，通过引入一个中介者对象来协调各个对象之间的交互。</li><li>中介者模式的核心组成部分: 中介者, 交互对象(可能是同事类);</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。</p><p>通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。</p><p>敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;中介者模式（Mediator Pattern）是一种行为型设计模式，用于解耦多个对象之间的通信，并将其集中处理。通过引入一个中介者对象，各个对象不再直接相互通信，而是通过中介者进行交互。这种模式可以减少对象间的耦合度，提高系统的可维护性和灵活性。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>建造者模式：构建复杂对象的灵活设计模式</title>
    <link href="https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-03-19T06:12:53.157Z</published>
    <updated>2024-03-25T10:01:31.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。"><a href="#建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。" class="headerlink" title="建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。"></a>建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。</h2><h3 id="示例场景-创建一个计算机对象"><a href="#示例场景-创建一个计算机对象" class="headerlink" title="示例场景(创建一个计算机对象)"></a>示例场景(创建一个计算机对象)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Product: 表示要构建的复杂对象​</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;​</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cpu</span> = <span class="string">&quot;&quot;</span>;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">gpu</span> = <span class="string">&quot;&quot;</span>;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ram</span> = <span class="number">0</span>;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storage</span> = <span class="string">&quot;&quot;</span>;​</span><br><span class="line">  &#125;​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">describe</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Computer with CPU: <span class="subst">$&#123;<span class="variable language_">this</span>.cpu&#125;</span>, GPU: <span class="subst">$&#123;<span class="variable language_">this</span>.gpu&#125;</span>, RAM: <span class="subst">$&#123;<span class="variable language_">this</span>.ram&#125;</span>GB, Storage: <span class="subst">$&#123;<span class="variable language_">this</span>.storage&#125;</span>`</span>;​</span><br><span class="line">  &#125;​</span><br><span class="line">&#125;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// Builder: 声明构建复杂对象的接口​</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerBuilder</span> &#123;​</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">computer</span> = <span class="keyword">new</span> <span class="title class_">Computer</span>();​</span><br><span class="line">  &#125;​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">setCPU</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">computer</span>.<span class="property">cpu</span> = <span class="string">&quot;AMD 5600G&quot;</span>;​</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;​</span><br><span class="line">  &#125;​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">setGPU</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">computer</span>.<span class="property">gpu</span> = <span class="string">&quot;核显&quot;</span>;​</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;​</span><br><span class="line">  &#125;​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">setRAM</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">computer</span>.<span class="property">ram</span> = <span class="number">16</span>;​</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;​</span><br><span class="line">  &#125;​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">setStorage</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">computer</span>.<span class="property">storage</span> = <span class="string">&quot;500G&quot;</span>;​</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;​</span><br><span class="line">  &#125;​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">build</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">computer</span>;​</span><br><span class="line">  &#125;​</span><br><span class="line">&#125;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// Director: 负责使用 Builder 构建对象​</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerEngineer</span> &#123;​</span><br><span class="line">  <span class="title function_">constructComputer</span>(<span class="params">builder</span>) &#123;​</span><br><span class="line">    <span class="keyword">return</span> builder​</span><br><span class="line">      .<span class="title function_">setCPU</span>()​</span><br><span class="line">      .<span class="title function_">setGPU</span>()​</span><br><span class="line">      .<span class="title function_">setRAM</span>()​</span><br><span class="line">      .<span class="title function_">setStorage</span>()​</span><br><span class="line">      .<span class="title function_">build</span>();​</span><br><span class="line">  &#125;​</span><br><span class="line">&#125;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 使用建造者模式创建复杂对象​</span></span><br><span class="line"><span class="keyword">const</span> engineer = <span class="keyword">new</span> <span class="title class_">ComputerEngineer</span>();​</span><br><span class="line"><span class="keyword">const</span> builder = <span class="keyword">new</span> <span class="title class_">ComputerBuilder</span>();​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> computer = engineer.<span class="title function_">constructComputer</span>(builder);​</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>建造者模式的核心思想是将对象的构建过程和表示分离;</li><li>建造者模式的核心组成部分是: 构建对象类, 构建器类, 指挥者类;</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。</p><p>通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。</p><p>敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。&quot;&gt;&lt;a href=&quot;#建造者模式是一种创建型设计</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>工厂模式：灵活创建对象的设计模式</title>
    <link href="https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-03-19T06:12:52.958Z</published>
    <updated>2024-03-24T10:50:30.808Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式是一种创建型设计模式，它通过使用工厂方法或抽象工厂，将对象的实例化过程封装起来，使得客户端与具体的对象创建过程解耦。工厂模式可以根据不同的条件或参数来创建不同的对象，提供了一种灵活的对象创建方式。</p><hr><h3 id="实现工厂模式的方式"><a href="#实现工厂模式的方式" class="headerlink" title="实现工厂模式的方式"></a>实现工厂模式的方式</h3><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="title function_">createShape</span>(<span class="params">type</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(type === <span class="string">&#x27;circle&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type === <span class="string">&#x27;rectangle&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;无效的形状&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;绘制接口必须实现&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同的具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;绘制圆&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;绘制矩形&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> <span class="title class_">ShapeFactory</span>(<span class="string">&#x27;circle&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> <span class="title class_">ShapeFactory</span>(<span class="string">&#x27;rectangle&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="title function_">createShape</span>(<span class="params">type</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;创建形状接口必须实现&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleFactory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="title function_">createShape</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RectangleFactory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="title function_">createShape</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;绘制接口必须实现&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不同的具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;绘制圆&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>  <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;绘制矩形&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> <span class="title class_">CircleFactory</span>();</span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> <span class="title class_">RectFactory</span>();</span><br></pre></td></tr></table></figure><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">H5Factory</span> &#123;</span><br><span class="line">    <span class="title function_">createButton</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">H5Button</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">createIcon</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">H5Icon</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WxFactory</span> &#123;</span><br><span class="line">     <span class="title function_">createButton</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WxButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">createIcon</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WxIcon</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同的具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">H5Button</span> &#123;</span><br><span class="line">    <span class="title function_">description</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是个按钮&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">H5Icon</span> &#123;</span><br><span class="line">    <span class="title function_">description</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是个图标&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WxButton</span> &#123;</span><br><span class="line">    <span class="title function_">description</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是个按钮&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WxIcon</span> &#123;</span><br><span class="line">    <span class="title function_">description</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是个图标&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> h5Factory = <span class="keyword">new</span> <span class="title function_">H5Factory</span>();</span><br><span class="line"><span class="keyword">const</span> wxFactory = <span class="keyword">new</span> <span class="title function_">wxFactory</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> h5Button = <span class="keyword">new</span> h5Factory.<span class="title function_">createButton</span>();</span><br><span class="line"><span class="keyword">const</span> h5Icon = <span class="keyword">new</span> h5Factory.<span class="title function_">createIcon</span>();</span><br></pre></td></tr></table></figure><h3 id="简单工厂、工厂方法、抽象工厂模式的区别"><a href="#简单工厂、工厂方法、抽象工厂模式的区别" class="headerlink" title="简单工厂、工厂方法、抽象工厂模式的区别"></a>简单工厂、工厂方法、抽象工厂模式的区别</h3><ul><li>关注点不同: <ul><li>简单工厂使用一个接口创建所有产品； </li><li>工厂方法将产品实例化放到不同的工厂中，关注产品的从属性；</li><li>抽象工厂关注的是一个工厂包含多个产品对应的接口，关注的是产品族的创建；</li></ul></li><li>组成结构不同：<ul><li>简单工厂主要含有工厂类、具体产品类，工厂类下仅含有一个创建产品的接口；</li><li>工厂方法主要含有抽象工厂类、具体工厂类、具体产品类；</li><li>抽象工厂主要含有工厂类，具体产品A类，具体产品B类，工厂类下含有创建产品族的方法；</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>工厂模式的核心思想是将对象的实例化过程封装起来，通过一个接口进行实例化，使得客户端与具体的对象创建过程解耦。</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。</p><p>通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。</p><p>敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;工厂模式是一种创建型设计模式，它通过使用工厂方法或抽象工厂，将对象的实例化过程封装起来，使得客户端与具体的对象创建过程解耦。工厂模式可以根据不同的条件或参数来创建不同的对象，提供了一种灵活的对象创建方式。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;实现工厂模式的方式&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>单例模式：实现全局唯一实例的设计模式</title>
    <link href="https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-03-19T06:12:52.789Z</published>
    <updated>2024-03-23T09:30:29.280Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式是一种常见的设计模式，它通过限制类的实例化次数，确保只有一个实例存在。</p><h3 id="示例场景-vue3创建渲染器"><a href="#示例场景-vue3创建渲染器" class="headerlink" title="示例场景(vue3创建渲染器)"></a>示例场景(vue3创建渲染器)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> renderer;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ensureRenderer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> renderer || <span class="title function_">createRender</span>(rendererOptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他实现方式"><a href="#其他实现方式" class="headerlink" title="其他实现方式"></a>其他实现方式</h3><p>由于 JavaScript 的事件循环机制和单线程执行，实现单例模式考虑的没那那么复杂，实现起来比较简单。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Singleton</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> instance;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">createInstance</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="string">&#x27;I am the instance&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">getInstance</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!instance) &#123;</span><br><span class="line">                instance = <span class="title function_">createInstance</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> instance = <span class="title class_">Singleton</span>.<span class="title function_">getInstance</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二，直接使用对象字面量</span></span><br><span class="line"><span class="keyword">const</span> messageManager = &#123;</span><br><span class="line">    <span class="title function_">success</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">    <span class="title function_">error</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(messageManager)</span><br></pre></td></tr></table></figure><h3 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h3><ul><li>全局配置：单例模式可以用于管理全局的配置信息，确保在应用中只有一个配置实例被使用。</li><li>日志记录器：单例模式可以用于创建全局唯一的日志记录器，方便在应用中统一管理和记录日志信息</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>单例模式的核心思想是需要确保一个类只有一个实例。</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。</p><p>通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。</p><p>敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;单例模式是一种常见的设计模式，它通过限制类的实例化次数，确保只有一个实例存在。&lt;/p&gt;
&lt;h3 id=&quot;示例场景-vue3创建渲染器&quot;&gt;&lt;a href=&quot;#示例场景-vue3创建渲染器&quot; class=&quot;headerlink&quot; title=&quot;示例场景(vue3创建渲染器)&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>渲染器：数据访问是如何被代理的？</title>
    <link href="https://sanxun8.github.io/2024/03/13/%E6%BA%90%E7%A0%81/vue3/3-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84/"/>
    <id>https://sanxun8.github.io/2024/03/13/%E6%BA%90%E7%A0%81/vue3/3-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84/</id>
    <published>2024-03-13T13:19:55.092Z</published>
    <updated>2024-03-20T00:50:15.318Z</updated>
    
    <content type="html"><![CDATA[<h2 id="渲染器：数据访问是如何被代理的？"><a href="#渲染器：数据访问是如何被代理的？" class="headerlink" title="渲染器：数据访问是如何被代理的？"></a>渲染器：数据访问是如何被代理的？</h2><h3 id="源码定义-对组件实例上下文进行代理"><a href="#源码定义-对组件实例上下文进行代理" class="headerlink" title="源码定义: 对组件实例上下文进行代理"></a>源码定义: 对组件实例上下文进行代理</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setupStatefulComponent</span>(<span class="params">instance, isSSR</span>) &#123;</span><br><span class="line">  instance.<span class="property">accessCache</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">  instance.<span class="property">proxy</span> = <span class="title function_">markRaw</span>(<span class="keyword">new</span> <span class="title class_">Proxy</span>(instance.<span class="property">ctx</span>, <span class="title class_">PublicInstanceProxyHandlers</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PublicInstanceProxyHandlers-get"><a href="#PublicInstanceProxyHandlers-get" class="headerlink" title="PublicInstanceProxyHandlers.get"></a>PublicInstanceProxyHandlers.get</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const PublicInstanceProxyHandlers = &#123;</span><br><span class="line">  get(&#123; _: instance &#125;, key) &#123;</span><br><span class="line">    const &#123; ctx, setupState, data, props, accessCache, type, appContext &#125; = instance</span><br><span class="line">    if (__DEV__ &amp;&amp; key === &#x27;__isVue&#x27;) &#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let normalizedProps;  // 预定义模块所需变量</span><br><span class="line">    if (key[0] !== &#x27;$&#x27;) &#123; // 处理非预留属性</span><br><span class="line">      const n = accessCache[key] // 读取缓存内容</span><br><span class="line">      if (n !== undefined) &#123;</span><br><span class="line">        switch (n) &#123;</span><br><span class="line">          case AccessTypes.SETUP:</span><br><span class="line">            return setupState[key]</span><br><span class="line">          case AccessTypes.DATA:</span><br><span class="line">            return data[key]</span><br><span class="line">          case AccessTypes.CONTEXT:</span><br><span class="line">            return ctx[key]</span><br><span class="line">          case AccessTypes.PROPS:</span><br><span class="line">            return props[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (hasSetupBinding(setupState, key)) &#123;</span><br><span class="line">        accessCache![key] = AccessTypes.SETUP</span><br><span class="line">        return setupState[key]</span><br><span class="line">      &#125; else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123;</span><br><span class="line">        accessCache![key] = AccessTypes.DATA</span><br><span class="line">        return data[key]</span><br><span class="line">      &#125; else if (</span><br><span class="line">        (normalizedProps = instance.propsOptions[0]) &amp;&amp;</span><br><span class="line">        hasOwn(normalizedProps, key)</span><br><span class="line">      ) &#123;</span><br><span class="line">        accessCache![key] = AccessTypes.PROPS</span><br><span class="line">        return props![key]</span><br><span class="line">      &#125; else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123;</span><br><span class="line">        accessCache![key] = AccessTypes.CONTEXT</span><br><span class="line">        return ctx[key]</span><br><span class="line">      &#125; else if (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) &#123;</span><br><span class="line">        accessCache![key] = AccessTypes.OTHER</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const publicGetter = publicPropertiesMap[key] // 开始处理预留属性</span><br><span class="line">    let cssModule, globalProperties</span><br><span class="line">    if (publicGetter) &#123;</span><br><span class="line">      // $保留字开头的相关逻辑</span><br><span class="line">    &#125; else if (</span><br><span class="line">      (cssModule = type.__cssModules) &amp;&amp;</span><br><span class="line">      (cssModule = cssModule[key])</span><br><span class="line">    ) &#123;</span><br><span class="line">      return cssModule</span><br><span class="line">    &#125; else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123;</span><br><span class="line">      accessCache![key] = AccessTypes.CONTEXT</span><br><span class="line">      return ctx[key]</span><br><span class="line">    &#125; else if (</span><br><span class="line">      ((globalProperties = appContext.config.globalProperties),</span><br><span class="line">        hasOwn(globalProperties, key))</span><br><span class="line">    ) &#123;</span><br><span class="line">      if (__COMPAT__) &#123;</span><br><span class="line">        const desc = Object.getOwnPropertyDescriptor(globalProperties, key)!</span><br><span class="line">        if (desc.get) &#123;</span><br><span class="line">          return desc.get.call(instance.proxy)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          const val = globalProperties[key]</span><br><span class="line">          return isFunction(val)</span><br><span class="line">            ? Object.assign(val.bind(instance.proxy), val)</span><br><span class="line">            : val</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return globalProperties[key]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (</span><br><span class="line">      // 一些告警</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h4><ol><li>访问顺序为<code>setupState</code>》<code>data</code>》<code>prop</code>》<code>ctx</code></li><li>使用<code>空间换时间</code>进行了优化，使用<code>accessCache</code>标记<code>key</code>存在于哪个属性上，减少了频繁调用<code>hasOwn</code>耗费性能。</li></ol><h3 id="PublicInstanceProxyHandlers-get-1"><a href="#PublicInstanceProxyHandlers-get-1" class="headerlink" title="PublicInstanceProxyHandlers .get"></a>PublicInstanceProxyHandlers .get</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const PublicInstanceProxyHandlers = &#123;</span><br><span class="line">  set(&#123; _: instance &#125;, key, value) &#123;</span><br><span class="line">    const &#123; data, setupState, ctx &#125; = instance</span><br><span class="line">    if (hasSetupBinding(setupState, key)) &#123;</span><br><span class="line">      setupState[key] = value</span><br><span class="line">      return true</span><br><span class="line">    &#125; else if (</span><br><span class="line">      __DEV__ &amp;&amp;</span><br><span class="line">      setupState.__isScriptSetup &amp;&amp;</span><br><span class="line">      hasOwn(setupState, key)</span><br><span class="line">    ) &#123;</span><br><span class="line">      warn(`Cannot mutate &lt;script setup&gt; binding &quot;$&#123;key&#125;&quot; from Options API.`)</span><br><span class="line">      return false</span><br><span class="line">    &#125; else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123;</span><br><span class="line">      data[key] = value</span><br><span class="line">      return true</span><br><span class="line">    &#125; else if (hasOwn(instance.props, key)) &#123;</span><br><span class="line">      __DEV__ &amp;&amp; warn(`Attempting to mutate prop &quot;$&#123;key&#125;&quot;. Props are readonly.`)</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">    if (key[0] === &#x27;$&#x27; &amp;&amp; key.slice(1) in instance) &#123;</span><br><span class="line">      __DEV__ &amp;&amp;</span><br><span class="line">      warn(</span><br><span class="line">        `Attempting to mutate public property &quot;$&#123;key&#125;&quot;. ` +</span><br><span class="line">        `Properties starting with $ are reserved and readonly.`,</span><br><span class="line">      )</span><br><span class="line">      return false</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (__DEV__ &amp;&amp; key in instance.appContext.config.globalProperties) &#123;</span><br><span class="line">        Object.defineProperty(ctx, key, &#123;</span><br><span class="line">          enumerable: true,</span><br><span class="line">          configurable: true,</span><br><span class="line">          value,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        ctx[key] = value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong> 更改顺序为：<code>setupState</code> 》<code>data</code> 》<code>props</code> 》<code>globalProperties</code></p><h3 id="PublicInstanceProxyHandlers-has"><a href="#PublicInstanceProxyHandlers-has" class="headerlink" title="PublicInstanceProxyHandlers .has"></a>PublicInstanceProxyHandlers .has</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const PublicInstanceProxyHandlers = &#123;</span><br><span class="line">  has(&#123;_: &#123; data, setupState, accessCache, ctx, appContext, propsOptions &#125;&#125;, key) &#123;</span><br><span class="line">    let normalizedProps</span><br><span class="line">    return (</span><br><span class="line">      !!accessCache[key] ||</span><br><span class="line">      (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) ||</span><br><span class="line">      hasSetupBinding(setupState, key) ||</span><br><span class="line">      ((normalizedProps = propsOptions[0]) &amp;&amp; hasOwn(normalizedProps, key)) ||</span><br><span class="line">      hasOwn(ctx, key) ||</span><br><span class="line">      hasOwn(publicPropertiesMap, key) || // $保留字开头的函数</span><br><span class="line">      hasOwn(appContext.config.globalProperties, key)</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong> 访问顺序为<code>data </code>》<code>setupState</code>》<code>props</code>》<code>ctx</code>》<code>publicPropertiesMap</code>》<code>globalProperties</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;渲染器：数据访问是如何被代理的？&quot;&gt;&lt;a href=&quot;#渲染器：数据访问是如何被代理的？&quot; class=&quot;headerlink&quot; title=&quot;渲染器：数据访问是如何被代理的？&quot;&gt;&lt;/a&gt;渲染器：数据访问是如何被代理的？&lt;/h2&gt;&lt;h3 id=&quot;源码定义-对组件实</summary>
      
    
    
    
    
  </entry>
  
</feed>
