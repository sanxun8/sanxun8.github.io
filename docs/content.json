{"meta":{"title":"屯货三旬的个人网站","subtitle":"","description":"屯货三旬的个人网站","author":"屯货三旬","url":"https://sanxun8.github.io","root":"/"},"pages":[{"title":"About-Me","date":"2022-01-14T06:37:51.000Z","updated":"2023-08-12T07:53:20.004Z","comments":true,"path":"about-me/index.html","permalink":"https://sanxun8.github.io/about-me/index.html","excerpt":"","text":""},{"title":"Archives","date":"2022-01-14T06:32:41.000Z","updated":"2023-08-12T18:55:33.125Z","comments":true,"path":"archives/index.html","permalink":"https://sanxun8.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-01-14T06:19:06.000Z","updated":"2023-08-12T19:16:48.550Z","comments":true,"path":"categories/index.html","permalink":"https://sanxun8.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-08-12T18:52:22.000Z","updated":"2023-08-13T07:59:02.232Z","comments":true,"path":"link/index.html","permalink":"https://sanxun8.github.io/link/index.html","excerpt":"","text":""},{"title":"List","date":"2023-08-12T18:51:35.000Z","updated":"2023-08-12T18:51:52.186Z","comments":true,"path":"list/index.html","permalink":"https://sanxun8.github.io/list/index.html","excerpt":"","text":""},{"title":"Messageboard","date":"2023-08-14T14:28:47.000Z","updated":"2023-08-14T14:47:44.281Z","comments":true,"path":"messageboard/index.html","permalink":"https://sanxun8.github.io/messageboard/index.html","excerpt":"","text":""},{"title":"视频","date":"2023-08-13T05:31:06.000Z","updated":"2023-08-13T05:31:39.757Z","comments":true,"path":"movies/index.html","permalink":"https://sanxun8.github.io/movies/index.html","excerpt":"","text":""},{"title":"音乐","date":"2023-08-13T05:26:07.000Z","updated":"2023-08-13T05:31:13.426Z","comments":true,"path":"music/index.html","permalink":"https://sanxun8.github.io/music/index.html","excerpt":"","text":""},{"title":"图库","date":"2023-08-13T07:22:42.000Z","updated":"2023-08-14T05:18:21.142Z","comments":true,"path":"photo/index.html","permalink":"https://sanxun8.github.io/photo/index.html","excerpt":"","text":"壁紙 收藏的一些壁紙 漫威 關於漫威的圖片"},{"title":"","date":"2023-08-13T17:36:04.285Z","updated":"2023-08-13T17:34:13.767Z","comments":true,"path":"pwa/manifest.json","permalink":"https://sanxun8.github.io/pwa/manifest.json","excerpt":"","text":"{\"name\":\"string\",\"short_name\":\"Junzhou\",\"theme_color\":\"#49b1f5\",\"background_color\":\"#49b1f5\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"images/pwaicons/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"标签","date":"2022-01-14T06:36:42.000Z","updated":"2023-08-12T19:14:30.951Z","comments":true,"path":"tags/index.html","permalink":"https://sanxun8.github.io/tags/index.html","excerpt":"","text":""},{"title":"漫威","date":"2023-08-13T05:26:07.000Z","updated":"2023-08-13T17:16:21.822Z","comments":true,"path":"photo/marwel/index.html","permalink":"https://sanxun8.github.io/photo/marwel/index.html","excerpt":"","text":"[{\"url\":\"/photo/marwel/img/1.png\",\"alt\":\"\"},{\"url\":\"/photo/marwel/img/1.webp\",\"alt\":\"\"},{\"url\":\"/photo/marwel/img/2.webp\",\"alt\":\"\"},{\"url\":\"/photo/marwel/img/3.webp\",\"alt\":\"\"}]"},{"title":"壁纸","date":"2023-08-13T07:28:24.000Z","updated":"2023-08-13T17:15:49.918Z","comments":true,"path":"photo/wallpaper/index.html","permalink":"https://sanxun8.github.io/photo/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"渲染器：组件是如何被渲染成DOM的？","slug":"源码/vue3/runtime/mountComponent","date":"2024-04-05T13:37:05.935Z","updated":"2024-04-06T11:19:47.172Z","comments":true,"path":"2024/04/05/源码/vue3/runtime/mountComponent/","link":"","permalink":"https://sanxun8.github.io/2024/04/05/%E6%BA%90%E7%A0%81/vue3/runtime/mountComponent/","excerpt":"","text":"我们知道，Vue3是通过createApp创建一个项目实例的，本章将已createApp为起点，解析组件的渲染过程。 createAppexport const createApp = (...args) =&gt; &#123; const app = ensureRenderer().createApp(...args); const &#123; mount &#125; = app; app.mount = (containerSelector) =&gt; &#123; const container = normalizeContainer(containerSelector); if (!container) return; const component = app._component; if (!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) &#123; component.template = container.innnerHTML; &#125; container.innnerHTML = &#x27;&#x27;; const proxy = mount(container, false, resolveRootNamespace(container)); if (container instanceof Element) &#123; container.removeAttribute(&#x27;v-cloak&#x27;); container.setAttribute(&#x27;data-v-app&#x27;, &#x27;&#x27;); &#125; return proxy; &#125; return app;&#125; 可以发现该函数主要逻辑是执行ensureRenderer以及ensureRenderer返回的createApp函数。 然后对app.mount添加而外操作，包括对container进行参数归一化，初始化component.template、container.innnerHTML。我们看一下normalizeContainer的实现 function normalizeContainer(container) &#123; if (isString(container)) &#123; const res = document.querySelector(container); return res; &#125; return container;&#125;。 最后就是构建mount所需参数并调用，我们看一下resolveRootNamespace实现 function resolveRootNamespace(container) &#123; if (container instanceof SVGElement) &#123; return &quot;svg&quot;; &#125; if ( typeof MathMLElement === &quot;function&quot; &amp;&amp; container instanceof MathMLElement ) &#123; return &quot;mathml&quot;; &#125;&#125; 默认情况下我们传入的container是个div元素，所以运行该函数返回值为undifined ensureRenderer回过头来，我们看一下ensureRenderer的实现 let renderer;function ensureRenderer() &#123; return renderer || (renderer = createRender(renderOptions));&#125;export function createRenderer(options) &#123; return baseCreateRenderer(options);&#125; function baseCreateRenderer(options, createHydrationFns) &#123; // ... const processComponent = ( n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized ) =&gt; &#123; // ... &#125; const processElement = ( n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, sptimized ) =&gt; &#123; // ... &#125; const render = (vnode, container, namespace) =&gt; &#123; // ... &#125; return &#123; render, hydrate, createApp: createAppAPI(render, hydrate), &#125;&#125; 该函数返回一个renderer, 默认情况下renderer是未定义的，执行createRender实际是执行baseCreateRenderer。我们这里现有一个概念，Dom的渲染都是由baseCreateRenderer方法内部进行定义，如processComponent组件流程管理, processElement元素流程管理, render虚拟节点渲染等等。 createAppAPI当我们执行ensureRenderer().createApp(…args)实际是执行createAppAPI的返回函数，我们看一下createAppAPI实现 let uid = 0export function createAppAPI(render, hydrate) &#123; return function createApp(rootComponent, rootProps = null) &#123; if (!isFunction(rootComponent)) &#123; rootComponent = extent(&#123;&#125;, rootComponent); &#125; if (rootProps != null &amp;&amp; !isObject(rootProps)) &#123; rootProps = null; &#125; const context = createAppContext(); const installedPlugins = new WeakSet(); let isMounted = false; const app = context.app = &#123; _uid: uid ++, _component: rootComponent, _props: rootProps, _container: null, _context: context, _instance: null, version, get config() &#123; return context.config; &#125;, set config(v) &#123; // 报警 &#125;, use(plugin, ...options) &#123; if (installedPlugins.has(plugin)) &#123; // 报警 &#125; else if (plugin &amp;&amp; isFunction(plugin.install)) &#123; installedPlugins.add(plugin); plugin.install(app, ...options); &#125; else if (isFunction(plugin)) &#123; installedPlugins.add(plugin); plugin(app, ...options); &#125; return app; &#125;, mixin(mixin) &#123; // 兼容vue2 &#125;, component(name, component) &#123; if (!component) &#123; return context.components[name]; &#125; context.components[name] = component; return app; &#125;, directive(name, directive) &#123; if (!directive) &#123; return context.directive[name]; &#125; context.directive[name] = directive; return app; &#125;, mount(rootContainer, isHydrate, namespace) &#123; if (!isMounted) &#123; const vnode = createVNode(rootComponent, rootProps); vnode.appContext = context; if (namespace === true) &#123; namespace = &#x27;svg&#x27;; &#125; else if (namespace === false) &#123; namespace = undefined; &#125; if (isHydrate &amp;&amp; hydrate) &#123; hydrate(vnode, rootContainer); &#125; else &#123; render(vnode, rootContainer, namespace); &#125; isMounted = true; app._container = rootContainer; rootContainer.__vue_app = app; return getExposeProxy(vnode.component) || vnode.component.proxy; &#125; &#125; &#125; &#125;;&#125; 可以发现上述代码主要逻辑就是对参数进行一些处理，然后对app实例属性和方法进行初始化设置，我们看一下createAppContext实现 createAppContextexport function createAppContext() &#123; return &#123; app: null, config: &#123; isNativeTag: NO, performance: false, globalProperties: &#123;&#125;, optionsMergeStrategies: &#123;&#125;, errorHandler: undefined, warnHandler: undefined, compilerOptions: &#123;&#125;, &#125;, mixins: [], components: &#123;&#125;, directive: &#123;&#125;, provides: Object.create(null), optionsCache: new WeakMap(), propsCache: new WeakMap(), emitsCache: new WeakMap(), &#125;;&#125; 这里只需要对appContext对象有一个初步印象。 然后我们着重看一下app.mount，当我们调用该方法后，我们会调用createVNode创建虚拟节点对象，其内部实际是调用createBaseVNode进行创建的，我们简单看一下虚拟节点对象的属性 createBaseVNodefunction createBaseVNode( type, props, children, patchFlag, dynamicProps, shapeFlag = type === Fragment ? 0 : ShapeFlags.ELEMENT, isBlockNode = false, needFuluuChildrenNormalization = false) &#123; const vnode = &#123; __v_isVNode: true, __v_skip: true, type, props, key: props &amp;&amp; normalizeKey(props), ref: props &amp;&amp; normalizeRef(props), scopeId: currentScopeId, children, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetAnchor: null, staticCount: 0, shapeFlag, patchFlag, dynamicProps, dynamicChildren: null, appContext: null, ctx: currentRenderingInstance &#125; // ... return vnode;&#125; 得到虚拟节点对象后，给该对象绑定appContext属性存储app实例上下文信息, 此时我们传输的isHydrate &#x3D; false, namespace &#x3D; undefined， 会执行render方法，我们看一下其实现 function baseCreateRenderer(options, createHydrationFns) &#123; const render = (vnode, container, namespace) =&gt; &#123; if (vnode === null) &#123; if (container._vnode) &#123; unmount(container._vnode, null, null, true); &#125; &#125; else &#123; patch( container._vnode || null, vnode, container, null, null, null, namespace ); &#125; container._vnode = vnode; &#125;&#125; 此时我们的vnode有值，执行patch patchfunction baseCreateRenderer(options, createHydrationFns) &#123; const patch = ( n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = undefined, slotScopeIds = null, optimized = !!n2.dynamicChildren ) =&gt; &#123; if (n1 === n2) &#123; return; &#125; if (n1 &amp;&amp; !isSameVNodeType(n1, n2)) &#123; anchor = getNextHostNode(n1); unmount(n1, parentComponent, parentSuspense, true); n1 = null; &#125; if (n2.patchFlag === PatchFlags.BAIL) &#123; optimized = false; n2.dynamicChildren = null; &#125; const &#123; type, ref, shapeFlag &#125; = n2; switch (type) &#123; case Text: processText(n1, n2, container, anchor); break; case Comment: processCommentNode(n1, n2, container, anchor); break; case Static: if (n1 == null) &#123; mountStaticNode(n2, container, anchor, namespace); &#125; break; case Fragment: processFragment( n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized ); break; default: if (shapeFlag &amp; ShapeELEMENT) &#123; processElement( n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized ); &#125; else if (shapeFlag &amp; shapeFlag.COMPONENT) &#123; processComponent( n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized ); &#125; else if (shapeFlag &amp; ShapeFlags.TELEPORT) &#123; type.process( n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals ); &#125; &#125; &#125;;&#125; 可以发现patch函数实际就是一个中转站，根据不同的type和shapeFlag执行不同的流程，此时我们执行的是processComponent流程 processComponentfunction baseCreateRenderer(options, createHydrationFns) &#123; const processComponent = ( n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized ) =&gt; &#123; n2.slotScopeIds = slotScopeIds; if (n1 == null) &#123; if (n2.shapeFlag &amp; ShapeFlags.COMPONENT_KEPT_ALIVE) &#123; parentComponent.ctx.active( n2, container, anchor, namespace, optimized1 ); &#125; else &#123; mountComponent( n2, container, anchor, parentComponent, parentSuspense, namespace, optimized ); &#125; &#125; else &#123; updateComponent(n1, n2, optimized); &#125; &#125;;&#125; 可以发现processComponent也是一个流程的控制，此时n1 &#x3D; null的，执行mountComponent mountComponentfunction baseCreateRenderer(options, createHydrationFns) &#123; const mountComponent = ( initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized ) =&gt; &#123; const instance = initialVNode.component = createComponentInstance( initialVNode, parentComponent, parentSuspense ); if (isKeepAlive(initialVNode)) &#123; // 为 keepAlive 注入渲染器内部结构 instance.ctx.renderer = internals &#125; setupComponent(instance); setupRenderEffect( instance, initialVNode, container, anchor, parentSuspense, namespace, optimized, ); &#125;;&#125; 可以发现组件挂载的核心就在与执行createComponentInstance、setupComponent、setupRenderEffect这三个函数。我们先来看一下createComponentInstance createAppContextlet uid = 0;const emptyAppContext = createAppContext()export function createComponentInstance( vnode, parent, suspense) &#123; const type = vnode.type; const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext; const instance = &#123; uid: uid++, vnode, parent, appContext, root: null, next: null, subTree: null, effect: null, update: null, scope: new EffectScope(true), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: parent ? parent.provides : Object.create(appContext.provides), accessCache: null, renderCache: [], components: null, directives: null, propsOptions: normalizePropsOptions(type, appContext), emitsOptions: normalizeEmitsOptions(type, appContext), emit: null, emitted: null, propsDefault: EMPTY_OBJ, inheritAttrs: type.inheritAttrs, ctx: EMPTY_OBJ, data: EMPTY_OBJ, props: EMPTY_OBJ, attrs: EMPTY_OBJ, slots: EMPTY_OBJ, refs: EMPTY_OBJ, setupState: EMPTY_OBJ, setupContext: null, attrsProxy: null, slotsProxy: null, suspense, suspenseId: suspense ? suspense.pedingId : 0, asyncDep: null, asyncResolved: false, // 生命周期钩子 isMounted: false, isUnmounted: false, isDeactivated: false, bc: null, // 创建前 c: null, // 创建 bm: null, // 挂载前 m: null, // 挂载 bu: null, // 更新前 u: null, // 更新 um: null, // 卸载 bum: null, // 卸载前 da: null, // 若组件实例是 &lt;KeepAlive&gt; 缓存树的一部分，组件从 DOM 中被移除时 a: null, // 若组件实例是 &lt;KeepAlive&gt; 缓存树的一部分，当组件被插入到 DOM 中时调用 rtg: null, // 当响应式依赖的变更触发了组件渲染时调用。 rtc: null, // 当组件渲染过程中追踪到响应式依赖时调用。 ec: null, // 在捕获了后代组件传递的错误时调用。 sp: null, // 在组件实例在服务器上被渲染之前调用。 &#125; // ... return instance&#125; 再看看setupComponent实现 export function setupComponent( instance, isSSR = false) &#123; isSSR &amp;&amp; setInSSRSetupState(isSSR); const &#123; props, children &#125; = instance.vnode; const isStateful = isStatefulComponent(instance); initProps(instance, props, isStateful, isSSR); initSlots(instance, children); const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : undefined; isSSR &amp;&amp; setInSSRSetupState(false); return setupResult;&#125; 可以发现该函数组要进行组件的初始化工作。 再看一下setupRenderEffect的实现 function baseCreateRenderer(options, createHydrationFns) &#123; const setupRenderEffect = ( instance, initialVNode, container, anchor, parentSuspense, namspace, optimized ) =&gt; &#123; const componentUpdateFn = () =&gt; &#123; // ... &#125;; const effect = (instance.effect = new ReactiveEffect( componentUpdateFn, NOOP, () =&gt; queueJob(update), instance.scope )); const update = (instance.update = () =&gt; &#123; if (effect.dirty) &#123; effect.run(); &#125; &#125;); update.id = instance.uid; toggleRecurse(instance, true); update(); &#125;;&#125;","categories":[],"tags":[]},{"title":"响应式原理：nextTick函数解析","slug":"源码/vue3/reactivity/nextTick","date":"2024-04-05T13:22:29.226Z","updated":"2024-04-05T13:33:11.304Z","comments":true,"path":"2024/04/05/源码/vue3/reactivity/nextTick/","link":"","permalink":"https://sanxun8.github.io/2024/04/05/%E6%BA%90%E7%A0%81/vue3/reactivity/nextTick/","excerpt":"","text":"const resolvePromise = Promise.resolve();export function nextTick(fn) &#123; const p = currentPromise || resolvePromise; return fn ? p.then(this ? fn.bind(this) : fn) : p;&#125; 可以发现，当currentPromise不存在时，默认将fn放到微任务队列里面。","categories":[],"tags":[]},{"title":"响应式原理：依赖注入实现跨级组件数据共享","slug":"源码/vue3/reactivity/apiInject","date":"2024-04-05T12:02:23.832Z","updated":"2024-04-05T13:10:07.500Z","comments":true,"path":"2024/04/05/源码/vue3/reactivity/apiInject/","link":"","permalink":"https://sanxun8.github.io/2024/04/05/%E6%BA%90%E7%A0%81/vue3/reactivity/apiInject/","excerpt":"","text":"provide源码定义 export function provide(key, value) &#123; let provides = currentInstance.provides; const parentProvides = currentInstance.parent &amp;&amp; currentInstance.parent.provides; if (parentProvide === provides) &#123; provides = currentInstance.provides = Object.create(parentProvides); &#125; provides[key] = value;&#125; 可以发现instance对象下含有provides属性，用于存储我们提供的数据，那么provides的初始化是怎么样的呢 export function createComponentInstance(vnode, parent, suspense) &#123; // ... const instance = &#123; // ... parent, providees: parent ? parent.provides : Object.create(appContext.provides) // ... &#125; // ...&#125; 可以发现provides利用原型链方式进行存储数据，默认情况下，实例继承其父级的提供对象，但是当它需要提供自己的值时，它会创建自己的值，自己提供的对象使用父级提供的对象作为原型。 inject源码定义 export function inject(key, defaultValue, treatDefaultAsFactory = false) &#123; const instance = currentInstance || currentRenderingInstance; if (instance || currentApp) &#123; const provides = instance ? instance.parent == null ? instance.vnode.appContext &amp;&amp; instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides; if (provides &amp;&amp; key in provides) &#123; return provides[key]; &#125; else if (arguments.length &gt; 1) &#123; return treatDefaultAsFactory &amp;&amp; isFunction(defaultValue) ? defaultValue.call(instance &amp;&amp; instance.proxy) : defaultValue; &#125; &#125;&#125; 上述代码主要逻辑就是需要provides对象，判断key是否是provides对象的枚举属性，若不是则使用提供的默认值。","categories":[],"tags":[]},{"title":"响应式原理：Watch函数的实现","slug":"源码/vue3/reactivity/watch","date":"2024-04-03T14:11:14.651Z","updated":"2024-04-05T13:41:38.014Z","comments":true,"path":"2024/04/03/源码/vue3/reactivity/watch/","link":"","permalink":"https://sanxun8.github.io/2024/04/03/%E6%BA%90%E7%A0%81/vue3/reactivity/watch/","excerpt":"","text":"参数归一化我们知道watch的source参数接受类型有ref, computed, reactive, gertter或者组合成数组类型 export function watch(source, cb, options) &#123; return dowatch(source, cb, options);&#125;export function doWatch(source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ) &#123; const warnInvalidSource = (s) =&gt; &#123; // 一些警告 &#125; const instance = currentInstance; const reactiveGetter = source =&gt; deep === true ? source : traverse(source, deep === false ? 1 : undefined); let getter; let forceTrigger = false; let isMultiSource = false; // 参数归一化 if (isRef(source)) &#123; getter = () =&gt; source.value; forceTrigger = isShallow(source); &#125; else if (isReactive(source)) &#123; getter = () =&gt; reactiveGetter(source); forceTrigger = true; &#125; else if (isArray(source)) &#123; isMultiSource = true; forceTrigger = source.some(s =&gt; isReactive(s) || isShallow(s)); getter = () =&gt; source.map(s =&gt; &#123; if (isRef(s)) &#123; return s.value; &#125; else if (isReactive(s)) &#123; return reactiveGetter(s); &#125; else if (isFunction(s)) &#123; return callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER); &#125; else &#123; warnInvalidSource(s); &#125; &#125;); &#125; else if (isFunction(source)) &#123; if (cb) &#123; getter = () =&gt; callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER); &#125; else &#123; getter = () =&gt; &#123; if (cleanup) &#123; cleanup(); &#125; return callWithAsyncErrorHandling( source, instance, ErrorCodes.WATCH_GETTER, [onCleanup] ); &#125; &#125; &#125; else &#123; getter = Noop; warnInvalidSource(s); &#125; // ...&#125; 可以发现watch实际通过doWatch实现的，doWatch第一步就是watch的参数source进行归一化处理。以达到我们访问getter会触发响应式数据的依赖收集的目的。 深层响应式处理export function doWatch(source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ) &#123; // ... if (cb &amp;&amp; deep) &#123; const baseGetter = getter; getter = () =&gt; traverse(baseGetter()); &#125; // ...&#125;export function traverse(value, depth, currentDepth = 0, seen) &#123; if (!isObject(value) || value[ReactiveFlags.SKIP]) &#123; // 跳出递归方式 return value; &#125; if (depth &amp;&amp; depth &gt; 0) &#123; if (currentDepth &gt;= depth) &#123; return value; &#125; currentDepth++; &#125; seen = seen || new Set(); if (seen.has(value)) &#123; // 重复值则跳出 return value; &#125; seen.add(value); // 对各种类型进行属性访问，达到依赖收集效果 if (isRef(value)) &#123; traverse(value.value, depth, currentDepth, seen); &#125; else if (isArray(value)) &#123; for (let i = 0; i &lt; value.length; i++) &#123; traverse(value[i], depth, currentDepth, seen); &#125; &#125; else if (isSet(value) || isMap(value)) &#123; value.forEach(v =&gt; &#123; traverse(v, depth, currentDepth, seen); &#125;) &#125; else if (isPlainObject(value)) &#123; for (const key in value) &#123; traverse(value[key], depth, currentDepth, seen); &#125; &#125; return value;&#125; 可以发现深层响应式处理核心在traverse函数，该函数为递归函数，当value不为对象时，直接返回value。 提供了depth对监听层级进行管理，不传则为深层监听。提供seen处理重复值跳出。最后时对不同类型对象属性进行访问，达到依赖收集的效果。 提供清理钩子export function doWatch(source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ) &#123; // ... // 提供清理钩子 let cleanup; let onCleanup = fn =&gt; &#123; cleanup = effect.onStop = () =&gt; &#123; callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP); cleanup = effect.onStop = undefined; &#125; &#125; let ssrCleanup; if (__SSR__ &amp;&amp; isInSSRComponentSetup) &#123; onCleanup = Noop; if (!cb) &#123; getter(); &#125; else if (immediate) &#123; callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [ getter(), isMultiSource ? [] : undefined, onCleanup ]); &#125; if (flush === &#x27;sync&#x27;) &#123; const ctx = useSSRContext(); ssrCleanup = ctx.__watchHandles || (ctx.__watchHandles = []); &#125; else &#123; return NOOP; &#125; &#125; // ...&#125; onCleanup将会成为cb的第三个实参，我们可以根据业务需要执行onCleanup。 定义工作函数export function doWatch(source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ) &#123; // ... let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE; const job = () =&gt; &#123; // 定义工作函数 if (!effect.active || !effect.dirty) &#123; // 不在响应式上下文或无脏值 return; &#125; if (cb) &#123; const newValue = effect.run(); if ( deep || forceTrigger || (isMultiSource ? newValue.some((v, i) =&gt; hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue) ) ) &#123; if (cleanup) &#123; cleanup(); &#125; callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [ newValue, oldValue === INITIAL_WATCHER_VALUE ? undefined : isMultiSource &amp;&amp; oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue, onCleanup ]); &#125; &#125; else &#123; effect.run(); &#125; &#125; job.allowRecurse = !!cb; // ...&#125; 可以发现job函数主要逻辑是先判断watch函数执行上下文，以及是否有脏值，然后执行effect.run，即执行归一化化后的getter函数达到依赖收集效果。若接受了cb函数，根据是否存在脏值执行cb,b并更新oldValue值。 定义调度器export function doWatch(source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ) &#123; // ... let scheduler; // 定义调度器 if (flush === &#x27;sync&#x27;) &#123; scheduler = job; &#125; else if (flush === &#x27;post&#x27;) &#123; scheduler = () =&gt; queuePostRenderEffect(job, instance &amp;&amp; instance.suspense); &#125; else &#123; job.pre = true; if (instance) job.id = instance.id; scheduler = () =&gt; queueJob(job); &#125; // ...&#125; 构建ReactiveEffectexport function doWatch(source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ) &#123; // ... const effect = new ReactiveEffect(getter, NOOP, scheduler); // ...&#125; 可以发现前面定义的getter, job其实都是服务于构建ReactiveEffect实例的。 定义监听卸载export function doWatch(source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ) &#123; // ... const scope = getCurrentScope(); const unwatch = () =&gt; &#123; effect.stop(); // 清楚依赖 if (scope) &#123; remove(scope.effects, effect); &#125; &#125; // ...&#125; 首次执行export function doWatch(source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ) &#123; // ...if (cb) &#123; if (immediate) &#123; job(); &#125; else &#123; oldValue = effect.run(); &#125; &#125; else if (flush === &#x27;post&#x27;) &#123; queuePostRenderEffect( effect.run.bind(effect), instance &amp;&amp; instance.suspense ); &#125; else &#123; effect.run(); &#125; if (__SSR__ &amp;&amp; ssrCleanup) ssrCleanup.push(unwatch); return unwatch;&#125; 到这里doWatch流程就已经走完，我们对知识做个扩展，了解一下watchEffect是如何实现的 watchEffectexport function watchEffect(effect, options) &#123; return doWatch(effect, null, options);&#125; 可以发现，watchEffect实际上也是doWatch一种使用形式，传入source的值为函数，不传cb函数","categories":[],"tags":[]},{"title":"响应式原理：Reactive对象解析","slug":"源码/vue3/reactivity/reactive","date":"2024-04-03T09:43:47.885Z","updated":"2024-04-04T09:04:05.427Z","comments":true,"path":"2024/04/03/源码/vue3/reactivity/reactive/","link":"","permalink":"https://sanxun8.github.io/2024/04/03/%E6%BA%90%E7%A0%81/vue3/reactivity/reactive/","excerpt":"","text":"reactive源码中关于Reactive部分的定义： export function reactive(target) &#123; if(isReadonly(target)) &#123; return target; &#125; return createReactiveObject( target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap );&#125; 这个函数核心也就是通过createReactiveObject把我们传入的target变成响应式的 function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) &#123; if(!isObject(target)) &#123; return target; &#125; if(target[ReactiveFlags.RAW] &amp;&amp; !(isReadonly &amp;&amp; target[ReactiveFlags.IS_REACTIVE])) &#123; return target; &#125; const existingProxy = proxyMap.get(target); if(existingProxy) &#123; return existingProxy; &#125; const targetType = getTargetType(target); if(targetType === TargetType.INVALID) &#123; return target; &#125; const proxy = new Proxy( target, targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers ); proxyMap.set(target, proxy); return proxy;&#125; 上述代码核心流程就是首先经过一系列判断，判断符合要求的target才能被响应式。包括target的类型、是否是响应式、是否已经被定义过了、是否是符合要求的类型。最后执行new Proxy对target进行代理, 其核心是处理器。我们先来看一下是定义了几种处理器，以及如何确认处理器的类型的 function targetType(rawType) &#123; switch (rawType) &#123; case &#x27;Object&#x27;: case &#x27;Array&#x27;: return TargetType.COMMON; case &#x27;Map&#x27;: case &#x27;Set&#x27;: case &#x27;WeakMap&#x27;: case &#x27;WeakSet&#x27;: return TargetType.COLLECTION; default: return TargetType.INVALID; &#125;&#125;function getTargetType(value) &#123; return value[ReactiveFlags.SKIP] || !Object.isExtensible(value) ? TargetType.INVALID : targetType(toRawType(value));&#125;export const toRawType = (value) =&gt; &#123; // toTypeString 转换成字符串的方式，比如 &quot;[object RawType]&quot; return toTypeString(value).slice(8, -1)&#125; 因为target传入进来的是一个Object，所以toRawType得到的值是Object。所以这里的值等于TargetType.Common也就是使用baseHandlers。若传入进来的是Map、Set、WeakMap、WeakSet类型，则使用collectionHandlers，本章不进行展开collectionHandlers的解析。 接下来看一下baseHandlers的实现： export const mutableHandlers = &#123; get, set, deleteProperty, has, ownKeys,&#125; 这里就是Proxy中的定义handler的一些属性 get：属性读取操作的捕捉器。 set：属性设置操作的捕捉器。 deleteProperty： delete操作符的捕捉器。 has：in操作符的捕捉器。 ownKeys：Object.getOwnPropertyNames方法和Object.getOwnPropertySymbols方法的捕捉器。 reactive对象响应式的核心就在set和get中，我们一起来看一下二者的实现 getget的源码实现 class BaseReactiveHandler &#123; constructor(_isReadonly = false, _isShallow = false) &#123; this._isReadonly = isReadonly; this._isShallow = _isShallow; &#125; get(target, key, receiver) &#123; const isReadonly = this._isReadonly; const isShallow = this._isShallow; // 对 ReactiveFlags 的处理部分 if (key === ReactiveFlags.IS_REACTIVE) &#123; return !isReadonly; &#125; else if (key === ReactiveFlags.IS_READONLY) &#123; return isReadonly; &#125; else if (key === ReactiveFlags.IS_SHALLOW) &#123; return isShallow; &#125; else if (key === ReactiveFlags.RAW) &#123; if ( receiver === (isReadonly ? isShallow ? shallowReadonlyMap : readonlyMap : isShallow ? shallowReactiveMap : reactiveMap ).get(target) || Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver) ) &#123; return target; &#125; return; &#125; const targetIsArray = isArray(target); if (!isReadonly) &#123; // 过滤数组变异方法 if (targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) &#123; return Reflect.get(Instrumentations, key, receiver); &#125; if (key === &#x27;hasOwnProperty&#x27;) &#123; return hasOwnProperty; &#125; &#125; const res = Reflect.get(target, key, receiver); // 过滤 Symbol Key 和 一些不收集依赖的键 if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) &#123; return res; &#125; if (!isReadonly) &#123; track(target, TrackOpTypes.Get, key); &#125; if (isShallow) &#123; return res; &#125; if (isRef(res)) &#123; return targetIsArray &amp;&amp; isIntegerKey(key) ? res : res.value; &#125; if (isObject(res)) &#123; return isReadonly ? readonly(res) : reactive(res); &#125; return res; &#125;&#125; get api核心流程就是首先经过一系列判断, 判断符合要求的key才进行依赖收集, 然后根据对不同的类型进行处理返回。不收集依赖的key包括预设属性、symbol类型的自有属性。 当我们的target是数组，且key值存在arrayInstrumentations中时，返回arrayInstrumentations中对应的key值。我们再来看看arrayInstrumentations是个什么： const arrayInstrumentations = createArrayInstrumentations()function createArrayInstrumentations() &#123; const instrumentations = &#123;&#125;; ([&#x27;includes&#x27;, &#x27;indexOf&#x27;, &#x27;lastIndexOf&#x27;]).forEach(key =&gt; &#123; instrumentations[key] = function (this, ...args) &#123; // toRaw 可以把响应式对象转成原始数据 const arr = toRaw(this) for (let i = 0, l = this.length; i &lt; l; i++) &#123; // 对数组的每一项进行依赖收集 track(arr, TrackOpTypes.GET, i + &#x27;&#x27;) &#125; // 先尝试用参数本身，可能是响应式数据 const res = arr[key](...args) if (res === -1 || res === false) &#123; // 如果失败，再尝试把参数转成原始数据 return arr[key](...args.map(toRaw)) &#125; else &#123; return res &#125; &#125; &#125;); [&#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;splice&#x27;].forEach(key =&gt; &#123; instrumentations[key] = function (this, ...args) &#123; pauseTracking() const res = toRaw(this)[key].apply(this, args) resetTracking() return res &#125; &#125;) return instrumentations&#125; arrayInstrumentations会重写两类函数，一类是查询类函数：inclues、indexOf、lastIndeOf，代表对数组的读取操作。在这些函数中会执行track函数，对数组的索引进行依赖收集。 另一类是修改类函数：push、pop、shift、unshift、splice，代表对数组的修改操作，在这些函数中暂停了全局的追踪功能，防止某些情况下导致死循环。 如果你想了解track做了些什么，可以查看我的文章响应式原理：dep（响应式对象的依赖管理器） set上面说完了get的流程，我们了解一下依赖收集后的数据结构存储在了targetMap中，接下来我们接着看set的过程： class MutableReactiveHandler extends BaseReactiveHandler &#123; constructor(isShallow = false) &#123; super(false, isShallow); &#125; set(target, key, value, receiver) &#123; let oldValue = target[key]; // 对深层响应式，处理新旧值 if (!this._isShallow) &#123; const isOldValueReadonly = isReadonly(oldValue); if (!isShallow(value) &amp;&amp; !isReadonly(value)) &#123; oldValue = toRaw(oldValue); value = toRaw(value); &#125; if (!isArray(target) &amp;&amp; isRef(oldValue) &amp;&amp; !isRef(value)) &#123; if (isOldValueReadonly) &#123; return false; &#125; else &#123; oldValue.value = value; return true; &#125; &#125; &#125; // 判断是否为已有属性 const hadKey = isArray(target) &amp;&amp; isIntegerKey(key) ? (Number(key) &lt; target.length) : hasOwn(target, key); const result = Reflect.set(target, key, value, receiver); if (target === toRaw(receiver)) &#123; // 触发响应 if (!hadKey) &#123; trigger(target, TriggerOpTypes.ADD, key, value); &#125; else if (hasChanged(value, oldValue)) &#123; trigger(target, TriggerOpTypes.SET, key, value, oldValue); &#125; &#125; return result; &#125;&#125; 可以看到set接口核心逻辑就是根据是否为渐层响应式来确认原始值和新值，这里默认不是浅层的响应式，所以会先把原始值和新值进行toRaw转换，然后通过Reflect.set设置值，最后通过trigger函数派发通知，并依据key是否存在于target来确认通知类型是add（新增）还是set（修改）。 如果你想了解trigger做了些什么，可以查看我的文章[响应式原理：dep（响应式对象的依赖管理器）]","categories":[],"tags":[]},{"title":"响应式原理：ReactiveEffect响应式副作用探秘","slug":"源码/vue3/reactivity/effect","date":"2024-04-03T03:26:32.142Z","updated":"2024-04-05T09:58:57.362Z","comments":true,"path":"2024/04/03/源码/vue3/reactivity/effect/","link":"","permalink":"https://sanxun8.github.io/2024/04/03/%E6%BA%90%E7%A0%81/vue3/reactivity/effect/","excerpt":"","text":"响应式对象中的执行函数、响应式触发器、调度器都是由reactiveEffect类进行管理的，学习本章，你将会明白effect、computed、doWatch、setupRenderEffect是如何通过reativeEffect控制执行函数、响应式触发器、调度器的执行时机的。 ReactiveEffect源码定义 export class ReactiveEffect &#123; constructor(fn, trigger, scheduler, scope) &#123; this.fn = fn; this.trigger = trigger; this.scheduler = scheduler; this._runnings = 0; // 运行时状态 this._trackId = 0; // 依赖标识 this._depsLength = 0; // 绑定该effect的deps长度 this.deps = []; // 绑定该effect的deps recordEffectScope(this, scope); // 记录副作用范围 &#125; run() &#123; this._dirtyLevel = DirtyLevels.NotDirty; // 设置脏值等级 if (!this.active) &#123; return this.fn(); // 若副作用函数不在响应式上下文中，则执行fn不收集依赖 &#125; let lastShouldTrack = shouldTrack; // 解决effect嵌套 let lastEffect = activeEffect; // 解决effect嵌套 try &#123; shouldTrack = true; activeEffect = this; // 记录活动副作用实例 this._runnings++; preCleanupEffect(this); // 属性初始化 return this.fn(); // 运行回调函数（依赖收集，依赖清理） &#125; finally &#123; postCleanupEffect(this); // 依赖清理 this._runnings--; activeEffect = lastEffect; shouldTrack = lastShouldTrack; &#125; &#125;&#125; run接口的主要逻辑是处理先处理fn不在响应式上下文的情况，然后初始化lastShouldTrack、lastEffect解决effect嵌套问题，其次一些状态的初始化，包括shouldTrack、activeEffect、**_running、deps、_depsLength**。 初始化属性后执行fn触发依赖收集， 最后执行完依赖清理后，重置部分状态，重置状态包括**_running、activeEffect、shouldTrack**。 我们来看一下preCleanupEffect和postCleanupEffect的实现 function preCleanupEffect(effect) &#123; // 属性处理 effect._trackId++; effect._depsLength = 0;&#125;function postCleanupEffect(effect) &#123; // 清楚依赖副作用 if (effect.deps.length &gt; effect._depsLength) &#123; for (let i = effect._depsLength; i &lt; effect.deps.length; i++) &#123; cleanupDepEffect(effect.deps[i], effect); &#125; &#125;&#125; 可以看到preCleanupEffect只是做了一些属性的初始化，postCleanupEffect遍历绑定当前effect的dep，清理dep下的effect。 function cleanupDepEffect(dep, effect) &#123; const trackId = dep.get(effect); // 获取依赖标识 if (trackId !== undefined &amp;&amp; effect._trackId !== trackId) &#123; dep.delete(effect); // 依赖删除 if (dep.size === 0) &#123; dep.cleanup(); // 执行回调 &#125; &#125;&#125; 我们简单梳理一下ReactiveEffect实例接口调用逻辑，当我们调用ReactiveEffect.run会运行fn触发依赖收集，当响应式数据变化后会通知ReactiveEffect.trgger和ReactiveEffect。shcedule执行，具体依赖通知可以查看我的文章: 响应式原理：dep（响应式对象的依赖管理器）。 我们知道当我们对一个响应式数据进行访问时，会触发响应式依赖收集，ReactiveEffect.run就是调用ReactiveEffect.fn达到依赖收集效果，但ReactiveEffect.run首次是在在哪里调用，以及后续响应式更新如何调用ReactiveEffect.run。带着这两个问题，我们来理解一下effect、computed、doWatch、setupRenderEffect对ReactiveEffect的使用情况。 effect有了以上知识，我们了解一下effect函数是如何调用ReactiveEffect.run触发依赖收集，当依赖变化后又做了哪些事情 export function effect(fn, options) &#123; // 如果 fn 已经是一个 effect 函数了，则指向原始函数 if (fn.effect instanceof ReactiveEffect) &#123; fn = fn.effect.fn; &#125; // 初始化响应式副作用实例 const _effect = new ReactiveEffect(fn, NOOP, () =&gt; &#123; if (_effect.dirty) &#123; _effect.run(); &#125; &#125;) // 选项逻辑处理 if (options) &#123; extend(_effect, options); // 合并对象 if (options.scope) recordEffectScope(_effect, options.scope); // 记录副作用范围 &#125; /// 副作用运行 if (!options || !options.lazy) &#123; _effect.run(); &#125; const runner = _effect.run.bind(_effect); runner.effect = _effect; return runner; // 返回运行器&#125; effect首先处理fn为副作用函数时，指向回原函数，然后构建一个ReactiveEffect实例，通过传入一个schedule函数达到从新执行fn效果。然后就是options逻辑的处理。当我们不传options时，默认执行ReactiveEffect.run达到依赖收集效果，函数返回ReactiveEffect.run函数，可以根据业务自由调用。 ComputedRefImpl有些同学可能不了解ComputedRefImpl是个什么，ComputedRefIml实际时computed对象的构造器的，我们接着来了解一个ComputedRefImpl是如何调用ReactiveEffect.run触发依赖收集的。 export function computed(getterOptions, debugOptions, isSSR = false) &#123; let getter; let setter; const onlyGetter = isFunction(getterOptions); if (onlyGetter) &#123; getter = getterOptions; &#125; else &#123; getter = getterOptions.get; setter = getterOptions.set; &#125; const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR); return cRef;&#125;export class ComputedRefImpl &#123; constructor(getter, _setter, isReadonly, isSSR) &#123; // 实例化副作用 this.effect = new ReactiveEffect( () =&gt; getter(this._value), () =&gt; triggerRefValue( this, this.effect._dirtyLevel === DirtyLevels.MaybeDirty_ComputedSideEffect ? DirtyLevels.MaybeDirty_ComputedSideEffect : DirtyLevels.MaybeDirty, ) ); &#125; get value() &#123; const self = toRaw(this); self._value = self.effect.run(); return self._value; &#125;&#125; 可以发现，当我们ComputedRefImpl.value getter访问时，会触发ReactiveEffect.run从而调用computed.value getter触发依赖收集 doWatch如果你还不了解doWatch是个什么，你可以查看一下我的文章：响应式原理：Watch 函数的实现 export function doWatch(source, cb, &#123; immediate, deep, flush, once, onTrack, onTrigger &#125; = EMPTY_OBJ) &#123; // ... const job = () =&gt; &#123; effect.run(); &#125; const effect = new ReactiveEffect(getter, NOOP, scheduler); effect.run()&#125; 这里对doWatch的实现代码进行大量缩减。从上述代码以及前面对ReactiveEffect认识，我们可以发现，doWatch实际上定义了个getter函数对响应式依赖进行收集。这里不对scheduler定义进行展开，你可以简单理解为scheduler实际就是执行job函数，从而达到执行getter效果，而ReactiveEffect.run的首次调用是在doWatch内部执行的。 setupRenderEffectsetupRenderEffect是组件更新的核心 function baseCreateRenderer(options, createHydrationFns) &#123; const setupRenderEffect = ( instance, initialVNode, container, anchor, parentSuspense, namspace, optimized, ) =&gt; &#123; const effect = new ReactiveEffect(componentUpdateFn, NOOP, () =&gt; queueJob(update), instance.scope); const update = () =&gt; &#123; if (effect.dirty) &#123; effect.run(); &#125; &#125; update(); &#125;&#125; 我们知道组件编译后会编译成render函数，这里我们可以理解componentUpdateFn实际就是调用组件render达到响应式数据依赖收集的效果，而传输的scheduler调度器就简单理解成对update函数的调用，而ReactiveEffect.run的首次调用也是在setupRenderEffect调用的。","categories":[],"tags":[]},{"title":"响应式原理：Dep（响应式对象的依赖管理器）","slug":"源码/vue3/reactivity/dep","date":"2024-04-03T01:31:33.380Z","updated":"2024-04-05T08:59:02.758Z","comments":true,"path":"2024/04/03/源码/vue3/reactivity/dep/","link":"","permalink":"https://sanxun8.github.io/2024/04/03/%E6%BA%90%E7%A0%81/vue3/reactivity/dep/","excerpt":"","text":"前言在本章开始之前，需要有一个前置认知：Vue响应式的核心就是响应式对象和函数，对象改变，函数执行。在响应式中，dep起到是一个中间者的角色，看完本章，你将会明白reactive、ref响应式对象是如何通过dep通知函数的执行的。 dep实际上是一个map对象，键是effect对象，值为依赖标识。 export const createDep = (cleanup, computed) =&gt; &#123; const dep = new Map(); dep.cleanup = cleanup; dep.computed = computed;&#125; 不同的响应式对象会创建用于存储dep的不同的数据结构，并使用dep进行通知函数执行，我们先来看一下reactive对象的dep结构创建以及函数调用通知过程。 reactive依赖收集（对象构建）让我看一下reactive创建用于存储dep的不同的数据结构的流程。 let shouldTrack = true;let activeEffect; // ReactiveEffect实例const targetMap = new WeakMap();export function track(target, type, key) &#123; if (shouldTrack &amp;&amp; activeEffect) &#123; let depsMap = targetMap.get(target); // 初始化依赖映射 if (!depsMap) &#123; targetMap.set(target, (depsMap = new Map())); &#125; let dep = depsMap.get(key); // 设置依赖 if (!dep) &#123; depsMap.set(key, (dep = createDep(() =&gt; depsMap.delete(key)))); &#125; // 收集副作用 trackEffect(activeEffect, dep); &#125;&#125;export function trackEffect(effect, dep, debuggerEventExtraInfo) &#123; if (dep.get(effect) !== effect._trackId) &#123; // effect._trackId 在ReactiveEffect.run时设置 dep.set(effect, effect._trackId); // 设置副作用标识 const oldDep = effect.deps[effect._depslength]; if (oldDep !== dep) &#123; if (oldDep) &#123; cleanupDepEffect(oldDep, effect); // 清理dep下的副作用 &#125; effect.deps[effect._depslength++] = dep; // 标识副作用绑定到哪个dep &#125; else &#123; effect._depslength++; // 标识副作用绑定到多少dep下 &#125; &#125;&#125; 上面函数有点绕，其实核心就是在生成一个数据结构，什么样的数据结构呢？我们来画个图看看： 我们创建了全局的targetMap，它的键是target，值是depsMap；这个depsMap的键是target的key，值是dep集合，dep集合中存储的是依赖的副作用函数effect。 响应处理（函数执行）看一下源码定义 export function trigger(target, type, key, newValue, oldValue, oldTarget) &#123; const depsMap = targetMap.get(target); // 处理未收集 if (!depsMap) &#123; return &#125; let deps = []; // 需要被处理依赖 if (type === TriggerOpTypes.CLEAR) &#123; // 操作为清理 deps = [...depsMap.values()]; &#125; else if (key === &#x27;length&#x27; &amp;&amp; isArray(target)) &#123; const newLength = Number(newValue); depsMap.forEach((dep, key) =&gt; &#123; if (key === &#x27;length&#x27; || (!isSymbol(key) &amp;&amp; key &gt;= newLength)) &#123; deps.push(dep); &#125; &#125;); &#125; else &#123; if (key !== void 0) &#123; deps.push(depsMap.get(key)); &#125; switch (type) &#123; case TriggerOpTypes.ADD: if (!isArray(target)) &#123; deps.push(depsMap.get(ITERACE_KEY)); // 暂不理解 if (isMap(target)) &#123; deps.push(depsMap.get(MAP_KEY_ITERATE_KEY)); // 暂不理解 &#125; &#125; else if (isIntegerKey(key)) &#123; deps.push(depsMap.get(&#x27;length&#x27;)); // // 暂不理解 &#125; break; case TriggerOpTypes.DELETE: if ((!isArray(target))) &#123; deps.push(depsMap.get(ITERACE_KEY)); // 暂不理解 if (isMap(target)) &#123; deps.push(depsMap.get(MAP_KEY_ITERATE_KEY)); // 暂不理解 &#125; &#125; break; case TriggerOptypes.SET: if (isMap(target)) &#123; deps.push(depsMap.get(ITERACE_KEY)); // 暂不理解 &#125; &#125; &#125; // 暂停调度 pauseScheduling(); // 遍历依赖，执行副作用 for (const dep of deps) &#123; if (dep) &#123; triggerEffects(dep, DirtyLevels.Dirty) &#125; &#125; // 重置调调 resetScheduling();&#125; 述代码的核心流程就是获取需要响应的依赖，首先处理预留清理响应操作类型，所有依赖都需要被清理，其次修改属性为length且target为数组时，访问length属性的依赖以及数组中超过新数组长度的元素依赖需要被清理。获取需要响应的依赖后，暂停全局调度后，遍历执行triggerEffects，最后重置调度。 我们来看一下triggerEffects的实现 export function triggerEffects(dep, dirtyLevels, debuggerEventExtraInfo) &#123; pasuScheduling(); // 暂停全局调度 // 遍历dep for (const effect of dep.keys()) &#123; let tracking; if ( effect._dirtyLevel &lt; dirtyLevel &amp;&amp; (tracking ??= dep.get(effect) === effect._trackId) ) &#123; effect._shouldSchedule ||= effect._dirtyLevel === dirtyLevels.NotDirty; effect._dirtyLevel = dirtyLevel; &#125; if ( effect._shouldSchedule &amp;&amp; (tracking ??= dep.get(effect === effect._trackId) === effect._trackId) ) &#123; effect.trigger(); // 执行函数 if (!effect._runnings || effect.allRecurse &amp;&amp; effect._dirtyLevel !== dirtyLevels.MaybeDirty_ComputedSideEffect ) &#123; // 副作用不在运行中或者副作用允许递归且_dirtyLevel值不为2 effect._shouldSchedule = false; if (effect.scheduler) &#123; queueEffectSchedulers.push(effect.scheduler); &#125; &#125; &#125; &#125; resetScheduling(); // 执行调度&#125; 上述代码的主要逻辑是，先暂停全局调度，然后遍历副作用对象，更新**_shouldSchedule标识，然后根据_shouldSchedule**判断是否执行调度函数，最后重新执行全局调度。 到这里我们就解析完reactive对象所创建用于存储dep的数据结构，以及dep进行通知函数执行的过程了。 ref依赖收集（对象构建）让我看一下ref创建用于存储dep的不同的数据结构流程。 export function trackRefValue(ref) &#123; if (shouldTrack &amp;&amp; activeEffect) &#123; ref = toRaw(ref); ref.dep ??= createDep(() =&gt; (ref.dep = undefined), ref instanceof ComputedRefImpl ? ref : undefined); trackEffect(activeEffect, ref.dep); &#125;&#125; 可以发现，ref并没有创建额外的变量用于存储dep而是直接绑定到dep属性下面，然后复用trackEffect逻辑进行依赖收集。 响应处理（函数执行）看一下源码定义 export function triggerRefValue(ref, dirtyLevel, newValue) &#123; ref = toRaw(ref); const dep = ref.dep; if (dep) &#123; triggerEffects(dep, dirtyLevel); &#125;&#125; 可以发现，除了用于存储dep的数据结构不同外，traEffect以及triggerEffects都得到了很好的复用。","categories":[],"tags":[]},{"title":"Vue3中computed对象解析","slug":"源码/vue3/reactivity/computed","date":"2024-03-30T02:01:04.141Z","updated":"2024-04-05T13:23:26.337Z","comments":true,"path":"2024/03/30/源码/vue3/reactivity/computed/","link":"","permalink":"https://sanxun8.github.io/2024/03/30/%E6%BA%90%E7%A0%81/vue3/reactivity/computed/","excerpt":"","text":"computed源码中关于computed部分的定义： export function computed(getterOptions, debugOptions, isSSR = false) &#123; let getter; let setter; const onlyGetter = isFunction(getterOptions); if (onlyGetter) &#123; getter = getterOptions; &#125; else &#123; getter = getterOptions.get; setter = getterOptions.set; &#125; const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR); return cRef;&#125; 上述代理核心流程就是先进行参数归一化, 然后生成并返回一个实例化对象。让我们一起看一下啊ComputedRefImpl的实现 export class ComputedRefImpl &#123; constructor(getter, _setter, isReadonly, isSSR) &#123; this.getter = getter; this._setter = _setter; // 实例化副作用 暂不清楚_dirtyLevel属性更新逻辑 this.effect = new ReactiveEffect( () =&gt; getter(this._value), () =&gt; triggerRefValue( this, this.effect._dirtyLevel === DirtyLevels.MaybeDirty_ComputedSideEffect ? DirtyLevels.MaybeDirty_ComputedSideEffect : DirtyLevels.MaybeDirty, ) ); this.effect.computed = this; // 一个标记，会优先于其他普通副作用函数先执行 this.effect.active = this._cacheable = !isSSR; // 暂不知道active用途 this[ReactiveFlags.IS_READONLY] = isReadonly; &#125; get value() &#123; const self = toRaw(this); // 脏值则进行更新 if( (!self._cacheable || self.effect.dirty) &amp;&amp; hasChanged(self._value, (self._value) = self.effect.run()) ) &#123; triggerRefValue(self, DirtyLevels.Dirty); &#125; // 依赖收集 trackRefValue(self); if(self.effect._dirtyLevel &gt;= DirtyLevels.MaybeDirty_ComputedSideEffect) &#123; triggerRefValue(self, DirtyLevels.MaybeDirty_ComputedSideEffect); &#125; return self._value; &#125; // 执行setter set value(newValue) &#123; this._setter(newValue); &#125;&#125; 简单看一下该类的实现，在构造函数的时候，创建一个副作用对像effect。并为effect额外定义了一个computed属性执行当前响应式对象cRef对象。 另外，定义了一个ComputedRefImpl.value getter方法，当我们通过cRef.value取值的时候，会判断是否有脏值，脏值处理核心就是调用trggerRefValue，如果你想了解trackRefValue、**trggerRefValue做了些什么，可以查看我的文章[响应式原理：dep（响应式对象的依赖管理器）] 其还定义了一个ComputedRefImpl.value setter方法，该方法就是执行过程传入进来得computed.value setter函数。 有了上面得介绍，我们来看一个具体的例子，看看computed是如何执行的： &lt;script src=&quot;../../dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;demo&quot;&gt; &lt;div&gt; &#123;&#123; sum.value &#125;&#125; &lt;/div&gt; &lt;button @click=&quot;add&quot;&gt;add&lt;/button&gt;&lt;/div&gt;&lt;script&gt; Vue.createApp(&#123; setup() &#123; const a = Vue.ref(1); const sum = Vue.computed(getter); function getter() &#123; return a.value + 1 &#125; function add() &#123; a.value = 2; &#125; return &#123; sum &#125; &#125;, &#125;).mount(&#x27;#demo&#x27;)&lt;/script&gt; computed函数执行，初始化过程中，生成了一个computed effect. 上述的template会被编译为render函数，render执行，访问了sum.value，触发了收集，此时收集的副作用为render effect, 会执行ComputedRefImpl.value getter，此时的self._dirty &#x3D; true执行effect.run()也就是执行了computed.value getter函数，得到**_value &#x3D; 1** computed.value getter函数体内访问了a.value触发了对a的依赖收集，此时收集到的依赖为computed effect。 按钮点击后，执行add更新了a.value值触发了computed effect的trigger，也就是执行render。 执行render会访问ComputedRefImpl.value getter, 会执行computed effect.run()触发computed.value getter函数的执行。因为此时的**_dirty &#x3D; true**, 所以get value会重新计算**_value的值为sum.value &#x3D; 3**。 sum.value的值变化后，触发了triggerRefvalue, 即render会重新执行。","categories":[],"tags":[]},{"title":"响应式原理：Ref对象解析","slug":"源码/vue3/reactivity/ref","date":"2024-03-22T12:33:24.547Z","updated":"2024-04-05T08:56:11.409Z","comments":true,"path":"2024/03/22/源码/vue3/reactivity/ref/","link":"","permalink":"https://sanxun8.github.io/2024/03/22/%E6%BA%90%E7%A0%81/vue3/reactivity/ref/","excerpt":"","text":"Ref源码中关于ref部分的定义： export function ref(value) &#123; return createRef(value, false);&#125; 这个函数的核心也就是通过createRef把我们传入的value变成响应式的 function createRef(rawValue, shallow) &#123; if (isRef(rawValue)) &#123; return rawValue; &#125; return new RefImpl(rawValue, shallow);&#125; 先经过判断，判断符合要求的value才能被响应式。一起来看看这个API的实现： class RefImpl &#123; constructor(value, __v_isShallow) &#123; this.__v_isShallow = __v_isShallow; this._rawValue = __v_isShallow ? value : toRaw(value); this._value = __v_isShallow ? value : toReactive(value); &#125; get value() &#123; trackRefValue(this); // 收集依赖 return this._value; &#125; set value(newVal) &#123; const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal); newVal = useDirectValue ? newVal : toRaw(newVal); if (hasChanged(newVal, this._rawValue)) &#123; this._rawValue = newVal; this._value = useDirectValue ? newVal : toReactive(newVal); triggerRefValue(this, DirtyLevels.Dirty, newVal); // 触发响应 &#125; &#125;&#125; 可以发现，RefImpl定义了value gettter用于依赖的收集，定义了value setter用于触发响应。如果你想了解trackRefValue、triggerRefValue做了些什么，可以查看我的文章响应式原理：dep（响应式对象的依赖管理器）","categories":[],"tags":[]},{"title":"Vue3中中获取最长递增子序列","slug":"源码/vue3/runtime/最长递增子序列","date":"2024-03-22T11:17:15.570Z","updated":"2024-03-29T15:16:48.013Z","comments":true,"path":"2024/03/22/源码/vue3/runtime/最长递增子序列/","link":"","permalink":"https://sanxun8.github.io/2024/03/22/%E6%BA%90%E7%A0%81/vue3/runtime/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"function getSequence(arr) &#123; const p = arr.slice(); // 反向链表 可以使用 p = []初始化 const result = [0] // 结果值到原数组索引的映射 let i, j, u, v, c; const len = arr.length; for (i = 0; i &lt; len; i++) &#123; const arrI = arr[i]; if (arrI !== 0) &#123; j = result[result.length - 1] if (arr[j] &lt; arrI) &#123; // 与最后一项对比 p[i] = j; result.push(i); continue &#125; u = 0; v = result.length - 1; while (u &lt; v) &#123; // 二分查找 c = (u + v) &gt;&gt; 1; if (arr[result[c]] &lt; arrI) &#123; u = c + 1 &#125; else &#123; v = c &#125; &#125; if (arrI &lt; arr[result[u]]) &#123; if (u &gt; 0) &#123; p[i] = result[u - 1] &#125; result[u] = i &#125; &#125; &#125; // 回溯修正 u = result.length v = result[u - 1] while (u-- &gt; 0) &#123; result[u] = v v = p[v] &#125; return result&#125;","categories":[],"tags":[]},{"title":"渲染器：数组节点中的Dom Diff","slug":"源码/vue3/runtime/vue3_dom_diff","date":"2024-03-22T08:43:51.154Z","updated":"2024-04-01T11:52:13.246Z","comments":true,"path":"2024/03/22/源码/vue3/runtime/vue3_dom_diff/","link":"","permalink":"https://sanxun8.github.io/2024/03/22/%E6%BA%90%E7%A0%81/vue3/runtime/vue3_dom_diff/","excerpt":"","text":"在前端开发中，我们经常需要处理包含数组子节点的动态列表或复杂组件。本文将基于源码，梳理数组子节点的Diff更新流程，帮助读者更好地理解Vue3是如何通过Diff算法来高效地更新这些子节点，以提升应用性能。 从头对比const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) =&gt; &#123; let i = 0; // 当前对比索引 const l2 = c2.length; // 新节点长度 let e1 = c1.length - 1; // 旧节点结束标识 let e2 = l2 - 1; // 新节点介绍标识 // 1. 头对比 // (a b) c // (a b) d e while (i &lt; e1 &amp;&amp; i &lt; e2) &#123; const n1 = c1[i]; const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]); if (isSameVNodeType(n1, n2)) &#123; patch(n1, n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) &#125; else &#123; break; &#125; i++; &#125;&#125; 从尾部对比const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) =&gt; &#123; let i = 0; // 当前对比索引 const l2 = c2.length; // 新节点长度 let e1 = c1.length - 1; // 旧节点结束标识 let e2 = l2 - 1; // 新节点介绍标识 // 1. 头对比 // ... // 2. 尾对比 // a (b c) // d e (b c) while (i &lt; e1 &amp;&amp; i &lt; e2) &#123; const n1 = c1[e1]; const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]); if (isSameVNodeType(n1, n2)) &#123; patch(n1, n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) &#125; else &#123; break; &#125; e1--; e2--; &#125;&#125; 仅处理新增const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) =&gt; &#123; let i = 0; // 当前对比索引 const l2 = c2.length; // 新节点长度 let e1 = c1.length - 1; // 旧节点结束标识 let e2 = l2 - 1; // 新节点介绍标识 // 1. 头对比 // ... // 2. 从尾部对比 // ... // 3. 仅新增 // (a b) // (a b) c // i = 2, e1 = 1, e2 = 2 // (a b) // c (a b) // i = 0, e1 = -1, e2 = 0 if (i &gt; e1) &#123; if (i &lt;= e2) &#123; const nextPos = e2 + 1; const anchor = nextPos &lt; l2 ? c2[nextPos].el : parentAnchor; while (i &lt;= e2) &#123; patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense) i++; &#125; &#125; &#125; &#125; 仅处理卸载const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) =&gt; &#123; let i = 0; // 当前对比索引 const l2 = c2.length; // 新节点长度 let e1 = c1.length - 1; // 旧节点结束标识 let e2 = l2 - 1; // 新节点介绍标识 // 1. 头对比 // ... // 2. 从尾部对比 // ... // 3. 仅新增 if(i &gt; e1) &#123; // ...&#125; // 4. 仅卸载 // (a b) c // (a b) // i = 2, e1 = 2, e2 = 1 // a (b c) // (b c) // i = 0, e1 = 0, e2 = -1 else if (i &gt; e2) &#123; while (i &lt;= e1) &#123; unmount(c1[i], parentComponent, parentAnchor, true); i++; &#125; &#125;&#125; 处理未知序列构建新节点key到index的映射const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) =&gt; &#123; let i = 0; // 当前对比索引 const l2 = c2.length; // 新节点长度 let e1 = c1.length - 1; // 旧节点结束标识 let e2 = l2 - 1; // 新节点介绍标识 // 1. 头对比 // ... // 2. 从尾部对比 // ... // 3. 仅新增 if(i &gt; e1) &#123; // ...&#125; // 4. 仅卸载 else if (i &gt; e2) &#123; // ... &#125; else &#123; const s1 = i; // 旧节点开始处理索引 const s2 = i; // 新节点开始处理索引 // 5.1 构建新节点key到index的映射 const keyToNewIndexMap = new Map(); for (i = s2; i &lt;= e2; i++) &#123; const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]); if (nextChild.key != null) &#123; keyToNewIndexMap.set(nextChild.key, i); &#125; &#125; &#125;&#125; 5.2 处理旧节点（更新和卸载）const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) =&gt; &#123; let i = 0; // 当前对比索引 const l2 = c2.length; // 新节点长度 let e1 = c1.length - 1; // 旧节点结束标识 let e2 = l2 - 1; // 新节点介绍标识 // 1. 头对比 // ... // 2. 从尾部对比 // ... // 3. 仅新增 if(i &gt; e1) &#123; // ...&#125; // 4. 仅卸载 else if (i &gt; e2) &#123; // ... &#125; else &#123; const s1 = i; // 旧节点开始处理索引 const s2 = i; // 新节点开始处理索引 // 5.1 构建新节点key到index的映射 // ... // 5.2 处理旧节点（更新和卸载） let patched = 0; // 已处理的数目 const toBePatched = e2 - s2 + 1; // 需要处理的数目 let moved = false; // 标记节点是否移动 let maxNewIndexSoFar = 0; // 辅助判断节点是否移动 const newIndexToOldIndexMap = new Array(toBePatched); for (i = 0; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = 0; for (i = s1; i &lt;= e1; i++) &#123; const prevChild = e1[i]; if (patched &gt;= toBePatched) &#123; // 卸载多余节点 unmount(prevChild, parentComponent, parentSuspense, true); continue; &#125; let nextIndex; newIndex = keyToNewIndexMap.get(prevChild.key); if (newIndex === undefined) &#123; // 新节点找不到则卸载 unmount(prevChild, parentComponent, parentAnchor, true); &#125; else &#123; newIndexToOldIndexMap[newIndex - s2] = i + 1; if (newIndex &gt;= maxNewIndexSoFar) &#123; maxNewIndexSoFar = newIndex; &#125; else &#123; moved = true; &#125; patch(prevChild, c2[newIndex], null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) patched++; &#125; &#125; &#125;&#125; 5.3 移动和新增const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) =&gt; &#123; let i = 0; // 当前对比索引 const l2 = c2.length; // 新节点长度 let e1 = c1.length - 1; // 旧节点结束标识 let e2 = l2 - 1; // 新节点介绍标识 // 1. 头对比 // ... // 2. 从尾部对比 // ... // 3. 仅新增 if(i &gt; e1) &#123; // ...&#125; // 4. 仅卸载 else if (i &gt; e2) &#123; // ... &#125; else &#123; const s1 = i; // 旧节点开始处理索引 const s2 = i; // 新节点开始处理索引 // 5.1 构建新节点key到index的映射 // ... // 5.2 处理旧节点（更新和卸载） // ... // 5.3 移动和新增 const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR; let j = increasingNewIndexSequence.length - 1; for (i = toBePatched - 1; i &gt;= 0; i--) &#123; const nextIndex = s2 + i; const nextChild = c2[nextIndex]; const anchor = nextIndex + 1 &lt; l2 ? c2[nextIndex].el : parentAnchor; if (newIndexToOldIndexMap[i] === 0) &#123; patch(null, nextChild, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized); &#125; else if (moved) &#123; if (j &lt; 0 || i !== increasingNewIndexSequence[j]) &#123; moved(nextChild, container, anchor, MoveType.REORDER); &#125; else &#123; j--; &#125; &#125; &#125;&#125; 优化思考 唯一标识: 我们使用 v-for 编写列表时为什么不建议使用 index 作为 key? 总结希望本文能够帮助读者深入理解基于数组子节点的Diff更新流程，并在实际项目中应用这一知识，提升应用的性能和用户体验","categories":[],"tags":[]},{"title":"vue2中nextTick的实现","slug":"源码/vue2/vue2_nextTeck","date":"2024-03-21T12:56:44.097Z","updated":"2024-03-29T15:13:35.007Z","comments":true,"path":"2024/03/21/源码/vue2/vue2_nextTeck/","link":"","permalink":"https://sanxun8.github.io/2024/03/21/%E6%BA%90%E7%A0%81/vue2/vue2_nextTeck/","excerpt":"","text":"const inBrowser = typeof window !== &#x27;undefined&#x27; &amp;&amp; Object.prototype.toString.call(window) !== &#x27;[object Object]&#x27;;const nextTick = (function () &#123; let callbacks = []; let pendding = false; let timeFunc; function nextTickHandler() &#123; pendding = false; const copies = callbacks.slice(0); callbacks = []; for (let i = 0; i &lt; copies.length; i++) &#123; copies[i](); &#125; &#125; if (typeof MutationObserver === &#x27;undefined&#x27;) &#123; // cb同步执行 let counter = 1; const observer = new MutationObserver(nextTickHandler) const textNode = document.createTextNode(String(counter)); observer.observe(textNode, &#123; characterData: true, &#125;); timeFunc = function () &#123; counter = (counter + 1) % 2; textNode.data = String(counter); &#125; &#125; else &#123; // cb同步执行 const context = inBrowser ? window : typeof global !== &#x27;undefined&#x27; ? global : &#123;&#125;; timeFunc = context.setImmediate || setTimeout; &#125; return function(cb, ctx) &#123; const func = ctx ? function() &#123;cb.call(ctx);&#125; : cb; callbacks.push(func); if(pendding) return; pendding = true; timeFunc(nextTickHandler, 0) &#125;&#125;)()","categories":[],"tags":[]},{"title":"原型模式：创建对象的灵活性与效率的完美结合","slug":"设计模式/原型模式","date":"2024-03-19T06:14:08.699Z","updated":"2024-04-05T13:51:02.454Z","comments":true,"path":"2024/03/19/设计模式/原型模式/","link":"","permalink":"https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"原型模式是一种创建型设计模式，其核心思想是通过复制现有对象来创建新的对象，而无需显式地使用构造函数。原型模式基于原型实例来生成对象的副本，从而避免了直接创建对象所带来的性能开销和复杂的初始化过程。 示例场景(Vue3代理处理器)// 使用原型模式实现依赖收集class BaseReactiveHandler &#123; get(target, key, receiver) &#123; // 预置属性过滤 // 数组类型, 变异方法过滤 // symbol类型, 自有属性过滤 // 依赖收集 // 返回值处理 &#125;&#125;class MutableReactiveHandler extends BaseReactiveHandler &#123; set(target, key, value, receiver) &#123; // 对深层响应对象的旧值和新值处理 // 判断target类型并判断key是否为已有属性 // 触发更新 &#125; deleteProperty(target, key) &#123; // 判断是否为已有属性 // 若为已有属性, 触发更新 &#125; has(target, key) &#123; // 判断key是否为symbol类型或非Symbol自有属性 // 若key为symbol类型或非Symbol自有属性, 则触发更新 &#125; ownKeys(target) &#123; // 触发更新 &#125;&#125;class ReaonlyReactiveHandler extends BaseReactiveHandler &#123; set(target, key) &#123; // 报警 &#125; deleteProperty(target, key) &#123; // 报警 &#125;&#125; 示例场景（Vue3依赖注入实现跨级组件数据共享）export function createComponentInstance(vnode, parent, suspense) &#123; // ... const instance = &#123; // ... parent, providees: parent ? parent.provides : Object.create(appContext.provides) // ... &#125; // ...&#125; 可以发现provides利用原型链方式进行存储数据，默认情况下，实例继承其父级的提供对象，但是当它需要提供自己的值时，它会创建自己的值，自己提供的对象使用父级提供的对象作为原型。","categories":[],"tags":[]},{"title":"中介者模式：简化对象间的通信","slug":"设计模式/中介者模式","date":"2024-03-19T06:12:59.572Z","updated":"2024-03-25T09:55:19.471Z","comments":true,"path":"2024/03/19/设计模式/中介者模式/","link":"","permalink":"https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"中介者模式（Mediator Pattern）是一种行为型设计模式，用于解耦多个对象之间的通信，并将其集中处理。通过引入一个中介者对象，各个对象不再直接相互通信，而是通过中介者进行交互。这种模式可以减少对象间的耦合度，提高系统的可维护性和灵活性。 示例场景(vue2中收集响应式依赖, 通过Dep类集中处理依赖更新)// 中介模式let uid = 0; // 使用闭包实现唯一标识class Dep &#123; constructor() &#123; this.id = uid++; this.subs = []; &#125; addSub(sub) &#123; this.subs.push(sub); &#125; removeSub(sub) &#123; remove(this.subs, sub); // 一个工具函数 &#125; depend() &#123; if (Dep.target) &#123; Dep.target.addDep(this); &#125; &#125; notify() &#123; const subs = this.subs.slice(); for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update(); // 调用Watcher.prototype.addDep &#125; &#125;&#125;// 视图模型对象class Watcher &#123; addDep(dep) &#123; dep.addSub(this); &#125; update() &#123; // 更新视图 &#125;&#125;// 模型对象function defineReacitve(obj, key, value, customSetter) &#123; const dep = new Dep() Object.defineProperty(obj, key, &#123; enumeralbe: true, configurable: true, get: function () &#123; if(Dep.target) &#123; dep.depend() // 收集 &#125; &#125;, set: function () &#123; dep.notify(); // 通知 &#125;, &#125;)&#125; 该案例中使用了Dep类充当中介者角色, 模型对象不直接与视图模型对象直接通信, 避免了响应式数据挟持后书写视图更新的负责逻辑代码; 其他场景假设我们正在开发一个聊天室应用程序，其中包含多个用户（User）和一个聊天室（ChatRoom）。用户之间可以相互发送消息，同时聊天室也可以将消息广播给所有用户。 在这个场景中，可以使用中介者模式来简化用户和聊天室之间的通信。聊天室充当中介者，用户充当同事类。用户之间的消息不再直接发送给其他用户，而是通过聊天室中介者进行转发。 总结 中介者模式的核心思想是将对象间的通信行为集中管理，通过引入一个中介者对象来协调各个对象之间的交互。 中介者模式的核心组成部分: 中介者, 交互对象(可能是同事类); 结语在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。 通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。 敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。","categories":[],"tags":[]},{"title":"建造者模式：构建复杂对象的灵活设计模式","slug":"设计模式/建造者模式","date":"2024-03-19T06:12:53.157Z","updated":"2024-04-05T13:51:18.620Z","comments":true,"path":"2024/03/19/设计模式/建造者模式/","link":"","permalink":"https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。示例场景(创建一个计算机对象)// Product: 表示要构建的复杂对象​class Computer &#123;​ constructor() &#123;​ this.cpu = &quot;&quot;;​ this.gpu = &quot;&quot;;​ this.ram = 0;​ this.storage = &quot;&quot;;​ &#125;​​ describe() &#123;​ return `Computer with CPU: $&#123;this.cpu&#125;, GPU: $&#123;this.gpu&#125;, RAM: $&#123;this.ram&#125;GB, Storage: $&#123;this.storage&#125;`;​ &#125;​&#125;​​// Builder: 声明构建复杂对象的接口​class ComputerBuilder &#123;​ constructor() &#123;​ this.computer = new Computer();​ &#125;​​ setCPU() &#123;​ this.computer.cpu = &quot;AMD 5600G&quot;;​ return this;​ &#125;​​ setGPU() &#123;​ this.computer.gpu = &quot;核显&quot;;​ return this;​ &#125;​​ setRAM() &#123;​ this.computer.ram = 16;​ return this;​ &#125;​​ setStorage() &#123;​ this.computer.storage = &quot;500G&quot;;​ return this;​ &#125;​​ build() &#123;​ return this.computer;​ &#125;​&#125;​​// Director: 负责使用 Builder 构建对象​class ComputerEngineer &#123;​ constructComputer(builder) &#123;​ return builder​ .setCPU()​ .setGPU()​ .setRAM()​ .setStorage()​ .build();​ &#125;​&#125;​​// 使用建造者模式创建复杂对象​const engineer = new ComputerEngineer();​const builder = new ComputerBuilder();​​const computer = engineer.constructComputer(builder);​ 总结 建造者模式的核心思想是将对象的构建过程和表示分离; 建造者模式的核心组成部分是: 构建对象类, 构建器类, 指挥者类; 结语在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。 通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。 敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。","categories":[],"tags":[]},{"title":"工厂模式：灵活创建对象的设计模式","slug":"设计模式/工厂模式","date":"2024-03-19T06:12:52.958Z","updated":"2024-03-24T10:50:30.808Z","comments":true,"path":"2024/03/19/设计模式/工厂模式/","link":"","permalink":"https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"工厂模式是一种创建型设计模式，它通过使用工厂方法或抽象工厂，将对象的实例化过程封装起来，使得客户端与具体的对象创建过程解耦。工厂模式可以根据不同的条件或参数来创建不同的对象，提供了一种灵活的对象创建方式。 实现工厂模式的方式简单工厂模式// 工厂类class ShapeFactory &#123; createShape(type) &#123; if(type === &#x27;circle&#x27;) &#123; return new Circle(); &#125; else if(type === &#x27;rectangle&#x27;) &#123; return new Rectangle(); &#125; else &#123; throw new Error(&#x27;无效的形状&#x27;); &#125; &#125;&#125;class Shape &#123; draw() &#123; throw new Error(&#x27;绘制接口必须实现&#x27;); &#125;&#125;// 不同的具体产品class Circle extends Shape &#123; draw() &#123; console.log(&#x27;绘制圆&#x27;); &#125;&#125;class Rectangle extends Shape &#123; draw() &#123; console.log(&#x27;绘制矩形&#x27;); &#125;&#125;const circle = new ShapeFactory(&#x27;circle&#x27;);const rectangle = new ShapeFactory(&#x27;rectangle&#x27;); 工厂方法模式// 工厂类class ShapeFactory &#123; createShape(type) &#123; throw new Error(&#x27;创建形状接口必须实现&#x27;); &#125;&#125;class CircleFactory extends ShapeFactory &#123; createShape() &#123; return new Circle(); &#125;&#125;class RectangleFactory extends ShapeFactory &#123; createShape() &#123; return new Rectangle(); &#125;&#125;class Shape &#123; draw() &#123; throw new Error(&#x27;绘制接口必须实现&#x27;); &#125;&#125;// 不同的具体产品class Circle extends Shape &#123; draw() &#123; console.log(&#x27;绘制圆&#x27;); &#125;&#125;class Rectangle extends Shape &#123; draw() &#123; console.log(&#x27;绘制矩形&#x27;); &#125;&#125;const circle = new CircleFactory();const rectangle = new RectFactory(); 抽象工厂模式// 工厂类class H5Factory &#123; createButton() &#123; return new H5Button(); &#125; createIcon() &#123; return new H5Icon(); &#125;&#125;class WxFactory &#123; createButton() &#123; return new WxButton(); &#125; createIcon() &#123; return new WxIcon(); &#125;&#125;// 不同的具体产品class H5Button &#123; description() &#123; console.log(&#x27;这是个按钮&#x27;); &#125;&#125;class H5Icon &#123; description() &#123; console.log(&#x27;这是个图标&#x27;); &#125;&#125;class WxButton &#123; description() &#123; console.log(&#x27;这是个按钮&#x27;); &#125;&#125;class WxIcon &#123; description() &#123; console.log(&#x27;这是个图标&#x27;); &#125;&#125;const h5Factory = new H5Factory();const wxFactory = new wxFactory();const h5Button = new h5Factory.createButton();const h5Icon = new h5Factory.createIcon(); 简单工厂、工厂方法、抽象工厂模式的区别 关注点不同: 简单工厂使用一个接口创建所有产品； 工厂方法将产品实例化放到不同的工厂中，关注产品的从属性； 抽象工厂关注的是一个工厂包含多个产品对应的接口，关注的是产品族的创建； 组成结构不同： 简单工厂主要含有工厂类、具体产品类，工厂类下仅含有一个创建产品的接口； 工厂方法主要含有抽象工厂类、具体工厂类、具体产品类； 抽象工厂主要含有工厂类，具体产品A类，具体产品B类，工厂类下含有创建产品族的方法； 总结 工厂模式的核心思想是将对象的实例化过程封装起来，通过一个接口进行实例化，使得客户端与具体的对象创建过程解耦。 结语在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。 通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。 敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。","categories":[],"tags":[]},{"title":"单例模式：实现全局唯一实例的设计模式","slug":"设计模式/单例模式","date":"2024-03-19T06:12:52.789Z","updated":"2024-03-23T09:30:29.280Z","comments":true,"path":"2024/03/19/设计模式/单例模式/","link":"","permalink":"https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式是一种常见的设计模式，它通过限制类的实例化次数，确保只有一个实例存在。 示例场景(vue3创建渲染器)let renderer;function ensureRenderer() &#123; return renderer || createRender(rendererOptions);&#125; 其他实现方式由于 JavaScript 的事件循环机制和单线程执行，实现单例模式考虑的没那那么复杂，实现起来比较简单。 // 方式一const Singleton = (function() &#123; let instance; function createInstance() &#123; return new Object(&#x27;I am the instance&#x27;); &#125; return &#123; getInstance: function() &#123; if(!instance) &#123; instance = createInstance(); &#125; return instance; &#125; &#125;&#125;)const instance = Singleton.getInstance();// 方式二，直接使用对象字面量const messageManager = &#123; success() &#123;&#125;, error() &#123;&#125;,&#125;Object.freeze(messageManager) 其他场景 全局配置：单例模式可以用于管理全局的配置信息，确保在应用中只有一个配置实例被使用。 日志记录器：单例模式可以用于创建全局唯一的日志记录器，方便在应用中统一管理和记录日志信息 总结 单例模式的核心思想是需要确保一个类只有一个实例。 结语在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。 通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。 敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。","categories":[],"tags":[]},{"title":"渲染器：数据访问是如何被代理的？","slug":"源码/vue3/runtime/instance_proxy","date":"2024-03-13T13:19:55.092Z","updated":"2024-04-05T13:35:53.724Z","comments":true,"path":"2024/03/13/源码/vue3/runtime/instance_proxy/","link":"","permalink":"https://sanxun8.github.io/2024/03/13/%E6%BA%90%E7%A0%81/vue3/runtime/instance_proxy/","excerpt":"","text":"渲染器：数据访问是如何被代理的？源码定义: 对组件实例上下文进行代理function setupStatefulComponent(instance, isSSR) &#123; instance.accessCache = Object.create(null) instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers))&#125; PublicInstanceProxyHandlers.getconst PublicInstanceProxyHandlers = &#123; get(&#123; _: instance &#125;, key) &#123; const &#123; ctx, setupState, data, props, accessCache, type, appContext &#125; = instance let normalizedProps; // 预定义模块所需变量 if (key[0] !== &#x27;$&#x27;) &#123; // 处理非预留属性 const n = accessCache[key] // 读取缓存内容 if (n !== undefined) &#123; switch (n) &#123; case AccessTypes.SETUP: return setupState[key] case AccessTypes.DATA: return data[key] case AccessTypes.CONTEXT: return ctx[key] case AccessTypes.PROPS: return props[key] &#125; &#125; else if (hasSetupBinding(setupState, key)) &#123; accessCache![key] = AccessTypes.SETUP return setupState[key] &#125; else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123; accessCache![key] = AccessTypes.DATA return data[key] &#125; else if ( (normalizedProps = instance.propsOptions[0]) &amp;&amp; hasOwn(normalizedProps, key) ) &#123; accessCache![key] = AccessTypes.PROPS return props![key] &#125; else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123; accessCache![key] = AccessTypes.CONTEXT return ctx[key] &#125; else if (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) &#123; accessCache![key] = AccessTypes.OTHER &#125; &#125; const publicGetter = publicPropertiesMap[key] // 开始处理预留属性 let cssModule, globalProperties if (publicGetter) &#123; // $保留字开头的相关逻辑 &#125; else if ( (cssModule = type.__cssModules) &amp;&amp; (cssModule = cssModule[key]) ) &#123; return cssModule &#125; else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123; accessCache![key] = AccessTypes.CONTEXT return ctx[key] &#125; else if ( ((globalProperties = appContext.config.globalProperties), hasOwn(globalProperties, key)) ) &#123; if (__COMPAT__) &#123; const desc = Object.getOwnPropertyDescriptor(globalProperties, key)! if (desc.get) &#123; return desc.get.call(instance.proxy) &#125; else &#123; const val = globalProperties[key] return isFunction(val) ? Object.assign(val.bind(instance.proxy), val) : val &#125; &#125; else &#123; return globalProperties[key] &#125; &#125; &#125;&#125; 笔记 访问顺序为setupState》data》prop》ctx 使用空间换时间进行了优化，使用accessCache标记key存在于哪个属性上，减少了频繁调用hasOwn耗费性能。 PublicInstanceProxyHandlers .getconst PublicInstanceProxyHandlers = &#123; set(&#123; _: instance &#125;, key, value) &#123; const &#123; data, setupState, ctx &#125; = instance if (hasSetupBinding(setupState, key)) &#123; setupState[key] = value return true &#125; else if ( __DEV__ &amp;&amp; setupState.__isScriptSetup &amp;&amp; hasOwn(setupState, key) ) &#123; warn(`Cannot mutate &lt;script setup&gt; binding &quot;$&#123;key&#125;&quot; from Options API.`) return false &#125; else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123; data[key] = value return true &#125; else if (hasOwn(instance.props, key)) &#123; __DEV__ &amp;&amp; warn(`Attempting to mutate prop &quot;$&#123;key&#125;&quot;. Props are readonly.`) return false &#125; if (key[0] === &#x27;$&#x27; &amp;&amp; key.slice(1) in instance) &#123; __DEV__ &amp;&amp; warn( `Attempting to mutate public property &quot;$&#123;key&#125;&quot;. ` + `Properties starting with $ are reserved and readonly.`, ) return false &#125; else &#123; if (__DEV__ &amp;&amp; key in instance.appContext.config.globalProperties) &#123; Object.defineProperty(ctx, key, &#123; enumerable: true, configurable: true, value, &#125;) &#125; else &#123; ctx[key] = value &#125; &#125; return true &#125;,&#125; 结论： 更改顺序为：setupState 》data 》props 》globalProperties PublicInstanceProxyHandlers .hasconst PublicInstanceProxyHandlers = &#123; has(&#123;_: &#123; data, setupState, accessCache, ctx, appContext, propsOptions &#125;&#125;, key) &#123; let normalizedProps return ( !!accessCache[key] || (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) || hasSetupBinding(setupState, key) || ((normalizedProps = propsOptions[0]) &amp;&amp; hasOwn(normalizedProps, key)) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || // $保留字开头的函数 hasOwn(appContext.config.globalProperties, key) ) &#125;,&#125; 结论： 访问顺序为data 》setupState》props》ctx》publicPropertiesMap》globalProperties","categories":[],"tags":[]}],"categories":[],"tags":[]}