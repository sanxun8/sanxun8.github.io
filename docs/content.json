{"meta":{"title":"屯货三旬的个人网站","subtitle":"","description":"屯货三旬的个人网站","author":"屯货三旬","url":"https://sanxun8.github.io","root":"/"},"pages":[{"title":"About-Me","date":"2022-01-14T06:37:51.000Z","updated":"2023-08-12T07:53:20.004Z","comments":true,"path":"about-me/index.html","permalink":"https://sanxun8.github.io/about-me/index.html","excerpt":"","text":""},{"title":"Archives","date":"2022-01-14T06:32:41.000Z","updated":"2023-08-12T18:55:33.125Z","comments":true,"path":"archives/index.html","permalink":"https://sanxun8.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-01-14T06:19:06.000Z","updated":"2023-08-12T19:16:48.550Z","comments":true,"path":"categories/index.html","permalink":"https://sanxun8.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-08-12T18:52:22.000Z","updated":"2023-08-13T07:59:02.232Z","comments":true,"path":"link/index.html","permalink":"https://sanxun8.github.io/link/index.html","excerpt":"","text":""},{"title":"List","date":"2023-08-12T18:51:35.000Z","updated":"2023-08-12T18:51:52.186Z","comments":true,"path":"list/index.html","permalink":"https://sanxun8.github.io/list/index.html","excerpt":"","text":""},{"title":"Messageboard","date":"2023-08-14T14:28:47.000Z","updated":"2023-08-14T14:47:44.281Z","comments":true,"path":"messageboard/index.html","permalink":"https://sanxun8.github.io/messageboard/index.html","excerpt":"","text":""},{"title":"视频","date":"2023-08-13T05:31:06.000Z","updated":"2023-08-13T05:31:39.757Z","comments":true,"path":"movies/index.html","permalink":"https://sanxun8.github.io/movies/index.html","excerpt":"","text":""},{"title":"音乐","date":"2023-08-13T05:26:07.000Z","updated":"2023-08-13T05:31:13.426Z","comments":true,"path":"music/index.html","permalink":"https://sanxun8.github.io/music/index.html","excerpt":"","text":""},{"title":"图库","date":"2023-08-13T07:22:42.000Z","updated":"2023-08-14T05:18:21.142Z","comments":true,"path":"photo/index.html","permalink":"https://sanxun8.github.io/photo/index.html","excerpt":"","text":"壁紙 收藏的一些壁紙 漫威 關於漫威的圖片"},{"title":"","date":"2023-08-13T17:36:04.285Z","updated":"2023-08-13T17:34:13.767Z","comments":true,"path":"pwa/manifest.json","permalink":"https://sanxun8.github.io/pwa/manifest.json","excerpt":"","text":"{\"name\":\"string\",\"short_name\":\"Junzhou\",\"theme_color\":\"#49b1f5\",\"background_color\":\"#49b1f5\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"images/pwaicons/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"标签","date":"2022-01-14T06:36:42.000Z","updated":"2023-08-12T19:14:30.951Z","comments":true,"path":"tags/index.html","permalink":"https://sanxun8.github.io/tags/index.html","excerpt":"","text":""},{"title":"漫威","date":"2023-08-13T05:26:07.000Z","updated":"2023-08-13T17:16:21.822Z","comments":true,"path":"photo/marwel/index.html","permalink":"https://sanxun8.github.io/photo/marwel/index.html","excerpt":"","text":"[{\"url\":\"/photo/marwel/img/1.png\",\"alt\":\"\"},{\"url\":\"/photo/marwel/img/1.webp\",\"alt\":\"\"},{\"url\":\"/photo/marwel/img/2.webp\",\"alt\":\"\"},{\"url\":\"/photo/marwel/img/3.webp\",\"alt\":\"\"}]"},{"title":"壁纸","date":"2023-08-13T07:28:24.000Z","updated":"2023-08-13T17:15:49.918Z","comments":true,"path":"photo/wallpaper/index.html","permalink":"https://sanxun8.github.io/photo/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"数组节点中的Dom Diff","slug":"源码/vue3_dom_diff","date":"2024-03-22T08:43:51.154Z","updated":"2024-03-22T08:43:54.205Z","comments":true,"path":"2024/03/22/源码/vue3_dom_diff/","link":"","permalink":"https://sanxun8.github.io/2024/03/22/%E6%BA%90%E7%A0%81/vue3_dom_diff/","excerpt":"","text":"在前端开发中，我们经常需要处理包含数组子节点的动态列表或复杂组件。本文将基于源码，梳理数组子节点的Diff更新流程，帮助读者更好地理解Vue3是如何通过Diff算法来高效地更新这些子节点，以提升应用性能。 从头对比const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) =&gt; &#123; let i = 0; // 当前对比索引 const l2 = c2.length; // 新节点长度 let e1 = c1.length - 1; // 旧节点结束标识 let e2 = l2 - 1; // 新节点介绍标识 // 1. 头对比 // (a b) c // (a b) d e while (i &lt; e1 &amp;&amp; i &lt; e2) &#123; const n1 = c1[i]; const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]); if (isSameVNodeType(n1, n2)) &#123; patch(n1, n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) &#125; else &#123; break; &#125; i++; &#125;&#125; 从尾部对比const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) =&gt; &#123; let i = 0; // 当前对比索引 const l2 = c2.length; // 新节点长度 let e1 = c1.length - 1; // 旧节点结束标识 let e2 = l2 - 1; // 新节点介绍标识 // 1. 头对比 // ... // 2. 尾对比 // a (b c) // d e (b c) while (i &lt; e1 &amp;&amp; i &lt; e2) &#123; const n1 = c1[e1]; const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]); if (isSameVNodeType(n1, n2)) &#123; patch(n1, n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) &#125; else &#123; break; &#125; e1--; e2--; &#125;&#125; 仅处理新增const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) =&gt; &#123; let i = 0; // 当前对比索引 const l2 = c2.length; // 新节点长度 let e1 = c1.length - 1; // 旧节点结束标识 let e2 = l2 - 1; // 新节点介绍标识 // 1. 头对比 // ... // 2. 从尾部对比 // ... // 3. 仅新增 // (a b) // (a b) c // i = 2, e1 = 1, e2 = 2 // (a b) // c (a b) // i = 0, e1 = -1, e2 = 0 if (i &gt; e1) &#123; if (i &lt;= e2) &#123; const nextPos = e2 + 1; const anchor = nextPos &lt; l2 ? c2[nextPos].el : parentAnchor; while (i &lt;= e2) &#123; patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense) i++; &#125; &#125; &#125; &#125; 仅处理卸载const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) =&gt; &#123; let i = 0; // 当前对比索引 const l2 = c2.length; // 新节点长度 let e1 = c1.length - 1; // 旧节点结束标识 let e2 = l2 - 1; // 新节点介绍标识 // 1. 头对比 // ... // 2. 从尾部对比 // ... // 3. 仅新增 if(i &gt; e1) &#123; // ...&#125; // 4. 仅卸载 // (a b) c // (a b) // i = 2, e1 = 2, e2 = 1 // a (b c) // (b c) // i = 0, e1 = 0, e2 = -1 else if (i &gt; e2) &#123; while (i &lt;= e1) &#123; unmount(c1[i], parentComponent, parentAnchor, true); i++; &#125; &#125;&#125; 处理未知序列构建新节点key到index的映射const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) =&gt; &#123; let i = 0; // 当前对比索引 const l2 = c2.length; // 新节点长度 let e1 = c1.length - 1; // 旧节点结束标识 let e2 = l2 - 1; // 新节点介绍标识 // 1. 头对比 // ... // 2. 从尾部对比 // ... // 3. 仅新增 if(i &gt; e1) &#123; // ...&#125; // 4. 仅卸载 else if (i &gt; e2) &#123; // ... &#125; else &#123; const s1 = i; // 旧节点开始处理索引 const s2 = i; // 新节点开始处理索引 // 5.1 构建新节点key到index的映射 const keyToNewIndexMap = new Map(); for (i = s2; i &lt;= e2; i++) &#123; const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]); if (nextChild.key != null) &#123; keyToNewIndexMap.set(nextChild.key, i); &#125; &#125; &#125;&#125; 5.2 处理旧节点（更新和卸载）const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) =&gt; &#123; let i = 0; // 当前对比索引 const l2 = c2.length; // 新节点长度 let e1 = c1.length - 1; // 旧节点结束标识 let e2 = l2 - 1; // 新节点介绍标识 // 1. 头对比 // ... // 2. 从尾部对比 // ... // 3. 仅新增 if(i &gt; e1) &#123; // ...&#125; // 4. 仅卸载 else if (i &gt; e2) &#123; // ... &#125; else &#123; const s1 = i; // 旧节点开始处理索引 const s2 = i; // 新节点开始处理索引 // 5.1 构建新节点key到index的映射 // ... // 5.2 处理旧节点（更新和卸载） let patched = 0; // 已处理的数目 const toBePatched = e2 - s2 + 1; // 需要处理的数目 let moved = false; // 标记节点是否移动 let maxNewIndexSoFar = 0; // 辅助判断节点是否移动 const newIndexToOldIndexMap = new Array(toBePatched); for (i = 0; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = 0; for (i = s1; i &lt;= e1; i++) &#123; const prevChild = e1[i]; if (patched &gt;= toBePatched) &#123; // 卸载多余节点 unmount(prevChild, parentComponent, parentSuspense, true); continue; &#125; let nextIndex; newIndex = keyToNewIndexMap.get(prevChild.key); if (newIndex === undefined) &#123; // 新节点找不到则卸载 unmount(prevChild, parentComponent, parentAnchor, true); &#125; else &#123; newIndexToOldIndexMap[newIndex - s2] = i + 1; if (newIndex &gt;= maxNewIndexSoFar) &#123; maxNewIndexSoFar = newIndex; &#125; else &#123; moved = true; &#125; patch(prevChild, c2[newIndex], null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) patched++; &#125; &#125; &#125;&#125; 5.3 移动和新增const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) =&gt; &#123; let i = 0; // 当前对比索引 const l2 = c2.length; // 新节点长度 let e1 = c1.length - 1; // 旧节点结束标识 let e2 = l2 - 1; // 新节点介绍标识 // 1. 头对比 // ... // 2. 从尾部对比 // ... // 3. 仅新增 if(i &gt; e1) &#123; // ...&#125; // 4. 仅卸载 else if (i &gt; e2) &#123; // ... &#125; else &#123; const s1 = i; // 旧节点开始处理索引 const s2 = i; // 新节点开始处理索引 // 5.1 构建新节点key到index的映射 // ... // 5.2 处理旧节点（更新和卸载） // ... // 5.3 移动和新增 const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR; let j = increasingNewIndexSequence.length - 1; for (i = toBePatched - 1; i &gt;= 0; i--) &#123; const nextIndex = s2 + i; const nextChild = c2[nextIndex]; const anchor = nextIndex + 1 &lt; l2 ? c2[nextIndex].el : parentAnchor; if (newIndexToOldIndexMap[i] === 0) &#123; patch(null, nextChild, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized); &#125; else if (moved) &#123; if (j &lt; 0 || i !== increasingNewIndexSequence[j]) &#123; moved(nextChild, container, anchor, MoveType.REORDER); &#125; else &#123; j--; &#125; &#125; &#125;&#125; 优化思考 唯一标识: 我们使用 v-for 编写列表时为什么不建议使用 index 作为 key? 总结希望本文能够帮助读者深入理解基于数组子节点的Diff更新流程，并在实际项目中应用这一知识，提升应用的性能和用户体验","categories":[],"tags":[]},{"title":"中介者模式：简化对象间的通信","slug":"设计模式/中介者模式","date":"2024-03-19T06:12:59.572Z","updated":"2024-03-20T00:48:37.026Z","comments":true,"path":"2024/03/19/设计模式/中介者模式/","link":"","permalink":"https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"中介者模式（Mediator Pattern）是一种行为型设计模式，用于解耦多个对象之间的通信，并将其集中处理。通过引入一个中介者对象，各个对象不再直接相互通信，而是通过中介者进行交互。这种模式可以减少对象间的耦合度，提高系统的可维护性和灵活性。 示例场景(vue2中收集响应式依赖, 通过Dep类集中处理依赖更新)// 中介模式let uid = 0; // 使用闭包实现唯一标识class Dep &#123; constructor() &#123; this.id = uid++; this.subs = []; &#125; addSub(sub) &#123; this.subs.push(sub); &#125; removeSub(sub) &#123; remove(this.subs, sub); // 一个工具函数 &#125; depend() &#123; if (Dep.target) &#123; Dep.target.addDep(this); &#125; &#125; notify() &#123; const subs = this.subs.slice(); for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update(); // 调用Watcher.prototype.addDep &#125; &#125;&#125;// 视图模型对象class Watcher &#123; addDep(dep) &#123; dep.addSub(this); &#125; update() &#123; // 更新视图 &#125;&#125;// 模型对象function defineReacitve(obj, key, value, customSetter) &#123; const dep = new Dep() Object.defineProperty(obj, key, &#123; enumeralbe: true, configurable: true, get: function () &#123; if(Dep.target) &#123; dep.depend() // 收集 &#125; &#125;, set: function () &#123; dep.notify(); // 通知 &#125;, &#125;)&#125; 该案例中使用了Dep类充当中介者角色, 模型对象不直接与视图模型对象直接通信, 避免了响应式数据挟持后书写视图更新的负责逻辑代码; 其他场景假设我们正在开发一个聊天室应用程序，其中包含多个用户（User）和一个聊天室（ChatRoom）。用户之间可以相互发送消息，同时聊天室也可以将消息广播给所有用户。 在这个场景中，可以使用中介者模式来简化用户和聊天室之间的通信。聊天室充当中介者，用户充当同事类。用户之间的消息不再直接发送给其他用户，而是通过聊天室中介者进行转发。 总结 中介者模式的核心思想是将对象间的通信行为集中管理，通过引入一个中介者对象来协调各个对象之间的交互。 中介者的核心组成部分: 中介者, 交互对象(可能是同事类); 结语在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。 通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。 敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。","categories":[],"tags":[]},{"title":"渲染器：数据访问是如何被代理的？","slug":"源码/3-渲染器-数据访问是如何被代理的","date":"2024-03-13T13:19:55.092Z","updated":"2024-03-20T00:50:15.318Z","comments":true,"path":"2024/03/13/源码/3-渲染器-数据访问是如何被代理的/","link":"","permalink":"https://sanxun8.github.io/2024/03/13/%E6%BA%90%E7%A0%81/3-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84/","excerpt":"","text":"渲染器：数据访问是如何被代理的？源码定义: 对组件实例上下文进行代理function setupStatefulComponent(instance, isSSR) &#123; instance.accessCache = Object.create(null) instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers))&#125; PublicInstanceProxyHandlers.getconst PublicInstanceProxyHandlers = &#123; get(&#123; _: instance &#125;, key) &#123; const &#123; ctx, setupState, data, props, accessCache, type, appContext &#125; = instance if (__DEV__ &amp;&amp; key === &#x27;__isVue&#x27;) &#123; return true &#125; let normalizedProps; // 预定义模块所需变量 if (key[0] !== &#x27;$&#x27;) &#123; // 处理非预留属性 const n = accessCache[key] // 读取缓存内容 if (n !== undefined) &#123; switch (n) &#123; case AccessTypes.SETUP: return setupState[key] case AccessTypes.DATA: return data[key] case AccessTypes.CONTEXT: return ctx[key] case AccessTypes.PROPS: return props[key] &#125; &#125; else if (hasSetupBinding(setupState, key)) &#123; accessCache![key] = AccessTypes.SETUP return setupState[key] &#125; else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123; accessCache![key] = AccessTypes.DATA return data[key] &#125; else if ( (normalizedProps = instance.propsOptions[0]) &amp;&amp; hasOwn(normalizedProps, key) ) &#123; accessCache![key] = AccessTypes.PROPS return props![key] &#125; else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123; accessCache![key] = AccessTypes.CONTEXT return ctx[key] &#125; else if (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) &#123; accessCache![key] = AccessTypes.OTHER &#125; &#125; const publicGetter = publicPropertiesMap[key] // 开始处理预留属性 let cssModule, globalProperties if (publicGetter) &#123; // $保留字开头的相关逻辑 &#125; else if ( (cssModule = type.__cssModules) &amp;&amp; (cssModule = cssModule[key]) ) &#123; return cssModule &#125; else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123; accessCache![key] = AccessTypes.CONTEXT return ctx[key] &#125; else if ( ((globalProperties = appContext.config.globalProperties), hasOwn(globalProperties, key)) ) &#123; if (__COMPAT__) &#123; const desc = Object.getOwnPropertyDescriptor(globalProperties, key)! if (desc.get) &#123; return desc.get.call(instance.proxy) &#125; else &#123; const val = globalProperties[key] return isFunction(val) ? Object.assign(val.bind(instance.proxy), val) : val &#125; &#125; else &#123; return globalProperties[key] &#125; &#125; else if ( // 一些告警 &#125; &#125;&#125; 笔记 访问顺序为setupState》data》prop》ctx 使用空间换时间进行了优化，使用accessCache标记key存在于哪个属性上，减少了频繁调用hasOwn耗费性能。 PublicInstanceProxyHandlers .getconst PublicInstanceProxyHandlers = &#123; set(&#123; _: instance &#125;, key, value) &#123; const &#123; data, setupState, ctx &#125; = instance if (hasSetupBinding(setupState, key)) &#123; setupState[key] = value return true &#125; else if ( __DEV__ &amp;&amp; setupState.__isScriptSetup &amp;&amp; hasOwn(setupState, key) ) &#123; warn(`Cannot mutate &lt;script setup&gt; binding &quot;$&#123;key&#125;&quot; from Options API.`) return false &#125; else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123; data[key] = value return true &#125; else if (hasOwn(instance.props, key)) &#123; __DEV__ &amp;&amp; warn(`Attempting to mutate prop &quot;$&#123;key&#125;&quot;. Props are readonly.`) return false &#125; if (key[0] === &#x27;$&#x27; &amp;&amp; key.slice(1) in instance) &#123; __DEV__ &amp;&amp; warn( `Attempting to mutate public property &quot;$&#123;key&#125;&quot;. ` + `Properties starting with $ are reserved and readonly.`, ) return false &#125; else &#123; if (__DEV__ &amp;&amp; key in instance.appContext.config.globalProperties) &#123; Object.defineProperty(ctx, key, &#123; enumerable: true, configurable: true, value, &#125;) &#125; else &#123; ctx[key] = value &#125; &#125; return true &#125;,&#125; 结论： 更改顺序为：setupState 》data 》props 》globalProperties PublicInstanceProxyHandlers .hasconst PublicInstanceProxyHandlers = &#123; has(&#123;_: &#123; data, setupState, accessCache, ctx, appContext, propsOptions &#125;&#125;, key) &#123; let normalizedProps return ( !!accessCache[key] || (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) || hasSetupBinding(setupState, key) || ((normalizedProps = propsOptions[0]) &amp;&amp; hasOwn(normalizedProps, key)) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || // $保留字开头的函数 hasOwn(appContext.config.globalProperties, key) ) &#125;,&#125; 结论： 访问顺序为data 》setupState》props》ctx》publicPropertiesMap》globalProperties","categories":[],"tags":[]}],"categories":[],"tags":[]}