{"meta":{"title":"屯货三旬的个人网站","subtitle":"","description":"屯货三旬的个人网站","author":"屯货三旬","url":"https://sanxun8.github.io","root":"/"},"pages":[{"title":"About-Me","date":"2022-01-14T06:37:51.000Z","updated":"2023-08-12T07:53:20.004Z","comments":true,"path":"about-me/index.html","permalink":"https://sanxun8.github.io/about-me/index.html","excerpt":"","text":""},{"title":"Archives","date":"2022-01-14T06:32:41.000Z","updated":"2023-08-12T18:55:33.125Z","comments":true,"path":"archives/index.html","permalink":"https://sanxun8.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-01-14T06:19:06.000Z","updated":"2023-08-12T19:16:48.550Z","comments":true,"path":"categories/index.html","permalink":"https://sanxun8.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-08-12T18:52:22.000Z","updated":"2023-08-13T07:59:02.232Z","comments":true,"path":"link/index.html","permalink":"https://sanxun8.github.io/link/index.html","excerpt":"","text":""},{"title":"List","date":"2023-08-12T18:51:35.000Z","updated":"2023-08-12T18:51:52.186Z","comments":true,"path":"list/index.html","permalink":"https://sanxun8.github.io/list/index.html","excerpt":"","text":""},{"title":"Messageboard","date":"2023-08-14T14:28:47.000Z","updated":"2023-08-14T14:47:44.281Z","comments":true,"path":"messageboard/index.html","permalink":"https://sanxun8.github.io/messageboard/index.html","excerpt":"","text":""},{"title":"视频","date":"2023-08-13T05:31:06.000Z","updated":"2023-08-13T05:31:39.757Z","comments":true,"path":"movies/index.html","permalink":"https://sanxun8.github.io/movies/index.html","excerpt":"","text":""},{"title":"音乐","date":"2023-08-13T05:26:07.000Z","updated":"2023-08-13T05:31:13.426Z","comments":true,"path":"music/index.html","permalink":"https://sanxun8.github.io/music/index.html","excerpt":"","text":""},{"title":"图库","date":"2023-08-13T07:22:42.000Z","updated":"2023-08-14T05:18:21.142Z","comments":true,"path":"photo/index.html","permalink":"https://sanxun8.github.io/photo/index.html","excerpt":"","text":"壁紙 收藏的一些壁紙 漫威 關於漫威的圖片"},{"title":"","date":"2023-08-13T17:36:04.285Z","updated":"2023-08-13T17:34:13.767Z","comments":true,"path":"pwa/manifest.json","permalink":"https://sanxun8.github.io/pwa/manifest.json","excerpt":"","text":"{\"name\":\"string\",\"short_name\":\"Junzhou\",\"theme_color\":\"#49b1f5\",\"background_color\":\"#49b1f5\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"images/pwaicons/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"标签","date":"2022-01-14T06:36:42.000Z","updated":"2023-08-12T19:14:30.951Z","comments":true,"path":"tags/index.html","permalink":"https://sanxun8.github.io/tags/index.html","excerpt":"","text":""},{"title":"漫威","date":"2023-08-13T05:26:07.000Z","updated":"2023-08-13T17:16:21.822Z","comments":true,"path":"photo/marwel/index.html","permalink":"https://sanxun8.github.io/photo/marwel/index.html","excerpt":"","text":"[{\"url\":\"/photo/marwel/img/1.png\",\"alt\":\"\"},{\"url\":\"/photo/marwel/img/1.webp\",\"alt\":\"\"},{\"url\":\"/photo/marwel/img/2.webp\",\"alt\":\"\"},{\"url\":\"/photo/marwel/img/3.webp\",\"alt\":\"\"}]"},{"title":"壁纸","date":"2023-08-13T07:28:24.000Z","updated":"2023-08-13T17:15:49.918Z","comments":true,"path":"photo/wallpaper/index.html","permalink":"https://sanxun8.github.io/photo/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue中ref模块源码解析","slug":"源码/vue3/ref","date":"2024-03-22T12:33:24.547Z","updated":"2024-03-29T15:15:07.990Z","comments":true,"path":"2024/03/22/源码/vue3/ref/","link":"","permalink":"https://sanxun8.github.io/2024/03/22/%E6%BA%90%E7%A0%81/vue3/ref/","excerpt":"","text":"Ref源码中关于ref部分的定义： export function ref(value) &#123; return createRef(value, false);&#125;export function shallowRef(value) &#123; return createRef(value, true);&#125;function createRef(rawValue, shallow) &#123; if (isRef(rawValue)) &#123; return rawValue; &#125; return new RefImpl(rawValue, shallow);&#125;class RefImpl &#123; constructor(value, __v_isShallow) &#123; this.__v_isShallow = __v_isShallow; this._rawValue = __v_isShallow ? value : toRaw(value); this._value = __v_isShallow ? value : toReactive(value); &#125; get value() &#123; trackRefValue(this); // 收集依赖 return this._value; &#125; set value(newVal) &#123; const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal); newVal = useDirectValue ? newVal : toRaw(newVal); if (hasChanged(newVal, this._rawValue)) &#123; this._rawValue = newVal; this._value = useDirectValue ? newVal : toReactive(newVal); triggerRefValue(this, DirtyLevels.Dirty, newVal); // 触发相应 &#125; &#125;&#125; 其他内容function isRef(r) &#123; return !!(r &amp;&amp; r.__v_isRef === true);&#125;export function unref(ref) &#123; return isRef(ref) ? ref.value : ref;&#125;export function toValue(source) &#123; return isFunction(source) ? source() : unref(source);&#125;const shallowUnwrapHandlers = &#123; get: (target, key, receiver) =&gt; unref(Reflect.get(target, key, receiver)), set: (target, key, value, receiver) =&gt; &#123; const oldValue = target[key]; if (isRef(oldValue) &amp;&amp; !isRef(value)) &#123; oldValue.value = value; return true; &#125; else &#123; return Reflect.set(target, key, value, receiver); &#125; &#125;,&#125;export function proxyRefs(objectWithRefs) &#123; // 不太理解依赖收集 return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);&#125;class CustomRefImpl &#123; constructor(factory) &#123; const &#123; get, set &#125; = factory(() =&gt; trackRefValue(this), () =&gt; triggerRefValue(this)); this._get = get; this._set = set; &#125; get value() &#123; return this._get(); &#125; set value(newVal) &#123; this._set(newVal); &#125;&#125;export function customRef(factory) &#123; return new CustomRefImpl(factory);&#125;export function toRefs(object) &#123; if (__DEV__ &amp;&amp; !isProxy(object)) &#123; warn(`toRefs() expects a reactive object but received a plain one.`); &#125; const ret = isArray(object) ? new Array(object.length) : &#123;&#125;; for (const key in object) &#123; ret[key] = propertyToRef(object, key) &#125; return ret&#125;class ObjectRefImpl &#123; constructor(_object, _key, _defaultValue) &#123; this._object = _object; this._key = _key; this._defaultValue = _defaultValue; &#125; get value() &#123; const val = this._object[this._key]; return val === undefined ? this._defaultValue : val; &#125; set value(newVal) &#123; this._object[this._key] = newVal; &#125; get dep() &#123; return getDepFromReactive(toRaw(this._object), this._key) &#125;&#125;class GetterRefImpl &#123; constructor(_getter) &#123; this._getter = _getter; this.__v_isRef = true; this.__v_isReadonly = true; &#125; get value() &#123; return this._getter(); &#125;&#125;export function toRef(source, key, defaultValue) &#123; if (isRef(source)) &#123; return source; &#125; else if (isFunction(source)) &#123; // 不太理解依赖收集 return new GetterRefImpl(source); &#125; else if (isObject(source) &amp;&amp; arguments.length &gt; 1) &#123; // 不太理解依赖搜集 return propertyToRef(source, key, defaultValue); &#125; else &#123; return ref(source); &#125;&#125;function propertyToRef(source, key, defaultValue) &#123; const val = source[key]; return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);&#125;","categories":[],"tags":[]},{"title":"Vue3中中获取最长递增子序列","slug":"源码/vue3/最长递增子序列","date":"2024-03-22T11:17:15.570Z","updated":"2024-03-29T15:16:48.013Z","comments":true,"path":"2024/03/22/源码/vue3/最长递增子序列/","link":"","permalink":"https://sanxun8.github.io/2024/03/22/%E6%BA%90%E7%A0%81/vue3/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"function getSequence(arr) &#123; const p = arr.slice(); // 反向链表 可以使用 p = []初始化 const result = [0] // 结果值到原数组索引的映射 let i, j, u, v, c; const len = arr.length; for (i = 0; i &lt; len; i++) &#123; const arrI = arr[i]; if (arrI !== 0) &#123; j = result[result.length - 1] if (arr[j] &lt; arrI) &#123; // 与最后一项对比 p[i] = j; result.push(i); continue &#125; u = 0; v = result.length - 1; while (u &lt; v) &#123; // 二分查找 c = (u + v) &gt;&gt; 1; if (arr[result[c]] &lt; arrI) &#123; u = c + 1 &#125; else &#123; v = c &#125; &#125; if (arrI &lt; arr[result[u]]) &#123; if (u &gt; 0) &#123; p[i] = result[u - 1] &#125; result[u] = i &#125; &#125; &#125; // 回溯修正 u = result.length v = result[u - 1] while (u-- &gt; 0) &#123; result[u] = v v = p[v] &#125; return result&#125;","categories":[],"tags":[]},{"title":"数组节点中的Dom Diff","slug":"源码/vue3/vue3_dom_diff","date":"2024-03-22T08:43:51.154Z","updated":"2024-03-22T08:43:54.205Z","comments":true,"path":"2024/03/22/源码/vue3/vue3_dom_diff/","link":"","permalink":"https://sanxun8.github.io/2024/03/22/%E6%BA%90%E7%A0%81/vue3/vue3_dom_diff/","excerpt":"","text":"在前端开发中，我们经常需要处理包含数组子节点的动态列表或复杂组件。本文将基于源码，梳理数组子节点的Diff更新流程，帮助读者更好地理解Vue3是如何通过Diff算法来高效地更新这些子节点，以提升应用性能。 从头对比const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) =&gt; &#123; let i = 0; // 当前对比索引 const l2 = c2.length; // 新节点长度 let e1 = c1.length - 1; // 旧节点结束标识 let e2 = l2 - 1; // 新节点介绍标识 // 1. 头对比 // (a b) c // (a b) d e while (i &lt; e1 &amp;&amp; i &lt; e2) &#123; const n1 = c1[i]; const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]); if (isSameVNodeType(n1, n2)) &#123; patch(n1, n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) &#125; else &#123; break; &#125; i++; &#125;&#125; 从尾部对比const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) =&gt; &#123; let i = 0; // 当前对比索引 const l2 = c2.length; // 新节点长度 let e1 = c1.length - 1; // 旧节点结束标识 let e2 = l2 - 1; // 新节点介绍标识 // 1. 头对比 // ... // 2. 尾对比 // a (b c) // d e (b c) while (i &lt; e1 &amp;&amp; i &lt; e2) &#123; const n1 = c1[e1]; const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]); if (isSameVNodeType(n1, n2)) &#123; patch(n1, n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) &#125; else &#123; break; &#125; e1--; e2--; &#125;&#125; 仅处理新增const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) =&gt; &#123; let i = 0; // 当前对比索引 const l2 = c2.length; // 新节点长度 let e1 = c1.length - 1; // 旧节点结束标识 let e2 = l2 - 1; // 新节点介绍标识 // 1. 头对比 // ... // 2. 从尾部对比 // ... // 3. 仅新增 // (a b) // (a b) c // i = 2, e1 = 1, e2 = 2 // (a b) // c (a b) // i = 0, e1 = -1, e2 = 0 if (i &gt; e1) &#123; if (i &lt;= e2) &#123; const nextPos = e2 + 1; const anchor = nextPos &lt; l2 ? c2[nextPos].el : parentAnchor; while (i &lt;= e2) &#123; patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense) i++; &#125; &#125; &#125; &#125; 仅处理卸载const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) =&gt; &#123; let i = 0; // 当前对比索引 const l2 = c2.length; // 新节点长度 let e1 = c1.length - 1; // 旧节点结束标识 let e2 = l2 - 1; // 新节点介绍标识 // 1. 头对比 // ... // 2. 从尾部对比 // ... // 3. 仅新增 if(i &gt; e1) &#123; // ...&#125; // 4. 仅卸载 // (a b) c // (a b) // i = 2, e1 = 2, e2 = 1 // a (b c) // (b c) // i = 0, e1 = 0, e2 = -1 else if (i &gt; e2) &#123; while (i &lt;= e1) &#123; unmount(c1[i], parentComponent, parentAnchor, true); i++; &#125; &#125;&#125; 处理未知序列构建新节点key到index的映射const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) =&gt; &#123; let i = 0; // 当前对比索引 const l2 = c2.length; // 新节点长度 let e1 = c1.length - 1; // 旧节点结束标识 let e2 = l2 - 1; // 新节点介绍标识 // 1. 头对比 // ... // 2. 从尾部对比 // ... // 3. 仅新增 if(i &gt; e1) &#123; // ...&#125; // 4. 仅卸载 else if (i &gt; e2) &#123; // ... &#125; else &#123; const s1 = i; // 旧节点开始处理索引 const s2 = i; // 新节点开始处理索引 // 5.1 构建新节点key到index的映射 const keyToNewIndexMap = new Map(); for (i = s2; i &lt;= e2; i++) &#123; const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]); if (nextChild.key != null) &#123; keyToNewIndexMap.set(nextChild.key, i); &#125; &#125; &#125;&#125; 5.2 处理旧节点（更新和卸载）const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) =&gt; &#123; let i = 0; // 当前对比索引 const l2 = c2.length; // 新节点长度 let e1 = c1.length - 1; // 旧节点结束标识 let e2 = l2 - 1; // 新节点介绍标识 // 1. 头对比 // ... // 2. 从尾部对比 // ... // 3. 仅新增 if(i &gt; e1) &#123; // ...&#125; // 4. 仅卸载 else if (i &gt; e2) &#123; // ... &#125; else &#123; const s1 = i; // 旧节点开始处理索引 const s2 = i; // 新节点开始处理索引 // 5.1 构建新节点key到index的映射 // ... // 5.2 处理旧节点（更新和卸载） let patched = 0; // 已处理的数目 const toBePatched = e2 - s2 + 1; // 需要处理的数目 let moved = false; // 标记节点是否移动 let maxNewIndexSoFar = 0; // 辅助判断节点是否移动 const newIndexToOldIndexMap = new Array(toBePatched); for (i = 0; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = 0; for (i = s1; i &lt;= e1; i++) &#123; const prevChild = e1[i]; if (patched &gt;= toBePatched) &#123; // 卸载多余节点 unmount(prevChild, parentComponent, parentSuspense, true); continue; &#125; let nextIndex; newIndex = keyToNewIndexMap.get(prevChild.key); if (newIndex === undefined) &#123; // 新节点找不到则卸载 unmount(prevChild, parentComponent, parentAnchor, true); &#125; else &#123; newIndexToOldIndexMap[newIndex - s2] = i + 1; if (newIndex &gt;= maxNewIndexSoFar) &#123; maxNewIndexSoFar = newIndex; &#125; else &#123; moved = true; &#125; patch(prevChild, c2[newIndex], null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) patched++; &#125; &#125; &#125;&#125; 5.3 移动和新增const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) =&gt; &#123; let i = 0; // 当前对比索引 const l2 = c2.length; // 新节点长度 let e1 = c1.length - 1; // 旧节点结束标识 let e2 = l2 - 1; // 新节点介绍标识 // 1. 头对比 // ... // 2. 从尾部对比 // ... // 3. 仅新增 if(i &gt; e1) &#123; // ...&#125; // 4. 仅卸载 else if (i &gt; e2) &#123; // ... &#125; else &#123; const s1 = i; // 旧节点开始处理索引 const s2 = i; // 新节点开始处理索引 // 5.1 构建新节点key到index的映射 // ... // 5.2 处理旧节点（更新和卸载） // ... // 5.3 移动和新增 const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR; let j = increasingNewIndexSequence.length - 1; for (i = toBePatched - 1; i &gt;= 0; i--) &#123; const nextIndex = s2 + i; const nextChild = c2[nextIndex]; const anchor = nextIndex + 1 &lt; l2 ? c2[nextIndex].el : parentAnchor; if (newIndexToOldIndexMap[i] === 0) &#123; patch(null, nextChild, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized); &#125; else if (moved) &#123; if (j &lt; 0 || i !== increasingNewIndexSequence[j]) &#123; moved(nextChild, container, anchor, MoveType.REORDER); &#125; else &#123; j--; &#125; &#125; &#125;&#125; 优化思考 唯一标识: 我们使用 v-for 编写列表时为什么不建议使用 index 作为 key? 总结希望本文能够帮助读者深入理解基于数组子节点的Diff更新流程，并在实际项目中应用这一知识，提升应用的性能和用户体验","categories":[],"tags":[]},{"title":"vue2中nextTick的实现","slug":"源码/vue2/vue2_nextTeck","date":"2024-03-21T12:56:44.097Z","updated":"2024-03-29T15:13:35.007Z","comments":true,"path":"2024/03/21/源码/vue2/vue2_nextTeck/","link":"","permalink":"https://sanxun8.github.io/2024/03/21/%E6%BA%90%E7%A0%81/vue2/vue2_nextTeck/","excerpt":"","text":"const inBrowser = typeof window !== &#x27;undefined&#x27; &amp;&amp; Object.prototype.toString.call(window) !== &#x27;[object Object]&#x27;;const nextTick = (function () &#123; let callbacks = []; let pendding = false; let timeFunc; function nextTickHandler() &#123; pendding = false; const copies = callbacks.slice(0); callbacks = []; for (let i = 0; i &lt; copies.length; i++) &#123; copies[i](); &#125; &#125; if (typeof MutationObserver === &#x27;undefined&#x27;) &#123; // cb同步执行 let counter = 1; const observer = new MutationObserver(nextTickHandler) const textNode = document.createTextNode(String(counter)); observer.observe(textNode, &#123; characterData: true, &#125;); timeFunc = function () &#123; counter = (counter + 1) % 2; textNode.data = String(counter); &#125; &#125; else &#123; // cb同步执行 const context = inBrowser ? window : typeof global !== &#x27;undefined&#x27; ? global : &#123;&#125;; timeFunc = context.setImmediate || setTimeout; &#125; return function(cb, ctx) &#123; const func = ctx ? function() &#123;cb.call(ctx);&#125; : cb; callbacks.push(func); if(pendding) return; pendding = true; timeFunc(nextTickHandler, 0) &#125;&#125;)()","categories":[],"tags":[]},{"title":"中介者模式：简化对象间的通信","slug":"设计模式/中介者模式","date":"2024-03-19T06:12:59.572Z","updated":"2024-03-25T09:55:19.471Z","comments":true,"path":"2024/03/19/设计模式/中介者模式/","link":"","permalink":"https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"中介者模式（Mediator Pattern）是一种行为型设计模式，用于解耦多个对象之间的通信，并将其集中处理。通过引入一个中介者对象，各个对象不再直接相互通信，而是通过中介者进行交互。这种模式可以减少对象间的耦合度，提高系统的可维护性和灵活性。 示例场景(vue2中收集响应式依赖, 通过Dep类集中处理依赖更新)// 中介模式let uid = 0; // 使用闭包实现唯一标识class Dep &#123; constructor() &#123; this.id = uid++; this.subs = []; &#125; addSub(sub) &#123; this.subs.push(sub); &#125; removeSub(sub) &#123; remove(this.subs, sub); // 一个工具函数 &#125; depend() &#123; if (Dep.target) &#123; Dep.target.addDep(this); &#125; &#125; notify() &#123; const subs = this.subs.slice(); for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update(); // 调用Watcher.prototype.addDep &#125; &#125;&#125;// 视图模型对象class Watcher &#123; addDep(dep) &#123; dep.addSub(this); &#125; update() &#123; // 更新视图 &#125;&#125;// 模型对象function defineReacitve(obj, key, value, customSetter) &#123; const dep = new Dep() Object.defineProperty(obj, key, &#123; enumeralbe: true, configurable: true, get: function () &#123; if(Dep.target) &#123; dep.depend() // 收集 &#125; &#125;, set: function () &#123; dep.notify(); // 通知 &#125;, &#125;)&#125; 该案例中使用了Dep类充当中介者角色, 模型对象不直接与视图模型对象直接通信, 避免了响应式数据挟持后书写视图更新的负责逻辑代码; 其他场景假设我们正在开发一个聊天室应用程序，其中包含多个用户（User）和一个聊天室（ChatRoom）。用户之间可以相互发送消息，同时聊天室也可以将消息广播给所有用户。 在这个场景中，可以使用中介者模式来简化用户和聊天室之间的通信。聊天室充当中介者，用户充当同事类。用户之间的消息不再直接发送给其他用户，而是通过聊天室中介者进行转发。 总结 中介者模式的核心思想是将对象间的通信行为集中管理，通过引入一个中介者对象来协调各个对象之间的交互。 中介者模式的核心组成部分: 中介者, 交互对象(可能是同事类); 结语在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。 通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。 敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。","categories":[],"tags":[]},{"title":"建造者模式：构建复杂对象的灵活设计模式","slug":"设计模式/建造者模式","date":"2024-03-19T06:12:53.157Z","updated":"2024-03-25T10:01:31.331Z","comments":true,"path":"2024/03/19/设计模式/建造者模式/","link":"","permalink":"https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。示例场景(创建一个计算机对象)// Product: 表示要构建的复杂对象​class Computer &#123;​ constructor() &#123;​ this.cpu = &quot;&quot;;​ this.gpu = &quot;&quot;;​ this.ram = 0;​ this.storage = &quot;&quot;;​ &#125;​​ describe() &#123;​ return `Computer with CPU: $&#123;this.cpu&#125;, GPU: $&#123;this.gpu&#125;, RAM: $&#123;this.ram&#125;GB, Storage: $&#123;this.storage&#125;`;​ &#125;​&#125;​​// Builder: 声明构建复杂对象的接口​class ComputerBuilder &#123;​ constructor() &#123;​ this.computer = new Computer();​ &#125;​​ setCPU() &#123;​ this.computer.cpu = &quot;AMD 5600G&quot;;​ return this;​ &#125;​​ setGPU() &#123;​ this.computer.gpu = &quot;核显&quot;;​ return this;​ &#125;​​ setRAM() &#123;​ this.computer.ram = 16;​ return this;​ &#125;​​ setStorage() &#123;​ this.computer.storage = &quot;500G&quot;;​ return this;​ &#125;​​ build() &#123;​ return this.computer;​ &#125;​&#125;​​// Director: 负责使用 Builder 构建对象​class ComputerEngineer &#123;​ constructComputer(builder) &#123;​ return builder​ .setCPU()​ .setGPU()​ .setRAM()​ .setStorage()​ .build();​ &#125;​&#125;​​// 使用建造者模式创建复杂对象​const engineer = new ComputerEngineer();​const builder = new ComputerBuilder();​​const computer = engineer.constructComputer(builder);​ 总结 建造者模式的核心思想是将对象的构建过程和表示分离; 建造者模式的核心组成部分是: 构建对象类, 构建器类, 指挥者类; 结语在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。 通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。 敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。","categories":[],"tags":[]},{"title":"工厂模式：灵活创建对象的设计模式","slug":"设计模式/工厂模式","date":"2024-03-19T06:12:52.958Z","updated":"2024-03-24T10:50:30.808Z","comments":true,"path":"2024/03/19/设计模式/工厂模式/","link":"","permalink":"https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"工厂模式是一种创建型设计模式，它通过使用工厂方法或抽象工厂，将对象的实例化过程封装起来，使得客户端与具体的对象创建过程解耦。工厂模式可以根据不同的条件或参数来创建不同的对象，提供了一种灵活的对象创建方式。 实现工厂模式的方式简单工厂模式// 工厂类class ShapeFactory &#123; createShape(type) &#123; if(type === &#x27;circle&#x27;) &#123; return new Circle(); &#125; else if(type === &#x27;rectangle&#x27;) &#123; return new Rectangle(); &#125; else &#123; throw new Error(&#x27;无效的形状&#x27;); &#125; &#125;&#125;class Shape &#123; draw() &#123; throw new Error(&#x27;绘制接口必须实现&#x27;); &#125;&#125;// 不同的具体产品class Circle extends Shape &#123; draw() &#123; console.log(&#x27;绘制圆&#x27;); &#125;&#125;class Rectangle extends Shape &#123; draw() &#123; console.log(&#x27;绘制矩形&#x27;); &#125;&#125;const circle = new ShapeFactory(&#x27;circle&#x27;);const rectangle = new ShapeFactory(&#x27;rectangle&#x27;); 工厂方法模式// 工厂类class ShapeFactory &#123; createShape(type) &#123; throw new Error(&#x27;创建形状接口必须实现&#x27;); &#125;&#125;class CircleFactory extends ShapeFactory &#123; createShape() &#123; return new Circle(); &#125;&#125;class RectangleFactory extends ShapeFactory &#123; createShape() &#123; return new Rectangle(); &#125;&#125;class Shape &#123; draw() &#123; throw new Error(&#x27;绘制接口必须实现&#x27;); &#125;&#125;// 不同的具体产品class Circle extends Shape &#123; draw() &#123; console.log(&#x27;绘制圆&#x27;); &#125;&#125;class Rectangle extends Shape &#123; draw() &#123; console.log(&#x27;绘制矩形&#x27;); &#125;&#125;const circle = new CircleFactory();const rectangle = new RectFactory(); 抽象工厂模式// 工厂类class H5Factory &#123; createButton() &#123; return new H5Button(); &#125; createIcon() &#123; return new H5Icon(); &#125;&#125;class WxFactory &#123; createButton() &#123; return new WxButton(); &#125; createIcon() &#123; return new WxIcon(); &#125;&#125;// 不同的具体产品class H5Button &#123; description() &#123; console.log(&#x27;这是个按钮&#x27;); &#125;&#125;class H5Icon &#123; description() &#123; console.log(&#x27;这是个图标&#x27;); &#125;&#125;class WxButton &#123; description() &#123; console.log(&#x27;这是个按钮&#x27;); &#125;&#125;class WxIcon &#123; description() &#123; console.log(&#x27;这是个图标&#x27;); &#125;&#125;const h5Factory = new H5Factory();const wxFactory = new wxFactory();const h5Button = new h5Factory.createButton();const h5Icon = new h5Factory.createIcon(); 简单工厂、工厂方法、抽象工厂模式的区别 关注点不同: 简单工厂使用一个接口创建所有产品； 工厂方法将产品实例化放到不同的工厂中，关注产品的从属性； 抽象工厂关注的是一个工厂包含多个产品对应的接口，关注的是产品族的创建； 组成结构不同： 简单工厂主要含有工厂类、具体产品类，工厂类下仅含有一个创建产品的接口； 工厂方法主要含有抽象工厂类、具体工厂类、具体产品类； 抽象工厂主要含有工厂类，具体产品A类，具体产品B类，工厂类下含有创建产品族的方法； 总结 工厂模式的核心思想是将对象的实例化过程封装起来，通过一个接口进行实例化，使得客户端与具体的对象创建过程解耦。 结语在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。 通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。 敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。","categories":[],"tags":[]},{"title":"单例模式：实现全局唯一实例的设计模式","slug":"设计模式/单例模式","date":"2024-03-19T06:12:52.789Z","updated":"2024-03-23T09:30:29.280Z","comments":true,"path":"2024/03/19/设计模式/单例模式/","link":"","permalink":"https://sanxun8.github.io/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式是一种常见的设计模式，它通过限制类的实例化次数，确保只有一个实例存在。 示例场景(vue3创建渲染器)let renderer;function ensureRenderer() &#123; return renderer || createRender(rendererOptions);&#125; 其他实现方式由于 JavaScript 的事件循环机制和单线程执行，实现单例模式考虑的没那那么复杂，实现起来比较简单。 // 方式一const Singleton = (function() &#123; let instance; function createInstance() &#123; return new Object(&#x27;I am the instance&#x27;); &#125; return &#123; getInstance: function() &#123; if(!instance) &#123; instance = createInstance(); &#125; return instance; &#125; &#125;&#125;)const instance = Singleton.getInstance();// 方式二，直接使用对象字面量const messageManager = &#123; success() &#123;&#125;, error() &#123;&#125;,&#125;Object.freeze(messageManager) 其他场景 全局配置：单例模式可以用于管理全局的配置信息，确保在应用中只有一个配置实例被使用。 日志记录器：单例模式可以用于创建全局唯一的日志记录器，方便在应用中统一管理和记录日志信息 总结 单例模式的核心思想是需要确保一个类只有一个实例。 结语在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。 通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。 敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。","categories":[],"tags":[]},{"title":"渲染器：数据访问是如何被代理的？","slug":"源码/vue3/3-渲染器-数据访问是如何被代理的","date":"2024-03-13T13:19:55.092Z","updated":"2024-03-20T00:50:15.318Z","comments":true,"path":"2024/03/13/源码/vue3/3-渲染器-数据访问是如何被代理的/","link":"","permalink":"https://sanxun8.github.io/2024/03/13/%E6%BA%90%E7%A0%81/vue3/3-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84/","excerpt":"","text":"渲染器：数据访问是如何被代理的？源码定义: 对组件实例上下文进行代理function setupStatefulComponent(instance, isSSR) &#123; instance.accessCache = Object.create(null) instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers))&#125; PublicInstanceProxyHandlers.getconst PublicInstanceProxyHandlers = &#123; get(&#123; _: instance &#125;, key) &#123; const &#123; ctx, setupState, data, props, accessCache, type, appContext &#125; = instance if (__DEV__ &amp;&amp; key === &#x27;__isVue&#x27;) &#123; return true &#125; let normalizedProps; // 预定义模块所需变量 if (key[0] !== &#x27;$&#x27;) &#123; // 处理非预留属性 const n = accessCache[key] // 读取缓存内容 if (n !== undefined) &#123; switch (n) &#123; case AccessTypes.SETUP: return setupState[key] case AccessTypes.DATA: return data[key] case AccessTypes.CONTEXT: return ctx[key] case AccessTypes.PROPS: return props[key] &#125; &#125; else if (hasSetupBinding(setupState, key)) &#123; accessCache![key] = AccessTypes.SETUP return setupState[key] &#125; else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123; accessCache![key] = AccessTypes.DATA return data[key] &#125; else if ( (normalizedProps = instance.propsOptions[0]) &amp;&amp; hasOwn(normalizedProps, key) ) &#123; accessCache![key] = AccessTypes.PROPS return props![key] &#125; else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123; accessCache![key] = AccessTypes.CONTEXT return ctx[key] &#125; else if (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) &#123; accessCache![key] = AccessTypes.OTHER &#125; &#125; const publicGetter = publicPropertiesMap[key] // 开始处理预留属性 let cssModule, globalProperties if (publicGetter) &#123; // $保留字开头的相关逻辑 &#125; else if ( (cssModule = type.__cssModules) &amp;&amp; (cssModule = cssModule[key]) ) &#123; return cssModule &#125; else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123; accessCache![key] = AccessTypes.CONTEXT return ctx[key] &#125; else if ( ((globalProperties = appContext.config.globalProperties), hasOwn(globalProperties, key)) ) &#123; if (__COMPAT__) &#123; const desc = Object.getOwnPropertyDescriptor(globalProperties, key)! if (desc.get) &#123; return desc.get.call(instance.proxy) &#125; else &#123; const val = globalProperties[key] return isFunction(val) ? Object.assign(val.bind(instance.proxy), val) : val &#125; &#125; else &#123; return globalProperties[key] &#125; &#125; else if ( // 一些告警 &#125; &#125;&#125; 笔记 访问顺序为setupState》data》prop》ctx 使用空间换时间进行了优化，使用accessCache标记key存在于哪个属性上，减少了频繁调用hasOwn耗费性能。 PublicInstanceProxyHandlers .getconst PublicInstanceProxyHandlers = &#123; set(&#123; _: instance &#125;, key, value) &#123; const &#123; data, setupState, ctx &#125; = instance if (hasSetupBinding(setupState, key)) &#123; setupState[key] = value return true &#125; else if ( __DEV__ &amp;&amp; setupState.__isScriptSetup &amp;&amp; hasOwn(setupState, key) ) &#123; warn(`Cannot mutate &lt;script setup&gt; binding &quot;$&#123;key&#125;&quot; from Options API.`) return false &#125; else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123; data[key] = value return true &#125; else if (hasOwn(instance.props, key)) &#123; __DEV__ &amp;&amp; warn(`Attempting to mutate prop &quot;$&#123;key&#125;&quot;. Props are readonly.`) return false &#125; if (key[0] === &#x27;$&#x27; &amp;&amp; key.slice(1) in instance) &#123; __DEV__ &amp;&amp; warn( `Attempting to mutate public property &quot;$&#123;key&#125;&quot;. ` + `Properties starting with $ are reserved and readonly.`, ) return false &#125; else &#123; if (__DEV__ &amp;&amp; key in instance.appContext.config.globalProperties) &#123; Object.defineProperty(ctx, key, &#123; enumerable: true, configurable: true, value, &#125;) &#125; else &#123; ctx[key] = value &#125; &#125; return true &#125;,&#125; 结论： 更改顺序为：setupState 》data 》props 》globalProperties PublicInstanceProxyHandlers .hasconst PublicInstanceProxyHandlers = &#123; has(&#123;_: &#123; data, setupState, accessCache, ctx, appContext, propsOptions &#125;&#125;, key) &#123; let normalizedProps return ( !!accessCache[key] || (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) || hasSetupBinding(setupState, key) || ((normalizedProps = propsOptions[0]) &amp;&amp; hasOwn(normalizedProps, key)) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || // $保留字开头的函数 hasOwn(appContext.config.globalProperties, key) ) &#125;,&#125; 结论： 访问顺序为data 》setupState》props》ctx》publicPropertiesMap》globalProperties","categories":[],"tags":[]}],"categories":[],"tags":[]}