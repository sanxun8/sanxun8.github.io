<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>中介者模式：简化对象间的通信</title>
      <link href="/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>中介者模式（Mediator Pattern）是一种行为型设计模式，用于解耦多个对象之间的通信，并将其集中处理。通过引入一个中介者对象，各个对象不再直接相互通信，而是通过中介者进行交互。这种模式可以减少对象间的耦合度，提高系统的可维护性和灵活性。</p><hr><h3 id="示例场景-vue2中收集响应式依赖-通过Dep类集中处理依赖更新"><a href="#示例场景-vue2中收集响应式依赖-通过Dep类集中处理依赖更新" class="headerlink" title="示例场景(vue2中收集响应式依赖, 通过Dep类集中处理依赖更新)"></a>示例场景(vue2中收集响应式依赖, 通过Dep类集中处理依赖更新)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中介模式</span></span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span>; <span class="comment">// 使用闭包实现唯一标识</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = uid++;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addSub</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">removeSub</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">    <span class="title function_">remove</span>(<span class="variable language_">this</span>.<span class="property">subs</span>, sub); <span class="comment">// 一个工具函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">depend</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">      <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">addDep</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">slice</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].<span class="title function_">update</span>();  <span class="comment">// 调用Watcher.prototype.addDep</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图模型对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">    <span class="title function_">addDep</span>(<span class="params">dep</span>) &#123;</span><br><span class="line">        dep.<span class="title function_">addSub</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 更新视图</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模型对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReacitve</span>(<span class="params">obj, key, value, customSetter</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="attr">enumeralbe</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">                dep.<span class="title function_">depend</span>() <span class="comment">// 收集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            dep.<span class="title function_">notify</span>(); <span class="comment">// 通知</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该案例中使用了<strong>Dep类</strong>充当中介者角色, <strong>模型对象</strong>不直接与<strong>视图模型对象</strong>直接通信, 避免了响应式数据挟持后书写视图更新的负责逻辑代码;</p><h3 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h3><p>假设我们正在开发一个聊天室应用程序，其中包含多个用户（User）和一个聊天室（ChatRoom）。用户之间可以相互发送消息，同时聊天室也可以将消息广播给所有用户。</p><p>在这个场景中，可以使用中介者模式来简化用户和聊天室之间的通信。聊天室充当中介者，用户充当同事类。用户之间的消息不再直接发送给其他用户，而是通过聊天室中介者进行转发。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>中介者模式的核心思想是将对象间的通信行为集中管理，通过引入一个中介者对象来协调各个对象之间的交互。</li><li>中介者的核心组成部分: 中介者, 交互对象(可能是同事类);</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。</p><p>通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。</p><p>敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>渲染器：数据访问是如何被代理的？</title>
      <link href="/2024/03/13/%E6%BA%90%E7%A0%81/3-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84/"/>
      <url>/2024/03/13/%E6%BA%90%E7%A0%81/3-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="渲染器：数据访问是如何被代理的？"><a href="#渲染器：数据访问是如何被代理的？" class="headerlink" title="渲染器：数据访问是如何被代理的？"></a>渲染器：数据访问是如何被代理的？</h2><h3 id="源码定义-对组件实例上下文进行代理"><a href="#源码定义-对组件实例上下文进行代理" class="headerlink" title="源码定义: 对组件实例上下文进行代理"></a>源码定义: 对组件实例上下文进行代理</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setupStatefulComponent</span>(<span class="params">instance, isSSR</span>) &#123;</span><br><span class="line">  instance.<span class="property">accessCache</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">  instance.<span class="property">proxy</span> = <span class="title function_">markRaw</span>(<span class="keyword">new</span> <span class="title class_">Proxy</span>(instance.<span class="property">ctx</span>, <span class="title class_">PublicInstanceProxyHandlers</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PublicInstanceProxyHandlers-get"><a href="#PublicInstanceProxyHandlers-get" class="headerlink" title="PublicInstanceProxyHandlers.get"></a>PublicInstanceProxyHandlers.get</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const PublicInstanceProxyHandlers = &#123;</span><br><span class="line">  get(&#123; _: instance &#125;, key) &#123;</span><br><span class="line">    const &#123; ctx, setupState, data, props, accessCache, type, appContext &#125; = instance</span><br><span class="line">    if (__DEV__ &amp;&amp; key === &#x27;__isVue&#x27;) &#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let normalizedProps;  // 预定义模块所需变量</span><br><span class="line">    if (key[0] !== &#x27;$&#x27;) &#123; // 处理非预留属性</span><br><span class="line">      const n = accessCache[key] // 读取缓存内容</span><br><span class="line">      if (n !== undefined) &#123;</span><br><span class="line">        switch (n) &#123;</span><br><span class="line">          case AccessTypes.SETUP:</span><br><span class="line">            return setupState[key]</span><br><span class="line">          case AccessTypes.DATA:</span><br><span class="line">            return data[key]</span><br><span class="line">          case AccessTypes.CONTEXT:</span><br><span class="line">            return ctx[key]</span><br><span class="line">          case AccessTypes.PROPS:</span><br><span class="line">            return props[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (hasSetupBinding(setupState, key)) &#123;</span><br><span class="line">        accessCache![key] = AccessTypes.SETUP</span><br><span class="line">        return setupState[key]</span><br><span class="line">      &#125; else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123;</span><br><span class="line">        accessCache![key] = AccessTypes.DATA</span><br><span class="line">        return data[key]</span><br><span class="line">      &#125; else if (</span><br><span class="line">        (normalizedProps = instance.propsOptions[0]) &amp;&amp;</span><br><span class="line">        hasOwn(normalizedProps, key)</span><br><span class="line">      ) &#123;</span><br><span class="line">        accessCache![key] = AccessTypes.PROPS</span><br><span class="line">        return props![key]</span><br><span class="line">      &#125; else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123;</span><br><span class="line">        accessCache![key] = AccessTypes.CONTEXT</span><br><span class="line">        return ctx[key]</span><br><span class="line">      &#125; else if (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) &#123;</span><br><span class="line">        accessCache![key] = AccessTypes.OTHER</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const publicGetter = publicPropertiesMap[key] // 开始处理预留属性</span><br><span class="line">    let cssModule, globalProperties</span><br><span class="line">    if (publicGetter) &#123;</span><br><span class="line">      // $保留字开头的相关逻辑</span><br><span class="line">    &#125; else if (</span><br><span class="line">      (cssModule = type.__cssModules) &amp;&amp;</span><br><span class="line">      (cssModule = cssModule[key])</span><br><span class="line">    ) &#123;</span><br><span class="line">      return cssModule</span><br><span class="line">    &#125; else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123;</span><br><span class="line">      accessCache![key] = AccessTypes.CONTEXT</span><br><span class="line">      return ctx[key]</span><br><span class="line">    &#125; else if (</span><br><span class="line">      ((globalProperties = appContext.config.globalProperties),</span><br><span class="line">        hasOwn(globalProperties, key))</span><br><span class="line">    ) &#123;</span><br><span class="line">      if (__COMPAT__) &#123;</span><br><span class="line">        const desc = Object.getOwnPropertyDescriptor(globalProperties, key)!</span><br><span class="line">        if (desc.get) &#123;</span><br><span class="line">          return desc.get.call(instance.proxy)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          const val = globalProperties[key]</span><br><span class="line">          return isFunction(val)</span><br><span class="line">            ? Object.assign(val.bind(instance.proxy), val)</span><br><span class="line">            : val</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return globalProperties[key]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (</span><br><span class="line">      // 一些告警</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h4><ol><li>访问顺序为<code>setupState</code>》<code>data</code>》<code>prop</code>》<code>ctx</code></li><li>使用<code>空间换时间</code>进行了优化，使用<code>accessCache</code>标记<code>key</code>存在于哪个属性上，减少了频繁调用<code>hasOwn</code>耗费性能。</li></ol><h3 id="PublicInstanceProxyHandlers-get-1"><a href="#PublicInstanceProxyHandlers-get-1" class="headerlink" title="PublicInstanceProxyHandlers .get"></a>PublicInstanceProxyHandlers .get</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const PublicInstanceProxyHandlers = &#123;</span><br><span class="line">  set(&#123; _: instance &#125;, key, value) &#123;</span><br><span class="line">    const &#123; data, setupState, ctx &#125; = instance</span><br><span class="line">    if (hasSetupBinding(setupState, key)) &#123;</span><br><span class="line">      setupState[key] = value</span><br><span class="line">      return true</span><br><span class="line">    &#125; else if (</span><br><span class="line">      __DEV__ &amp;&amp;</span><br><span class="line">      setupState.__isScriptSetup &amp;&amp;</span><br><span class="line">      hasOwn(setupState, key)</span><br><span class="line">    ) &#123;</span><br><span class="line">      warn(`Cannot mutate &lt;script setup&gt; binding &quot;$&#123;key&#125;&quot; from Options API.`)</span><br><span class="line">      return false</span><br><span class="line">    &#125; else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123;</span><br><span class="line">      data[key] = value</span><br><span class="line">      return true</span><br><span class="line">    &#125; else if (hasOwn(instance.props, key)) &#123;</span><br><span class="line">      __DEV__ &amp;&amp; warn(`Attempting to mutate prop &quot;$&#123;key&#125;&quot;. Props are readonly.`)</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">    if (key[0] === &#x27;$&#x27; &amp;&amp; key.slice(1) in instance) &#123;</span><br><span class="line">      __DEV__ &amp;&amp;</span><br><span class="line">      warn(</span><br><span class="line">        `Attempting to mutate public property &quot;$&#123;key&#125;&quot;. ` +</span><br><span class="line">        `Properties starting with $ are reserved and readonly.`,</span><br><span class="line">      )</span><br><span class="line">      return false</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (__DEV__ &amp;&amp; key in instance.appContext.config.globalProperties) &#123;</span><br><span class="line">        Object.defineProperty(ctx, key, &#123;</span><br><span class="line">          enumerable: true,</span><br><span class="line">          configurable: true,</span><br><span class="line">          value,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        ctx[key] = value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong> 更改顺序为：<code>setupState</code> 》<code>data</code> 》<code>props</code> 》<code>globalProperties</code></p><h3 id="PublicInstanceProxyHandlers-has"><a href="#PublicInstanceProxyHandlers-has" class="headerlink" title="PublicInstanceProxyHandlers .has"></a>PublicInstanceProxyHandlers .has</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const PublicInstanceProxyHandlers = &#123;</span><br><span class="line">  has(&#123;_: &#123; data, setupState, accessCache, ctx, appContext, propsOptions &#125;&#125;, key) &#123;</span><br><span class="line">    let normalizedProps</span><br><span class="line">    return (</span><br><span class="line">      !!accessCache[key] ||</span><br><span class="line">      (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) ||</span><br><span class="line">      hasSetupBinding(setupState, key) ||</span><br><span class="line">      ((normalizedProps = propsOptions[0]) &amp;&amp; hasOwn(normalizedProps, key)) ||</span><br><span class="line">      hasOwn(ctx, key) ||</span><br><span class="line">      hasOwn(publicPropertiesMap, key) || // $保留字开头的函数</span><br><span class="line">      hasOwn(appContext.config.globalProperties, key)</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong> 访问顺序为<code>data </code>》<code>setupState</code>》<code>props</code>》<code>ctx</code>》<code>publicPropertiesMap</code>》<code>globalProperties</code></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
