<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数组节点中的Dom Diff</title>
      <link href="/2024/03/22/%E6%BA%90%E7%A0%81/vue3_dom_diff/"/>
      <url>/2024/03/22/%E6%BA%90%E7%A0%81/vue3_dom_diff/</url>
      
        <content type="html"><![CDATA[<p>在前端开发中，我们经常需要处理包含数组子节点的动态列表或复杂组件。本文将基于源码，梳理数组子节点的Diff更新流程，帮助读者更好地理解Vue3是如何通过Diff算法来高效地更新这些子节点，以提升应用性能。</p><h3 id="从头对比"><a href="#从头对比" class="headerlink" title="从头对比"></a>从头对比</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 当前对比索引</span></span><br><span class="line">    <span class="keyword">const</span> l2 = c2.<span class="property">length</span>; <span class="comment">// 新节点长度</span></span><br><span class="line">    <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 旧节点结束标识</span></span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>; <span class="comment">// 新节点介绍标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 头对比</span></span><br><span class="line">    <span class="comment">// (a b) c</span></span><br><span class="line">    <span class="comment">// (a b) d e</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; e1 &amp;&amp; i &lt; e2) &#123;</span><br><span class="line">        <span class="keyword">const</span> n1 = c1[i];</span><br><span class="line">        <span class="keyword">const</span> n2 = c2[i] = optimized ? <span class="title function_">cloneIfMounted</span>(c2[i]) : <span class="title function_">normalizeVNode</span>(c2[i]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class="line">            <span class="title function_">patch</span>(n1, n2, container, <span class="literal">null</span>, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从尾部对比"><a href="#从尾部对比" class="headerlink" title="从尾部对比"></a>从尾部对比</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 当前对比索引</span></span><br><span class="line">    <span class="keyword">const</span> l2 = c2.<span class="property">length</span>; <span class="comment">// 新节点长度</span></span><br><span class="line">    <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 旧节点结束标识</span></span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>; <span class="comment">// 新节点介绍标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 头对比</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 尾对比</span></span><br><span class="line">    <span class="comment">// a (b c)</span></span><br><span class="line">    <span class="comment">// d e (b c)</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; e1 &amp;&amp; i &lt; e2) &#123;</span><br><span class="line">        <span class="keyword">const</span> n1 = c1[e1];</span><br><span class="line">        <span class="keyword">const</span> n2 = c2[e2] = optimized ? <span class="title function_">cloneIfMounted</span>(c2[e2]) : <span class="title function_">normalizeVNode</span>(c2[e2]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class="line">            <span class="title function_">patch</span>(n1, n2, container, <span class="literal">null</span>, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        e1--;</span><br><span class="line">        e2--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="仅处理新增"><a href="#仅处理新增" class="headerlink" title="仅处理新增"></a>仅处理新增</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 当前对比索引</span></span><br><span class="line">    <span class="keyword">const</span> l2 = c2.<span class="property">length</span>; <span class="comment">// 新节点长度</span></span><br><span class="line">    <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 旧节点结束标识</span></span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>; <span class="comment">// 新节点介绍标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 头对比</span></span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    <span class="comment">// 2. 从尾部对比</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 仅新增</span></span><br><span class="line">    <span class="comment">// (a b)</span></span><br><span class="line">    <span class="comment">// (a b) c</span></span><br><span class="line">    <span class="comment">// i = 2, e1 = 1, e2 = 2</span></span><br><span class="line">    <span class="comment">// (a b)</span></span><br><span class="line">    <span class="comment">// c (a b)</span></span><br><span class="line">    <span class="comment">// i = 0, e1 = -1, e2 = 0</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; e1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= e2) &#123;</span><br><span class="line">            <span class="keyword">const</span> nextPos = e2 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">const</span> anchor = nextPos &lt; l2 ? c2[nextPos].<span class="property">el</span> : parentAnchor;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= e2) &#123;</span><br><span class="line">                <span class="title function_">patch</span>(<span class="literal">null</span>, c2[i] = optimized ? <span class="title function_">cloneIfMounted</span>(c2[i]) : <span class="title function_">normalizeVNode</span>(c2[i]), container, anchor, parentComponent, parentSuspense)</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="仅处理卸载"><a href="#仅处理卸载" class="headerlink" title="仅处理卸载"></a>仅处理卸载</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 当前对比索引</span></span><br><span class="line">    <span class="keyword">const</span> l2 = c2.<span class="property">length</span>; <span class="comment">// 新节点长度</span></span><br><span class="line">    <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 旧节点结束标识</span></span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>; <span class="comment">// 新节点介绍标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 头对比</span></span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    <span class="comment">// 2. 从尾部对比</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 3. 仅新增</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; e1) &#123; <span class="comment">// ...&#125; </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 仅卸载</span></span><br><span class="line">    <span class="comment">// (a b) c</span></span><br><span class="line">    <span class="comment">// (a b)</span></span><br><span class="line">    <span class="comment">// i = 2, e1 = 2, e2 = 1</span></span><br><span class="line">    <span class="comment">// a (b c)</span></span><br><span class="line">    <span class="comment">// (b c)</span></span><br><span class="line">    <span class="comment">// i = 0, e1 = 0, e2 = -1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= e1) &#123;</span><br><span class="line">            <span class="title function_">unmount</span>(c1[i], parentComponent, parentAnchor, <span class="literal">true</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理未知序列"><a href="#处理未知序列" class="headerlink" title="处理未知序列"></a>处理未知序列</h3><h4 id="构建新节点key到index的映射"><a href="#构建新节点key到index的映射" class="headerlink" title="构建新节点key到index的映射"></a>构建新节点key到index的映射</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 当前对比索引</span></span><br><span class="line">    <span class="keyword">const</span> l2 = c2.<span class="property">length</span>; <span class="comment">// 新节点长度</span></span><br><span class="line">    <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 旧节点结束标识</span></span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>; <span class="comment">// 新节点介绍标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 头对比</span></span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    <span class="comment">// 2. 从尾部对比</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 3. 仅新增</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; e1) &#123; <span class="comment">// ...&#125; </span></span><br><span class="line">    <span class="comment">// 4. 仅卸载</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123; <span class="comment">// ... &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> s1 = i; <span class="comment">// 旧节点开始处理索引</span></span><br><span class="line">        <span class="keyword">const</span> s2 = i; <span class="comment">// 新节点开始处理索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.1 构建新节点key到index的映射</span></span><br><span class="line">        <span class="keyword">const</span> keyToNewIndexMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">        <span class="keyword">for</span> (i = s2; i &lt;= e2; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> nextChild = c2[i] = optimized ? <span class="title function_">cloneIfMounted</span>(c2[i]) : <span class="title function_">normalizeVNode</span>(c2[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nextChild.<span class="property">key</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">                keyToNewIndexMap.<span class="title function_">set</span>(nextChild.<span class="property">key</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-处理旧节点（更新和卸载）"><a href="#5-2-处理旧节点（更新和卸载）" class="headerlink" title="5.2 处理旧节点（更新和卸载）"></a>5.2 处理旧节点（更新和卸载）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 当前对比索引</span></span><br><span class="line">    <span class="keyword">const</span> l2 = c2.<span class="property">length</span>; <span class="comment">// 新节点长度</span></span><br><span class="line">    <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 旧节点结束标识</span></span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>; <span class="comment">// 新节点介绍标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 头对比</span></span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    <span class="comment">// 2. 从尾部对比</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 3. 仅新增</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; e1) &#123; <span class="comment">// ...&#125; </span></span><br><span class="line">    <span class="comment">// 4. 仅卸载</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123; <span class="comment">// ... &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> s1 = i; <span class="comment">// 旧节点开始处理索引</span></span><br><span class="line">        <span class="keyword">const</span> s2 = i; <span class="comment">// 新节点开始处理索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.1 构建新节点key到index的映射</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.2 处理旧节点（更新和卸载）</span></span><br><span class="line">        <span class="keyword">let</span> patched = <span class="number">0</span>; <span class="comment">// 已处理的数目</span></span><br><span class="line">        <span class="keyword">const</span> toBePatched = e2 - s2 + <span class="number">1</span>; <span class="comment">// 需要处理的数目</span></span><br><span class="line">        <span class="keyword">let</span> moved = <span class="literal">false</span>; <span class="comment">// 标记节点是否移动</span></span><br><span class="line">        <span class="keyword">let</span> maxNewIndexSoFar = <span class="number">0</span>; <span class="comment">// 辅助判断节点是否移动</span></span><br><span class="line">        <span class="keyword">const</span> newIndexToOldIndexMap = <span class="keyword">new</span> <span class="title class_">Array</span>(toBePatched);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = s1; i &lt;= e1; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> prevChild = e1[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (patched &gt;= toBePatched) &#123; <span class="comment">// 卸载多余节点</span></span><br><span class="line">                <span class="title function_">unmount</span>(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> nextIndex;</span><br><span class="line">            newIndex = keyToNewIndexMap.<span class="title function_">get</span>(prevChild.<span class="property">key</span>);</span><br><span class="line">            <span class="keyword">if</span> (newIndex === <span class="literal">undefined</span>) &#123; <span class="comment">// 新节点找不到则卸载</span></span><br><span class="line">                <span class="title function_">unmount</span>(prevChild, parentComponent, parentAnchor, <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newIndexToOldIndexMap[newIndex - s2] = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class="line">                    maxNewIndexSoFar = newIndex;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    moved = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_">patch</span>(prevChild, c2[newIndex], <span class="literal">null</span>, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)</span><br><span class="line">                patched++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-移动和新增"><a href="#5-3-移动和新增" class="headerlink" title="5.3 移动和新增"></a>5.3 移动和新增</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 当前对比索引</span></span><br><span class="line">    <span class="keyword">const</span> l2 = c2.<span class="property">length</span>; <span class="comment">// 新节点长度</span></span><br><span class="line">    <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 旧节点结束标识</span></span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>; <span class="comment">// 新节点介绍标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 头对比</span></span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    <span class="comment">// 2. 从尾部对比</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 3. 仅新增</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; e1) &#123; <span class="comment">// ...&#125; </span></span><br><span class="line">    <span class="comment">// 4. 仅卸载</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123; <span class="comment">// ... &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> s1 = i; <span class="comment">// 旧节点开始处理索引</span></span><br><span class="line">        <span class="keyword">const</span> s2 = i; <span class="comment">// 新节点开始处理索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.1 构建新节点key到index的映射</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 5.2 处理旧节点（更新和卸载）</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.3 移动和新增</span></span><br><span class="line">        <span class="keyword">const</span> increasingNewIndexSequence = moved ? <span class="title function_">getSequence</span>(newIndexToOldIndexMap) : <span class="variable constant_">EMPTY_ARR</span>;</span><br><span class="line">        <span class="keyword">let</span> j = increasingNewIndexSequence.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = toBePatched - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">const</span> nextIndex = s2 + i;</span><br><span class="line">            <span class="keyword">const</span> nextChild = c2[nextIndex];</span><br><span class="line">            <span class="keyword">const</span> anchor = nextIndex + <span class="number">1</span> &lt; l2 ? c2[nextIndex].<span class="property">el</span> : parentAnchor;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newIndexToOldIndexMap[i] === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="title function_">patch</span>(<span class="literal">null</span>, nextChild, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (moved) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; <span class="number">0</span> || i !== increasingNewIndexSequence[j]) &#123;</span><br><span class="line">                    <span class="title function_">moved</span>(nextChild, container, anchor, <span class="title class_">MoveType</span>.<span class="property">REORDER</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化思考"><a href="#优化思考" class="headerlink" title="优化思考"></a>优化思考</h4><ul><li>唯一标识: 我们使用 v-for 编写列表时为什么不建议使用 index 作为 key?</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>希望本文能够帮助读者深入理解基于数组子节点的Diff更新流程，并在实际项目中应用这一知识，提升应用的性能和用户体验</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>中介者模式：简化对象间的通信</title>
      <link href="/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>中介者模式（Mediator Pattern）是一种行为型设计模式，用于解耦多个对象之间的通信，并将其集中处理。通过引入一个中介者对象，各个对象不再直接相互通信，而是通过中介者进行交互。这种模式可以减少对象间的耦合度，提高系统的可维护性和灵活性。</p><hr><h3 id="示例场景-vue2中收集响应式依赖-通过Dep类集中处理依赖更新"><a href="#示例场景-vue2中收集响应式依赖-通过Dep类集中处理依赖更新" class="headerlink" title="示例场景(vue2中收集响应式依赖, 通过Dep类集中处理依赖更新)"></a>示例场景(vue2中收集响应式依赖, 通过Dep类集中处理依赖更新)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中介模式</span></span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span>; <span class="comment">// 使用闭包实现唯一标识</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = uid++;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addSub</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">removeSub</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">    <span class="title function_">remove</span>(<span class="variable language_">this</span>.<span class="property">subs</span>, sub); <span class="comment">// 一个工具函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">depend</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">      <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">addDep</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">slice</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].<span class="title function_">update</span>();  <span class="comment">// 调用Watcher.prototype.addDep</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图模型对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">    <span class="title function_">addDep</span>(<span class="params">dep</span>) &#123;</span><br><span class="line">        dep.<span class="title function_">addSub</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 更新视图</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模型对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReacitve</span>(<span class="params">obj, key, value, customSetter</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="attr">enumeralbe</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">                dep.<span class="title function_">depend</span>() <span class="comment">// 收集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            dep.<span class="title function_">notify</span>(); <span class="comment">// 通知</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该案例中使用了<strong>Dep类</strong>充当中介者角色, <strong>模型对象</strong>不直接与<strong>视图模型对象</strong>直接通信, 避免了响应式数据挟持后书写视图更新的负责逻辑代码;</p><h3 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h3><p>假设我们正在开发一个聊天室应用程序，其中包含多个用户（User）和一个聊天室（ChatRoom）。用户之间可以相互发送消息，同时聊天室也可以将消息广播给所有用户。</p><p>在这个场景中，可以使用中介者模式来简化用户和聊天室之间的通信。聊天室充当中介者，用户充当同事类。用户之间的消息不再直接发送给其他用户，而是通过聊天室中介者进行转发。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>中介者模式的核心思想是将对象间的通信行为集中管理，通过引入一个中介者对象来协调各个对象之间的交互。</li><li>中介者模式的核心组成部分: 中介者, 交互对象(可能是同事类);</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。</p><p>通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。</p><p>敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式：构建复杂对象的灵活设计模式</title>
      <link href="/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。"><a href="#建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。" class="headerlink" title="建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。"></a>建造者模式是一种创建型设计模式，它将对象的构建过程和表示分离，通过使用一个独立的“建造者”类来封装对象的构建过程。建造者模式允许我们通过一系列的步骤来构建复杂对象，每个步骤可以有不同的实现方式，从而创建不同的表示。</h2><h3 id="示例场景-创建一个计算机对象"><a href="#示例场景-创建一个计算机对象" class="headerlink" title="示例场景(创建一个计算机对象)"></a>示例场景(创建一个计算机对象)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Product: 表示要构建的复杂对象​</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;​</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cpu</span> = <span class="string">&quot;&quot;</span>;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">gpu</span> = <span class="string">&quot;&quot;</span>;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ram</span> = <span class="number">0</span>;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storage</span> = <span class="string">&quot;&quot;</span>;​</span><br><span class="line">  &#125;​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">describe</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Computer with CPU: <span class="subst">$&#123;<span class="variable language_">this</span>.cpu&#125;</span>, GPU: <span class="subst">$&#123;<span class="variable language_">this</span>.gpu&#125;</span>, RAM: <span class="subst">$&#123;<span class="variable language_">this</span>.ram&#125;</span>GB, Storage: <span class="subst">$&#123;<span class="variable language_">this</span>.storage&#125;</span>`</span>;​</span><br><span class="line">  &#125;​</span><br><span class="line">&#125;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// Builder: 声明构建复杂对象的接口​</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerBuilder</span> &#123;​</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">computer</span> = <span class="keyword">new</span> <span class="title class_">Computer</span>();​</span><br><span class="line">  &#125;​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">setCPU</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">computer</span>.<span class="property">cpu</span> = <span class="string">&quot;AMD 5600G&quot;</span>;​</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;​</span><br><span class="line">  &#125;​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">setGPU</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">computer</span>.<span class="property">gpu</span> = <span class="string">&quot;核显&quot;</span>;​</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;​</span><br><span class="line">  &#125;​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">setRAM</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">computer</span>.<span class="property">ram</span> = <span class="number">16</span>;​</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;​</span><br><span class="line">  &#125;​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">setStorage</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">computer</span>.<span class="property">storage</span> = <span class="string">&quot;500G&quot;</span>;​</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;​</span><br><span class="line">  &#125;​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">build</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">computer</span>;​</span><br><span class="line">  &#125;​</span><br><span class="line">&#125;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// Director: 负责使用 Builder 构建对象​</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerEngineer</span> &#123;​</span><br><span class="line">  <span class="title function_">constructComputer</span>(<span class="params">builder</span>) &#123;​</span><br><span class="line">    <span class="keyword">return</span> builder​</span><br><span class="line">      .<span class="title function_">setCPU</span>()​</span><br><span class="line">      .<span class="title function_">setGPU</span>()​</span><br><span class="line">      .<span class="title function_">setRAM</span>()​</span><br><span class="line">      .<span class="title function_">setStorage</span>()​</span><br><span class="line">      .<span class="title function_">build</span>();​</span><br><span class="line">  &#125;​</span><br><span class="line">&#125;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 使用建造者模式创建复杂对象​</span></span><br><span class="line"><span class="keyword">const</span> engineer = <span class="keyword">new</span> <span class="title class_">ComputerEngineer</span>();​</span><br><span class="line"><span class="keyword">const</span> builder = <span class="keyword">new</span> <span class="title class_">ComputerBuilder</span>();​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> computer = engineer.<span class="title function_">constructComputer</span>(builder);​</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>建造者模式的核心思想是将对象的构建过程和表示分离;</li><li>建造者模式的核心组成部分是: 构建对象类, 构建器类, 指挥者类;</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。</p><p>通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。</p><p>敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式：灵活创建对象的设计模式</title>
      <link href="/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>工厂模式是一种创建型设计模式，它通过使用工厂方法或抽象工厂，将对象的实例化过程封装起来，使得客户端与具体的对象创建过程解耦。工厂模式可以根据不同的条件或参数来创建不同的对象，提供了一种灵活的对象创建方式。</p><hr><h3 id="实现工厂模式的方式"><a href="#实现工厂模式的方式" class="headerlink" title="实现工厂模式的方式"></a>实现工厂模式的方式</h3><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="title function_">createShape</span>(<span class="params">type</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(type === <span class="string">&#x27;circle&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type === <span class="string">&#x27;rectangle&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;无效的形状&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;绘制接口必须实现&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同的具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;绘制圆&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;绘制矩形&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> <span class="title class_">ShapeFactory</span>(<span class="string">&#x27;circle&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> <span class="title class_">ShapeFactory</span>(<span class="string">&#x27;rectangle&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="title function_">createShape</span>(<span class="params">type</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;创建形状接口必须实现&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleFactory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="title function_">createShape</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RectangleFactory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="title function_">createShape</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;绘制接口必须实现&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不同的具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;绘制圆&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>  <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;绘制矩形&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> <span class="title class_">CircleFactory</span>();</span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> <span class="title class_">RectFactory</span>();</span><br></pre></td></tr></table></figure><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">H5Factory</span> &#123;</span><br><span class="line">    <span class="title function_">createButton</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">H5Button</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">createIcon</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">H5Icon</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WxFactory</span> &#123;</span><br><span class="line">     <span class="title function_">createButton</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WxButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">createIcon</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WxIcon</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同的具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">H5Button</span> &#123;</span><br><span class="line">    <span class="title function_">description</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是个按钮&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">H5Icon</span> &#123;</span><br><span class="line">    <span class="title function_">description</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是个图标&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WxButton</span> &#123;</span><br><span class="line">    <span class="title function_">description</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是个按钮&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WxIcon</span> &#123;</span><br><span class="line">    <span class="title function_">description</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是个图标&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> h5Factory = <span class="keyword">new</span> <span class="title function_">H5Factory</span>();</span><br><span class="line"><span class="keyword">const</span> wxFactory = <span class="keyword">new</span> <span class="title function_">wxFactory</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> h5Button = <span class="keyword">new</span> h5Factory.<span class="title function_">createButton</span>();</span><br><span class="line"><span class="keyword">const</span> h5Icon = <span class="keyword">new</span> h5Factory.<span class="title function_">createIcon</span>();</span><br></pre></td></tr></table></figure><h3 id="简单工厂、工厂方法、抽象工厂模式的区别"><a href="#简单工厂、工厂方法、抽象工厂模式的区别" class="headerlink" title="简单工厂、工厂方法、抽象工厂模式的区别"></a>简单工厂、工厂方法、抽象工厂模式的区别</h3><ul><li>关注点不同: <ul><li>简单工厂使用一个接口创建所有产品； </li><li>工厂方法将产品实例化放到不同的工厂中，关注产品的从属性；</li><li>抽象工厂关注的是一个工厂包含多个产品对应的接口，关注的是产品族的创建；</li></ul></li><li>组成结构不同：<ul><li>简单工厂主要含有工厂类、具体产品类，工厂类下仅含有一个创建产品的接口；</li><li>工厂方法主要含有抽象工厂类、具体工厂类、具体产品类；</li><li>抽象工厂主要含有工厂类，具体产品A类，具体产品B类，工厂类下含有创建产品族的方法；</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>工厂模式的核心思想是将对象的实例化过程封装起来，通过一个接口进行实例化，使得客户端与具体的对象创建过程解耦。</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。</p><p>通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。</p><p>敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>单例模式：实现全局唯一实例的设计模式</title>
      <link href="/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/03/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>单例模式是一种常见的设计模式，它通过限制类的实例化次数，确保只有一个实例存在。</p><h3 id="示例场景-vue3创建渲染器"><a href="#示例场景-vue3创建渲染器" class="headerlink" title="示例场景(vue3创建渲染器)"></a>示例场景(vue3创建渲染器)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> renderer;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ensureRenderer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> renderer || <span class="title function_">createRender</span>(rendererOptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他实现方式"><a href="#其他实现方式" class="headerlink" title="其他实现方式"></a>其他实现方式</h3><p>由于 JavaScript 的事件循环机制和单线程执行，实现单例模式考虑的没那那么复杂，实现起来比较简单。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Singleton</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> instance;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">createInstance</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="string">&#x27;I am the instance&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">getInstance</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!instance) &#123;</span><br><span class="line">                instance = <span class="title function_">createInstance</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> instance = <span class="title class_">Singleton</span>.<span class="title function_">getInstance</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二，直接使用对象字面量</span></span><br><span class="line"><span class="keyword">const</span> messageManager = &#123;</span><br><span class="line">    <span class="title function_">success</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">    <span class="title function_">error</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(messageManager)</span><br></pre></td></tr></table></figure><h3 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h3><ul><li>全局配置：单例模式可以用于管理全局的配置信息，确保在应用中只有一个配置实例被使用。</li><li>日志记录器：单例模式可以用于创建全局唯一的日志记录器，方便在应用中统一管理和记录日志信息</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>单例模式的核心思想是需要确保一个类只有一个实例。</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在本章中, 我们通过实际场景和案例来展示设计模式在实际项目中的应用。我们将探讨如何选择适当的设计模式来解决具体问题，并讨论设计模式的优缺点以及适用性。</p><p>通过这一系列的文章，读者将对设计模式有一个简洁而全面的了解。我们将覆盖常见的设计模式，并介绍它们的概念、应用场景和实现方式。通过学习设计模式，读者将能够更好地理解和应用设计模式，提高代码的可重用性、可维护性和灵活性。</p><p>敬请关注本系列的后续文章，希望能为您带来有价值的知识和启发。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>渲染器：数据访问是如何被代理的？</title>
      <link href="/2024/03/13/%E6%BA%90%E7%A0%81/3-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84/"/>
      <url>/2024/03/13/%E6%BA%90%E7%A0%81/3-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="渲染器：数据访问是如何被代理的？"><a href="#渲染器：数据访问是如何被代理的？" class="headerlink" title="渲染器：数据访问是如何被代理的？"></a>渲染器：数据访问是如何被代理的？</h2><h3 id="源码定义-对组件实例上下文进行代理"><a href="#源码定义-对组件实例上下文进行代理" class="headerlink" title="源码定义: 对组件实例上下文进行代理"></a>源码定义: 对组件实例上下文进行代理</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setupStatefulComponent</span>(<span class="params">instance, isSSR</span>) &#123;</span><br><span class="line">  instance.<span class="property">accessCache</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">  instance.<span class="property">proxy</span> = <span class="title function_">markRaw</span>(<span class="keyword">new</span> <span class="title class_">Proxy</span>(instance.<span class="property">ctx</span>, <span class="title class_">PublicInstanceProxyHandlers</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PublicInstanceProxyHandlers-get"><a href="#PublicInstanceProxyHandlers-get" class="headerlink" title="PublicInstanceProxyHandlers.get"></a>PublicInstanceProxyHandlers.get</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const PublicInstanceProxyHandlers = &#123;</span><br><span class="line">  get(&#123; _: instance &#125;, key) &#123;</span><br><span class="line">    const &#123; ctx, setupState, data, props, accessCache, type, appContext &#125; = instance</span><br><span class="line">    if (__DEV__ &amp;&amp; key === &#x27;__isVue&#x27;) &#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let normalizedProps;  // 预定义模块所需变量</span><br><span class="line">    if (key[0] !== &#x27;$&#x27;) &#123; // 处理非预留属性</span><br><span class="line">      const n = accessCache[key] // 读取缓存内容</span><br><span class="line">      if (n !== undefined) &#123;</span><br><span class="line">        switch (n) &#123;</span><br><span class="line">          case AccessTypes.SETUP:</span><br><span class="line">            return setupState[key]</span><br><span class="line">          case AccessTypes.DATA:</span><br><span class="line">            return data[key]</span><br><span class="line">          case AccessTypes.CONTEXT:</span><br><span class="line">            return ctx[key]</span><br><span class="line">          case AccessTypes.PROPS:</span><br><span class="line">            return props[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (hasSetupBinding(setupState, key)) &#123;</span><br><span class="line">        accessCache![key] = AccessTypes.SETUP</span><br><span class="line">        return setupState[key]</span><br><span class="line">      &#125; else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123;</span><br><span class="line">        accessCache![key] = AccessTypes.DATA</span><br><span class="line">        return data[key]</span><br><span class="line">      &#125; else if (</span><br><span class="line">        (normalizedProps = instance.propsOptions[0]) &amp;&amp;</span><br><span class="line">        hasOwn(normalizedProps, key)</span><br><span class="line">      ) &#123;</span><br><span class="line">        accessCache![key] = AccessTypes.PROPS</span><br><span class="line">        return props![key]</span><br><span class="line">      &#125; else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123;</span><br><span class="line">        accessCache![key] = AccessTypes.CONTEXT</span><br><span class="line">        return ctx[key]</span><br><span class="line">      &#125; else if (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) &#123;</span><br><span class="line">        accessCache![key] = AccessTypes.OTHER</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const publicGetter = publicPropertiesMap[key] // 开始处理预留属性</span><br><span class="line">    let cssModule, globalProperties</span><br><span class="line">    if (publicGetter) &#123;</span><br><span class="line">      // $保留字开头的相关逻辑</span><br><span class="line">    &#125; else if (</span><br><span class="line">      (cssModule = type.__cssModules) &amp;&amp;</span><br><span class="line">      (cssModule = cssModule[key])</span><br><span class="line">    ) &#123;</span><br><span class="line">      return cssModule</span><br><span class="line">    &#125; else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123;</span><br><span class="line">      accessCache![key] = AccessTypes.CONTEXT</span><br><span class="line">      return ctx[key]</span><br><span class="line">    &#125; else if (</span><br><span class="line">      ((globalProperties = appContext.config.globalProperties),</span><br><span class="line">        hasOwn(globalProperties, key))</span><br><span class="line">    ) &#123;</span><br><span class="line">      if (__COMPAT__) &#123;</span><br><span class="line">        const desc = Object.getOwnPropertyDescriptor(globalProperties, key)!</span><br><span class="line">        if (desc.get) &#123;</span><br><span class="line">          return desc.get.call(instance.proxy)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          const val = globalProperties[key]</span><br><span class="line">          return isFunction(val)</span><br><span class="line">            ? Object.assign(val.bind(instance.proxy), val)</span><br><span class="line">            : val</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return globalProperties[key]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (</span><br><span class="line">      // 一些告警</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h4><ol><li>访问顺序为<code>setupState</code>》<code>data</code>》<code>prop</code>》<code>ctx</code></li><li>使用<code>空间换时间</code>进行了优化，使用<code>accessCache</code>标记<code>key</code>存在于哪个属性上，减少了频繁调用<code>hasOwn</code>耗费性能。</li></ol><h3 id="PublicInstanceProxyHandlers-get-1"><a href="#PublicInstanceProxyHandlers-get-1" class="headerlink" title="PublicInstanceProxyHandlers .get"></a>PublicInstanceProxyHandlers .get</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const PublicInstanceProxyHandlers = &#123;</span><br><span class="line">  set(&#123; _: instance &#125;, key, value) &#123;</span><br><span class="line">    const &#123; data, setupState, ctx &#125; = instance</span><br><span class="line">    if (hasSetupBinding(setupState, key)) &#123;</span><br><span class="line">      setupState[key] = value</span><br><span class="line">      return true</span><br><span class="line">    &#125; else if (</span><br><span class="line">      __DEV__ &amp;&amp;</span><br><span class="line">      setupState.__isScriptSetup &amp;&amp;</span><br><span class="line">      hasOwn(setupState, key)</span><br><span class="line">    ) &#123;</span><br><span class="line">      warn(`Cannot mutate &lt;script setup&gt; binding &quot;$&#123;key&#125;&quot; from Options API.`)</span><br><span class="line">      return false</span><br><span class="line">    &#125; else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123;</span><br><span class="line">      data[key] = value</span><br><span class="line">      return true</span><br><span class="line">    &#125; else if (hasOwn(instance.props, key)) &#123;</span><br><span class="line">      __DEV__ &amp;&amp; warn(`Attempting to mutate prop &quot;$&#123;key&#125;&quot;. Props are readonly.`)</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">    if (key[0] === &#x27;$&#x27; &amp;&amp; key.slice(1) in instance) &#123;</span><br><span class="line">      __DEV__ &amp;&amp;</span><br><span class="line">      warn(</span><br><span class="line">        `Attempting to mutate public property &quot;$&#123;key&#125;&quot;. ` +</span><br><span class="line">        `Properties starting with $ are reserved and readonly.`,</span><br><span class="line">      )</span><br><span class="line">      return false</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (__DEV__ &amp;&amp; key in instance.appContext.config.globalProperties) &#123;</span><br><span class="line">        Object.defineProperty(ctx, key, &#123;</span><br><span class="line">          enumerable: true,</span><br><span class="line">          configurable: true,</span><br><span class="line">          value,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        ctx[key] = value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong> 更改顺序为：<code>setupState</code> 》<code>data</code> 》<code>props</code> 》<code>globalProperties</code></p><h3 id="PublicInstanceProxyHandlers-has"><a href="#PublicInstanceProxyHandlers-has" class="headerlink" title="PublicInstanceProxyHandlers .has"></a>PublicInstanceProxyHandlers .has</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const PublicInstanceProxyHandlers = &#123;</span><br><span class="line">  has(&#123;_: &#123; data, setupState, accessCache, ctx, appContext, propsOptions &#125;&#125;, key) &#123;</span><br><span class="line">    let normalizedProps</span><br><span class="line">    return (</span><br><span class="line">      !!accessCache[key] ||</span><br><span class="line">      (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) ||</span><br><span class="line">      hasSetupBinding(setupState, key) ||</span><br><span class="line">      ((normalizedProps = propsOptions[0]) &amp;&amp; hasOwn(normalizedProps, key)) ||</span><br><span class="line">      hasOwn(ctx, key) ||</span><br><span class="line">      hasOwn(publicPropertiesMap, key) || // $保留字开头的函数</span><br><span class="line">      hasOwn(appContext.config.globalProperties, key)</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong> 访问顺序为<code>data </code>》<code>setupState</code>》<code>props</code>》<code>ctx</code>》<code>publicPropertiesMap</code>》<code>globalProperties</code></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
